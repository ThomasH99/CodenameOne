<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BufferedOutputStream.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codenameone-core-unittests</a> &gt; <a href="index.source.html" class="el_package">com.codename1.io</a> &gt; <span class="el_source">BufferedOutputStream.java</span></div><h1>BufferedOutputStream.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores
 * CA 94065 USA or visit www.oracle.com if you need additional information or
 * have any questions.
 */
package com.codename1.io;

import java.io.IOException;
import java.io.OutputStream;

/**
 * Based on the buffered output stream from the JDK with some minor tweaks to allow
 * external classes to monitor stream status and progress.
 */
public class BufferedOutputStream extends OutputStream {
<span class="fc" id="L34">    private static int streamCount = 0;</span>
<span class="fc" id="L35">    private static int defaultBufferSize = 8192;</span>
    /**
     * The internal buffer where data is stored.
     */
    protected byte[] buf;
    /**
     * The number of valid bytes in the buffer. This value is always
     * in the range &lt;tt&gt;0&lt;/tt&gt; through &lt;tt&gt;buf.length&lt;/tt&gt;; elements
     * &lt;tt&gt;buf[0]&lt;/tt&gt; through &lt;tt&gt;buf[count-1]&lt;/tt&gt; contain valid
     * byte data.
     */
    protected int count;
    private Object connection;
    private boolean closed;
    private final OutputStream out;
    private long lastActivityTime;
    private int totalBytesWritten;
    private IOProgressListener progressListener;
    private final String name;

    /**
     * Creates a new buffered output stream to write data to the
     * specified underlying output stream.
     *
     * @param out the underlying output stream.
     */
    public BufferedOutputStream(OutputStream out) {
<span class="fc" id="L62">        this(out, defaultBufferSize);</span>
<span class="fc" id="L63">    }</span>

    /**
     * Creates a new buffered output stream to write data to the
     * specified underlying output stream.
     *
     * @param out  the underlying output stream.
     * @param name the name of the stream used for debugging/logging purposes
     */
    public BufferedOutputStream(OutputStream out, String name) {
<span class="fc" id="L73">        this(out, defaultBufferSize, name);</span>
<span class="fc" id="L74">    }</span>

    /**
     * Creates a new buffered output stream to write data to the
     * specified underlying output stream with the specified buffer
     * size.
     *
     * @param out  the underlying output stream.
     * @param size the buffer size.
     * @throws IllegalArgumentException if size &amp;lt;= 0.
     */
    public BufferedOutputStream(OutputStream out, int size) {
<span class="fc" id="L86">        this(out, size, &quot;unnamed&quot;);</span>
<span class="fc" id="L87">    }</span>

    /**
     * Creates a new buffered output stream to write data to the
     * specified underlying output stream with the specified buffer
     * size.
     *
     * @param out  the underlying output stream.
     * @param size the buffer size.
     * @param name the name of the stream used for debugging/logging purposes
     * @throws IllegalArgumentException if size &amp;lt;= 0.
     */
<span class="fc" id="L99">    public BufferedOutputStream(OutputStream out, int size, String name) {</span>
<span class="fc" id="L100">        this.out = out;</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">        if (size &lt;= 0) {</span>
<span class="fc" id="L102">            throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);</span>
        }
<span class="fc" id="L104">        buf = new byte[size];</span>
<span class="fc" id="L105">        streamCount++;</span>
<span class="fc" id="L106">        this.name = name;</span>
<span class="fc" id="L107">        Util.getImplementation().logStreamCreate(name, false, streamCount);</span>
<span class="fc" id="L108">    }</span>

    /**
     * The default size for a stream buffer
     *
     * @return the defaultBufferSize
     */
    public static int getDefaultBufferSize() {
<span class="fc" id="L116">        return defaultBufferSize;</span>
    }

    /**
     * The default size for a stream buffer
     *
     * @param aDefaultBufferSize the defaultBufferSize to set
     */
    public static void setDefaultBufferSize(int aDefaultBufferSize) {
<span class="fc" id="L125">        defaultBufferSize = aDefaultBufferSize;</span>
<span class="fc" id="L126">    }</span>

    /**
     * Indicates the name of the stream for debugging purposes
     *
     * @return the name of the stream
     */
    public String getName() {
<span class="fc" id="L134">        return name;</span>
    }

    /**
     * Flush the internal buffer
     */
    public void flushBuffer() throws IOException {
<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (closed) {</span>
<span class="fc" id="L142">            return;</span>
        }
<span class="fc bfc" id="L144" title="All 2 branches covered.">        if (count &gt; 0) {</span>
<span class="fc" id="L145">            out.write(buf, 0, count);</span>
<span class="fc" id="L146">            count = 0;</span>
        }
<span class="fc" id="L148">    }</span>

    /**
     * Writes the specified byte to this buffered output stream.
     *
     * @param b the byte to be written.
     * @throws IOException if an I/O error occurs.
     */
    public synchronized void write(int b) throws IOException {
<span class="fc bfc" id="L157" title="All 2 branches covered.">        if (count &gt;= buf.length) {</span>
<span class="fc" id="L158">            flushBuffer();</span>
        }
<span class="fc" id="L160">        totalBytesWritten++;</span>
<span class="fc" id="L161">        fireProgress();</span>
<span class="fc" id="L162">        lastActivityTime = System.currentTimeMillis();</span>
<span class="fc" id="L163">        buf[count++] = (byte) b;</span>
<span class="fc" id="L164">    }</span>

    /**
     * Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array
     * starting at offset &lt;code&gt;off&lt;/code&gt; to this buffered output stream.
     *
     * &lt;p&gt; Ordinarily this method stores bytes from the given array into this
     * stream's buffer, flushing the buffer to the underlying output stream as
     * needed.  If the requested length is at least as large as this stream's
     * buffer, however, then this method will flush the buffer and write the
     * bytes directly to the underlying output stream.  Thus redundant
     * &lt;code&gt;BufferedOutputStream&lt;/code&gt;s will not copy data unnecessarily.
     *
     * @param b   the data.
     * @param off the start offset in the data.
     * @param len the number of bytes to write.
     * @throws IOException if an I/O error occurs.
     */
    public synchronized void write(byte[] b, int off, int len) throws IOException {
<span class="fc bfc" id="L183" title="All 2 branches covered.">        if (len &gt;= buf.length) {</span>
            /* If the request length exceeds the size of the output buffer,
            flush the output buffer and then write the data directly.
            In this way buffered streams will cascade harmlessly. */
<span class="fc" id="L187">            flushBuffer();</span>
<span class="fc" id="L188">            out.write(b, off, len);</span>
        } else {
<span class="fc bfc" id="L190" title="All 2 branches covered.">            if (len &gt; buf.length - count) {</span>
<span class="fc" id="L191">                flushBuffer();</span>
            }
<span class="fc" id="L193">            System.arraycopy(b, off, buf, count, len);</span>
<span class="fc" id="L194">            count += len;</span>
        }
<span class="fc" id="L196">        totalBytesWritten += len;</span>
<span class="fc" id="L197">        fireProgress();</span>
<span class="fc" id="L198">        lastActivityTime = System.currentTimeMillis();</span>
<span class="fc" id="L199">    }</span>

    /**
     * Flushes this buffered output stream. This forces any buffered
     * output bytes to be written out to the underlying output stream.
     *
     * @throws IOException if an I/O error occurs.
     */
    public synchronized void flush() throws IOException {
<span class="fc bfc" id="L208" title="All 2 branches covered.">        if (closed) {</span>
<span class="fc" id="L209">            return;</span>
        }
<span class="fc" id="L211">        flushBuffer();</span>
<span class="fc" id="L212">        out.flush();</span>
<span class="fc" id="L213">        lastActivityTime = System.currentTimeMillis();</span>
<span class="fc" id="L214">    }</span>

    /**
     * Returns the time of the last activity
     *
     * @return time of the last activity on this stream
     */
    public long getLastActivityTime() {
<span class="fc" id="L222">        return lastActivityTime;</span>
    }

    /**
     * Returns the total amount of bytes written to this stream so far
     *
     * @return the total amount of bytes written to this stream so far
     */
    public int getTotalBytesWritten() {
<span class="fc" id="L231">        return totalBytesWritten;</span>
    }

    /**
     * Sets the callback for IO updates from a buffered stream
     *
     * @param progressListener the progressListener to set
     */
    public void setProgressListener(IOProgressListener progressListener) {
<span class="fc" id="L240">        this.progressListener = progressListener;</span>
<span class="fc" id="L241">    }</span>

    private void fireProgress() {
<span class="fc bfc" id="L244" title="All 2 branches covered.">        if (progressListener != null) {</span>
<span class="fc" id="L245">            progressListener.ioStreamUpdate(this, totalBytesWritten);</span>
        }
<span class="fc" id="L247">    }</span>

    /**
     * Writes &lt;code&gt;b.length&lt;/code&gt; bytes to this output stream.
     * &lt;p&gt;
     * The &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;FilterOutputStream&lt;/code&gt;
     * calls its &lt;code&gt;write&lt;/code&gt; method of three arguments with the
     * arguments &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, and
     * &lt;code&gt;b.length&lt;/code&gt;.
     * &lt;p&gt;
     * Note that this method does not call the one-argument
     * &lt;code&gt;write&lt;/code&gt; method of its underlying stream with the single
     * argument &lt;code&gt;b&lt;/code&gt;.
     *
     * @param b the data to be written.
     * @throws IOException if an I/O error occurs.
     */
    public void write(byte[] b) throws IOException {
<span class="fc" id="L265">        write(b, 0, b.length);</span>
<span class="fc" id="L266">    }</span>

    /**
     * Closes this output stream and releases any system resources
     * associated with the stream.
     * &lt;p&gt;
     * The &lt;code&gt;close&lt;/code&gt; method of &lt;code&gt;FilterOutputStream&lt;/code&gt;
     * calls its &lt;code&gt;flush&lt;/code&gt; method, and then calls the
     * &lt;code&gt;close&lt;/code&gt; method of its underlying output stream.
     *
     * @throws IOException if an I/O error occurs.
     */
    public void close() throws IOException {
<span class="fc bfc" id="L279" title="All 2 branches covered.">        if (!closed) {</span>
<span class="fc" id="L280">            streamCount--;</span>
<span class="fc" id="L281">            Util.getImplementation().closingOutput(out);</span>
<span class="fc" id="L282">            Util.getImplementation().logStreamClose(name, false, streamCount);</span>
            try {
<span class="fc" id="L284">                flush();</span>
<span class="nc" id="L285">            } catch (Exception ignored) {</span>
            } finally {
<span class="fc" id="L287">                Util.cleanup(out);</span>
            }
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">            if (connection != null) {</span>
<span class="nc" id="L290">                Util.getImplementation().cleanup(connection);</span>
            }
<span class="fc" id="L292">            closed = true;</span>
        } else {
<span class="fc" id="L294">            Util.getImplementation().logStreamDoubleClose(name, false);</span>
        }
<span class="fc" id="L296">    }</span>

    /**
     * If applicable this member represents the connection object for the stream
     *
     * @return the connection
     */
    public Object getConnection() {
<span class="fc" id="L304">        return connection;</span>
    }

    /**
     * If applicable this member represents the connection object for the stream
     *
     * @param connection the connection to set
     */
    public void setConnection(Object connection) {
<span class="fc" id="L313">        this.connection = connection;</span>
<span class="fc" id="L314">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>