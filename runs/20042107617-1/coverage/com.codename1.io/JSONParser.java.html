<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JSONParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codenameone-core-unittests</a> &gt; <a href="index.source.html" class="el_package">com.codename1.io</a> &gt; <span class="el_source">JSONParser.java</span></div><h1>JSONParser.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores
 * CA 94065 USA or visit www.oracle.com if you need additional information or
 * have any questions.
 */
package com.codename1.io;

import com.codename1.processing.Result;

import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Vector;

/**
 * &lt;p&gt;Fast and dirty parser for JSON content on the web, it essentially returns
 * a {@link java.util.Map} object containing the object fields mapped to their values. If the value is
 * a nested object a nested {@link java.util.Map}/{@link java.util.List} is returned. &lt;/p&gt;
 *
 * &lt;p&gt;
 * The {@code JSONParser} returns a {@code Map} which is great if the root object is a {@code Map} but in
 * some cases its a list of elements (as is the case above). In this case a special case {@code &quot;root&quot;} element is
 * created to contain the actual list of elements. See the sample below for exact usage of this.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The sample below includes JSON from &lt;a href=&quot;https://anapioficeandfire.com/&quot;&gt;https://anapioficeandfire.com/&lt;/a&gt;
 * generated by the query &lt;a href=&quot;http://www.anapioficeandfire.com/api/characters?page=5&amp;amp;pageSize=3&quot;&gt;http://www.anapioficeandfire.com/api/characters?page=5&amp;amp;pageSize=3&lt;/a&gt;:
 * &lt;/p&gt;
 * &lt;script src=&quot;https://gist.github.com/codenameone/f9fdacaac12583cd2eed.js&quot;&gt;&lt;/script&gt;
 * &lt;img src=&quot;https://www.codenameone.com/img/developer-guide/json-parsing.png&quot; alt=&quot;JSON Parsing Result&quot;&gt;
 *
 *
 * &lt;p&gt;The sample  code below fetches a page of data from the nestoria housing listing API as a list of Map elements.
 * You can see instructions on how to display the data in the {@link com.codename1.components.InfiniteScrollAdapter}
 * class.&lt;/p&gt;
 * &lt;script src=&quot;https://gist.github.com/codenameone/22efe9e04e2b8986dfc3.js&quot;&gt;&lt;/script&gt;
 *
 * @author Shai Almog
 */
<span class="fc" id="L62">public class JSONParser implements JSONParseCallback {</span>

    private static boolean useLongsDefault;
    /**
     * Indicates that the parser will generate Boolean objects and not just Strings for boolean values
     */
    private static boolean useBooleanDefault;
    private static boolean includeNullsDefault;
<span class="fc" id="L70">    private boolean useLongs = useLongsDefault;</span>
<span class="fc" id="L71">    private boolean useBoolean = useBooleanDefault;</span>
<span class="fc" id="L72">    private boolean includeNulls = includeNullsDefault;</span>
    private boolean modern;
    private Map&lt;String, Object&gt; state;
    private java.util.List&lt;Object&gt; parseStack;
    private String currentKey;
    /**
     * If strict is set to false, then the parser will attempt to sanitize the JSON
     * input before parsing.  I.e. it will accept invalid JSON, such as unquoted keys, etc..
     */
<span class="fc" id="L81">    private boolean strict = true;</span>

    /**
     * Checks whether JSONParser instances will use longs to represent numeric values by default. This is just a
     * global default setting.  You should use {@link #isUseLongsInstance() } to check the status for a particular
     * JSONParser object.
     *
     * @return the useLongsDefault
     * @deprecated Use {@link #isUseLongsInstance() } to check whether the current JSONParser uses longs.
     */
    public static boolean isUseLongs() {
<span class="nc" id="L92">        return useLongsDefault;</span>
    }

    /**
     * Indicates that the parser will generate long objects and not just doubles for numeric values.
     *
     * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt;  This method will affect ALL JSONParser instances in the application.  Prefer to use {@link #setUseLongsInstance(boolean) }
     * to only affect the behaviour of the particular JSONParser instance.&lt;/p&gt;
     *
     * @param aUseLongsDefault the useLongsDefault to set
     * @deprecated Use {@link #setUseLongsInstance(boolean) }
     */
    public static void setUseLongs(boolean aUseLongsDefault) {
<span class="nc" id="L105">        useLongsDefault = aUseLongsDefault;</span>
<span class="nc" id="L106">    }</span>

    /**
     * Checks the default setting for {@link #isIncludeNullsInstance() }.
     *
     * @return the includeNullsDefault The global default setting for {@link #isIncludeNullsInstance() }.
     * @deprecated Use {@link #isIncludeNullsInstance() } instead.
     */
    public static boolean isIncludeNulls() {
<span class="nc" id="L115">        return includeNullsDefault;</span>
    }

    /**
     * Sets the global default settings for {@link #isIncludeNullsInstance() }.
     *
     * @param aIncludeNullsDefault the includeNullsDefault to set
     * @deprecated Use {@link #setIncludeNullsInstance(boolean) } instead.
     */
    public static void setIncludeNulls(boolean aIncludeNullsDefault) {
<span class="nc" id="L125">        includeNullsDefault = aIncludeNullsDefault;</span>
<span class="nc" id="L126">    }</span>

    /**
     * Global default setting for {@link #isUseBooleanInstance() }.
     *
     * @return the useBooleanDefault
     * @deprecated Use {@link #isUseBooleanInstance() } instead.
     */
    public static boolean isUseBoolean() {
<span class="nc" id="L135">        return useBooleanDefault;</span>
    }

    /**
     * Sets the global default value for {@link #isUseBooleanInstance() }
     *
     * @param aUseBooleanDefault the useBooleanDefault to set
     * @deprecated Use {@link #setUseBooleanInstance(boolean) } instead.
     */
    public static void setUseBoolean(boolean aUseBooleanDefault) {
<span class="nc" id="L145">        useBooleanDefault = aUseBooleanDefault;</span>
<span class="nc" id="L146">    }</span>

    private static boolean useLongs(JSONParseCallback callback) {
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        if (callback instanceof JSONParser) {</span>
<span class="fc" id="L150">            return ((JSONParser) callback).isUseLongsInstance();</span>
        }
<span class="nc" id="L152">        return useLongsDefault;</span>
    }

    private static boolean useBoolean(JSONParseCallback callback) {
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">        if (callback instanceof JSONParser) {</span>
<span class="fc" id="L157">            return ((JSONParser) callback).isUseBooleanInstance();</span>
        }
<span class="nc" id="L159">        return useBooleanDefault;</span>
    }

    /**
     * Static method! Parses the given input stream and fires the data into the given callback.
     *
     * @param i        the reader
     * @param callback a generic callback to receive the parse events
     * @throws IOException if thrown by the stream
     */
    public static void parse(Reader i, JSONParseCallback callback) throws IOException {
<span class="fc" id="L170">        boolean quoteMode = false;</span>
<span class="fc" id="L171">        ReaderClass rc = new ReaderClass();</span>
<span class="fc" id="L172">        rc.buffOffset = 0;</span>
<span class="fc" id="L173">        rc.buffSize = -1;</span>
<span class="fc" id="L174">        int row = 1;</span>
<span class="fc" id="L175">        int column = 1;</span>
<span class="fc" id="L176">        StringBuilder currentToken = new StringBuilder();</span>
<span class="fc" id="L177">        KeyStack blocks = new KeyStack();</span>
<span class="fc" id="L178">        String currentBlock = &quot;&quot;;</span>
<span class="fc" id="L179">        String lastKey = null;</span>
        try {
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">            while (callback.isAlive()) {</span>
<span class="fc" id="L182">                int currentChar = rc.read(i);</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">                if (currentChar &lt; 0) {</span>
<span class="fc" id="L184">                    return;</span>
                }
<span class="fc" id="L186">                char c = (char) currentChar;</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">                if (c == '\n') {</span>
<span class="fc" id="L188">                    row++;</span>
<span class="fc" id="L189">                    column = 0;</span>
                } else {
<span class="fc" id="L191">                    column++;</span>
                }

<span class="fc bfc" id="L194" title="All 2 branches covered.">                if (quoteMode) {</span>
<span class="pc bpc" id="L195" title="1 of 3 branches missed.">                    switch (c) {</span>
                        case '&quot;':
<span class="fc" id="L197">                            String v = currentToken.toString();</span>
<span class="fc" id="L198">                            callback.stringToken(v);</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">                            if (lastKey != null) {</span>
<span class="fc" id="L200">                                callback.keyValue(lastKey, v);</span>
<span class="fc" id="L201">                                lastKey = null;</span>
                            } else {
<span class="fc" id="L203">                                lastKey = v;</span>
                            }
<span class="fc" id="L205">                            currentToken.setLength(0);</span>
<span class="fc" id="L206">                            quoteMode = false;</span>
<span class="fc" id="L207">                            continue;</span>
                        case '\\':
<span class="nc" id="L209">                            c = (char) rc.read(i);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">                            if (c == 'u') {</span>
<span class="nc" id="L211">                                String unicode = &quot;&quot; + ((char) rc.read(i)) + ((char) rc.read(i)) + ((char) rc.read(i)) + ((char) rc.read(i));</span>
                                try {
<span class="nc" id="L213">                                    c = (char) Integer.parseInt(unicode, 16);</span>
<span class="nc" id="L214">                                } catch (NumberFormatException err) {</span>
                                    // problem in parsing the u notation!
<span class="nc" id="L216">                                    Log.e(err);</span>
<span class="nc" id="L217">                                    Log.p(&quot;Error in parsing \\u&quot; + unicode);</span>
<span class="nc" id="L218">                                }</span>
<span class="nc" id="L219">                            } else {</span>
<span class="nc bnc" id="L220" title="All 4 branches missed.">                                switch (c) {</span>
                                    case 'n':
<span class="nc" id="L222">                                        currentToken.append('\n');</span>
<span class="nc" id="L223">                                        continue;</span>
                                    case 't':
<span class="nc" id="L225">                                        currentToken.append('\t');</span>
<span class="nc" id="L226">                                        continue;</span>
                                    case 'r':
<span class="nc" id="L228">                                        currentToken.append('\r');</span>
<span class="nc" id="L229">                                        continue;</span>
                                }
                            }
<span class="nc" id="L232">                            currentToken.append(c);</span>
<span class="nc" id="L233">                            continue;</span>
                    }
<span class="fc" id="L235">                    currentToken.append(c);</span>
                } else {
<span class="pc bpc" id="L237" title="1 of 12 branches missed.">                    switch (c) {</span>
                        case 'n':
                            // check for null
<span class="fc" id="L240">                            char u = (char) rc.read(i);</span>
<span class="fc" id="L241">                            char l = (char) rc.read(i);</span>
<span class="fc" id="L242">                            char l2 = (char) rc.read(i);</span>
<span class="pc bpc" id="L243" title="3 of 6 branches missed.">                            if (u == 'u' &amp;&amp; l == 'l' &amp;&amp; l2 == 'l') {</span>
                                // this is null
<span class="fc" id="L245">                                callback.stringToken(null);</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">                                if (lastKey != null) {</span>
<span class="fc" id="L247">                                    callback.keyValue(lastKey, null);</span>
<span class="fc" id="L248">                                    lastKey = null;</span>
                                }
                            } else {
                                // parsing error....
<span class="nc" id="L252">                                Log.p(&quot;Expected null for key value while parsing JSON token at row: &quot; + row + &quot; column: &quot; + column + &quot; buffer: &quot; + currentToken);</span>
                            }

<span class="nc" id="L255">                            continue;</span>
                        case 't':
                            // check for true
<span class="fc" id="L258">                            char a1 = (char) rc.read(i);</span>
<span class="fc" id="L259">                            char a2 = (char) rc.read(i);</span>
<span class="fc" id="L260">                            char a3 = (char) rc.read(i);</span>
<span class="pc bpc" id="L261" title="3 of 6 branches missed.">                            if (a1 == 'r' &amp;&amp; a2 == 'u' &amp;&amp; a3 == 'e') {</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">                                if (useBoolean(callback)) {</span>
<span class="fc" id="L263">                                    callback.booleanToken(true);</span>
                                } else {
<span class="fc" id="L265">                                    callback.stringToken(&quot;true&quot;);</span>
                                }
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">                                if (lastKey != null) {</span>
<span class="fc" id="L268">                                    callback.keyValue(lastKey, &quot;true&quot;);</span>
<span class="fc" id="L269">                                    lastKey = null;</span>
                                }
                            } else {
                                // parsing error....
<span class="nc" id="L273">                                Log.p(&quot;Expected true for key value while parsing JSON token at row: &quot; + row + &quot; column: &quot; + column + &quot; buffer: &quot; + currentToken);</span>
                            }

<span class="nc" id="L276">                            continue;</span>
                        case 'f':
                            // this can either be the start of &quot;false&quot; or the end of a
                            // fraction number...
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">                            if (currentToken.length() &gt; 0) {</span>
<span class="nc" id="L281">                                currentToken.append('f');</span>
<span class="nc" id="L282">                                continue;</span>
                            }
                            // check for false
<span class="fc" id="L285">                            char b1 = (char) rc.read(i);</span>
<span class="fc" id="L286">                            char b2 = (char) rc.read(i);</span>
<span class="fc" id="L287">                            char b3 = (char) rc.read(i);</span>
<span class="fc" id="L288">                            char b4 = (char) rc.read(i);</span>
<span class="pc bpc" id="L289" title="4 of 8 branches missed.">                            if (b1 == 'a' &amp;&amp; b2 == 'l' &amp;&amp; b3 == 's' &amp;&amp; b4 == 'e') {</span>
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">                                if (useBoolean(callback)) {</span>
<span class="fc" id="L291">                                    callback.booleanToken(false);</span>
                                } else {
<span class="nc" id="L293">                                    callback.stringToken(&quot;false&quot;);</span>
                                }
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">                                if (lastKey != null) {</span>
<span class="fc" id="L296">                                    callback.keyValue(lastKey, &quot;false&quot;);</span>
<span class="fc" id="L297">                                    lastKey = null;</span>
                                }
                            } else {
                                // parsing error....
<span class="nc" id="L301">                                Log.p(&quot;Expected false for key value while parsing JSON token at row: &quot; + row + &quot; column: &quot; + column + &quot; buffer: &quot; + currentToken);</span>
                            }

<span class="nc" id="L304">                            continue;</span>
                        case '{':
<span class="fc bfc" id="L306" title="All 2 branches covered.">                            if (lastKey == null) {</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">                                if (blocks.size() == 0) {</span>
<span class="fc" id="L308">                                    lastKey = &quot;root&quot;;</span>
                                } else {
<span class="fc" id="L310">                                    lastKey = blocks.peek();</span>
                                }
                            }
<span class="fc" id="L313">                            blocks.push(lastKey);</span>
<span class="fc" id="L314">                            callback.startBlock(lastKey);</span>
<span class="fc" id="L315">                            lastKey = null;</span>
<span class="fc" id="L316">                            continue;</span>
                        case '}':
<span class="fc bfc" id="L318" title="All 2 branches covered.">                            if (currentToken.length() &gt; 0) {</span>
                                try {
<span class="fc" id="L320">                                    String ct = currentToken.toString();</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">                                    if (useLongs(callback)) {</span>
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">                                        if (ct.indexOf('.') &gt; -1) {</span>
<span class="nc" id="L323">                                            callback.numericToken(Double.parseDouble(ct));</span>
                                        } else {
<span class="fc" id="L325">                                            callback.longToken(Long.parseLong(ct));</span>
                                        }
                                    } else {
<span class="fc" id="L328">                                        callback.numericToken(Double.parseDouble(ct));</span>
                                    }
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">                                    if (lastKey != null) {</span>
<span class="fc" id="L331">                                        callback.keyValue(lastKey, currentToken.toString());</span>
<span class="fc" id="L332">                                        lastKey = null;</span>
<span class="fc" id="L333">                                        currentToken.setLength(0);</span>
                                    }

<span class="nc" id="L336">                                } catch (NumberFormatException err) {</span>
<span class="nc" id="L337">                                    Log.e(err);</span>
                                    // this isn't a number!
<span class="fc" id="L339">                                }</span>
                            }
<span class="fc" id="L341">                            currentBlock = blocks.pop();</span>
<span class="fc" id="L342">                            callback.endBlock(currentBlock);</span>
<span class="fc" id="L343">                            lastKey = null;</span>
<span class="fc" id="L344">                            continue;</span>
                        case '[':
<span class="fc" id="L346">                            blocks.push(lastKey);</span>

<span class="fc" id="L348">                            callback.startArray(lastKey);</span>
<span class="fc" id="L349">                            lastKey = null;</span>
<span class="fc" id="L350">                            continue;</span>
                        case ']':
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">                            if (currentToken.length() &gt; 0) {</span>
                                try {
<span class="nc" id="L354">                                    String ct = currentToken.toString();</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">                                    if (useLongs(callback)) {</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">                                        if (ct.indexOf('.') &gt; -1) {</span>
<span class="nc" id="L357">                                            callback.numericToken(Double.parseDouble(ct));</span>
                                        } else {
<span class="nc" id="L359">                                            callback.longToken(Long.parseLong(ct));</span>
                                        }
                                    } else {
<span class="nc" id="L362">                                        callback.numericToken(Double.parseDouble(ct));</span>
                                    }
<span class="nc bnc" id="L364" title="All 2 branches missed.">                                    if (lastKey != null) {</span>
<span class="nc" id="L365">                                        callback.keyValue(lastKey, currentToken.toString());</span>
<span class="nc" id="L366">                                        lastKey = null;</span>
                                    }
<span class="nc" id="L368">                                } catch (NumberFormatException err) {</span>
                                    // this isn't a number!
<span class="nc" id="L370">                                }</span>
                            }
<span class="fc" id="L372">                            currentToken.setLength(0);</span>

<span class="fc" id="L374">                            currentBlock = blocks.pop();</span>
<span class="fc" id="L375">                            callback.endArray(currentBlock);</span>
<span class="fc" id="L376">                            lastKey = null;</span>
<span class="fc" id="L377">                            continue;</span>
                        case ' ':
                        case '\r':
                        case '\t':
                        case '\n':
                            // whitespace
<span class="fc" id="L383">                            continue;</span>

                        case '&quot;':
<span class="fc" id="L386">                            quoteMode = true;</span>
<span class="fc" id="L387">                            continue;</span>
                        case ':':
                        case ',':
<span class="fc bfc" id="L390" title="All 2 branches covered.">                            if (currentToken.length() &gt; 0) {</span>
                                try {
<span class="fc" id="L392">                                    String ct = currentToken.toString();</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">                                    if (useLongs(callback)) {</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">                                        if (ct.indexOf('.') &gt; -1) {</span>
<span class="fc" id="L395">                                            callback.numericToken(Double.parseDouble(ct));</span>
                                        } else {
<span class="fc" id="L397">                                            callback.longToken(Long.parseLong(ct));</span>
                                        }
                                    } else {
<span class="fc" id="L400">                                        callback.numericToken(Double.parseDouble(ct));</span>
                                    }
<span class="fc bfc" id="L402" title="All 2 branches covered.">                                    if (lastKey != null) {</span>
<span class="fc" id="L403">                                        callback.keyValue(lastKey, currentToken.toString());</span>
<span class="fc" id="L404">                                        lastKey = null;</span>
                                    }
<span class="nc" id="L406">                                } catch (NumberFormatException err) {</span>
                                    // this isn't a number!
<span class="fc" id="L408">                                }</span>
                            }
<span class="fc" id="L410">                            currentToken.setLength(0);</span>
<span class="fc" id="L411">                            continue;</span>
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case '-':
                        case '.':
                        case 'x':
                        case 'd':
                        case 'l':
                        case 'e':
                        case 'E':
<span class="fc" id="L429">                            currentToken.append(c);</span>
<span class="fc" id="L430">                            continue;</span>
                    }
                }
<span class="fc" id="L433">            }</span>
<span class="nc" id="L434">        } catch (Exception err) {</span>
<span class="nc" id="L435">            Log.e(err);</span>
<span class="nc" id="L436">            Log.p(&quot;Exception during JSON parsing at row: &quot; + row + &quot; column: &quot; + column + &quot; buffer: &quot; + currentToken);</span>
            /*System.out.println();
            int current = i.read();
            while(current &gt;= 0) {
            System.out.print((char)current);
            current = i.read();
            }*/
<span class="nc" id="L443">            i.close();</span>
<span class="nc" id="L444">        }</span>
<span class="nc" id="L445">    }</span>

    /**
     * Static method to convert the given {@link java.util.Map} to a valid JSON
     * representation. The values allowed types are: {@link java.lang.Number}, {@link java.lang.String}, {@link java.lang.Boolean},
     * {@link java.util.List}, {@link java.util.Map} or null.
     * &lt;p&gt;
     * Limited whitespace is inserted be make the resulting JSON string more
     * readable.
     * &lt;p&gt;
     * Simple example of usage:
     * &lt;pre&gt;{@code
     * Map&lt;String, Object&gt; person = new LinkedHashMap&lt;&gt;();
     * person.put(&quot;firstName&quot;, &quot;Paco&quot;);
     * person.put(&quot;lastName&quot;, &quot;Bellz&quot;);
     * person.put(&quot;isAlive&quot;, true);
     * person.put(&quot;age&quot;, 35);
     * person.put(&quot;weight (kg)&quot;, 70.7);
     *
     * Log.p(&quot;--- mapToJson() test&quot;);
     * Log.p(&quot;\n&quot; + mapToJson(person));
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * The output will be:
     * &lt;pre&gt;{@code
     * {
     *  &quot;firstName&quot;: &quot;Paco&quot;,
     *  &quot;lastName&quot;: &quot;Bellz&quot;,
     *  &quot;isAlive&quot;: true,
     *  &quot;age&quot;: 35,
     *  &quot;weight (kg)&quot;: 70.7
     * }
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * More complex example of usage:
     * &lt;pre&gt;{@code
     * Map&lt;String, Object&gt; phoneNumber1 = new LinkedHashMap&lt;&gt;();
     * phoneNumber1.put(&quot;home&quot;, &quot;212 555-1234&quot;);
     * Map&lt;String, Object&gt; phoneNumber2 = new LinkedHashMap&lt;&gt;();
     * phoneNumber2.put(&quot;office&quot;, &quot;646 555-4567&quot;);
     * Map&lt;String, Object&gt; phoneNumber3 = new LinkedHashMap&lt;&gt;();
     * phoneNumber3.put(&quot;mobile&quot;, &quot;123 456-7890&quot;);
     * Map&lt;String, Object&gt; phoneNumber4 = new LinkedHashMap&lt;&gt;();
     * phoneNumber4.put(&quot;mobile&quot;, &quot;06124578965&quot;);
     * ArrayList phoneNumbers = new ArrayList();
     * ArrayList phoneNumbers2 = new ArrayList();
     * phoneNumbers.add(phoneNumber1);
     * phoneNumbers.add(phoneNumber2);
     * phoneNumbers.add(phoneNumber3);
     * phoneNumbers2.add(phoneNumber4);
     * Map&lt;String, Object&gt; address1 = new LinkedHashMap&lt;&gt;();
     * address1.put(&quot;streetAddress&quot;, &quot;53, London Street&quot;);
     * address1.put(&quot;city&quot;, &quot;Paris&quot;);
     * address1.put(&quot;state&quot;, &quot;FR&quot;);
     * address1.put(&quot;postalCode&quot;, &quot;54856&quot;);
     * Map&lt;String, Object&gt; address2 = new LinkedHashMap&lt;&gt;();
     * address2.put(&quot;streetAddress&quot;, &quot;21 2nd Street&quot;);
     * address2.put(&quot;city&quot;, &quot;New York&quot;);
     * address2.put(&quot;state&quot;, &quot;NY&quot;);
     * address2.put(&quot;postalCode&quot;, &quot;10021-3100&quot;);
     * Map&lt;String, Object&gt; secondPerson = new LinkedHashMap&lt;&gt;();
     * secondPerson.put(&quot;firstName&quot;, &quot;Gioia&quot;);
     * secondPerson.put(&quot;lastName&quot;, &quot;Mia&quot;);
     * secondPerson.put(&quot;isAlive&quot;, true);
     * secondPerson.put(&quot;age&quot;, 34);
     * secondPerson.put(&quot;weight (kg)&quot;, 60.2);
     * secondPerson.put(&quot;address&quot;, address2);
     * address2.put(&quot;phoneNumbers&quot;, phoneNumbers2);
     * Map&lt;String, Object&gt; firstPerson = new LinkedHashMap&lt;&gt;();
     * firstPerson.put(&quot;firstName&quot;, &quot;Paco&quot;);
     * firstPerson.put(&quot;lastName&quot;, &quot;Bellz&quot;);
     * firstPerson.put(&quot;isAlive&quot;, true);
     * firstPerson.put(&quot;age&quot;, 35);
     * firstPerson.put(&quot;weight (kg)&quot;, 70.7);
     * firstPerson.put(&quot;address&quot;, address1);
     * firstPerson.put(&quot;partner&quot;, secondPerson);
     * firstPerson.put(&quot;children&quot;, new ArrayList());
     * firstPerson.put(&quot;extraInfo&quot;, null);
     * firstPerson.put(&quot;phoneNumbers&quot;, phoneNumbers);
     * List friends = new ArrayList();
     * friends.add(&quot;Paul&quot;);
     * friends.add(&quot;Karl&quot;);
     * friends.add(&quot;Mary&quot;);
     * firstPerson.put(&quot;onVacation&quot;, false);
     * firstPerson.put(&quot;friends&quot;, friends);
     *
     * Log.p(&quot;--- mapToJson() test&quot;);
     * Log.p(&quot;\n&quot; + mapToJson(firstPerson));
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * The output will be:
     * &lt;pre&gt;{@code
     * {
     *  &quot;firstName&quot;: &quot;Paco&quot;,
     *  &quot;lastName&quot;: &quot;Bellz&quot;,
     *  &quot;isAlive&quot;: true,
     *  &quot;age&quot;: 35,
     *  &quot;weight (kg)&quot;: 70.7,
     *  &quot;address&quot;: {
     *    &quot;streetAddress&quot;: &quot;53, London Street&quot;,
     *    &quot;city&quot;: &quot;Paris&quot;,
     *    &quot;state&quot;: &quot;FR&quot;,
     *    &quot;postalCode&quot;: &quot;54856&quot;
     *  },
     *  &quot;partner&quot;: {
     *    &quot;firstName&quot;: &quot;Gioia&quot;,
     *    &quot;lastName&quot;: &quot;Mia&quot;,
     *    &quot;isAlive&quot;: true,
     *    &quot;age&quot;: 34,
     *    &quot;weight (kg)&quot;: 60.2,
     *    &quot;address&quot;: {
     *      &quot;streetAddress&quot;: &quot;21 2nd Street&quot;,
     *      &quot;city&quot;: &quot;New York&quot;,
     *      &quot;state&quot;: &quot;NY&quot;,
     *      &quot;postalCode&quot;: &quot;10021-3100&quot;,
     *      &quot;phoneNumbers&quot;: [{&quot;mobile&quot;: &quot;06124578965&quot;}]
     *    }
     *  },
     *  &quot;children&quot;: [],
     *  &quot;extraInfo&quot;: null,
     *  &quot;phoneNumbers&quot;: [
     *    {&quot;home&quot;: &quot;212 555-1234&quot;},
     *    {&quot;office&quot;: &quot;646 555-4567&quot;},
     *    {&quot;mobile&quot;: &quot;123 456-7890&quot;}
     *  ],
     *  &quot;onVacation&quot;: false,
     *  &quot;friends&quot;: [
     *    &quot;Paul&quot;,
     *    &quot;Karl&quot;,
     *    &quot;Mary&quot;
     *  ]
     * }
     * }&lt;/pre&gt;
     *
     * @param map The map to be converted to a JSON string
     * @return The JSON string
     */
    public static String mapToJson(Map&lt;String, ?&gt; map) {
<span class="nc" id="L583">        return Result.fromContent(map).toString();</span>
    }

    /**
     * Checks to see if this parser generates long objects and not just doubles for numeric values.
     *
     * @return
     */
    public boolean isUseLongsInstance() {
<span class="fc" id="L592">        return useLongs;</span>
    }

    /**
     * Sets the current JSONParser instance to use longs instead of doubles for numeric values.  Prefer this to the static {@link #setUseLongs(boolean) }
     * so that it doesn't disrupt libraries that may depend on JSONParser.
     *
     * @param longs True to use
     * @since 7.0
     */
    public void setUseLongsInstance(boolean longs) {
<span class="fc" id="L603">        useLongs = longs;</span>
<span class="fc" id="L604">    }</span>

    /**
     * Checks whether this parser will include null values in parsed content.
     *
     * @return True if null values are included in parsed content.
     * @since 7.0
     */
    public boolean isIncludeNullsInstance() {
<span class="fc" id="L613">        return includeNulls;</span>
    }

    /**
     * Sets whether to include null values in parsed content.
     *
     * @param include True to include null values in parsed content.
     * @since 7.0
     */
    public void setIncludeNullsInstance(boolean include) {
<span class="fc" id="L623">        includeNulls = include;</span>
<span class="fc" id="L624">    }</span>

    /**
     * Indicates that the parser will generate Boolean objects and not just Strings for boolean values
     *
     * @return True if the parser will generate Boolean objects and not just Strings for boolean values.
     * @since 7.0
     */
    public boolean isUseBooleanInstance() {
<span class="fc" id="L633">        return useBoolean;</span>
    }

    /**
     * Indicates that the parser will generate Boolean objects and not just Strings for boolean values
     *
     * @param useBoolean True to generate Boolean objects and not just Strings for boolean values.
     * @since 7.0
     */
    public void setUseBooleanInstance(boolean useBoolean) {
<span class="fc" id="L643">        this.useBoolean = useBoolean;</span>
<span class="fc" id="L644">    }</span>

    /**
     * &lt;p&gt;
     * Parses the given input stream into this object and returns the parse tree.&lt;br&gt;
     * The {@code JSONParser} returns a {@code Map} which is great if the root object is a {@code Map} but in
     * some cases its a list of elements (as is the case above). In this case a special case {@code &quot;root&quot;} element is
     * created to contain the actual list of elements. See the sample below for exact usage of this.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The sample below includes JSON from &lt;a href=&quot;https://anapioficeandfire.com/&quot;&gt;https://anapioficeandfire.com/&lt;/a&gt;
     * generated by the query &lt;a href=&quot;http://www.anapioficeandfire.com/api/characters?page=5&amp;amp;pageSize=3&quot;&gt;http://www.anapioficeandfire.com/api/characters?page=5&amp;amp;pageSize=3&lt;/a&gt;:
     * &lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/codenameone/f9fdacaac12583cd2eed.js&quot;&gt;&lt;/script&gt;
     * &lt;img src=&quot;https://www.codenameone.com/img/developer-guide/json-parsing.png&quot; alt=&quot;JSON Parsing Result&quot;&gt;
     *
     * @param i the reader
     * @return the parse tree as a hashtable
     * @throws IOException if thrown by the stream
     */
    public Map&lt;String, Object&gt; parseJSON(Reader i) throws IOException {
<span class="fc" id="L665">        modern = true;</span>
<span class="fc" id="L666">        state = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L667">        parseStack = new ArrayList&lt;Object&gt;();</span>
<span class="fc" id="L668">        currentKey = null;</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">        if (!strict) {</span>
<span class="fc" id="L670">            i = new CharArrayReader(JSONSanitizer.sanitize(Util.readToString(i)).toCharArray());</span>
        }
<span class="fc" id="L672">        parse(i, this);</span>
<span class="fc" id="L673">        return state;</span>
    }

    /**
     * Parses the given input stream into this object and returns the parse tree
     *
     * @param i the reader
     * @return the parse tree as a hashtable
     * @throws IOException if thrown by the stream
     * @deprecated use the new parseJSON instead
     */
    public Hashtable&lt;String, Object&gt; parse(Reader i) throws IOException {
<span class="fc" id="L685">        modern = false;</span>
<span class="fc" id="L686">        Hashtable&lt;String, Object&gt; legacyState = new Hashtable&lt;String, Object&gt;();</span>
<span class="fc" id="L687">        state = legacyState;</span>
<span class="fc" id="L688">        parseStack = new Vector&lt;Object&gt;();</span>
<span class="fc" id="L689">        currentKey = null;</span>
<span class="pc bpc" id="L690" title="1 of 2 branches missed.">        if (!strict) {</span>
<span class="nc" id="L691">            String cleaned = JSONSanitizer.sanitize(Util.readToString(i));</span>
<span class="nc" id="L692">            i = new CharArrayReader(cleaned.toCharArray());</span>
        }
<span class="fc" id="L694">        parse(i, this);</span>
<span class="fc" id="L695">        return legacyState;</span>
    }

    private boolean isStackHash() {
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">        return parseStack.size() &gt; 0 &amp;&amp;</span>
<span class="fc bfc" id="L700" title="All 2 branches covered.">                parseStack.get(parseStack.size() - 1) instanceof Map;</span>
    }

    private Map getStackHash() {
<span class="fc" id="L704">        return (Map) parseStack.get(parseStack.size() - 1);</span>
    }

    private java.util.List&lt;Object&gt; getStackVec() {
<span class="fc" id="L708">        return (java.util.List&lt;Object&gt;) parseStack.get(parseStack.size() - 1);</span>
    }

    /**
     * {@inheritDoc}
     */
    public void startBlock(String blockName) {
<span class="fc bfc" id="L715" title="All 2 branches covered.">        if (parseStack.size() == 0) {</span>
<span class="fc" id="L716">            parseStack.add(state);</span>
        } else {
            Map newOne;
<span class="fc bfc" id="L719" title="All 2 branches covered.">            if (modern) {</span>
<span class="fc" id="L720">                newOne = new LinkedHashMap();</span>
            } else {
<span class="fc" id="L722">                newOne = new Hashtable();</span>
            }
<span class="fc bfc" id="L724" title="All 2 branches covered.">            if (isStackHash()) {</span>
<span class="fc" id="L725">                getStackHash().put(currentKey, newOne);</span>
<span class="fc" id="L726">                currentKey = null;</span>
            } else {
<span class="fc" id="L728">                getStackVec().add(newOne);</span>
            }
<span class="fc" id="L730">            parseStack.add(newOne);</span>
        }
<span class="fc" id="L732">    }</span>

    /**
     * {@inheritDoc}
     */
    public void endBlock(String blockName) {
<span class="fc" id="L738">        parseStack.remove(parseStack.size() - 1);</span>
<span class="fc" id="L739">    }</span>

    /**
     * Checks if this JSON parser is in strict mode.  When in strict mode, which is the default,
     * only valid JSON will be parsed.  If strict mode is disabled, then it will attempt to
     * sanitize the JSON input before parsing.  This can be handy if you want to parse structures
     * that are *almost* JSON.  E.g. non-quoted keys, single-quotes on strings, unquoted strings. Etc.
     *
     * @return True if strict mode is enabled.
     * @see #setStrict(boolean)
     * @since 7.0
     */
    public boolean isStrict() {
<span class="nc" id="L752">        return strict;</span>
    }

    /**
     * Enables or disables strict mode.  Default is true.
     * &lt;p&gt;When strict mode is disabled, the parser will sanitize the JSON input before parsing.  The effect
     * is that it will be able to parse input that is json-ish.&lt;/p&gt;
     * &lt;h3&gt;Non-Strict Input&lt;/h3&gt;
     * The sanitizer takes JSON like content, and interprets it as JS eval
     * would. Specifically, it deals with these non-standard constructs.
     * &lt;ul&gt;
     * &lt;li&gt;{@code '...'} Single quoted strings are converted to JSON strings.
     * &lt;li&gt;{@code \xAB} Hex escapes are converted to JSON unicode escapes.
     * &lt;li&gt;{@code \012} Octal escapes are converted to JSON unicode escapes.
     * &lt;li&gt;{@code 0xAB} Hex integer literals are converted to JSON decimal
     * numbers.
     * &lt;li&gt;{@code 012} Octal integer literals are converted to JSON decimal
     * numbers.
     * &lt;li&gt;{@code +.5} Decimal numbers are coerced to JSON's stricter format.
     * &lt;li&gt;{@code [0,,2]} Elisions in arrays are filled with {@code null}.
     * &lt;li&gt;{@code [1,2,3,]} Trailing commas are removed.
     * &lt;li&gt;&lt;code&gt;{foo:&quot;bar&quot;}&lt;/code&gt; Unquoted property names are quoted.
     * &lt;li&gt;&lt;code&gt;//comments&lt;/code&gt; JS style line and block comments are removed.
     * &lt;li&gt;&lt;code&gt;(...)&lt;/code&gt; Grouping parentheses are removed.
     * &lt;/ul&gt;
     *
     * @param strict True to enable strict mode, false to disable it.
     * @see #isStrict()
     */
    public void setStrict(boolean strict) {
<span class="fc" id="L782">        this.strict = strict;</span>
<span class="fc" id="L783">    }</span>

    /**
     * {@inheritDoc}
     */
    public void startArray(String arrayName) {
        java.util.List&lt;Object&gt; currentVector;
        Map newOne;
<span class="fc bfc" id="L791" title="All 2 branches covered.">        if (modern) {</span>
<span class="fc" id="L792">            currentVector = new ArrayList&lt;Object&gt;();</span>
        } else {
<span class="fc" id="L794">            currentVector = new Vector&lt;Object&gt;();</span>
        }

        // the root of the JSON is an array, we need to wrap it in an assignment
<span class="fc bfc" id="L798" title="All 2 branches covered.">        if (parseStack.size() == 0) {</span>
<span class="fc" id="L799">            parseStack.add(state);</span>
<span class="fc" id="L800">            currentKey = &quot;root&quot;;</span>
        }
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">        if (isStackHash()) {</span>
<span class="fc" id="L803">            getStackHash().put(currentKey, currentVector);</span>
<span class="fc" id="L804">            currentKey = null;</span>
        } else {
<span class="nc" id="L806">            getStackVec().add(currentVector);</span>
        }
<span class="fc" id="L808">        parseStack.add(currentVector);</span>
<span class="fc" id="L809">    }</span>

    /**
     * {@inheritDoc}
     */
    public void endArray(String arrayName) {
<span class="fc" id="L815">        parseStack.remove(parseStack.size() - 1);</span>
<span class="fc" id="L816">    }</span>

    /**
     * {@inheritDoc}
     */
    public void stringToken(String tok) {
<span class="fc bfc" id="L822" title="All 2 branches covered.">        if (isStackHash()) {</span>
<span class="fc bfc" id="L823" title="All 2 branches covered.">            if (currentKey == null) {</span>
<span class="fc" id="L824">                currentKey = tok;</span>
            } else {
<span class="pc bpc" id="L826" title="1 of 4 branches missed.">                if (tok != null || isIncludeNullsInstance()) {</span>
<span class="fc" id="L827">                    getStackHash().put(currentKey, tok);</span>
                }
<span class="fc" id="L829">                currentKey = null;</span>
            }
        } else {
<span class="fc" id="L832">            getStackVec().add(tok);</span>
        }
<span class="fc" id="L834">    }</span>

    /**
     * {@inheritDoc}
     */
    public void numericToken(double tok) {
<span class="fc bfc" id="L840" title="All 2 branches covered.">        if (isStackHash()) {</span>
<span class="fc" id="L841">            getStackHash().put(currentKey, new Double(tok));</span>
<span class="fc" id="L842">            currentKey = null;</span>
        } else {
<span class="fc" id="L844">            getStackVec().add(new Double(tok));</span>
        }
<span class="fc" id="L846">    }</span>

    /**
     * {@inheritDoc}
     */
    public void longToken(long tok) {
<span class="fc bfc" id="L852" title="All 2 branches covered.">        if (isStackHash()) {</span>
<span class="fc" id="L853">            getStackHash().put(currentKey, Long.valueOf(tok));</span>
<span class="fc" id="L854">            currentKey = null;</span>
        } else {
<span class="fc" id="L856">            getStackVec().add(Long.valueOf(tok));</span>
        }
<span class="fc" id="L858">    }</span>

    /**
     * {@inheritDoc}
     */
    public void booleanToken(boolean tok) {
<span class="pc bpc" id="L864" title="1 of 2 branches missed.">        if (isStackHash()) {</span>
<span class="fc" id="L865">            getStackHash().put(currentKey, tok);</span>
<span class="fc" id="L866">            currentKey = null;</span>
        } else {
<span class="nc" id="L868">            getStackVec().add(tok);</span>
        }
<span class="fc" id="L870">    }</span>

    /**
     * {@inheritDoc}
     */
    public void keyValue(String key, String value) {
<span class="fc" id="L876">    }</span>

    /**
     * {@inheritDoc}
     */
    public boolean isAlive() {
<span class="fc" id="L882">        return true;</span>
    }

<span class="fc" id="L885">    static class ReaderClass {</span>
        char[] buffer;
        int buffOffset;
<span class="fc" id="L888">        int buffSize = -1;</span>

        int read(Reader is) throws IOException {
<span class="fc" id="L891">            int c = -1;</span>
<span class="fc bfc" id="L892" title="All 2 branches covered.">            if (buffer == null) {</span>
<span class="fc" id="L893">                buffer = new char[8192];</span>
            }

<span class="fc bfc" id="L896" title="All 4 branches covered.">            if (buffSize &lt; 0 || buffOffset &gt;= buffSize) {</span>
<span class="fc" id="L897">                buffSize = is.read(buffer, 0, buffer.length);</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">                if (buffSize &lt; 0) {</span>
<span class="fc" id="L899">                    return -1;</span>
                }
<span class="fc" id="L901">                buffOffset = 0;</span>
            }
<span class="fc" id="L903">            c = buffer[buffOffset];</span>
<span class="fc" id="L904">            buffOffset++;</span>

<span class="fc" id="L906">            return c;</span>
        }

    }

<span class="fc" id="L911">    static class KeyStack extends Vector {</span>
        protected String peek() {
<span class="fc" id="L913">            return (String) elementAt(0);</span>
        }

        protected void push(String key) {
<span class="fc" id="L917">            insertElementAt(key, 0);</span>
<span class="fc" id="L918">        }</span>

        protected String pop() {
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">            if (isEmpty()) {</span>
<span class="nc" id="L922">                return null;</span>
            }
<span class="fc" id="L924">            String key = peek();</span>
<span class="fc" id="L925">            removeElementAt(0);</span>
<span class="fc" id="L926">            return key;</span>
        }
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>