<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RE.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codenameone-core-unittests</a> &gt; <a href="index.source.html" class="el_package">com.codename1.util.regex</a> &gt; <span class="el_source">RE.java</span></div><h1>RE.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.codename1.util.regex;

import java.util.ArrayList;

/**
 * RE is an efficient, lightweight regular expression evaluator/matcher
 * class. Regular expressions are pattern descriptions which enable
 * sophisticated matching of strings.  In addition to being able to
 * match a string against a pattern, you can also extract parts of the
 * match.  This is especially useful in text parsing! Details on the
 * syntax of regular expression patterns are given below.
 *
 * &lt;p&gt;
 * To compile a regular expression (RE), you can simply construct an RE
 * matcher object from the string specification of the pattern, like this:
 *
 * &lt;pre&gt;
 *  RE r = new RE(&quot;a*b&quot;);
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Once you have done this, you can call either of the RE.match methods to
 * perform matching on a String.  For example:
 *
 * &lt;pre&gt;
 *  boolean matched = r.match(&quot;aaaab&quot;);
 * &lt;/pre&gt;
 * &lt;p&gt;
 * will cause the boolean matched to be set to true because the
 * pattern &quot;a*b&quot; matches the string &quot;aaaab&quot;.
 *
 * &lt;p&gt;
 * If you were interested in the &lt;i&gt;number&lt;/i&gt; of a's which matched the
 * first part of our example expression, you could change the expression to
 * &quot;(a*)b&quot;.  Then when you compiled the expression and matched it against
 * something like &quot;xaaaab&quot;, you would get results like this:
 *
 * &lt;pre&gt;
 *  RE r = new RE(&quot;(a*)b&quot;);                  // Compile expression
 *  boolean matched = r.match(&quot;xaaaab&quot;);     // Match against &quot;xaaaab&quot;
 *
 *  String wholeExpr = r.getParen(0);        // wholeExpr will be 'aaaab'
 *  String insideParens = r.getParen(1);     // insideParens will be 'aaaa'
 *
 *  int startWholeExpr = r.getParenStart(0); // startWholeExpr will be index 1
 *  int endWholeExpr = r.getParenEnd(0);     // endWholeExpr will be index 6
 *  int lenWholeExpr = r.getParenLength(0);  // lenWholeExpr will be 5
 *
 *  int startInside = r.getParenStart(1);    // startInside will be index 1
 *  int endInside = r.getParenEnd(1);        // endInside will be index 5
 *  int lenInside = r.getParenLength(1);     // lenInside will be 4
 * &lt;/pre&gt;
 * &lt;p&gt;
 * You can also refer to the contents of a parenthesized expression
 * within a regular expression itself.  This is called a
 * 'backreference'.  The first backreference in a regular expression is
 * denoted by \1, the second by \2 and so on.  So the expression:
 *
 * &lt;pre&gt;
 *  ([0-9]+)=\1
 * &lt;/pre&gt;
 * &lt;p&gt;
 * will match any string of the form n=n (like 0=0 or 2=2).
 *
 * &lt;p&gt;
 * The full regular expression syntax accepted by RE is described here:
 *
 * &lt;pre&gt;
 *
 *  &lt;b&gt;&lt;font face=times roman&gt;Characters&lt;/font&gt;&lt;/b&gt;
 *
 *    &lt;i&gt;unicodeChar&lt;/i&gt;   Matches any identical unicode character
 *    \                    Used to quote a meta-character (like '*')
 *    \\                   Matches a single '\' character
 *    \0nnn                Matches a given octal character
 *    \xhh                 Matches a given 8-bit hexadecimal character
 *    \\uhhhh              Matches a given 16-bit hexadecimal character
 *    \t                   Matches an ASCII tab character
 *    \n                   Matches an ASCII newline character
 *    \r                   Matches an ASCII return character
 *    \f                   Matches an ASCII form feed character
 *
 *
 *  &lt;b&gt;&lt;font face=times roman&gt;Character Classes&lt;/font&gt;&lt;/b&gt;
 *
 *    [abc]                Simple character class
 *    [a-zA-Z]             Character class with ranges
 *    [^abc]               Negated character class
 * &lt;/pre&gt;
 *
 * &lt;b&gt;NOTE:&lt;/b&gt; Incomplete ranges will be interpreted as &amp;quot;starts
 * from zero&amp;quot; or &amp;quot;ends with last character&amp;quot;.
 * &lt;br&gt;
 * I.e. [-a] is the same as [\\u0000-a], and [a-] is the same as [a-\\uFFFF],
 * [-] means &amp;quot;all characters&amp;quot;.
 *
 * &lt;pre&gt;
 *
 *  &lt;b&gt;&lt;font face=times roman&gt;Standard POSIX Character Classes&lt;/font&gt;&lt;/b&gt;
 *
 *    [:alnum:]            Alphanumeric characters.
 *    [:alpha:]            Alphabetic characters.
 *    [:blank:]            Space and tab characters.
 *    [:cntrl:]            Control characters.
 *    [:digit:]            Numeric characters.
 *    [:graph:]            Characters that are printable and are also visible.
 *                         (A space is printable, but not visible, while an
 *                         `a' is both.)
 *    [:lower:]            Lower-case alphabetic characters.
 *    [:print:]            Printable characters (characters that are not
 *                         control characters.)
 *    [:punct:]            Punctuation characters (characters that are not letter,
 *                         digits, control characters, or space characters).
 *    [:space:]            Space characters (such as space, tab, and formfeed,
 *                         to name a few).
 *    [:upper:]            Upper-case alphabetic characters.
 *    [:xdigit:]           Characters that are hexadecimal digits.
 *
 *
 *  &lt;b&gt;&lt;font face=times roman&gt;Non-standard POSIX-style Character Classes&lt;/font&gt;&lt;/b&gt;
 *
 *    [:javastart:]        Start of a Java identifier
 *    [:javapart:]         Part of a Java identifier
 *
 *
 *  &lt;b&gt;&lt;font face=times roman&gt;Predefined Classes&lt;/font&gt;&lt;/b&gt;
 *
 *    .         Matches any character other than newline
 *    \w        Matches a &quot;word&quot; character (alphanumeric plus &quot;_&quot;)
 *    \W        Matches a non-word character
 *    \s        Matches a whitespace character
 *    \S        Matches a non-whitespace character
 *    \d        Matches a digit character
 *    \D        Matches a non-digit character
 *
 *
 *  &lt;b&gt;&lt;font face=times roman&gt;Boundary Matchers&lt;/font&gt;&lt;/b&gt;
 *
 *    ^         Matches only at the beginning of a line
 *    $         Matches only at the end of a line
 *    \b        Matches only at a word boundary
 *    \B        Matches only at a non-word boundary
 *
 *
 *  &lt;b&gt;&lt;font face=times roman&gt;Greedy Closures&lt;/font&gt;&lt;/b&gt;
 *
 *    A*        Matches A 0 or more times (greedy)
 *    A+        Matches A 1 or more times (greedy)
 *    A?        Matches A 1 or 0 times (greedy)
 *    A{n}      Matches A exactly n times (greedy)
 *    A{n,}     Matches A at least n times (greedy)
 *    A{n,m}    Matches A at least n but not more than m times (greedy)
 *
 *
 *  &lt;b&gt;&lt;font face=times roman&gt;Reluctant Closures&lt;/font&gt;&lt;/b&gt;
 *
 *    A*?       Matches A 0 or more times (reluctant)
 *    A+?       Matches A 1 or more times (reluctant)
 *    A??       Matches A 0 or 1 times (reluctant)
 *
 *
 *  &lt;b&gt;&lt;font face=times roman&gt;Logical Operators&lt;/font&gt;&lt;/b&gt;
 *
 *    AB        Matches A followed by B
 *    A|B       Matches either A or B
 *    (A)       Used for subexpression grouping
 *   (?:A)      Used for subexpression clustering (just like grouping but
 *              no backrefs)
 *
 *
 *  &lt;b&gt;&lt;font face=times roman&gt;Backreferences&lt;/font&gt;&lt;/b&gt;
 *
 *    \1    Backreference to 1st parenthesized subexpression
 *    \2    Backreference to 2nd parenthesized subexpression
 *    \3    Backreference to 3rd parenthesized subexpression
 *    \4    Backreference to 4th parenthesized subexpression
 *    \5    Backreference to 5th parenthesized subexpression
 *    \6    Backreference to 6th parenthesized subexpression
 *    \7    Backreference to 7th parenthesized subexpression
 *    \8    Backreference to 8th parenthesized subexpression
 *    \9    Backreference to 9th parenthesized subexpression
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * All closure operators (+, *, ?, {m,n}) are greedy by default, meaning
 * that they match as many elements of the string as possible without
 * causing the overall match to fail.  If you want a closure to be
 * reluctant (non-greedy), you can simply follow it with a '?'.  A
 * reluctant closure will match as few elements of the string as
 * possible when finding matches.  {m,n} closures don't currently
 * support reluctancy.
 *
 * &lt;p&gt;
 * &lt;b&gt;&lt;font face=&quot;times roman&quot;&gt;Line terminators&lt;/font&gt;&lt;/b&gt;
 * &lt;br&gt;
 * A line terminator is a one- or two-character sequence that marks
 * the end of a line of the input character sequence. The following
 * are recognized as line terminators:
 * &lt;ul&gt;
 * &lt;li&gt;A newline (line feed) character ('\n'),&lt;/li&gt;
 * &lt;li&gt;A carriage-return character followed immediately by a newline character (&quot;\r\n&quot;),&lt;/li&gt;
 * &lt;li&gt;A standalone carriage-return character ('\r'),&lt;/li&gt;
 * &lt;li&gt;A next-line character ('\u0085'),&lt;/li&gt;
 * &lt;li&gt;A line-separator character ('\u2028'), or&lt;/li&gt;
 * &lt;li&gt;A paragraph-separator character ('\u2029).&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * RE runs programs compiled by the RECompiler class.  But the RE
 * matcher class does not include the actual regular expression compiler
 * for reasons of efficiency. You can construct a single RECompiler object and
 * re-use it to compile each expression. Similarly, you can change the
 * program run by a given matcher object at any time. However, RE and
 * RECompiler are not threadsafe (for efficiency reasons, and because
 * requiring thread safety in this class is deemed to be a rare
 * requirement), so you will need to construct a separate compiler or
 * matcher object for each thread (unless you do thread synchronization
 * yourself). Once expression compiled into the REProgram object, REProgram
 * can be safely shared across multiple threads and RE objects.
 *
 * &lt;br&gt;&lt;p&gt;&lt;br&gt;
 *
 * &lt;font color=&quot;red&quot;&gt;
 * &lt;i&gt;ISSUES:&lt;/i&gt;
 *
 * &lt;ul&gt;
 *  &lt;li&gt;com.weusours.util.re is not currently compatible with all
 *      standard POSIX regcomp flags&lt;/li&gt;
 *  &lt;li&gt;com.weusours.util.re does not support POSIX equivalence classes
 *      ([=foo=] syntax) (I18N/locale issue)&lt;/li&gt;
 *  &lt;li&gt;com.weusours.util.re does not support nested POSIX character
 *      classes (definitely should, but not completely trivial)&lt;/li&gt;
 *  &lt;li&gt;com.weusours.util.re Does not support POSIX character collation
 *      concepts ([.foo.] syntax) (I18N/locale issue)&lt;/li&gt;
 *  &lt;li&gt;Should there be different matching styles (simple, POSIX, Perl etc?)&lt;/li&gt;
 *  &lt;li&gt;Should RE support character iterators (for backwards RE matching!)?&lt;/li&gt;
 *  &lt;li&gt;Should RE support reluctant {m,n} closures (does anyone care)?&lt;/li&gt;
 *  &lt;li&gt;Not *all* possibilities are considered for greediness when backreferences
 *      are involved (as POSIX suggests should be the case).  The POSIX RE
 *      &quot;(ac*)c*d[ac]*\1&quot;, when matched against &quot;acdacaa&quot; should yield a match
 *      of acdacaa where \1 is &quot;a&quot;.  This is not the case in this RE package,
 *      and actually Perl doesn't go to this extent either!  Until someone
 *      actually complains about this, I'm not sure it's worth &quot;fixing&quot;.
 *      If it ever is fixed, test #137 in RETest.txt should be updated.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;/font&gt;
 *
 * @author &lt;a href=&quot;mailto:jonl@muppetlabs.com&quot;&gt;Jonathan Locke&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:ts@sch-fer.de&quot;&gt;Tobias Sch&amp;auml;fer&lt;/a&gt;
 * @see RECompiler
 */
public class RE {

    /**
     * Specifies normal, case-sensitive matching behaviour.
     */
    public static final int MATCH_NORMAL = 0x0000;
    /**
     * Flag to indicate that matching should be case-independent (folded)
     */
    public static final int MATCH_CASEINDEPENDENT = 0x0001;
    /**
     * Newlines should match as BOL/EOL (^ and $)
     */
    public static final int MATCH_MULTILINE = 0x0002;
    /**
     * Consider all input a single body of text - newlines are matched by .
     */
    public static final int MATCH_SINGLELINE = 0x0004;
    /**
     * Flag bit that indicates that subst should replace all occurrences of this
     * regular expression.
     */
    public static final int REPLACE_ALL = 0x0000;
    /**
     * Flag bit that indicates that subst should only replace the first occurrence
     * of this regular expression.
     */
    public static final int REPLACE_FIRSTONLY = 0x0001;
    /**
     * Flag bit that indicates that subst should replace backreferences
     */
    public static final int REPLACE_BACKREFERENCES = 0x0002;
    /************************************************
     *                                              *
     * The format of a node in a program is:        *
     *                                              *
     * [ OPCODE ] [ OPDATA ] [ OPNEXT ] [ OPERAND ] *
     *                                              *
     * char OPCODE - instruction                    *
     * char OPDATA - modifying data                 *
     * char OPNEXT - next node (relative offset)    *
     *                                              *
     ************************************************/

    //   Opcode              Char       Opdata/Operand  Meaning
    //   ----------          ---------- --------------- --------------------------------------------------
    static final char OP_END = 'E';  //                 end of program
    static final char OP_BOL = '^';  //                 match only if at beginning of line
    static final char OP_EOL = '$';  //                 match only if at end of line
    static final char OP_ANY = '.';  //                 match any single character except newline
    static final char OP_ANYOF = '[';  // count/ranges    match any char in the list of ranges
    static final char OP_BRANCH = '|';  // node            match this alternative or the next one
    static final char OP_ATOM = 'A';  // length/string   length of string followed by string itself
    static final char OP_STAR = '*';  // node            kleene closure
    static final char OP_PLUS = '+';  // node            positive closure
    static final char OP_MAYBE = '?';  // node            optional closure
    static final char OP_ESCAPE = '\\'; // escape          special escape code char class (escape is E_* code)
    static final char OP_OPEN = '(';  // number          nth opening paren
    static final char OP_OPEN_CLUSTER = '&lt;';  //                 opening cluster
    static final char OP_CLOSE = ')';  // number          nth closing paren
    static final char OP_CLOSE_CLUSTER = '&gt;';  //                 closing cluster
    static final char OP_BACKREF = '#';  // number          reference nth already matched parenthesized string
    static final char OP_GOTO = 'G';  //                 nothing but a (back-)pointer
    static final char OP_NOTHING = 'N';  //                 match null string such as in '(a|)'
    static final char OP_CONTINUE = 'C';  //                 continue to the following command (ignore next)
    static final char OP_RELUCTANTSTAR = '8';  // none/expr       reluctant '*' (mnemonic for char is unshifted '*')
    static final char OP_RELUCTANTPLUS = '=';  // none/expr       reluctant '+' (mnemonic for char is unshifted '+')
    static final char OP_RELUCTANTMAYBE = '/';  // none/expr       reluctant '?' (mnemonic for char is unshifted '?')
    static final char OP_POSIXCLASS = 'P';  // classid         one of the posix character classes
    // Escape codes
    static final char E_ALNUM = 'w';  // Alphanumeric
    static final char E_NALNUM = 'W';  // Non-alphanumeric
    static final char E_BOUND = 'b';  // Word boundary
    static final char E_NBOUND = 'B';  // Non-word boundary
    static final char E_SPACE = 's';  // Whitespace
    static final char E_NSPACE = 'S';  // Non-whitespace
    static final char E_DIGIT = 'd';  // Digit
    static final char E_NDIGIT = 'D';  // Non-digit
    // Posix character classes
    static final char POSIX_CLASS_ALNUM = 'w';  // Alphanumerics
    static final char POSIX_CLASS_ALPHA = 'a';  // Alphabetics
    static final char POSIX_CLASS_BLANK = 'b';  // Blanks
    static final char POSIX_CLASS_CNTRL = 'c';  // Control characters
    static final char POSIX_CLASS_DIGIT = 'd';  // Digits
    static final char POSIX_CLASS_GRAPH = 'g';  // Graphic characters
    static final char POSIX_CLASS_LOWER = 'l';  // Lowercase characters
    static final char POSIX_CLASS_PRINT = 'p';  // Printable characters
    static final char POSIX_CLASS_PUNCT = '!';  // Punctuation
    static final char POSIX_CLASS_SPACE = 's';  // Spaces
    static final char POSIX_CLASS_UPPER = 'u';  // Uppercase characters
    static final char POSIX_CLASS_XDIGIT = 'x';  // Hexadecimal digits
    static final char POSIX_CLASS_JSTART = 'j';  // Java identifier start
    static final char POSIX_CLASS_JPART = 'k';  // Java identifier part
    // Limits
    static final int maxNode = 65536;            // Maximum number of nodes in a program
    static final int MAX_PAREN = 16;              // Number of paren pairs (only 9 can be backrefs)
    // Node layout constants
    static final int offsetOpcode = 0;            // Opcode offset (first character)
    static final int offsetOpdata = 1;            // Opdata offset (second char)
    static final int offsetNext = 2;            // Next index offset (third char)
    static final int nodeSize = 3;            // Node size (in chars)
    // State of current program
    REProgram program;                            // Compiled regular expression 'program'
    transient CharacterIterator search;           // The string being matched against
    int matchFlags;                               // Match behaviour flags
<span class="fc" id="L374">    int maxParen = MAX_PAREN;</span>
    // Parenthesized subexpressions
    transient int parenCount;                     // Number of subexpressions matched (num open parens + 1)
    transient int start0;                         // Cache of start[0]
    transient int end0;                           // Cache of start[0]
    transient int start1;                         // Cache of start[1]
    transient int end1;                           // Cache of start[1]
    transient int start2;                         // Cache of start[2]
    transient int end2;                           // Cache of start[2]
    transient int[] startn;                       // Lazy-alloced array of sub-expression starts
    transient int[] endn;                         // Lazy-alloced array of sub-expression ends
    // Backreferences
    transient int[] startBackref;                 // Lazy-alloced array of backref starts
    transient int[] endBackref;                   // Lazy-alloced array of backref ends

    /**
     * Constructs a regular expression matcher from a String by compiling it
     * using a new instance of RECompiler.  If you will be compiling many
     * expressions, you may prefer to use a single RECompiler object instead.
     *
     * @param pattern The regular expression pattern to compile.
     * @throws RESyntaxException Thrown if the regular expression has invalid syntax.
     * @see RECompiler
     */
    public RE(String pattern) throws RESyntaxException {
<span class="fc" id="L399">        this(pattern, MATCH_NORMAL);</span>
<span class="fc" id="L400">    }</span>

    /**
     * Constructs a regular expression matcher from a String by compiling it
     * using a new instance of RECompiler.  If you will be compiling many
     * expressions, you may prefer to use a single RECompiler object instead.
     *
     * @param pattern    The regular expression pattern to compile.
     * @param matchFlags The matching style
     * @throws RESyntaxException Thrown if the regular expression has invalid syntax.
     * @see RECompiler
     */
    public RE(String pattern, int matchFlags) throws RESyntaxException {
<span class="fc" id="L413">        this(new RECompiler().compile(pattern), matchFlags);</span>
<span class="fc" id="L414">    }</span>

    /**
     * Construct a matcher for a pre-compiled regular expression from program
     * (bytecode) data.  Permits special flags to be passed in to modify matching
     * behaviour.
     *
     * @param program    Compiled regular expression program (see RECompiler)
     * @param matchFlags One or more of the RE match behaviour flags (RE.MATCH_*):
     *
     *                   &lt;pre&gt;
     *                     MATCH_NORMAL              // Normal (case-sensitive) matching
     *                     MATCH_CASEINDEPENDENT     // Case folded comparisons
     *                     MATCH_MULTILINE           // Newline matches as BOL/EOL
     *                   &lt;/pre&gt;
     * @see RECompiler
     * @see REProgram
     */
<span class="fc" id="L432">    public RE(REProgram program, int matchFlags) {</span>
<span class="fc" id="L433">        setProgram(program);</span>
<span class="fc" id="L434">        setMatchFlags(matchFlags);</span>
<span class="fc" id="L435">    }</span>

    /**
     * Construct a matcher for a pre-compiled regular expression from program
     * (bytecode) data.
     *
     * @param program Compiled regular expression program
     * @see RECompiler
     */
    public RE(REProgram program) {
<span class="nc" id="L445">        this(program, MATCH_NORMAL);</span>
<span class="nc" id="L446">    }</span>

    /**
     * Constructs a regular expression matcher with no initial program.
     * This is likely to be an uncommon practice, but is still supported.
     */
    public RE() {
<span class="nc" id="L453">        this((REProgram) null, MATCH_NORMAL);</span>
<span class="nc" id="L454">    }</span>

    /**
     * Converts a 'simplified' regular expression to a full regular expression
     *
     * @param pattern The pattern to convert
     * @return The full regular expression
     */
    public static String simplePatternToFullRegularExpression(String pattern) {
<span class="nc" id="L463">        StringBuffer buf = new StringBuffer();</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">        for (int i = 0; i &lt; pattern.length(); i++) {</span>
<span class="nc" id="L465">            char c = pattern.charAt(i);</span>
<span class="nc bnc" id="L466" title="All 3 branches missed.">            switch (c) {</span>
                case '*':
<span class="nc" id="L468">                    buf.append(&quot;.*&quot;);</span>
<span class="nc" id="L469">                    break;</span>

                case '.':
                case '[':
                case ']':
                case '\\':
                case '+':
                case '?':
                case '{':
                case '}':
                case '$':
                case '^':
                case '|':
                case '(':
                case ')':
<span class="nc" id="L484">                    buf.append('\\');</span>
                default:
<span class="nc" id="L486">                    buf.append(c);</span>
                    break;
            }
        }
<span class="nc" id="L490">        return buf.toString();</span>
    }

    /**
     * Returns the current match behaviour flags.
     *
     * @return Current match behaviour flags (RE.MATCH_*).
     *
     * &lt;pre&gt;
     *   MATCH_NORMAL              // Normal (case-sensitive) matching
     *   MATCH_CASEINDEPENDENT     // Case folded comparisons
     *   MATCH_MULTILINE           // Newline matches as BOL/EOL
     * &lt;/pre&gt;
     * @see #setMatchFlags
     */
    public int getMatchFlags() {
<span class="nc" id="L506">        return matchFlags;</span>
    }

    /**
     * Sets match behaviour flags which alter the way RE does matching.
     *
     * @param matchFlags One or more of the RE match behaviour flags (RE.MATCH_*):
     *
     *                   &lt;pre&gt;
     *                     MATCH_NORMAL              // Normal (case-sensitive) matching
     *                     MATCH_CASEINDEPENDENT     // Case folded comparisons
     *                     MATCH_MULTILINE           // Newline matches as BOL/EOL
     *                   &lt;/pre&gt;
     */
    public void setMatchFlags(int matchFlags) {
<span class="fc" id="L521">        this.matchFlags = matchFlags;</span>
<span class="fc" id="L522">    }</span>

    /**
     * Returns the current regular expression program in use by this matcher object.
     *
     * @return Regular expression program
     * @see #setProgram
     */
    public REProgram getProgram() {
<span class="nc" id="L531">        return program;</span>
    }

    /**
     * Sets the current regular expression program used by this matcher object.
     *
     * @param program Regular expression program compiled by RECompiler.
     * @see RECompiler
     * @see REProgram
     */
    public void setProgram(REProgram program) {
<span class="fc" id="L542">        this.program = program;</span>
<span class="pc bpc" id="L543" title="2 of 4 branches missed.">        if (program != null &amp;&amp; program.maxParens != -1) {</span>
<span class="fc" id="L544">            this.maxParen = program.maxParens;</span>
        } else {
<span class="nc" id="L546">            this.maxParen = MAX_PAREN;</span>
        }
<span class="fc" id="L548">    }</span>

    /**
     * Returns the number of parenthesized subexpressions available after a successful match.
     *
     * @return Number of available parenthesized subexpressions
     */
    public int getParenCount() {
<span class="fc" id="L556">        return parenCount;</span>
    }

    /**
     * Gets the contents of a parenthesized subexpression after a successful match.
     *
     * @param which Nesting level of subexpression
     * @return String
     */
    public String getParen(int which) {
        int start;
<span class="pc bpc" id="L567" title="2 of 4 branches missed.">        if (which &lt; parenCount &amp;&amp; (start = getParenStart(which)) &gt;= 0) {</span>
<span class="fc" id="L568">            return search.substring(start, getParenEnd(which));</span>
        }
<span class="nc" id="L570">        return null;</span>
    }

    /**
     * Returns the start index of a given paren level.
     *
     * @param which Nesting level of subexpression
     * @return String index
     */
    public final int getParenStart(int which) {
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">        if (which &lt; parenCount) {</span>
<span class="pc bpc" id="L581" title="1 of 4 branches missed.">            switch (which) {</span>
                case 0:
<span class="fc" id="L583">                    return start0;</span>

                case 1:
<span class="fc" id="L586">                    return start1;</span>

                case 2:
<span class="fc" id="L589">                    return start2;</span>

                default:
<span class="nc bnc" id="L592" title="All 2 branches missed.">                    if (startn == null) {</span>
<span class="nc" id="L593">                        allocParens();</span>
                    }
<span class="nc" id="L595">                    return startn[which];</span>
            }
        }
<span class="nc" id="L598">        return -1;</span>
    }

    /**
     * Returns the end index of a given paren level.
     *
     * @param which Nesting level of subexpression
     * @return String index
     */
    public final int getParenEnd(int which) {
<span class="pc bpc" id="L608" title="1 of 2 branches missed.">        if (which &lt; parenCount) {</span>
<span class="pc bpc" id="L609" title="1 of 4 branches missed.">            switch (which) {</span>
                case 0:
<span class="fc" id="L611">                    return end0;</span>

                case 1:
<span class="fc" id="L614">                    return end1;</span>

                case 2:
<span class="fc" id="L617">                    return end2;</span>

                default:
<span class="nc bnc" id="L620" title="All 2 branches missed.">                    if (endn == null) {</span>
<span class="nc" id="L621">                        allocParens();</span>
                    }
<span class="nc" id="L623">                    return endn[which];</span>
            }
        }
<span class="nc" id="L626">        return -1;</span>
    }

    /**
     * Returns the length of a given paren level.
     *
     * @param which Nesting level of subexpression
     * @return Number of characters in the parenthesized subexpression
     */
    public final int getParenLength(int which) {
<span class="nc bnc" id="L636" title="All 2 branches missed.">        if (which &lt; parenCount) {</span>
<span class="nc" id="L637">            return getParenEnd(which) - getParenStart(which);</span>
        }
<span class="nc" id="L639">        return -1;</span>
    }

    /**
     * Sets the start of a paren level
     *
     * @param which Which paren level
     * @param i     Index in input array
     */
    protected final void setParenStart(int which, int i) {
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">        if (which &lt; parenCount) {</span>
<span class="pc bpc" id="L650" title="1 of 4 branches missed.">            switch (which) {</span>
                case 0:
<span class="fc" id="L652">                    start0 = i;</span>
<span class="fc" id="L653">                    break;</span>

                case 1:
<span class="fc" id="L656">                    start1 = i;</span>
<span class="fc" id="L657">                    break;</span>

                case 2:
<span class="fc" id="L660">                    start2 = i;</span>
<span class="fc" id="L661">                    break;</span>

                default:
<span class="nc bnc" id="L664" title="All 2 branches missed.">                    if (startn == null) {</span>
<span class="nc" id="L665">                        allocParens();</span>
                    }
<span class="nc" id="L667">                    startn[which] = i;</span>
                    break;
            }
        }
<span class="fc" id="L671">    }</span>

    /**
     * Sets the end of a paren level
     *
     * @param which Which paren level
     * @param i     Index in input array
     */
    protected final void setParenEnd(int which, int i) {
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">        if (which &lt; parenCount) {</span>
<span class="pc bpc" id="L681" title="1 of 4 branches missed.">            switch (which) {</span>
                case 0:
<span class="fc" id="L683">                    end0 = i;</span>
<span class="fc" id="L684">                    break;</span>

                case 1:
<span class="fc" id="L687">                    end1 = i;</span>
<span class="fc" id="L688">                    break;</span>

                case 2:
<span class="fc" id="L691">                    end2 = i;</span>
<span class="fc" id="L692">                    break;</span>

                default:
<span class="nc bnc" id="L695" title="All 2 branches missed.">                    if (endn == null) {</span>
<span class="nc" id="L696">                        allocParens();</span>
                    }
<span class="nc" id="L698">                    endn[which] = i;</span>
                    break;
            }
        }
<span class="fc" id="L702">    }</span>

    /**
     * Throws an Error representing an internal error condition probably resulting
     * from a bug in the regular expression compiler (or possibly data corruption).
     * In practice, this should be very rare.
     *
     * @param s Error description
     */
    protected void internalError(String s) throws Error {
<span class="nc" id="L712">        throw new Error(&quot;RE internal error: &quot; + s);</span>
    }

    /**
     * Performs lazy allocation of subexpression arrays
     */
    private void allocParens() {
        // Allocate arrays for subexpressions
<span class="nc" id="L720">        startn = new int[maxParen];</span>
<span class="nc" id="L721">        endn = new int[maxParen];</span>

        // Set sub-expression pointers to invalid values
<span class="nc bnc" id="L724" title="All 2 branches missed.">        for (int i = 0; i &lt; maxParen; i++) {</span>
<span class="nc" id="L725">            startn[i] = -1;</span>
<span class="nc" id="L726">            endn[i] = -1;</span>
        }
<span class="nc" id="L728">    }</span>

    /**
     * Try to match a string against a subset of nodes in the program
     *
     * @param firstNode Node to start at in program
     * @param lastNode  Last valid node (used for matching a subexpression without
     *                  matching the rest of the program as well).
     * @param idxStart  Starting position in character array
     * @return Final input array index if match succeeded.  -1 if not.
     */
    protected int matchNodes(int firstNode, int lastNode, int idxStart) {
        // Our current place in the string
<span class="fc" id="L741">        int idx = idxStart;</span>

        // Loop while node is valid
        int next, opcode, opdata;
        int idxNew;
<span class="fc" id="L746">        char[] instruction = program.instruction;</span>
<span class="pc bpc" id="L747" title="1 of 2 branches missed.">        for (int node = firstNode; node &lt; lastNode; ) {</span>
<span class="fc" id="L748">            opcode = instruction[node /* + offsetOpcode */];</span>
<span class="fc" id="L749">            next = node + (short) instruction[node + offsetNext];</span>
<span class="fc" id="L750">            opdata = instruction[node + offsetOpdata];</span>

<span class="pc bpc" id="L752" title="9 of 19 branches missed.">            switch (opcode) {</span>
                case OP_MAYBE:
                case OP_STAR: {
                    // Try to match the following subexpr. If it matches:
                    //   MAYBE:  Continues matching rest of the expression
                    //    STAR:  Points back here to repeat subexpr matching
<span class="nc bnc" id="L758" title="All 2 branches missed.">                    if ((idxNew = matchNodes(node + nodeSize, maxNode, idx)) != -1) {</span>
<span class="nc" id="L759">                        return idxNew;</span>
                    }

                    // If failed, just continue with the rest of expression
                    break;
                }

                case OP_PLUS: {
                    // Try to match the subexpr again (and again (and ...
<span class="fc bfc" id="L768" title="All 2 branches covered.">                    if ((idxNew = matchNodes(next, maxNode, idx)) != -1) {</span>
<span class="fc" id="L769">                        return idxNew;</span>
                    }

                    // If failed, just continue with the rest of expression
                    // Rest is located at the next pointer of the next instruction
                    // (which must be OP_CONTINUE)
<span class="fc" id="L775">                    node = next + (short) instruction[next + offsetNext];</span>
<span class="fc" id="L776">                    continue;</span>
                }

                case OP_RELUCTANTMAYBE:
                case OP_RELUCTANTSTAR: {
                    // Try to match the rest without using the reluctant subexpr
<span class="nc bnc" id="L782" title="All 2 branches missed.">                    if ((idxNew = matchNodes(next, maxNode, idx)) != -1) {</span>
<span class="nc" id="L783">                        return idxNew;</span>
                    }

                    // Try reluctant subexpr. If it matches:
                    //   RELUCTANTMAYBE: Continues matching rest of the expression
                    //    RELUCTANTSTAR: Points back here to repeat reluctant star matching
<span class="nc" id="L789">                    return matchNodes(node + nodeSize, next, idx);</span>
                }

                case OP_RELUCTANTPLUS: {
                    // Continue matching the rest without using the reluctant subexpr
<span class="nc bnc" id="L794" title="All 2 branches missed.">                    if ((idxNew = matchNodes(next + (short) instruction[next + offsetNext], maxNode, idx)) != -1) {</span>
<span class="nc" id="L795">                        return idxNew;</span>
                    }

                    // Try to match subexpression again
                    break;
                }

                case OP_OPEN:

                    // Match subexpression
<span class="pc bpc" id="L805" title="1 of 2 branches missed.">                    if ((program.flags &amp; REProgram.OPT_HASBACKREFS) != 0) {</span>
<span class="nc" id="L806">                        startBackref[opdata] = idx;</span>
                    }
<span class="fc bfc" id="L808" title="All 2 branches covered.">                    if ((idxNew = matchNodes(next, maxNode, idx)) != -1) {</span>
                        // Increase valid paren count
<span class="pc bpc" id="L810" title="1 of 2 branches missed.">                        if (opdata &gt;= parenCount) {</span>
<span class="nc" id="L811">                            parenCount = opdata + 1;</span>
                        }

                        // Don't set paren if already set later on
<span class="pc bpc" id="L815" title="1 of 2 branches missed.">                        if (getParenStart(opdata) == -1) {</span>
<span class="fc" id="L816">                            setParenStart(opdata, idx);</span>
                        }
                    }
<span class="fc" id="L819">                    return idxNew;</span>

                case OP_CLOSE:

                    // Done matching subexpression
<span class="pc bpc" id="L824" title="1 of 2 branches missed.">                    if ((program.flags &amp; REProgram.OPT_HASBACKREFS) != 0) {</span>
<span class="nc" id="L825">                        endBackref[opdata] = idx;</span>
                    }
<span class="fc bfc" id="L827" title="All 2 branches covered.">                    if ((idxNew = matchNodes(next, maxNode, idx)) != -1) {</span>
                        // Increase valid paren count
<span class="fc bfc" id="L829" title="All 2 branches covered.">                        if (opdata &gt;= parenCount) {</span>
<span class="fc" id="L830">                            parenCount = opdata + 1;</span>
                        }

                        // Don't set paren if already set later on
<span class="pc bpc" id="L834" title="1 of 2 branches missed.">                        if (getParenEnd(opdata) == -1) {</span>
<span class="fc" id="L835">                            setParenEnd(opdata, idx);</span>
                        }
                    }
<span class="fc" id="L838">                    return idxNew;</span>

                case OP_BACKREF: {
                    // Get the start and end of the backref
<span class="nc" id="L842">                    int s = startBackref[opdata];</span>
<span class="nc" id="L843">                    int e = endBackref[opdata];</span>

                    // We don't know the backref yet
<span class="nc bnc" id="L846" title="All 4 branches missed.">                    if (s == -1 || e == -1) {</span>
<span class="nc" id="L847">                        return -1;</span>
                    }

                    // The backref is empty size
<span class="nc bnc" id="L851" title="All 2 branches missed.">                    if (s == e) {</span>
<span class="nc" id="L852">                        break;</span>
                    }

                    // Get the length of the backref
<span class="nc" id="L856">                    int l = e - s;</span>

                    // If there's not enough input left, give up.
<span class="nc bnc" id="L859" title="All 2 branches missed.">                    if (search.isEnd(idx + l - 1)) {</span>
<span class="nc" id="L860">                        return -1;</span>
                    }

                    // Case fold the backref?
<span class="nc bnc" id="L864" title="All 2 branches missed.">                    final boolean caseFold =</span>
                            ((matchFlags &amp; MATCH_CASEINDEPENDENT) != 0);
                    // Compare backref to input
<span class="nc bnc" id="L867" title="All 2 branches missed.">                    for (int i = 0; i &lt; l; i++) {</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">                        if (compareChars(search.charAt(idx++), search.charAt(s + i), caseFold) != 0) {</span>
<span class="nc" id="L869">                            return -1;</span>
                        }
                    }
                }
<span class="nc" id="L873">                break;</span>

                case OP_BOL:

                    // Fail if we're not at the start of the string
<span class="fc bfc" id="L878" title="All 2 branches covered.">                    if (idx != 0) {</span>
                        // If we're multiline matching, we could still be at the start of a line
<span class="pc bpc" id="L880" title="1 of 2 branches missed.">                        if ((matchFlags &amp; MATCH_MULTILINE) == MATCH_MULTILINE) {</span>
                            // Continue if at the start of a line
<span class="nc bnc" id="L882" title="All 2 branches missed.">                            if (isNewline(idx - 1)) {</span>
<span class="nc" id="L883">                                break;</span>
                            }
                        }
<span class="fc" id="L886">                        return -1;</span>
                    }
                    break;

                case OP_EOL:

                    // If we're not at the end of string
<span class="pc bpc" id="L893" title="2 of 4 branches missed.">                    if (!search.isEnd(0) &amp;&amp; !search.isEnd(idx)) {</span>
                        // If we're multi-line matching
<span class="nc bnc" id="L895" title="All 2 branches missed.">                        if ((matchFlags &amp; MATCH_MULTILINE) == MATCH_MULTILINE) {</span>
                            // Continue if we're at the end of a line
<span class="nc bnc" id="L897" title="All 2 branches missed.">                            if (isNewline(idx)) {</span>
<span class="nc" id="L898">                                break;</span>
                            }
                        }
<span class="nc" id="L901">                        return -1;</span>
                    }
                    break;

                case OP_ESCAPE:

                    // Which escape?
<span class="pc bpc" id="L908" title="2 of 3 branches missed.">                    switch (opdata) {</span>
                        // Word boundary match
                        case E_NBOUND:
                        case E_BOUND: {
<span class="nc bnc" id="L912" title="All 2 branches missed.">                            char cLast = ((idx == 0) ? '\n' : search.charAt(idx - 1));</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">                            char cNext = ((search.isEnd(idx)) ? '\n' : search.charAt(idx));</span>
<span class="nc bnc" id="L914" title="All 6 branches missed.">                            if ((RECharacter.isLetterOrDigit(cLast) == RECharacter.isLetterOrDigit(cNext)) == (opdata == E_BOUND)) {</span>
<span class="nc" id="L915">                                return -1;</span>
                            }
                        }
<span class="nc" id="L918">                        break;</span>

                        // Alpha-numeric, digit, space, javaLetter, javaLetterOrDigit
                        case E_ALNUM:
                        case E_NALNUM:
                        case E_DIGIT:
                        case E_NDIGIT:
                        case E_SPACE:
                        case E_NSPACE:

                            // Give up if out of input
<span class="fc bfc" id="L929" title="All 2 branches covered.">                            if (search.isEnd(idx)) {</span>
<span class="fc" id="L930">                                return -1;</span>
                            }

<span class="fc" id="L933">                            char c = search.charAt(idx);</span>

                            // Switch on escape
<span class="pc bpc" id="L936" title="2 of 4 branches missed.">                            switch (opdata) {</span>
                                case E_ALNUM:
                                case E_NALNUM:
<span class="pc bpc" id="L939" title="2 of 8 branches missed.">                                    if (!((RECharacter.isLetterOrDigit(c) || c == '_') == (opdata == E_ALNUM))) {</span>
<span class="fc" id="L940">                                        return -1;</span>
                                    }
                                    break;

                                case E_DIGIT:
                                case E_NDIGIT:
<span class="pc bpc" id="L946" title="1 of 4 branches missed.">                                    if (!(RECharacter.isDigit(c) == (opdata == E_DIGIT))) {</span>
<span class="fc" id="L947">                                        return -1;</span>
                                    }
                                    break;

                                case E_SPACE:
                                case E_NSPACE:
<span class="nc bnc" id="L953" title="All 4 branches missed.">                                    if (!(RECharacter.isWhitespace(c) == (opdata == E_SPACE))) {</span>
<span class="nc" id="L954">                                        return -1;</span>
                                    }
                                    break;
                            }
<span class="fc" id="L958">                            idx++;</span>
<span class="fc" id="L959">                            break;</span>

                        default:
<span class="nc" id="L962">                            internalError(&quot;Unrecognized escape '&quot; + opdata + &quot;'&quot;);</span>
                    }
<span class="nc" id="L964">                    break;</span>

                case OP_ANY:

<span class="nc bnc" id="L968" title="All 2 branches missed.">                    if ((matchFlags &amp; MATCH_SINGLELINE) == MATCH_SINGLELINE) {</span>
                        // Match anything
<span class="nc bnc" id="L970" title="All 2 branches missed.">                        if (search.isEnd(idx)) {</span>
<span class="nc" id="L971">                            return -1;</span>
                        }
                    } else {
                        // Match anything but a newline
<span class="nc bnc" id="L975" title="All 4 branches missed.">                        if (search.isEnd(idx) || isNewline(idx)) {</span>
<span class="nc" id="L976">                            return -1;</span>
                        }
                    }
<span class="nc" id="L979">                    idx++;</span>
<span class="nc" id="L980">                    break;</span>

                case OP_ATOM: {
                    // Match an atom value
<span class="pc bpc" id="L984" title="1 of 2 branches missed.">                    if (search.isEnd(idx)) {</span>
<span class="nc" id="L985">                        return -1;</span>
                    }

                    // Get length of atom and starting index
                    // int lenAtom = opdata;
<span class="fc" id="L990">                    int startAtom = node + nodeSize;</span>

                    // Give up if not enough input remains to have a match
<span class="pc bpc" id="L993" title="1 of 2 branches missed.">                    if (search.isEnd(opdata + idx - 1)) {</span>
<span class="nc" id="L994">                        return -1;</span>
                    }

                    // Match atom differently depending on casefolding flag
<span class="pc bpc" id="L998" title="1 of 2 branches missed.">                    final boolean caseFold =</span>
                            ((matchFlags &amp; MATCH_CASEINDEPENDENT) != 0);

<span class="fc bfc" id="L1001" title="All 2 branches covered.">                    for (int i = 0; i &lt; opdata; i++) {</span>
<span class="fc bfc" id="L1002" title="All 2 branches covered.">                        if (compareChars(search.charAt(idx++), instruction[startAtom + i], caseFold) != 0) {</span>
<span class="fc" id="L1003">                            return -1;</span>
                        }
                    }
                }
<span class="fc" id="L1007">                break;</span>

                case OP_POSIXCLASS: {
                    // Out of input?
<span class="nc bnc" id="L1011" title="All 2 branches missed.">                    if (search.isEnd(idx)) {</span>
<span class="nc" id="L1012">                        return -1;</span>
                    }

<span class="nc bnc" id="L1015" title="All 15 branches missed.">                    switch (opdata) {</span>
                        case POSIX_CLASS_ALNUM:
<span class="nc bnc" id="L1017" title="All 2 branches missed.">                            if (!RECharacter.isLetterOrDigit(search.charAt(idx))) {</span>
<span class="nc" id="L1018">                                return -1;</span>
                            }
                            break;

                        case POSIX_CLASS_ALPHA:
<span class="nc bnc" id="L1023" title="All 2 branches missed.">                            if (!RECharacter.isLetter(search.charAt(idx))) {</span>
<span class="nc" id="L1024">                                return -1;</span>
                            }
                            break;

                        case POSIX_CLASS_DIGIT:
<span class="nc bnc" id="L1029" title="All 2 branches missed.">                            if (!RECharacter.isDigit(search.charAt(idx))) {</span>
<span class="nc" id="L1030">                                return -1;</span>
                            }
                            break;

                        case POSIX_CLASS_BLANK: // JWL - bugbug: is this right??
<span class="nc bnc" id="L1035" title="All 2 branches missed.">                            if (!RECharacter.isSpaceChar(search.charAt(idx))) {</span>
<span class="nc" id="L1036">                                return -1;</span>
                            }
                            break;

                        case POSIX_CLASS_SPACE:
<span class="nc bnc" id="L1041" title="All 2 branches missed.">                            if (!RECharacter.isWhitespace(search.charAt(idx))) {</span>
<span class="nc" id="L1042">                                return -1;</span>
                            }
                            break;

                        case POSIX_CLASS_CNTRL:
<span class="nc bnc" id="L1047" title="All 2 branches missed.">                            if (RECharacter.getType(search.charAt(idx)) != RECharacter.CONTROL) {</span>
<span class="nc" id="L1048">                                return -1;</span>
                            }
                            break;

                        case POSIX_CLASS_GRAPH: // JWL - bugbug???
<span class="nc bnc" id="L1053" title="All 2 branches missed.">                            switch (RECharacter.getType(search.charAt(idx))) {</span>
                                case RECharacter.MATH_SYMBOL:
                                case RECharacter.CURRENCY_SYMBOL:
                                case RECharacter.MODIFIER_SYMBOL:
                                case RECharacter.OTHER_SYMBOL:
<span class="nc" id="L1058">                                    break;</span>

                                default:
<span class="nc" id="L1061">                                    return -1;</span>
                            }
                            break;

                        case POSIX_CLASS_LOWER:
<span class="nc bnc" id="L1066" title="All 2 branches missed.">                            if (RECharacter.getType(search.charAt(idx)) != RECharacter.LOWERCASE_LETTER) {</span>
<span class="nc" id="L1067">                                return -1;</span>
                            }
                            break;

                        case POSIX_CLASS_UPPER:
<span class="nc bnc" id="L1072" title="All 2 branches missed.">                            if (RECharacter.getType(search.charAt(idx)) != RECharacter.UPPERCASE_LETTER) {</span>
<span class="nc" id="L1073">                                return -1;</span>
                            }
                            break;

                        case POSIX_CLASS_PRINT:
<span class="nc bnc" id="L1078" title="All 2 branches missed.">                            if (RECharacter.getType(search.charAt(idx)) == RECharacter.CONTROL) {</span>
<span class="nc" id="L1079">                                return -1;</span>
                            }
                            break;

                        case POSIX_CLASS_PUNCT: {
<span class="nc" id="L1084">                            int type = RECharacter.getType(search.charAt(idx));</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">                            switch (type) {</span>
                                case RECharacter.DASH_PUNCTUATION:
                                case RECharacter.START_PUNCTUATION:
                                case RECharacter.END_PUNCTUATION:
                                case RECharacter.CONNECTOR_PUNCTUATION:
                                case RECharacter.OTHER_PUNCTUATION:
<span class="nc" id="L1091">                                    break;</span>

                                default:
<span class="nc" id="L1094">                                    return -1;</span>
                            }
                        }
<span class="nc" id="L1097">                        break;</span>

                        case POSIX_CLASS_XDIGIT: // JWL - bugbug??
                        {
<span class="nc bnc" id="L1101" title="All 4 branches missed.">                            boolean isXDigit = ((search.charAt(idx) &gt;= '0' &amp;&amp; search.charAt(idx) &lt;= '9') ||</span>
<span class="nc bnc" id="L1102" title="All 4 branches missed.">                                    (search.charAt(idx) &gt;= 'a' &amp;&amp; search.charAt(idx) &lt;= 'f') ||</span>
<span class="nc bnc" id="L1103" title="All 4 branches missed.">                                    (search.charAt(idx) &gt;= 'A' &amp;&amp; search.charAt(idx) &lt;= 'F'));</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">                            if (!isXDigit) {</span>
<span class="nc" id="L1105">                                return -1;</span>
                            }
                        }
<span class="nc" id="L1108">                        break;</span>

                        case POSIX_CLASS_JSTART:
<span class="nc bnc" id="L1111" title="All 2 branches missed.">                            if (!RECharacter.isJavaIdentifierStart(search.charAt(idx))) {</span>
<span class="nc" id="L1112">                                return -1;</span>
                            }
                            break;

                        case POSIX_CLASS_JPART:
<span class="nc bnc" id="L1117" title="All 2 branches missed.">                            if (!RECharacter.isJavaIdentifierPart(search.charAt(idx))) {</span>
<span class="nc" id="L1118">                                return -1;</span>
                            }
                            break;

                        default:
<span class="nc" id="L1123">                            internalError(&quot;Bad posix class&quot;);</span>
                            break;
                    }

                    // Matched.
<span class="nc" id="L1128">                    idx++;</span>
                }
<span class="nc" id="L1130">                break;</span>

                case OP_ANYOF: {
                    // Out of input?
<span class="fc bfc" id="L1134" title="All 2 branches covered.">                    if (search.isEnd(idx)) {</span>
<span class="fc" id="L1135">                        return -1;</span>
                    }

                    // Get character to match against character class and maybe casefold
<span class="fc" id="L1139">                    char c = search.charAt(idx);</span>
<span class="pc bpc" id="L1140" title="1 of 2 branches missed.">                    boolean caseFold = (matchFlags &amp; MATCH_CASEINDEPENDENT) != 0;</span>
                    // Loop through character class checking our match character
<span class="fc" id="L1142">                    int idxRange = node + nodeSize;</span>
<span class="fc" id="L1143">                    int idxEnd = idxRange + (opdata * 2);</span>
<span class="fc" id="L1144">                    boolean match = false;</span>
<span class="fc bfc" id="L1145" title="All 4 branches covered.">                    for (int i = idxRange; !match &amp;&amp; i &lt; idxEnd; ) {</span>
                        // Get start, end and match characters
<span class="fc" id="L1147">                        char s = instruction[i++];</span>
<span class="fc" id="L1148">                        char e = instruction[i++];</span>

<span class="fc bfc" id="L1150" title="All 4 branches covered.">                        match = ((compareChars(c, s, caseFold) &gt;= 0) &amp;&amp; (compareChars(c, e, caseFold) &lt;= 0));</span>
<span class="fc" id="L1151">                    }</span>

                    // Fail if we didn't match the character class
<span class="fc bfc" id="L1154" title="All 2 branches covered.">                    if (!match) {</span>
<span class="fc" id="L1155">                        return -1;</span>
                    }
<span class="fc" id="L1157">                    idx++;</span>
                }
<span class="fc" id="L1159">                break;</span>

                case OP_BRANCH: {
                    // Check for choices
                    // FIXME Dead code - only reason to keep is backward compat with pre-compiled exprs. Remove?
<span class="nc bnc" id="L1164" title="All 2 branches missed.">                    if (instruction[next /* + offsetOpcode */] != OP_BRANCH) {</span>
                        // If there aren't any other choices, just evaluate this branch.
<span class="nc" id="L1166">                        node += nodeSize;</span>
<span class="nc" id="L1167">                        continue;</span>
                    }

                    // Try all available branches
                    int nextBranch;
                    do {
                        // Try matching the branch against the string
<span class="nc bnc" id="L1174" title="All 2 branches missed.">                        if ((idxNew = matchNodes(node + nodeSize, maxNode, idx)) != -1) {</span>
<span class="nc" id="L1175">                            return idxNew;</span>
                        }

                        // Go to next branch (if any)
<span class="nc" id="L1179">                        nextBranch = (short) instruction[node + offsetNext];</span>
<span class="nc" id="L1180">                        node += nextBranch;</span>
<span class="nc bnc" id="L1181" title="All 4 branches missed.">                    } while (nextBranch != 0 &amp;&amp; (instruction[node /* + offsetOpcode */] == OP_BRANCH));</span>

                    // Failed to match any branch!
<span class="nc" id="L1184">                    return -1;</span>
                }

                case OP_OPEN_CLUSTER:
                case OP_CLOSE_CLUSTER:
                    // starting or ending the matching of a subexpression which has no backref.

                case OP_NOTHING:
                case OP_GOTO:

                    // Just advance to the next node without doing anything
<span class="nc" id="L1195">                    break;</span>

                case OP_CONTINUE:

                    // Advance to the following node
<span class="fc" id="L1200">                    node += nodeSize;</span>
<span class="fc" id="L1201">                    continue;</span>

                case OP_END:

                    // Match has succeeded!
<span class="fc" id="L1206">                    setParenEnd(0, idx);</span>
<span class="fc" id="L1207">                    return idx;</span>

                default:

                    // Corrupt program
<span class="nc" id="L1212">                    internalError(&quot;Invalid opcode '&quot; + opcode + &quot;'&quot;);</span>
            }

            // Advance to the next node in the program
<span class="fc" id="L1216">            node = next;</span>
        }

        // We &quot;should&quot; never end up here
<span class="nc" id="L1220">        internalError(&quot;Corrupt program&quot;);</span>
<span class="nc" id="L1221">        return -1;</span>
    }

    /**
     * Match the current regular expression program against the current
     * input string, starting at index i of the input string.  This method
     * is only meant for internal use.
     *
     * @param i The input string index to start matching at
     * @return True if the input matched the expression
     */
    protected boolean matchAt(int i) {
        // Initialize start pointer, paren cache and paren count
<span class="fc" id="L1234">        start0 = -1;</span>
<span class="fc" id="L1235">        end0 = -1;</span>
<span class="fc" id="L1236">        start1 = -1;</span>
<span class="fc" id="L1237">        end1 = -1;</span>
<span class="fc" id="L1238">        start2 = -1;</span>
<span class="fc" id="L1239">        end2 = -1;</span>
<span class="fc" id="L1240">        startn = null;</span>
<span class="fc" id="L1241">        endn = null;</span>
<span class="fc" id="L1242">        parenCount = 1;</span>
<span class="fc" id="L1243">        setParenStart(0, i);</span>

        // Allocate backref arrays (unless optimizations indicate otherwise)
<span class="pc bpc" id="L1246" title="1 of 2 branches missed.">        if ((program.flags &amp; REProgram.OPT_HASBACKREFS) != 0) {</span>
<span class="nc" id="L1247">            startBackref = new int[maxParen];</span>
<span class="nc" id="L1248">            endBackref = new int[maxParen];</span>
        }

        // Match against string
        int idx;
<span class="fc bfc" id="L1253" title="All 2 branches covered.">        if ((idx = matchNodes(0, maxNode, i)) != -1) {</span>
<span class="fc" id="L1254">            setParenEnd(0, idx);</span>
<span class="fc" id="L1255">            return true;</span>
        }

        // Didn't match
<span class="fc" id="L1259">        parenCount = 0;</span>
<span class="fc" id="L1260">        return false;</span>
    }

    /**
     * Matches the current regular expression program against a character array,
     * starting at a given index.
     *
     * @param search String to match against
     * @param i      Index to start searching at
     * @return True if string matched
     */
    public boolean match(String search, int i) {
<span class="fc" id="L1272">        return match(new StringCharacterIterator(search), i);</span>
    }

    /**
     * Matches the current regular expression program against a character array,
     * starting at a given index.
     *
     * @param search String to match against
     * @param i      Index to start searching at
     * @return True if string matched
     */
    public boolean match(CharacterIterator search, int i) {
        // There is no compiled program to search with!
<span class="pc bpc" id="L1285" title="1 of 2 branches missed.">        if (program == null) {</span>
            // This should be uncommon enough to be an error case rather
            // than an exception (which would have to be handled everywhere)
<span class="nc" id="L1288">            internalError(&quot;No RE program to run!&quot;);</span>
        }

        // Save string to search
<span class="fc" id="L1292">        this.search = search;</span>

        // Can we optimize the search by looking for new lines?
<span class="pc bpc" id="L1295" title="1 of 2 branches missed.">        if ((program.flags &amp; REProgram.OPT_HASBOL) == REProgram.OPT_HASBOL) {</span>
            // Non multi-line matching with BOL: Must match at '0' index
<span class="nc bnc" id="L1297" title="All 2 branches missed.">            if ((matchFlags &amp; MATCH_MULTILINE) == 0) {</span>
<span class="nc bnc" id="L1298" title="All 4 branches missed.">                return i == 0 &amp;&amp; matchAt(i);</span>
            }

            // Multi-line matching with BOL: Seek to next line
<span class="nc bnc" id="L1302" title="All 2 branches missed.">            for (; !search.isEnd(i); i++) {</span>
                // Skip if we are at the beginning of the line
<span class="nc bnc" id="L1304" title="All 2 branches missed.">                if (isNewline(i)) {</span>
<span class="nc" id="L1305">                    continue;</span>
                }

                // Match at the beginning of the line
<span class="nc bnc" id="L1309" title="All 2 branches missed.">                if (matchAt(i)) {</span>
<span class="nc" id="L1310">                    return true;</span>
                }

                // Skip to the end of line
<span class="nc bnc" id="L1314" title="All 2 branches missed.">                for (; !search.isEnd(i); i++) {</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">                    if (isNewline(i)) {</span>
<span class="nc" id="L1316">                        break;</span>
                    }
                }
            }

<span class="nc" id="L1321">            return false;</span>
        }

        // Can we optimize the search by looking for a prefix string?
<span class="pc bpc" id="L1325" title="1 of 2 branches missed.">        if (program.prefix == null) {</span>
            // Unprefixed matching must try for a match at each character
<span class="fc bfc" id="L1327" title="All 2 branches covered.">            for (; !search.isEnd(i - 1); i++) {</span>
                // Try a match at index i
<span class="fc bfc" id="L1329" title="All 2 branches covered.">                if (matchAt(i)) {</span>
<span class="fc" id="L1330">                    return true;</span>
                }
            }
<span class="fc" id="L1333">            return false;</span>
        } else {
            // Prefix-anchored matching is possible
<span class="nc bnc" id="L1336" title="All 2 branches missed.">            boolean caseIndependent = (matchFlags &amp; MATCH_CASEINDEPENDENT) != 0;</span>
<span class="nc" id="L1337">            char[] prefix = program.prefix;</span>
<span class="nc bnc" id="L1338" title="All 2 branches missed.">            for (; !search.isEnd(i + prefix.length - 1); i++) {</span>
<span class="nc" id="L1339">                int j = i;</span>
<span class="nc" id="L1340">                int k = 0;</span>

                boolean match;
                do {
                    // If there's a mismatch of any character in the prefix, give up
<span class="nc bnc" id="L1345" title="All 2 branches missed.">                    match = (compareChars(search.charAt(j++), prefix[k++], caseIndependent) == 0);</span>
<span class="nc bnc" id="L1346" title="All 4 branches missed.">                } while (match &amp;&amp; k &lt; prefix.length);</span>

                // See if the whole prefix string matched
<span class="nc bnc" id="L1349" title="All 2 branches missed.">                if (k == prefix.length) {</span>
                    // We matched the full prefix at firstChar, so try it
<span class="nc bnc" id="L1351" title="All 2 branches missed.">                    if (matchAt(i)) {</span>
<span class="nc" id="L1352">                        return true;</span>
                    }
                }
            }
<span class="nc" id="L1356">            return false;</span>
        }
    }

    /**
     * Matches the current regular expression program against a String.
     *
     * @param search String to match against
     * @return True if string matched
     */
    public boolean match(String search) {
<span class="fc" id="L1367">        return match(search, 0);</span>
    }

    /**
     * Splits a string into an array of strings on regular expression boundaries.
     * This function works the same way as the Perl function of the same name.
     * Given a regular expression of &quot;[ab]+&quot; and a string to split of
     * &quot;xyzzyababbayyzabbbab123&quot;, the result would be the array of Strings
     * &quot;[xyzzy, yyz, 123]&quot;.
     *
     * &lt;p&gt;Please note that the first string in the resulting array may be an empty
     * string. This happens when the very first character of input string is
     * matched by the pattern.
     *
     * @param s String to split on this regular exression
     * @return Array of strings
     */
    public String[] split(String s) {
        // Create new vector
<span class="fc" id="L1386">        ArrayList v = new ArrayList();</span>

        // Start at position 0 and search the whole string
<span class="fc" id="L1389">        int pos = 0;</span>
<span class="fc" id="L1390">        int len = s.length();</span>

        // Try a match at each position
<span class="pc bpc" id="L1393" title="1 of 4 branches missed.">        while (pos &lt; len &amp;&amp; match(s, pos)) {</span>
            // Get start of match
<span class="fc" id="L1395">            int start = getParenStart(0);</span>

            // Get end of match
<span class="fc" id="L1398">            int newpos = getParenEnd(0);</span>

            // Check if no progress was made
<span class="pc bpc" id="L1401" title="1 of 2 branches missed.">            if (newpos == pos) {</span>
<span class="nc" id="L1402">                v.add(s.substring(pos, start + 1));</span>
<span class="nc" id="L1403">                newpos++;</span>
            } else {
<span class="fc" id="L1405">                v.add(s.substring(pos, start));</span>
            }

            // Move to new position
<span class="fc" id="L1409">            pos = newpos;</span>
<span class="fc" id="L1410">        }</span>

        // Push remainder if it's not empty
<span class="fc" id="L1413">        String remainder = s.substring(pos);</span>
<span class="pc bpc" id="L1414" title="1 of 2 branches missed.">        if (remainder.length() != 0) {</span>
<span class="nc" id="L1415">            v.add(remainder);</span>
        }

        // Return vector as an array of strings
<span class="fc" id="L1419">        String[] ret = new String[v.size()];</span>
<span class="fc" id="L1420">        v.toArray(ret);</span>
<span class="fc" id="L1421">        return ret;</span>
    }

    /**
     * Substitutes a string for this regular expression in another string.
     * This method works like the Perl function of the same name.
     * Given a regular expression of &quot;a*b&quot;, a String to substituteIn of
     * &quot;aaaabfooaaabgarplyaaabwackyb&quot; and the substitution String &quot;-&quot;, the
     * resulting String returned by subst would be &quot;-foo-garply-wacky-&quot;.
     *
     * @param substituteIn String to substitute within
     * @param substitution String to substitute for all matches of this regular expression.
     * @return The string substituteIn with zero or more occurrences of the current
     * regular expression replaced with the substitution String (if this regular
     * expression object doesn't match at any position, the original String is returned
     * unchanged).
     */
    public String subst(String substituteIn, String substitution) {
<span class="nc" id="L1439">        return subst(substituteIn, substitution, REPLACE_ALL);</span>
    }

    /**
     * Substitutes a string for this regular expression in another string.
     * This method works like the Perl function of the same name.
     * Given a regular expression of &quot;a*b&quot;, a String to substituteIn of
     * &quot;aaaabfooaaabgarplyaaabwackyb&quot; and the substitution String &quot;-&quot;, the
     * resulting String returned by subst would be &quot;-foo-garply-wacky-&quot;.
     * &lt;p&gt;
     * It is also possible to reference the contents of a parenthesized expression
     * with $0, $1, ... $9. A regular expression of &quot;http://[\\.\\w\\-\\?/~_@&amp;amp;=%]+&quot;,
     * a String to substituteIn of &quot;visit us: http://www.apache.org!&quot; and the
     * substitution String &quot;&amp;lt;a href=\&quot;$0\&quot;&amp;gt;$0&amp;lt;/a&amp;gt;&quot;, the resulting String
     * returned by subst would be
     * &quot;visit us: &amp;lt;a href=\&quot;http://www.apache.org\&quot;&amp;gt;http://www.apache.org&amp;lt;/a&amp;gt;!&quot;.
     * &lt;p&gt;
     * &lt;i&gt;Note:&lt;/i&gt; $0 represents the whole match.
     *
     * @param substituteIn String to substitute within
     * @param substitution String to substitute for matches of this regular expression
     * @param flags        One or more bitwise flags from REPLACE_*.  If the REPLACE_FIRSTONLY
     *                     flag bit is set, only the first occurrence of this regular expression is replaced.
     *                     If the bit is not set (REPLACE_ALL), all occurrences of this pattern will be
     *                     replaced. If the flag REPLACE_BACKREFERENCES is set, all backreferences will
     *                     be processed.
     * @return The string substituteIn with zero or more occurrences of the current
     * regular expression replaced with the substitution String (if this regular
     * expression object doesn't match at any position, the original String is returned
     * unchanged).
     */
    public String subst(String substituteIn, String substitution, int flags) {
        // String to return
<span class="fc" id="L1472">        StringBuffer ret = new StringBuffer();</span>

        // Start at position 0 and search the whole string
<span class="fc" id="L1475">        int pos = 0;</span>
<span class="fc" id="L1476">        int len = substituteIn.length();</span>

        // Try a match at each position
<span class="pc bpc" id="L1479" title="1 of 4 branches missed.">        while (pos &lt; len &amp;&amp; match(substituteIn, pos)) {</span>
            // Append string before match
<span class="fc" id="L1481">            ret.append(substituteIn.substring(pos, getParenStart(0)));</span>

<span class="pc bpc" id="L1483" title="1 of 2 branches missed.">            if ((flags &amp; REPLACE_BACKREFERENCES) != 0) {</span>
                // Process backreferences
<span class="fc" id="L1485">                int lCurrentPosition = 0;</span>
<span class="fc" id="L1486">                int lLastPosition = -2;</span>
<span class="fc" id="L1487">                int lLength = substitution.length();</span>

<span class="fc bfc" id="L1489" title="All 2 branches covered.">                while ((lCurrentPosition = substitution.indexOf(&quot;$&quot;, lCurrentPosition)) &gt;= 0) {</span>
<span class="pc bpc" id="L1490" title="2 of 6 branches missed.">                    if ((lCurrentPosition == 0 || substitution.charAt(lCurrentPosition - 1) != '\\') &amp;&amp; lCurrentPosition + 1 &lt; lLength) {</span>
<span class="fc" id="L1491">                        char c = substitution.charAt(lCurrentPosition + 1);</span>
<span class="pc bpc" id="L1492" title="2 of 4 branches missed.">                        if (c &gt;= '0' &amp;&amp; c &lt;= '9') {</span>
                            // Append everything between the last and the current $ sign
<span class="fc" id="L1494">                            ret.append(substitution.substring(lLastPosition + 2, lCurrentPosition));</span>

                            // Append the parenthesized expression, if present
<span class="fc" id="L1497">                            String val = getParen(c - '0');</span>
<span class="pc bpc" id="L1498" title="1 of 2 branches missed.">                            if (val != null) {</span>
<span class="fc" id="L1499">                                ret.append(val);</span>
                            }
<span class="fc" id="L1501">                            lLastPosition = lCurrentPosition;</span>
                        }
                    }

                    // Move forward, skipping past match
<span class="fc" id="L1506">                    lCurrentPosition++;</span>
                }

                // Append everything after the last $ sign
<span class="fc" id="L1510">                ret.append(substitution.substring(lLastPosition + 2, lLength));</span>
<span class="fc" id="L1511">            } else {</span>
                // Append substitution without processing backreferences
<span class="nc" id="L1513">                ret.append(substitution);</span>
            }

            // Move forward, skipping past match
<span class="fc" id="L1517">            int newpos = getParenEnd(0);</span>

            // We always want to make progress!
<span class="pc bpc" id="L1520" title="1 of 2 branches missed.">            if (newpos == pos) {</span>
<span class="nc" id="L1521">                newpos++;</span>
            }

            // Try new position
<span class="fc" id="L1525">            pos = newpos;</span>

            // Break out if we're only supposed to replace one occurrence
<span class="pc bpc" id="L1528" title="1 of 2 branches missed.">            if ((flags &amp; REPLACE_FIRSTONLY) != 0) {</span>
<span class="nc" id="L1529">                break;</span>
            }
<span class="fc" id="L1531">        }</span>

        // If there's remaining input, append it
<span class="pc bpc" id="L1534" title="1 of 2 branches missed.">        if (pos &lt; len) {</span>
<span class="nc" id="L1535">            ret.append(substituteIn.substring(pos));</span>
        }

        // Return string buffer as string
<span class="fc" id="L1539">        return ret.toString();</span>
    }

    /**
     * Returns an array of Strings, whose toString representation matches a regular
     * expression. This method works like the Perl function of the same name.  Given
     * a regular expression of &quot;a*b&quot; and an array of String objects of [foo, aab, zzz,
     * aaaab], the array of Strings returned by grep would be [aab, aaaab].
     *
     * @param search Array of Objects to search
     * @return Array of Strings whose toString() value matches this regular expression.
     */
    public String[] grep(Object[] search) {
        // Create new vector to hold return items
<span class="nc" id="L1553">        ArrayList v = new ArrayList();</span>

        // Traverse array of objects
<span class="nc bnc" id="L1556" title="All 2 branches missed.">        for (int i = 0; i &lt; search.length; i++) {</span>
            // Get next object as a string
<span class="nc" id="L1558">            String s = search[i].toString();</span>

            // If it matches this regexp, add it to the list
<span class="nc bnc" id="L1561" title="All 2 branches missed.">            if (match(s)) {</span>
<span class="nc" id="L1562">                v.add(s);</span>
            }
        }

        // Return vector as an array of strings
<span class="nc" id="L1567">        String[] ret = new String[v.size()];</span>
<span class="nc" id="L1568">        v.toArray(ret);</span>
<span class="nc" id="L1569">        return ret;</span>
    }

    /**
     * @return true if character at i-th position in the &lt;code&gt;search&lt;/code&gt; string is a newline
     */
    private boolean isNewline(int i) {
<span class="nc" id="L1576">        char nextChar = search.charAt(i);</span>

<span class="nc bnc" id="L1578" title="All 10 branches missed.">        return nextChar == '\n' || nextChar == '\r' || nextChar == '\u0085' ||</span>
                nextChar == '\u2028' || nextChar == '\u2029';
    }

    /**
     * Compares two characters.
     *
     * @param c1              first character to compare.
     * @param c2              second character to compare.
     * @param caseIndependent whether comparision is case insensitive or not.
     * @return negative, 0, or positive integer as the first character
     * less than, equal to, or greater then the second.
     */
    private int compareChars(char c1, char c2, boolean caseIndependent) {
<span class="pc bpc" id="L1592" title="1 of 2 branches missed.">        if (caseIndependent) {</span>
<span class="nc" id="L1593">            c1 = RECharacter.toLowerCase(c1);</span>
<span class="nc" id="L1594">            c2 = RECharacter.toLowerCase(c2);</span>
        }
<span class="fc" id="L1596">        return ((int) c1 - (int) c2);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>