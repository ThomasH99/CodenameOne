<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeneralPath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codenameone-core-unittests</a> &gt; <a href="index.source.html" class="el_package">com.codename1.ui.geom</a> &gt; <span class="el_source">GeneralPath.java</span></div><h1>GeneralPath.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, Codename One and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Codename One designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Codename One through http://www.codenameone.com/ if you
 * need additional information or have any questions.
 */
package com.codename1.ui.geom;


import com.codename1.io.Log;
import com.codename1.ui.Transform;
import com.codename1.ui.geom.Geometry.BezierCurve;
import com.codename1.util.MathUtil;

import java.util.ArrayList;
import java.util.Arrays;

/**
 * &lt;p&gt;A general geometric path, consisting of any number of subpaths constructed
 * out of straight lines and cubic or quadratic Bezier curves. The inside of the
 * curve is defined for drawing purposes by a winding rule. Either the
 * {@link #WIND_EVEN_ODD} or {@link #WIND_NON_ZERO} winding rule can be chosen.&lt;/p&gt;
 *
 * &lt;h4&gt;A drawing of a GeneralPath&lt;/h4&gt;
 * &lt;p&gt;
 * &lt;img
 * src=&quot;http://developer.classpath.org/doc/java/awt/geom/doc-files/GeneralPath-1.png&quot;/&gt;
 *
 * &lt;p&gt;
 * The {@link #WIND_EVEN_ODD} winding rule defines a point as inside a path if:
 * A ray from the point towards infinity in an arbitrary direction intersects
 * the path an odd number of times. Points {@literal A} and {@literal C} in the
 * image are considered to be outside the path. (both intersect twice) Point
 * {@literal B} intersects once, and is inside.&lt;/p&gt;
 *
 * &lt;p&gt;
 * The {@link #WIND_NON_ZERO} winding rule defines a point as inside a path if:
 * The path intersects the ray in an equal number of opposite directions. Point
 * {@link A} in the image is outside (one intersection in the 'up' direction,
 * one in the 'down' direction) Point {@literal B} in the image is inside (one
 * intersection 'down') Point C in the image is inside (two intersections in the
 * 'down' direction)&lt;/p&gt;
 *
 * &lt;script src=&quot;https://gist.github.com/codenameone/3f2f8cdaabb7780eae6f.js&quot;&gt;&lt;/script&gt;
 * &lt;img src=&quot;https://www.codenameone.com/img/developer-guide/graphics-shape-fill.png&quot; alt=&quot;Fill a shape general path&quot; /&gt;
 *
 * &lt;p&gt;Note: This description and image were copied from &lt;a
 * href=&quot;http://developer.classpath.org/doc/java/awt/geom/GeneralPath.html&quot;&gt;the
 * GNU classpath&lt;/a&gt;
 * docs). License here http://www.gnu.org/licenses/licenses.html#FDL&lt;/p&gt;
 *
 * @author shannah
 * @see com.codename1.ui.Graphics#drawShape
 * @see com.codename1.ui.Graphics#fillShape
 */
public final class GeneralPath implements Shape {

    /**
     * Same constant as {@link PathIterator#WIND_EVEN_ODD}
     */
    public static final int WIND_EVEN_ODD = PathIterator.WIND_EVEN_ODD;
    /**
     * Same constant as {@link PathIterator#WIND_NON_ZERO}
     */
    public static final int WIND_NON_ZERO = PathIterator.WIND_NON_ZERO;
    /**
     * The buffers size
     */
    private static final int BUFFER_SIZE = 10;
    /**
     * The buffers capacity
     */
    private static final int BUFFER_CAPACITY = 10;
    private static final int MAX_POOL_SIZE = 20;
    private static ArrayList&lt;GeneralPath&gt; pathPool;
    private static ArrayList&lt;Rectangle&gt; rectPool;
    private static ArrayList&lt;float[]&gt; floatPool;
    private static ArrayList&lt;boolean[]&gt; boolPool;
    private static ArrayList&lt;Iterator&gt; iteratorPool;
    /**
     * The space amount in points buffer for different segmenet's types
     */
<span class="fc" id="L99">    private static final int[] pointShift = {</span>
            2, // MOVETO
            2, // LINETO
            4, // QUADTO
            6, // CUBICTO
            0}; // CLOSE
    private static Pt tmpV1, tmpV2;
    /**
     * The point's types buffer
     */
    byte[] types;
    /**
     * The points buffer
     */
    float[] points;
    /**
     * The point's type buffer size
     */
    int typeSize;
    /**
     * The points buffer size
     */
    int pointSize;
    /**
     * The path rule
     */
    int rule;
<span class="fc" id="L126">    private boolean dirty = false;</span>

    /**
     * Constructs a GeneralPath with the default ({@link #WIND_NON_ZERO})
     * winding rule and initial capacity (10).
     */
    public GeneralPath() {
<span class="fc" id="L133">        this(WIND_NON_ZERO, BUFFER_SIZE);</span>
<span class="fc" id="L134">    }</span>


    /**
     * Constructs a GeneralPath with a specific winding rule and the default
     * initial capacity (10).
     *
     * @param rule The winding rule. One of {@link #WIND_NON_ZERO} and
     *             {@link #WIND_EVEN_ODD}
     * @see #WIND_NON_ZERO
     * @see #WIND_EVEN_ODD
     */
    public GeneralPath(int rule) {
<span class="nc" id="L147">        this(rule, BUFFER_SIZE);</span>
<span class="nc" id="L148">    }</span>

    /**
     * Constructs a GeneralPath with a specific winding rule and the initial
     * capacity. The initial capacity should be the approximate number of path
     * segments to be used.
     *
     * @param rule            The winding rule. ({@link #WIND_NON_ZERO} or
     *                        {@link #WIND_EVEN_ODD}).
     * @param initialCapacity the inital capacity, in path segments
     */
<span class="fc" id="L159">    public GeneralPath(int rule, int initialCapacity) {</span>
<span class="fc" id="L160">        setWindingRule(rule);</span>
<span class="fc" id="L161">        types = new byte[initialCapacity];</span>
<span class="fc" id="L162">        points = new float[initialCapacity * 2];</span>
<span class="fc" id="L163">    }</span>

    /**
     * Constructs a GeneralPath from an arbitrary shape object. The Shapes
     * PathIterator path and winding rule will be used.
     *
     * @param shape
     */
    public GeneralPath(Shape shape) {
<span class="nc" id="L172">        this(WIND_NON_ZERO, BUFFER_SIZE);</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (shape.getClass() == GeneralPath.class) {</span>
<span class="nc" id="L174">            setPath((GeneralPath) shape, null);</span>
        } else {
<span class="nc" id="L176">            PathIterator p = shape.getPathIterator();</span>
<span class="nc" id="L177">            setWindingRule(p.getWindingRule());</span>
<span class="nc" id="L178">            append(p, false);</span>
        }
<span class="nc" id="L180">    }</span>

    private static ArrayList&lt;GeneralPath&gt; pathPool() {
<span class="fc bfc" id="L183" title="All 2 branches covered.">        if (pathPool == null) {</span>
<span class="fc" id="L184">            pathPool = new ArrayList&lt;GeneralPath&gt;();</span>
        }
<span class="fc" id="L186">        return pathPool;</span>
    }

    // END Alpha Mask Caching Functionality
    //--------------------------------------------------------------------------

    private static ArrayList&lt;Rectangle&gt; rectPool() {
<span class="fc bfc" id="L193" title="All 2 branches covered.">        if (rectPool == null) {</span>
<span class="fc" id="L194">            rectPool = new ArrayList&lt;Rectangle&gt;();</span>
        }
<span class="fc" id="L196">        return rectPool;</span>
    }

    private static ArrayList&lt;float[]&gt; floatPool() {
<span class="fc bfc" id="L200" title="All 2 branches covered.">        if (floatPool == null) {</span>
<span class="fc" id="L201">            floatPool = new ArrayList&lt;float[]&gt;();</span>
        }
<span class="fc" id="L203">        return floatPool;</span>
    }

    private static ArrayList&lt;boolean[]&gt; boolPool() {
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if (boolPool == null) {</span>
<span class="fc" id="L208">            boolPool = new ArrayList&lt;boolean[]&gt;();</span>
        }
<span class="fc" id="L210">        return boolPool;</span>
    }

    private static ArrayList&lt;Iterator&gt; iteratorPool() {
<span class="fc bfc" id="L214" title="All 2 branches covered.">        if (iteratorPool == null) {</span>
<span class="fc" id="L215">            iteratorPool = new ArrayList&lt;Iterator&gt;();</span>
        }
<span class="fc" id="L217">        return iteratorPool;</span>
    }

    // These are package protected for ODD

    private static synchronized GeneralPath createPathFromPool() {
<span class="fc bfc" id="L223" title="All 2 branches covered.">        if (!pathPool().isEmpty()) {</span>
<span class="fc" id="L224">            GeneralPath out = pathPool.remove(pathPool.size() - 1);</span>
<span class="fc" id="L225">            out.reset();</span>
<span class="fc" id="L226">            return out;</span>
        }
<span class="fc" id="L228">        return new GeneralPath();</span>
    }

    private static synchronized Rectangle createRectFromPool() {
<span class="fc bfc" id="L232" title="All 2 branches covered.">        if (!rectPool().isEmpty()) {</span>
<span class="fc" id="L233">            return rectPool.remove(rectPool.size() - 1);</span>
        }
<span class="fc" id="L235">        return new Rectangle();</span>
    }

    private static synchronized float[] createFloatArrayFromPool(int size) {
<span class="fc" id="L239">        int len = floatPool().size();</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L241">            float[] arr = floatPool.get(i);</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">            if (arr.length == size) {</span>
<span class="fc" id="L243">                return floatPool.remove(i);</span>
            }
        }
<span class="fc" id="L246">        return new float[size];</span>
    }

    private static synchronized boolean[] createBoolArrayFromPool(int size) {
<span class="fc" id="L250">        int len = boolPool().size();</span>
<span class="pc bfc" id="L251" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L252">            boolean[] arr = boolPool.get(i);</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">            if (arr.length == size) {</span>
<span class="fc" id="L254">                return boolPool.remove(i);</span>
            }
        }
<span class="fc" id="L257">        return new boolean[size];</span>
    }

    private static synchronized Iterator createIteratorFromPool(GeneralPath p, Transform t) {
<span class="fc bfc" id="L261" title="All 2 branches covered.">        if (!iteratorPool().isEmpty()) {</span>
<span class="fc" id="L262">            Iterator it = iteratorPool.remove(iteratorPool.size() - 1);</span>
<span class="fc" id="L263">            it.p = p;</span>
<span class="fc" id="L264">            it.transform = t;</span>
<span class="fc" id="L265">            it.reset();</span>
<span class="fc" id="L266">            return it;</span>
        }
<span class="fc" id="L268">        return (Iterator) p.getPathIterator(t);</span>

    }

    /**
     * Returns a GeneralPath to the reusable object pool for GeneralPaths.
     *
     * @param p The path to recycle.
     * @see #createFromPool()
     */
    public static synchronized void recycle(GeneralPath p) {
<span class="pc bpc" id="L279" title="1 of 4 branches missed.">        if (pathPool().size() &gt;= MAX_POOL_SIZE || p == null) return;</span>
<span class="fc" id="L280">        pathPool.add(p);</span>
<span class="fc" id="L281">    }</span>

    private static synchronized void recycle(Rectangle r) {
<span class="pc bpc" id="L284" title="2 of 4 branches missed.">        if (rectPool.size() &gt;= MAX_POOL_SIZE || r == null) return;</span>
<span class="fc" id="L285">        rectPool.add(r);</span>
<span class="fc" id="L286">    }</span>

    private static synchronized void recycle(float[] a) {
<span class="pc bpc" id="L289" title="2 of 4 branches missed.">        if (floatPool().size() &gt;= MAX_POOL_SIZE || a == null) return;</span>
<span class="fc" id="L290">        floatPool.add(a);</span>
<span class="fc" id="L291">    }</span>

    private static synchronized void recycle(boolean[] b) {
<span class="pc bpc" id="L294" title="2 of 4 branches missed.">        if (boolPool().size() &gt;= MAX_POOL_SIZE || b == null) {</span>
<span class="nc" id="L295">            return;</span>
        }
<span class="fc" id="L297">        boolPool.add(b);</span>
<span class="fc" id="L298">    }</span>

    private static synchronized void recycle(Iterator it) {
<span class="pc bpc" id="L301" title="2 of 4 branches missed.">        if (iteratorPool().size() &gt;= MAX_POOL_SIZE || it == null) {</span>
<span class="nc" id="L302">            return;</span>
        }
<span class="fc" id="L304">        iteratorPool.add(it);</span>
<span class="fc" id="L305">    }</span>

    /**
     * Creates a new GeneralPath from an object Pool.  This is useful
     * if you need to create a temporary General path that you wish
     * to dispose of after using.
     *
     * &lt;p&gt;You should return this object back to the pool when you are done
     * using the {@link #recycle(com.codename1.ui.geom.GeneralPath) } method.
     *
     * @return
     */
    public static GeneralPath createFromPool() {
<span class="nc" id="L318">        return createPathFromPool();</span>
    }

    /**
     * Checks to see if the set of points form a convex polygon.
     * if
     *
     * @param xPoints The x coordinates of the polygon.
     * @param yPoints The y coordinates of the polygon.
     * @return True if the points comprise a convex polygon.
     */
    public static boolean isConvexPolygon(float[] xPoints, float[] yPoints) {
<span class="nc" id="L330">        int len = xPoints.length;</span>
<span class="nc" id="L331">        Pt[] p = new Pt[len];</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L333">            Pt point = new Pt();</span>
<span class="nc" id="L334">            point.x = xPoints[i];</span>
<span class="nc" id="L335">            point.y = yPoints[i];</span>
<span class="nc" id="L336">            p[i] = point;</span>
        }
<span class="nc bnc" id="L338" title="All 2 branches missed.">        return detectPolygonType(p, len) == 1;</span>

    }

    public static boolean isConvexPolygon(int[] xPoints, int[] yPoints) {
<span class="nc" id="L343">        int len = xPoints.length;</span>
<span class="nc" id="L344">        Pt[] p = new Pt[len];</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L346">            Pt point = new Pt();</span>
<span class="nc" id="L347">            point.x = xPoints[i];</span>
<span class="nc" id="L348">            point.y = yPoints[i];</span>
<span class="nc" id="L349">            p[i] = point;</span>
        }
<span class="nc bnc" id="L351" title="All 2 branches missed.">        return detectPolygonType(p, len) == 1;</span>

    }

    // 1 = convex, -1 = concave, 0 = not polygon
    private static int detectPolygonType(Pt[] p, int num_vertices) {
<span class="nc bnc" id="L357" title="All 2 branches missed.">        Pt v1 = tmpV1 == null ? (tmpV1 = new Pt()) : tmpV1;</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">        Pt v2 = tmpV2 == null ? (tmpV2 = new Pt()) : tmpV2;</span>

        double det_value;
        double cur_det_value;
        int i;

<span class="nc bnc" id="L364" title="All 2 branches missed.">        if (num_vertices &lt; 3) {</span>
<span class="nc" id="L365">            return 0;</span>
        }

<span class="nc" id="L368">        v1 = calcVector(p[0], p[num_vertices - 1], v1);</span>
<span class="nc" id="L369">        v2 = calcVector(p[1], p[0], v2);</span>
<span class="nc" id="L370">        det_value = calcDeterminant(v1, v2);</span>

<span class="nc bnc" id="L372" title="All 2 branches missed.">        for (i = 1; i &lt; num_vertices - 1; i++) {</span>
<span class="nc" id="L373">            v2.clone(v1);</span>
<span class="nc" id="L374">            v2 = calcVector(p[i + 1], p[i], v2);</span>
<span class="nc" id="L375">            cur_det_value = calcDeterminant(v1, v2);</span>

<span class="nc bnc" id="L377" title="All 2 branches missed.">            if ((cur_det_value * det_value) &lt; 0.0) {</span>
<span class="nc" id="L378">                return -1;</span>
            }

        }

<span class="nc" id="L383">        v1 = v2;</span>
<span class="nc" id="L384">        v2 = calcVector(p[0], p[num_vertices - 1], v2);</span>
<span class="nc" id="L385">        cur_det_value = calcDeterminant(v1, v2);</span>

<span class="nc bnc" id="L387" title="All 2 branches missed.">        if ((cur_det_value * det_value) &lt; 0.0) {</span>
<span class="nc" id="L388">            return -1;</span>
        } else {
<span class="nc" id="L390">            return 1;</span>
        }

    }

    private static double calcDeterminant(Pt p1, Pt p2) {
<span class="nc" id="L396">        return (p1.x * p2.y - p1.y * p2.x);</span>
    }

    private static Pt calcVector(Pt p0, Pt p1, Pt out) {
<span class="nc" id="L400">        Pt p = out;</span>

<span class="nc" id="L402">        p.x = p0.x - p1.x;</span>
<span class="nc" id="L403">        p.y = p0.y - p1.y;</span>
<span class="nc" id="L404">        return (p);</span>
    }

    /**
     * Checks to see if this path forms a polygon.
     *
     * @return True if the path is a polygon.
     */
    public boolean isPolygon() {

<span class="nc bnc" id="L414" title="All 2 branches missed.">        if (isRectangle()) {</span>
<span class="nc" id="L415">            return true;</span>
        }
<span class="nc" id="L417">        Iterator it = createIteratorFromPool(this, null);</span>
<span class="nc" id="L418">        float[] curr = createFloatArrayFromPool(6);</span>
<span class="nc" id="L419">        float[] firstPoint = createFloatArrayFromPool(2);</span>
        try {
<span class="nc" id="L421">            boolean firstMove = false;</span>
<span class="nc" id="L422">            int cmd = -1;</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">            while (!it.isDone()) {</span>
<span class="nc bnc" id="L424" title="All 3 branches missed.">                switch (cmd = it.currentSegment(curr)) {</span>
                    case PathIterator.SEG_MOVETO: {
<span class="nc bnc" id="L426" title="All 2 branches missed.">                        if (firstMove) {</span>
<span class="nc" id="L427">                            return false;</span>
                        }
<span class="nc" id="L429">                        firstMove = true;</span>
<span class="nc" id="L430">                        firstPoint[0] = curr[0];</span>
<span class="nc" id="L431">                        firstPoint[1] = curr[1];</span>
<span class="nc" id="L432">                        break;</span>
                    }
                    case PathIterator.SEG_CUBICTO:
                    case PathIterator.SEG_QUADTO:
<span class="nc" id="L436">                        return false;</span>
                }
<span class="nc" id="L438">                it.next();</span>
            }

<span class="nc bnc" id="L441" title="All 6 branches missed.">            return cmd == PathIterator.SEG_CLOSE || (curr[0] == firstPoint[0] &amp;&amp; curr[1] == firstPoint[1]);</span>

        } finally {
<span class="nc" id="L444">            recycle(it);</span>
<span class="nc" id="L445">            recycle(curr);</span>
<span class="nc" id="L446">            recycle(firstPoint);</span>
        }

    }

    /**
     * Returns the number of path commands in this path.
     *
     * @return The number of path commands in this path.
     */
    public int getTypesSize() {
<span class="nc" id="L457">        return typeSize;</span>
    }

    /**
     * Returns the number of points in this path.
     *
     * @return The number of points in this path.
     */
    public int getPointsSize() {
<span class="fc" id="L466">        return pointSize;</span>
    }

    /**
     * Returns a copy of the types (aka path commands) in this path.
     *
     * @param out An array to copy the path commands into.
     */
    public void getTypes(byte[] out) {
<span class="nc" id="L475">        System.arraycopy(types, 0, out, 0, Math.min(types.length, out.length));</span>
<span class="nc" id="L476">    }</span>

    /**
     * Returns a copy of the points in this path.
     *
     * @param out An array to copy the points into.
     */
    public void getPoints(float[] out) {
<span class="nc" id="L484">        System.arraycopy(points, 0, out, 0, Math.min(points.length, out.length));</span>
<span class="nc" id="L485">    }</span>

    public String toString() {
<span class="nc" id="L488">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L489">        sb.append(&quot;[General Path: &quot;);</span>
<span class="nc" id="L490">        Iterator it = createIteratorFromPool(this, null);</span>
<span class="nc" id="L491">        float[] buf = createFloatArrayFromPool(6);//new float[6];</span>
        try {
<span class="nc bnc" id="L493" title="All 2 branches missed.">            while (!it.isDone()) {</span>
<span class="nc" id="L494">                int type = it.currentSegment(buf);</span>
<span class="nc bnc" id="L495" title="All 6 branches missed.">                switch (type) {</span>
                    case PathIterator.SEG_MOVETO:
<span class="nc" id="L497">                        sb.append(&quot;Move (&quot; + buf[0] + &quot;,&quot; + buf[1] + &quot;), &quot;);</span>
<span class="nc" id="L498">                        break;</span>
                    case PathIterator.SEG_LINETO:
<span class="nc" id="L500">                        sb.append(&quot;Line (&quot; + buf[0] + &quot;,&quot; + buf[1] + &quot;), &quot;);</span>
<span class="nc" id="L501">                        break;</span>
                    case PathIterator.SEG_CUBICTO:
<span class="nc" id="L503">                        sb.append(&quot;Curve (&quot; + buf[0] + &quot;,&quot; + buf[1] + &quot;..&quot; + buf[2] + &quot;,&quot; + buf[3] + &quot;..&quot; + buf[4] + &quot;,&quot; + buf[5] + &quot;)&quot;);</span>
<span class="nc" id="L504">                        break;</span>
                    case PathIterator.SEG_QUADTO:
<span class="nc" id="L506">                        sb.append(&quot;Curve (&quot; + buf[0] + &quot;,&quot; + buf[1] + &quot;..&quot; + buf[2] + &quot;,&quot; + buf[3] + &quot;)&quot;);</span>
<span class="nc" id="L507">                        break;</span>
                    case PathIterator.SEG_CLOSE:
<span class="nc" id="L509">                        sb.append(&quot; CLOSE]&quot;);</span>
                        break;
                }
<span class="nc" id="L512">                it.next();</span>
<span class="nc" id="L513">            }</span>
        } finally {
<span class="nc" id="L515">            recycle(buf);</span>
<span class="nc" id="L516">            recycle(it);</span>
        }
<span class="nc" id="L518">        return sb.toString();</span>
    }

    public boolean equals(Shape shape, Transform t) {
<span class="pc bpc" id="L522" title="1 of 4 branches missed.">        if (t != null &amp;&amp; !t.isIdentity()) {</span>
<span class="fc" id="L523">            GeneralPath p = createPathFromPool();</span>
<span class="fc" id="L524">            p.setShape(shape, t);</span>
            try {
<span class="fc" id="L526">                return equals(p, null);</span>
            } finally {
<span class="fc" id="L528">                recycle(p);</span>
            }
        }
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">        if (shape == this) return true;</span>
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">        if (shape instanceof Rectangle) {</span>
<span class="nc" id="L533">            Rectangle r = (Rectangle) shape;</span>
<span class="nc" id="L534">            Rectangle tmpRect = createRectFromPool();</span>
            try {
<span class="nc" id="L536">                getBounds(tmpRect);</span>
<span class="nc" id="L537">                return r.equals(tmpRect);</span>
            } finally {
<span class="nc" id="L539">                recycle(tmpRect);</span>
            }
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">        } else if (shape instanceof GeneralPath) {</span>
<span class="fc" id="L542">            GeneralPath tmpPath = (GeneralPath) shape;</span>
<span class="pc bpc" id="L543" title="1 of 4 branches missed.">            return Arrays.equals(points, tmpPath.points) &amp;&amp; Arrays.equals(types, tmpPath.types);</span>
        } else {
<span class="nc" id="L545">            GeneralPath tmpPath2 = createPathFromPool();</span>
            try {
<span class="nc" id="L547">                tmpPath2.setShape(shape, null);</span>
<span class="nc" id="L548">                return equals(tmpPath2, null);</span>
            } finally {
<span class="nc" id="L550">                recycle(tmpPath2);</span>
            }
        }
    }

    /**
     * Returns the path's current winding rule.
     *
     * @return {@link #WIND_NON_ZERO} or {@link #WIND_EVEN_ODD}
     */
    public int getWindingRule() {
<span class="fc" id="L561">        return rule;</span>
    }

    /**
     * Sets the path's winding rule, which controls which areas are considered
     * 'inside' or 'outside' the path on drawing. Valid rules are
     * {@link #WIND_EVEN_ODD} for an even-odd winding rule, or
     * {@link #WIND_NON_ZERO} for a non-zero winding rule.
     *
     * @param rule the rule. ({@link #WIND_NON_ZERO} or {@link #WIND_EVEN_ODD}).
     */
    public void setWindingRule(int rule) {
<span class="fc bfc" id="L573" title="All 4 branches covered.">        if (rule != WIND_EVEN_ODD &amp;&amp; rule != WIND_NON_ZERO) {</span>
            // awt.209=Invalid winding rule value
<span class="fc" id="L575">            throw new java.lang.IllegalArgumentException(&quot;Invalid winding rule&quot;); //$NON-NLS-1$</span>
        }
<span class="fc" id="L577">        dirty = true;</span>
<span class="fc" id="L578">        this.rule = rule;</span>
<span class="fc" id="L579">    }</span>

    /**
     * Checks points and types buffer size to add pointCount points. If
     * necessary realloc buffers to enlarge size.
     *
     * @param pointCount - the point count to be added in buffer
     */
    private void checkBuf(int pointCount, boolean checkMove) {
<span class="fc bfc" id="L588" title="All 4 branches covered.">        if (checkMove &amp;&amp; typeSize == 0) {</span>
            // awt.20A=First segment should be SEG_MOVETO type
<span class="fc" id="L590">            throw new IndexOutOfBoundsException(&quot;First segment must be a moveto&quot;); //$NON-NLS-1$</span>
        }
<span class="fc bfc" id="L592" title="All 2 branches covered.">        if (typeSize == types.length) {</span>
<span class="fc" id="L593">            byte[] tmp = new byte[typeSize + BUFFER_CAPACITY];</span>
<span class="fc" id="L594">            System.arraycopy(types, 0, tmp, 0, typeSize);</span>
<span class="fc" id="L595">            types = tmp;</span>
        }
<span class="fc bfc" id="L597" title="All 2 branches covered.">        if (pointSize + pointCount &gt; points.length) {</span>
<span class="fc" id="L598">            float[] tmp = new float[pointSize + Math.max(BUFFER_CAPACITY * 2, pointCount)];</span>
<span class="fc" id="L599">            System.arraycopy(points, 0, tmp, 0, pointSize);</span>
<span class="fc" id="L600">            points = tmp;</span>
        }
<span class="fc" id="L602">    }</span>

    public void moveTo(double x, double y) {
<span class="fc" id="L605">        moveTo((float) x, (float) y);</span>
<span class="fc" id="L606">    }</span>

    /**
     * Adds a new point to a path.
     *
     * @param x the x-coordinate.
     * @param y the y-coordinate.
     */
    public void moveTo(float x, float y) {
<span class="fc bfc" id="L615" title="All 4 branches covered.">        if (typeSize &gt; 0 &amp;&amp; types[typeSize - 1] == PathIterator.SEG_MOVETO) {</span>
<span class="fc" id="L616">            points[pointSize - 2] = x;</span>
<span class="fc" id="L617">            points[pointSize - 1] = y;</span>
        } else {
<span class="fc" id="L619">            checkBuf(2, false);</span>
<span class="fc" id="L620">            types[typeSize++] = PathIterator.SEG_MOVETO;</span>
<span class="fc" id="L621">            points[pointSize++] = x;</span>
<span class="fc" id="L622">            points[pointSize++] = y;</span>
        }
<span class="fc" id="L624">        dirty = true;</span>
<span class="fc" id="L625">    }</span>

    public void lineTo(double x, double y) {
<span class="fc" id="L628">        lineTo((float) x, (float) y);</span>
<span class="fc" id="L629">    }</span>

    /**
     * Appends a straight line to the current path.
     *
     * @param x x coordinate of the line endpoint.
     * @param y y coordinate of the line endpoint.
     */
    public void lineTo(float x, float y) {
<span class="fc" id="L638">        checkBuf(2, true);</span>
<span class="fc" id="L639">        types[typeSize++] = PathIterator.SEG_LINETO;</span>
<span class="fc" id="L640">        points[pointSize++] = x;</span>
<span class="fc" id="L641">        points[pointSize++] = y;</span>
<span class="fc" id="L642">        dirty = true;</span>
<span class="fc" id="L643">    }</span>

    public void quadTo(double x1, double y1, double x2, double y2) {
<span class="fc" id="L646">        quadTo((float) x1, (float) y1, (float) x2, (float) y2);</span>
<span class="fc" id="L647">    }</span>

    /**
     * Appends a quadratic Bezier curve to the current path.
     *
     * @param x1 x coordinate of the control point
     * @param y1 y coordinate of the control point
     * @param x2 x coordinate of the curve endpoint.
     * @param y2 y coordinate of the curve endpoint.
     */
    public void quadTo(float x1, float y1, float x2, float y2) {
<span class="fc" id="L658">        checkBuf(4, true);</span>
<span class="fc" id="L659">        types[typeSize++] = PathIterator.SEG_QUADTO;</span>
<span class="fc" id="L660">        points[pointSize++] = x1;</span>
<span class="fc" id="L661">        points[pointSize++] = y1;</span>
<span class="fc" id="L662">        points[pointSize++] = x2;</span>
<span class="fc" id="L663">        points[pointSize++] = y2;</span>
<span class="fc" id="L664">        dirty = true;</span>
<span class="fc" id="L665">    }</span>

    public void curveTo(double x1, double y1, double x2, double y2, double x3, double y3) {
<span class="nc" id="L668">        curveTo((float) x1, (float) y1, (float) x2, (float) y2, (float) x3, (float) y3);</span>
<span class="nc" id="L669">    }</span>


//    private static void addBezierArcToPath(GeneralPath path, double cx, double cy,
//                                          double startX, double startY, double endX, double endY) {
//        addBezierArcToPath(path, cx, cy, startX, startY, endX, endY, false);
//    }

    /**
     * Appends a cubic Bezier curve to the current path.
     *
     * @param x1 x coordinate of the first control point
     * @param y1 y coordinate of the first control point
     * @param x2 x coordinate of the second control point
     * @param y2 y coordinate of the second control point
     * @param x3 x coordinate of the curve endpoint.
     * @param y3 y coordinate of the curve endpoint.
     */
    public void curveTo(float x1, float y1, float x2, float y2, float x3, float y3) {
<span class="fc" id="L688">        checkBuf(6, true);</span>
<span class="fc" id="L689">        types[typeSize++] = PathIterator.SEG_CUBICTO;</span>
<span class="fc" id="L690">        points[pointSize++] = x1;</span>
<span class="fc" id="L691">        points[pointSize++] = y1;</span>
<span class="fc" id="L692">        points[pointSize++] = x2;</span>
<span class="fc" id="L693">        points[pointSize++] = y2;</span>
<span class="fc" id="L694">        points[pointSize++] = x3;</span>
<span class="fc" id="L695">        points[pointSize++] = y3;</span>
<span class="fc" id="L696">        dirty = true;</span>
<span class="fc" id="L697">    }</span>

    /**
     * Draws an elliptical arc on the path given the provided bounds.
     *
     * @param x          Left x coord of bounding rect.
     * @param y          Top y coordof bounding rect.
     * @param w          Width of bounding rect.
     * @param h          Height of bounding rect.
     * @param startAngle Start angle on ellipse in radians.  Counter-clockwise from 3-o'clock.
     * @param sweepAngle Sweep angle in radians. Counter-clockwise.
     */
    public void arc(float x, float y, float w, float h, float startAngle, float sweepAngle) {

<span class="fc" id="L711">        arc(x, y, w, h, startAngle, sweepAngle, false);</span>
<span class="fc" id="L712">    }</span>

    /**
     * Adds a circular arc to the given path by approximating it through a cubic Bezier curve, splitting it if
     * necessary. The precision of the approximation can be adjusted through {@code pointsOnCircle} and
     * {@code overlapPoints} parameters.
     * &lt;p&gt;
     * &lt;strong&gt;Example:&lt;/strong&gt; imagine an arc starting from 0? and sweeping 100? with a value of
     * {@code pointsOnCircle} equal to 12 (threshold -&gt; 360? / 12 = 30?):
     * &lt;ul&gt;
     * &lt;li&gt;if {@code overlapPoints} is {@code true}, it will be split as following:
     * &lt;ul&gt;
     * &lt;li&gt;from 0? to 30? (sweep 30?)&lt;/li&gt;
     * &lt;li&gt;from 30? to 60? (sweep 30?)&lt;/li&gt;
     * &lt;li&gt;from 60? to 90? (sweep 30?)&lt;/li&gt;
     * &lt;li&gt;from 90? to 100? (sweep 10?)&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;/li&gt;
     * &lt;li&gt;if {@code overlapPoints} is {@code false}, it will be split into 4 equal arcs:
     * &lt;ul&gt;
     * &lt;li&gt;from 0? to 25? (sweep 25?)&lt;/li&gt;
     * &lt;li&gt;from 25? to 50? (sweep 25?)&lt;/li&gt;
     * &lt;li&gt;from 50? to 75? (sweep 25?)&lt;/li&gt;
     * &lt;li&gt;from 75? to 100? (sweep 25?)&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;/p&gt;
     * &lt;p/&gt;
     * For a technical explanation:
     * &lt;a href=&quot;http://hansmuller-flex.blogspot.de/2011/10/more-about-approximating-circular-arcs.html&quot;&gt;
     * http://hansmuller-flex.blogspot.de/2011/10/more-about-approximating-circular-arcs.html
     * &lt;/a&gt;
     *
     * @param center            The center of the circle.
     * @param radius            The radius of the circle.
     * @param startAngleRadians The starting angle on the circle (in radians).
     * @param sweepAngleRadians How long to make the total arc (in radians).
     * @param pointsOnCircle    Defines a &lt;i&gt;threshold&lt;/i&gt; (360? /{@code pointsOnCircle}) to split the Bezier arc to
     *                          better approximate a circular arc, depending also on the value of {@code overlapPoints}.
     *                          The suggested number to have a reasonable approximation of a circle is at least 4 (90?).
     *                          Less than 1 will be ignored (the arc will not be split).
     * @param overlapPoints     Given the &lt;i&gt;threshold&lt;/i&gt; defined through {@code pointsOnCircle}:
     *                          &lt;ul&gt;
     *                          &lt;li&gt;if {@code true}, split the arc on every angle which is a multiple of the
     *                          &lt;i&gt;threshold&lt;/i&gt; (yields better results if drawing precision is required,
     *                          especially when stacking multiple arcs, but can potentially use more points)&lt;/li&gt;
     *                          &lt;li&gt;if {@code false}, split the arc equally so that each part is shorter than
     *                          the &lt;i&gt;threshold&lt;/i&gt;&lt;/li&gt;
     *                          &lt;/ul&gt;
     * @param addToPath         An existing path where to add the arc to, or {@code null} to create a new path.
     *
     *
     * @see #createBezierArcDegrees(android.graphics.PointF, float, float, float, int, boolean, android.graphics.Path)
     */
//    private static void createBezierArcRadians(float cx, float cy, float radiusX, float radiusY, double startAngleRadians,
//                                              double sweepAngleRadians, int pointsOnCircle, boolean overlapPoints,
//                                              GeneralPath addToPath, boolean joinPath)
//    {
//        final GeneralPath path = addToPath;
//        if (sweepAngleRadians == 0d) { return; }
// 
//        float radius = radiusX;
//        float yScale = radiusY / radius;
//        
//        if (pointsOnCircle &gt;= 1)
//        {
//            final double threshold = Math.PI * 2d / pointsOnCircle;
//            if (Math.abs(sweepAngleRadians) &gt; threshold)
//            {
//                double angle = normalizeRadians(startAngleRadians);
//                //PointF end, start = pointFromAngleRadians(center, radius, angle);
//                double endX, endY;
//                double startX = cx + radius * Math.cos(angle);
//                double startY = cy + radius * Math.sin(angle) * yScale;
//                if (joinPath) {
//                    path.lineTo(startX, startY);
//                } else {
//                    path.moveTo(startX, startY);
//                }
//                if (overlapPoints)
//                {
//                    final boolean cw = sweepAngleRadians &gt; 0; // clockwise?
//                    final double angleEnd = angle + sweepAngleRadians;
//                    while (true)
//                    {
//                        double next = (cw ? Math.ceil(angle / threshold) : Math.floor(angle / threshold)) * threshold;
//                        if (angle == next) { next += threshold * (cw ? 1d : -1d); }
//                        final boolean isEnd = cw ? angleEnd &lt;= next : angleEnd &gt;= next;
//                        //end = pointFromAngleRadians(center, radius, isEnd ? angleEnd : next);
//                        endX = cx + radius * Math.cos(isEnd ? angleEnd : next);
//                        endY = cy + radius * Math.sin(isEnd ? angleEnd : next) *yScale;
//                        addBezierArcToPath(path, cx, cy, startX, startY, endX, endY);
//                        if (isEnd) { break; }
//                        angle = next;
//                        startX = endX;
//                        startY = endY;
//                    }
//                }
//                else
//                {
//                    final int n = Math.abs((int)Math.ceil(sweepAngleRadians / threshold));
//                    final double sweep = sweepAngleRadians / (double)n;
//                    for (int i = 0;
//                         i &lt; n;
//                         i++, startX = endX, startY = endY)
//                    {
//                        angle += sweep;
//                        //end = pointFromAngleRadians(center, radius, angle);
//                        endX = cx + radius * Math.cos(angle);
//                        endY = cy + radius * Math.sin(angle) * yScale;
//                        addBezierArcToPath(path, cx, cy, startX, startY, endX, endY);
//                    }
//                    
//                }
//                return;
//            }
//        }
// 
//        startAngleRadians = normalizeRadians(startAngleRadians);
//        double startX = cx + radius * Math.cos(startAngleRadians);
//        double startY = cy + radius * Math.sin(startAngleRadians) * yScale;
//        
//        double endX = cx + radius * Math.cos(startAngleRadians + sweepAngleRadians);
//        double endY = cy + radius * Math.sin(startAngleRadians + sweepAngleRadians) * yScale;
//        if (joinPath) {
//            path.lineTo(startX, startY);
//        } else {
//            path.moveTo(startX, startY);
//        }
//        addBezierArcToPath(path, cx, cy, startX, startY, endX, endY);
//        
//    }

    /**
     * Normalize the input radians in the range 360? &gt; x &gt;= 0?.
     *
     * @param radians The angle to normalize (in radians).
     *
     * @return The angle normalized in the range 360? &gt; x &gt;= 0?.
     */
//    private static double normalizeRadians(double radians)
//    {
//        double PI2 = Math.PI*2d;
//        radians %= PI2;
//        if (radians &lt; 0d) { radians += PI2; }
//        if (radians == PI2) { radians = 0d; }
//        return radians;
//    }

    /**
     * Draws an elliptical arc on the path given the provided bounds.
     *
     * @param x          Left x coord of bounding rect.
     * @param y          Top y coordof bounding rect.
     * @param w          Width of bounding rect.
     * @param h          Height of bounding rect.
     * @param startAngle Start angle on ellipse in radians.  Counter-clockwise from 3-o'clock.
     * @param sweepAngle Sweep angle in radians. Counter-clockwise.
     * @param joinPath   If true, then this will join the arc to the existing path with a line.
     */
    public void arc(float x, float y, float w, float h, float startAngle, float sweepAngle, boolean joinPath) {

<span class="fc" id="L875">        Ellipse e = new Ellipse();</span>
<span class="fc" id="L876">        Ellipse.initWithBounds(e, x, y, w, h);</span>
<span class="fc" id="L877">        e.addToPath(this, -startAngle, -sweepAngle, joinPath);</span>
<span class="fc" id="L878">    }</span>

    /**
     * Draws an elliptical arc on the path given the provided bounds.
     *
     * @param x          Left x coord of bounding rect.
     * @param y          Top y coordof bounding rect.
     * @param w          Width of bounding rect.
     * @param h          Height of bounding rect.
     * @param startAngle Start angle on ellipse in radians.  Counter-clockwise from 3-o'clock.
     * @param sweepAngle Sweep angle in radians. Counter-clockwise.
     */
    public void arc(double x, double y, double w, double h, double startAngle, double sweepAngle) {
<span class="nc" id="L891">        arc(x, y, w, h, startAngle, sweepAngle, false);</span>
<span class="nc" id="L892">    }</span>

    /**
     * Draws an elliptical arc on the path given the provided bounds.
     *
     * @param x          Left x coord of bounding rect.
     * @param y          Top y coordof bounding rect.
     * @param w          Width of bounding rect.
     * @param h          Height of bounding rect.
     * @param startAngle Start angle on ellipse in radians.  Counter-clockwise from 3-o'clock.
     * @param sweepAngle Sweep angle in radians. Counter-clockwise.
     * @param joinPath   If true then this will join the arc to the existing path with a line.
     */
    public void arc(double x, double y, double w, double h, double startAngle, double sweepAngle, boolean joinPath) {
<span class="fc" id="L906">        arc((float) x, (float) y, (float) w, (float) h, (float) startAngle, (float) sweepAngle, joinPath);</span>
<span class="fc" id="L907">    }</span>

    /**
     * Adds an arc to the path.  This method uses an approximation of an arc using
     * a cubic path.  It is not a precise arc.
     *
     * &lt;p&gt;Note:  The arc is drawn counter-clockwise around the center point.  See {@link #arcTo(double, double, double, double, boolean) }
     * to draw clockwise.&lt;/p&gt;
     *
     * @param cX   The x-coordinate of the oval center.
     * @param cY   The y-coordinate of the oval center.
     * @param endX The end X coordinate.
     * @param endY The end Y coordinate.
     */
    public void arcTo(float cX, float cY, float endX, float endY) {
<span class="nc" id="L922">        arcTo(cX, cY, endX, endY, false);</span>
<span class="nc" id="L923">    }</span>

    /**
     * Adds an arc to the path.  This method uses an approximation of an arc using
     * a cubic path.  It is not a precise arc.
     *
     * @param cX        The x-coordinate of the oval center.
     * @param cY        The y-coordinate of the oval center.
     * @param endX      The end X coordinate.
     * @param endY      The end Y coordinate.
     * @param clockwise If true, the arc is drawn clockwise around the center point.
     */
    public void arcTo(float cX, float cY, float endX, float endY, boolean clockwise) {
<span class="pc bpc" id="L936" title="1 of 2 branches missed.">        if (pointSize &lt; 2) {</span>
<span class="nc" id="L937">            throw new RuntimeException(&quot;Cannot add arc to path if it doesn't already have a starting point.&quot;);</span>

        }
<span class="fc" id="L940">        float startX = points[pointSize - 2];</span>
<span class="fc" id="L941">        float startY = points[pointSize - 1];</span>

<span class="fc" id="L943">        float dx = endX - cX;</span>
<span class="fc" id="L944">        float dy = endY - cY;</span>
<span class="fc" id="L945">        double r2 = Math.sqrt(dx * dx + dy * dy);</span>
<span class="fc" id="L946">        double dx1 = startX - cX;</span>
<span class="fc" id="L947">        double dy1 = startY - cY;</span>
<span class="fc" id="L948">        double r1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);</span>
<span class="pc bpc" id="L949" title="1 of 2 branches missed.">        if (Math.abs(r1 - r2) &gt; 1) {</span>
<span class="nc" id="L950">            Log.e(new RuntimeException(&quot;arcTo() called with start and end points that don't lie on the same arc r1=&quot; + r1 + &quot;, r2=&quot; + r2));</span>

        }
<span class="fc" id="L953">        Ellipse e = new Ellipse();</span>
<span class="fc" id="L954">        Ellipse.initWithBounds(e, cX - r2, cY - r2, r2 * 2, r2 * 2);</span>
<span class="fc" id="L955">        double startAngle = e.getAngleAtPoint(startX, startY);</span>
<span class="fc" id="L956">        double endAngle = e.getAngleAtPoint(endX, endY);</span>
<span class="fc" id="L957">        double sweepAngle = endAngle - startAngle;</span>
<span class="fc bfc" id="L958" title="All 4 branches covered.">        if (clockwise &amp;&amp; sweepAngle &gt; 0) {</span>
<span class="fc" id="L959">            sweepAngle = -sweepAngle;</span>
<span class="pc bpc" id="L960" title="1 of 4 branches missed.">        } else if (!clockwise &amp;&amp; sweepAngle &gt; 0) {</span>
<span class="fc" id="L961">            sweepAngle = 2 * Math.PI - sweepAngle;</span>
        }

<span class="fc" id="L964">        arc(cX - r2, cY - r2, r2 * 2, r2 * 2, -startAngle, sweepAngle, true);</span>
<span class="fc" id="L965">        lineTo(endX, endY);</span>
<span class="fc" id="L966">    }</span>

    /**
     * Adds an arc to the path.  This method uses an approximation of an arc using
     * a cubic path.  It is not a precise arc.
     * &lt;p&gt;Note:  The arc is drawn counter-clockwise around the center point.  See {@link #arcTo(double, double, double, double, boolean) }
     * to draw clockwise.&lt;/p&gt;
     *
     * @param cX   The x-coordinate of the oval center.
     * @param cY   The y-coordinate of the oval center.
     * @param endX The end X coordinate.
     * @param endY The end Y coordinate.
     */
    public void arcTo(double cX, double cY, double endX, double endY) {
<span class="fc" id="L980">        arcTo(cX, cY, endX, endY, false);</span>
<span class="fc" id="L981">    }</span>

    /**
     * Adds an arc to the path.  This method uses an approximation of an arc using
     * a cubic path.  It is not a precise arc.
     *
     * @param cX        The x-coordinate of the oval center.
     * @param cY        The y-coordinate of the oval center.
     * @param endX      The end X coordinate.
     * @param endY      The end Y coordinate.
     * @param clockwise If true, the arc is drawn clockwise around the center point.
     */
    public void arcTo(double cX, double cY, double endX, double endY, boolean clockwise) {
<span class="fc" id="L994">        arcTo((float) cX, (float) cY, (float) endX, (float) endY, clockwise);</span>
<span class="fc" id="L995">    }</span>

    /**
     * Closes the current subpath by drawing a line back to the point of the
     * last moveTo, unless the path is already closed.
     */
    public void closePath() {
<span class="pc bpc" id="L1002" title="2 of 4 branches missed.">        if (typeSize == 0 || types[typeSize - 1] != PathIterator.SEG_CLOSE) {</span>
<span class="fc" id="L1003">            checkBuf(0, true);</span>
<span class="fc" id="L1004">            types[typeSize++] = PathIterator.SEG_CLOSE;</span>
<span class="fc" id="L1005">            dirty = true;</span>
        }
<span class="fc" id="L1007">    }</span>

    /**
     * Appends the segments of a Shape to the path. If connect is
     * {@literal true}, the new path segments are connected to the existing one
     * with a line. The winding rule of the Shape is ignored.
     *
     * @param shape   the shape (null not permitted).
     * @param connect whether to connect the new shape to the existing path.
     */
    public void append(Shape shape, boolean connect) {
<span class="pc bpc" id="L1018" title="1 of 2 branches missed.">        if (shape.getClass() == GeneralPath.class) {</span>
<span class="fc" id="L1019">            Iterator it = createIteratorFromPool((GeneralPath) shape, null);</span>
            try {
<span class="fc" id="L1021">                append(it, connect);</span>
            } finally {
<span class="fc" id="L1023">                recycle(it);</span>
            }
<span class="fc" id="L1025">        } else {</span>
<span class="nc" id="L1026">            PathIterator p = shape.getPathIterator();</span>
<span class="nc" id="L1027">            append(p, connect);</span>
        }

<span class="fc" id="L1030">        dirty = true;</span>
<span class="fc" id="L1031">    }</span>

    /**
     * Appends the segments of a PathIterator to this GeneralPath. Optionally,
     * the initial {@link PathIterator#SEG_MOVETO} segment of the appended path
     * is changed into a {@link PathIterator#SEG_LINETO} segment.
     *
     * @param path    the PathIterator specifying which segments shall be appended
     *                (null not permitted).
     * @param connect {@literal true} for substituting the initial
     *                {@link PathIterator#SEG_MOVETO} segment by a
     *                {@link PathIterator#SEG_LINETO}, or false for not performing any
     *                substitution. If this {@code GeneralPath} is currently empty, connect is
     *                assumed to be {@literal false}, thus leaving the initial
     *                {@link PathIterator#SEG_MOVETO} unchanged.
     */
    public void append(PathIterator path, boolean connect) {
<span class="fc" id="L1048">        float[] coords = createFloatArrayFromPool(6);//new float[6];</span>
<span class="fc" id="L1049">        append(path, connect, coords);</span>
<span class="fc" id="L1050">        recycle(coords);</span>
<span class="fc" id="L1051">    }</span>

    private void append(PathIterator path, boolean connect, float[] tmpCoordsBuf) {
<span class="fc" id="L1054">        float[] coords = tmpCoordsBuf;</span>
<span class="fc bfc" id="L1055" title="All 2 branches covered.">        while (!path.isDone()) {</span>

<span class="pc bpc" id="L1057" title="3 of 6 branches missed.">            switch (path.currentSegment(coords)) {</span>
                case PathIterator.SEG_MOVETO:
<span class="pc bpc" id="L1059" title="1 of 4 branches missed.">                    if (!connect || typeSize == 0) {</span>
<span class="fc" id="L1060">                        moveTo(coords[0], coords[1]);</span>
<span class="fc" id="L1061">                        break;</span>
                    }
<span class="pc bpc" id="L1063" title="4 of 6 branches missed.">                    if (types[typeSize - 1] != PathIterator.SEG_CLOSE</span>
                            &amp;&amp; points[pointSize - 2] == coords[0]
                            &amp;&amp; points[pointSize - 1] == coords[1]) {
<span class="nc" id="L1066">                        break;</span>
                    }
                    // NO BREAK;
                case PathIterator.SEG_LINETO:
<span class="fc" id="L1070">                    lineTo(coords[0], coords[1]);</span>
<span class="fc" id="L1071">                    break;</span>
                case PathIterator.SEG_QUADTO:
<span class="nc" id="L1073">                    quadTo(coords[0], coords[1], coords[2], coords[3]);</span>
<span class="nc" id="L1074">                    break;</span>
                case PathIterator.SEG_CUBICTO:
<span class="nc" id="L1076">                    curveTo(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);</span>
<span class="nc" id="L1077">                    break;</span>
                case PathIterator.SEG_CLOSE:
<span class="fc" id="L1079">                    closePath();</span>
                    break;
            }
<span class="fc" id="L1082">            path.next();</span>
<span class="fc" id="L1083">            connect = false;</span>
        }
<span class="fc" id="L1085">        dirty = true;</span>
<span class="fc" id="L1086">    }</span>

    /**
     * Returns the current appending point of the path.
     *
     * @return 2-element array of the form {@code [x,y]} representing {@code x}
     * and {@code y} coordinate of the current appending point of the path..
     */
    public float[] getCurrentPoint() {
<span class="fc bfc" id="L1095" title="All 2 branches covered.">        if (typeSize == 0) {</span>
<span class="fc" id="L1096">            return null;</span>
        }
<span class="fc" id="L1098">        float[] out = new float[2];</span>
<span class="fc" id="L1099">        getCurrentPoint(out);</span>
<span class="fc" id="L1100">        return out;</span>
    }

    /**
     * Sets the coordinates of the given point to the current point in the path.
     *
     * @param point Out parameter.  Will be filled with the coords of the current point.
     */
    public void getCurrentPoint(float[] point) {
<span class="pc bpc" id="L1109" title="1 of 2 branches missed.">        if (typeSize == 0) {</span>
<span class="nc" id="L1110">            throw new RuntimeException(&quot;Cannot get point because the size of this command is 0&quot;);</span>
        }
<span class="fc" id="L1112">        int j = pointSize - 2;</span>
<span class="fc bfc" id="L1113" title="All 2 branches covered.">        if (types[typeSize - 1] == PathIterator.SEG_CLOSE) {</span>

<span class="fc bfc" id="L1115" title="All 2 branches covered.">            for (int i = typeSize - 2; i &gt; 0; i--) {</span>
<span class="fc" id="L1116">                int type = types[i];</span>
<span class="pc bpc" id="L1117" title="1 of 2 branches missed.">                if (type == PathIterator.SEG_MOVETO) {</span>
<span class="nc" id="L1118">                    break;</span>
                }
<span class="fc" id="L1120">                j -= pointShift[type];</span>
            }
        }
<span class="fc" id="L1123">        point[0] = points[j];</span>
<span class="fc" id="L1124">        point[1] = points[j + 1];</span>
        //return new float[]{points[j], points[j + 1]};
<span class="fc" id="L1126">    }</span>

    /**
     * Resets the path. All points and segments are destroyed.
     */
    public void reset() {
<span class="fc" id="L1132">        typeSize = 0;</span>
<span class="fc" id="L1133">        pointSize = 0;</span>
<span class="fc" id="L1134">        dirty = true;</span>
<span class="fc" id="L1135">    }</span>

    /**
     * Returns the path's bounding box, in float precision.
     *
     * @return 4-element array of the form {@code [x, y, width, height]}.
     */
    public float[] getBounds2D() {
<span class="fc" id="L1143">        float[] out = new float[4];</span>
<span class="fc" id="L1144">        getBounds2D(out);</span>
<span class="fc" id="L1145">        return out;</span>
    }

    /**
     * Sets the 4-element array to the bounding box coordinates of the path.  x, y, width, height.
     *
     * @param out 4-element float[] array.
     */
    public void getBounds2D(float[] out) {
        float rx1, ry1, rx2, ry2;
<span class="fc bfc" id="L1155" title="All 2 branches covered.">        if (pointSize == 0) {</span>
<span class="fc" id="L1156">            rx1 = ry1 = rx2 = ry2 = 0.0f;</span>
        } else {
<span class="fc" id="L1158">            int i = pointSize - 1;</span>
<span class="fc" id="L1159">            ry1 = ry2 = points[i--];</span>
<span class="fc" id="L1160">            rx1 = rx2 = points[i--];</span>
<span class="fc bfc" id="L1161" title="All 2 branches covered.">            while (i &gt; 0) {</span>
<span class="fc" id="L1162">                float y = points[i--];</span>
<span class="fc" id="L1163">                float x = points[i--];</span>
<span class="fc bfc" id="L1164" title="All 2 branches covered.">                if (x &lt; rx1) {</span>
<span class="fc" id="L1165">                    rx1 = x;</span>
<span class="fc bfc" id="L1166" title="All 2 branches covered.">                } else if (x &gt; rx2) {</span>
<span class="fc" id="L1167">                    rx2 = x;</span>
                }
<span class="fc bfc" id="L1169" title="All 2 branches covered.">                if (y &lt; ry1) {</span>
<span class="fc" id="L1170">                    ry1 = y;</span>
<span class="fc bfc" id="L1171" title="All 2 branches covered.">                } else if (y &gt; ry2) {</span>
<span class="fc" id="L1172">                    ry2 = y;</span>
                }
<span class="fc" id="L1174">            }</span>
        }
<span class="fc" id="L1176">        out[0] = rx1;</span>
<span class="fc" id="L1177">        out[1] = ry1;</span>
<span class="fc" id="L1178">        out[2] = rx2 - rx1;</span>
<span class="fc" id="L1179">        out[3] = ry2 - ry1;</span>
<span class="fc" id="L1180">    }</span>

    /**
     * Returns the path's bounding box.
     *
     * @return The bounding box of the path.
     */
    public Rectangle getBounds() {
        // NOTE (SJH20180614): If the path contains bezier curves,  may be larger than drawn bounds.
        // See note in getBounds(Rectangle) for more details.
<span class="fc" id="L1190">        float[] r = getBounds2D();</span>
<span class="fc" id="L1191">        int x1 = (int) Math.floor(r[0]);</span>
<span class="fc" id="L1192">        int y1 = (int) Math.floor(r[1]);</span>
<span class="fc" id="L1193">        int x2 = (int) Math.ceil(r[0] + r[2]);</span>
<span class="fc" id="L1194">        int y2 = (int) Math.ceil(r[1] + r[3]);</span>
<span class="fc" id="L1195">        return new Rectangle(x1, y1, x2 - x1, y2 - y1);</span>
    }

    /**
     * Sets the coordinates of the provided rectangle to the bounding box of this path.
     *
     * @param out
     */
    public void getBounds(Rectangle out) {
        // NOTE (SJH20180614): If the path contains bezier curves, this bounds
        // may be much larger than the actual drawn bounds because it includes
        // the control points in the bounds (and control points are not actually
        // drawn.
        // We can get an accurate bounds for the bezier curves using BezierCurve.getBoundingRect()
        // but this is a relatively expensive operation as it must solve cubic or quadratic
        // equations for each curve.
        // This this method is used inside the Graphics clipping functionality
        // we need to make sure it's fast.

        float rx1, ry1, rx2, ry2;
<span class="pc bpc" id="L1215" title="1 of 2 branches missed.">        if (pointSize == 0) {</span>
<span class="nc" id="L1216">            rx1 = ry1 = rx2 = ry2 = 0.0f;</span>
        } else {
<span class="fc" id="L1218">            int i = pointSize - 1;</span>
<span class="fc" id="L1219">            ry1 = ry2 = points[i--];</span>
<span class="fc" id="L1220">            rx1 = rx2 = points[i--];</span>
<span class="fc bfc" id="L1221" title="All 2 branches covered.">            while (i &gt; 0) {</span>
<span class="fc" id="L1222">                float y = points[i--];</span>
<span class="fc" id="L1223">                float x = points[i--];</span>
<span class="fc bfc" id="L1224" title="All 2 branches covered.">                if (x &lt; rx1) {</span>
<span class="fc" id="L1225">                    rx1 = x;</span>
<span class="fc bfc" id="L1226" title="All 2 branches covered.">                } else if (x &gt; rx2) {</span>
<span class="fc" id="L1227">                    rx2 = x;</span>
                }
<span class="fc bfc" id="L1229" title="All 2 branches covered.">                if (y &lt; ry1) {</span>
<span class="fc" id="L1230">                    ry1 = y;</span>
<span class="fc bfc" id="L1231" title="All 2 branches covered.">                } else if (y &gt; ry2) {</span>
<span class="fc" id="L1232">                    ry2 = y;</span>
                }
<span class="fc" id="L1234">            }</span>
        }
<span class="fc" id="L1236">        int x1 = (int) Math.floor(rx1);</span>
<span class="fc" id="L1237">        int y1 = (int) Math.floor(ry1);</span>
<span class="fc" id="L1238">        int x2 = (int) Math.ceil(rx2);</span>
<span class="fc" id="L1239">        int y2 = (int) Math.ceil(ry2);</span>
<span class="fc" id="L1240">        out.setX(x1);</span>
<span class="fc" id="L1241">        out.setY(y1);</span>
<span class="fc" id="L1242">        out.setWidth(x2 - x1);</span>
<span class="fc" id="L1243">        out.setHeight(y2 - y1);</span>

<span class="fc" id="L1245">    }</span>

    /**
     * Checks to see if this path is a rectangle.
     *
     * @return True if this path forms a rectangle.  False otherwise.
     */
    public boolean isRectangle() {
        // NOTE (SJH20180614): This is used extensively in clipping.   We can probably
        // do this more efficiently without needing to call getBounds()
<span class="fc" id="L1255">        float[] tmpPointsBuf = createFloatArrayFromPool(6);</span>
<span class="fc" id="L1256">        boolean[] tmpCornersBuf = createBoolArrayFromPool(4);</span>
<span class="fc" id="L1257">        Iterator it = createIteratorFromPool(this, null);</span>
<span class="fc" id="L1258">        Rectangle bounds = createRectFromPool();</span>
        try {
<span class="fc" id="L1260">            getBounds(bounds);</span>
<span class="pc bpc" id="L1261" title="1 of 2 branches missed.">            if (tmpPointsBuf.length != 6) {</span>
<span class="nc" id="L1262">                throw new RuntimeException(&quot;points buffer must be length 6&quot;);</span>
            }
<span class="fc" id="L1264">            float[] buf = tmpPointsBuf;</span>
<span class="pc bpc" id="L1265" title="1 of 2 branches missed.">            if (tmpCornersBuf.length != 4) {</span>
<span class="nc" id="L1266">                throw new RuntimeException(&quot;corners buffer must be length 4&quot;);</span>
            }
<span class="fc" id="L1268">            boolean[] corners = tmpCornersBuf;</span>
<span class="fc" id="L1269">            int prevX = 0;</span>
<span class="fc" id="L1270">            int prevY = 0;</span>
<span class="fc bfc" id="L1271" title="All 2 branches covered.">            while (!it.isDone()) {</span>
<span class="fc" id="L1272">                int type = it.currentSegment(buf);</span>

                // Rectangulars only support moves, lines, and closes
<span class="fc bfc" id="L1275" title="All 6 branches covered.">                if (type != PathIterator.SEG_CLOSE &amp;&amp; type != PathIterator.SEG_LINETO &amp;&amp; type != PathIterator.SEG_MOVETO) {</span>
<span class="fc" id="L1276">                    return false;</span>
                }


                // Get the current point
<span class="fc" id="L1281">                int x = (int) buf[0];</span>
<span class="fc" id="L1282">                int y = (int) buf[1];</span>

                // Make sure there are no diagonal lines
<span class="pc bpc" id="L1285" title="1 of 6 branches missed.">                if (type == PathIterator.SEG_LINETO &amp;&amp; !(x == prevX || y == prevY)) {</span>
<span class="nc" id="L1286">                    return false;</span>
                }

                // Make sure point is on the perimeter.
<span class="pc bpc" id="L1290" title="3 of 8 branches missed.">                if (x != bounds.getX() &amp;&amp; y != bounds.getY() &amp;&amp; x != bounds.getX() + bounds.getWidth() &amp;&amp; y != bounds.getY() + bounds.getHeight()) {</span>
<span class="nc" id="L1291">                    return false;</span>
                }

                // Make sure that all corners are accounted for.
<span class="fc bfc" id="L1295" title="All 2 branches covered.">                for (int i = 0; i &lt; 4; i++) {</span>
<span class="fc bfc" id="L1296" title="All 2 branches covered.">                    if (corners[i]) {</span>
<span class="fc" id="L1297">                        continue;</span>
                    }
<span class="pc bpc" id="L1299" title="1 of 5 branches missed.">                    switch (i) {</span>
                        case 0:
<span class="pc bpc" id="L1301" title="2 of 4 branches missed.">                            corners[i] = (x == bounds.getX() &amp;&amp; y == bounds.getY());</span>
<span class="fc" id="L1302">                            break;</span>
                        case 1:
<span class="pc bpc" id="L1304" title="1 of 4 branches missed.">                            corners[i] = (x == bounds.getX() + bounds.getWidth() &amp;&amp; y == bounds.getY());</span>
<span class="fc" id="L1305">                            break;</span>
                        case 2:
<span class="fc bfc" id="L1307" title="All 4 branches covered.">                            corners[i] = (x == bounds.getX() + bounds.getWidth() &amp;&amp; y == bounds.getY() + bounds.getHeight());</span>
<span class="fc" id="L1308">                            break;</span>
                        case 3:
<span class="fc bfc" id="L1310" title="All 4 branches covered.">                            corners[i] = (x == bounds.getX() &amp;&amp; y == bounds.getY() + bounds.getHeight());</span>
                            break;
                    }
                }

<span class="fc" id="L1315">                prevX = x;</span>
<span class="fc" id="L1316">                prevY = y;</span>
<span class="fc" id="L1317">                it.next();</span>
<span class="fc" id="L1318">            }</span>

<span class="pc bpc" id="L1320" title="4 of 8 branches missed.">            return corners[0] &amp;&amp; corners[1] &amp;&amp; corners[2] &amp;&amp; corners[3];</span>
        } finally {
<span class="fc" id="L1322">            recycle(tmpPointsBuf);</span>
<span class="fc" id="L1323">            recycle(tmpCornersBuf);</span>
<span class="fc" id="L1324">            recycle(it);</span>
<span class="fc" id="L1325">            recycle(bounds);</span>
        }
    }

    /**
     * {{@inheritDoc}}
     */
    public PathIterator getPathIterator() {
<span class="fc" id="L1333">        return new Iterator(this);</span>
    }

    /**
     * {{@inheritDoc}}
     */
    public PathIterator getPathIterator(Transform m) {
<span class="fc" id="L1340">        Iterator out = (Iterator) getPathIterator();</span>
<span class="fc" id="L1341">        out.transform = m;</span>
<span class="fc" id="L1342">        return out;</span>
    }

    /**
     * Returns a shape formed by transforming the current shape with the provided
     * transform.
     * &lt;p&gt;Note: If {@link com.codename1.ui.Transform#isSupported} is false, this may throw a RuntimeException.&lt;/p&gt;
     *
     * @param m The transform to be used to transform the shape.
     * @return The transformed shape.
     */
    public Shape createTransformedShape(Transform m) {

<span class="fc" id="L1355">        GeneralPath out = new GeneralPath();</span>
<span class="fc" id="L1356">        out.setPath(this, m);</span>
<span class="fc" id="L1357">        return out;</span>
    }

    /**
     * Sets this path to be identical to the provided path {@code p} with the given
     * Transform {@code t} applied to it.
     *
     * @param p The path to copy.
     * @param t The transform to apply to all points in the path.
     */
    public void setPath(GeneralPath p, Transform t) {
<span class="fc" id="L1368">        dirty = true;</span>
<span class="fc" id="L1369">        typeSize = p.typeSize;</span>
<span class="fc" id="L1370">        pointSize = p.pointSize;</span>
<span class="fc" id="L1371">        rule = p.rule;</span>
<span class="pc bpc" id="L1372" title="2 of 4 branches missed.">        if (points == null || points.length &lt; pointSize) {</span>
<span class="nc" id="L1373">            points = new float[pointSize];</span>
        }
<span class="pc bpc" id="L1375" title="2 of 4 branches missed.">        if (types == null || types.length &lt; typeSize) {</span>
<span class="nc" id="L1376">            types = new byte[typeSize];</span>
        }
<span class="fc" id="L1378">        System.arraycopy(p.types, 0, types, 0, typeSize);</span>
<span class="pc bpc" id="L1379" title="1 of 4 branches missed.">        if (t == null || t.isIdentity()) {</span>
<span class="fc" id="L1380">            System.arraycopy(p.points, 0, points, 0, pointSize);</span>

        } else {
<span class="fc" id="L1383">            t.transformPoints(2, p.points, 0, points, 0, pointSize / 2);</span>

        }

<span class="fc" id="L1387">    }</span>

    /**
     * Sets this path to be a rectangle with the provided bounds, but with
     * the given transform applied to it.
     *
     * @param r Rectangle to copy.
     * @param t The transform to apply to the points in in {@code r}.
     */
    public void setRect(Rectangle r, Transform t) {
<span class="fc" id="L1397">        reset();</span>
<span class="fc" id="L1398">        int x = r.getX();</span>
<span class="fc" id="L1399">        int y = r.getY();</span>
<span class="fc" id="L1400">        Dimension size = r.getSize();</span>
<span class="fc" id="L1401">        int w = size.getWidth();</span>
<span class="fc" id="L1402">        int h = size.getHeight();</span>

<span class="fc bfc" id="L1404" title="All 2 branches covered.">        if (t == null) {</span>
<span class="fc" id="L1405">            moveTo(x, y);</span>
<span class="fc" id="L1406">            lineTo(x + w, y);</span>
<span class="fc" id="L1407">            lineTo(x + w, y + h);</span>
<span class="fc" id="L1408">            lineTo(x, y + h);</span>
<span class="fc" id="L1409">            closePath();</span>
        } else {
<span class="fc" id="L1411">            float[] pointBuffer = createFloatArrayFromPool(6);</span>
            try {
<span class="fc" id="L1413">                pointBuffer[0] = x;</span>
<span class="fc" id="L1414">                pointBuffer[1] = y;</span>
<span class="fc" id="L1415">                pointBuffer[2] = 0;</span>
<span class="fc" id="L1416">                t.transformPoint(pointBuffer, pointBuffer);</span>
<span class="fc" id="L1417">                moveTo(pointBuffer[0], pointBuffer[1]);</span>
<span class="fc" id="L1418">                pointBuffer[0] = x + w;</span>
<span class="fc" id="L1419">                pointBuffer[1] = y;</span>
<span class="fc" id="L1420">                pointBuffer[2] = 0;</span>
<span class="fc" id="L1421">                t.transformPoint(pointBuffer, pointBuffer);</span>
<span class="fc" id="L1422">                lineTo(pointBuffer[0], pointBuffer[1]);</span>
<span class="fc" id="L1423">                pointBuffer[0] = x + w;</span>
<span class="fc" id="L1424">                pointBuffer[1] = y + h;</span>
<span class="fc" id="L1425">                pointBuffer[2] = 0;</span>
<span class="fc" id="L1426">                t.transformPoint(pointBuffer, pointBuffer);</span>
<span class="fc" id="L1427">                lineTo(pointBuffer[0], pointBuffer[1]);</span>
<span class="fc" id="L1428">                pointBuffer[0] = x;</span>
<span class="fc" id="L1429">                pointBuffer[1] = y + h;</span>
<span class="fc" id="L1430">                pointBuffer[2] = 0;</span>
<span class="fc" id="L1431">                t.transformPoint(pointBuffer, pointBuffer);</span>
<span class="fc" id="L1432">                lineTo(pointBuffer[0], pointBuffer[1]);</span>
<span class="fc" id="L1433">                closePath();</span>
            } finally {
<span class="fc" id="L1435">                recycle(pointBuffer);</span>
            }
        }
<span class="fc" id="L1438">    }</span>

    /**
     * Sets this path to be a copy of the provided shape, but with the provided
     * transform applied to it.
     *
     * @param s The shape to copy.
     * @param t The transform to apply to all points in the shape.
     */
    public void setShape(Shape s, Transform t) {
<span class="fc bfc" id="L1448" title="All 2 branches covered.">        if (s.getClass() == GeneralPath.class) {</span>
<span class="fc" id="L1449">            setPath((GeneralPath) s, t);</span>
<span class="pc bpc" id="L1450" title="1 of 2 branches missed.">        } else if (s.getClass() == Rectangle.class) {</span>
<span class="fc" id="L1451">            setRect((Rectangle) s, t);</span>
        } else {
<span class="nc" id="L1453">            reset();</span>
<span class="nc" id="L1454">            append(s.getPathIterator(t), false);</span>
        }
<span class="fc" id="L1456">    }</span>

    /**
     * Sets the current path to the intersection of itself and the provided rectangle.
     *
     * @param rect The rectangle to intersect with this path.
     * @return True if {@code rect} intersects the current path.  False otherwise.  If there is no intersection, the
     * path will be reset to be empty.
     */
    public boolean intersect(Rectangle rect) {
<span class="fc" id="L1466">        GeneralPath intersectionScratchPath = createPathFromPool();</span>
        try {
<span class="fc" id="L1468">            Shape result = ShapeUtil.intersection(rect, this, intersectionScratchPath);</span>
<span class="fc bfc" id="L1469" title="All 2 branches covered.">            if (result != null) {</span>
<span class="fc" id="L1470">                this.setPath(intersectionScratchPath, null);</span>
<span class="fc" id="L1471">                return true;</span>
            }
<span class="fc" id="L1473">            reset();</span>
<span class="fc" id="L1474">            return false;</span>

        } finally {
<span class="fc" id="L1477">            recycle(intersectionScratchPath);</span>
        }
    }

    public boolean intersect(int x, int y, int w, int h) {
<span class="nc" id="L1482">        Rectangle r = createRectFromPool();</span>
        try {
<span class="nc" id="L1484">            r.setBounds(x, y, w, h);</span>
<span class="nc" id="L1485">            return intersect(r);</span>
        } finally {
<span class="nc" id="L1487">            recycle(r);</span>
        }
    }

    /**
     * Transforms the current path in place using the given transform.
     *
     * @param m The transform to apply to the path.
     */
    public void transform(Transform m) {
<span class="pc bpc" id="L1497" title="2 of 4 branches missed.">        if (m != null &amp;&amp; !m.isIdentity()) {</span>
<span class="fc" id="L1498">            m.transformPoints(2, points, 0, points, 0, pointSize / 2);</span>
        }
<span class="fc" id="L1500">    }</span>

    /**
     * Resets this path to be the intersection of itself with the given shape.  Note that only
     * {@link com.codename1.ui.geom.Rectangle}s are current supported.  If you pass any other
     * shape, it will throw a RuntimeException.
     * &lt;p&gt;Note: If {@link com.codename1.ui.TransformisSupported} is false, this will throw a Runtime Exception&lt;/p&gt;
     *
     * @param shape The shape to intersect with the current shape.
     */
    public void intersect(Shape shape) {
        //Log.p(&quot;Start intersect&quot;);
<span class="nc bnc" id="L1512" title="All 2 branches missed.">        if (!(shape instanceof Rectangle)) {</span>
<span class="nc" id="L1513">            throw new RuntimeException(&quot;GeneralPath.intersect() only supports Rectangles&quot;);</span>
        }
<span class="nc" id="L1515">        intersect((Rectangle) shape);</span>
<span class="nc" id="L1516">    }</span>

    /**
     * {{@inheritDoc}}
     */
    public Shape intersection(Rectangle rect) {
<span class="nc" id="L1522">        Shape out = ShapeUtil.intersection(rect, this);</span>
<span class="nc bnc" id="L1523" title="All 2 branches missed.">        if (out == null) {</span>
<span class="nc" id="L1524">            return new Rectangle(rect.getX(), rect.getY(), 0, 0);</span>
        }
<span class="nc" id="L1526">        return out;</span>
    }

    /**
     * Checks cross count according to path rule to define is it point inside shape or not.
     *
     * @param cross - the point cross count
     * @return true if point is inside path, or false otherwise
     */
    boolean isInside(int cross) {
<span class="pc bpc" id="L1536" title="1 of 2 branches missed.">        if (rule == WIND_NON_ZERO) {</span>
<span class="fc" id="L1537">            return ShapeUtil.isInsideNonZero(cross);</span>
        }
<span class="nc" id="L1539">        return ShapeUtil.isInsideEvenOdd(cross);</span>
    }

    /**
     * Checks if the given point is contained in the current shape.
     *
     * @param x The x coordinate to check
     * @param y The y coordinate to check
     * @return True if the point is inside the shape.
     */
    public boolean contains(float x, float y) {
<span class="fc" id="L1550">        return isInside(ShapeUtil.crossShape(this, x, y));</span>
    }

    /**
     * {{@inheritDoc}}
     */
    public boolean contains(int x, int y) {
<span class="fc" id="L1557">        return contains((float) x, (float) y);</span>
    }

    /**
     * @param path
     * @param cx
     * @param cy
     * @param startX
     * @param startY
     * @param endX
     * @param endY
     * @param clockwise
     */
//    private static void addBezierArcToPath(GeneralPath path, double cx, double cy,
//                                          double startX, double startY, double endX, double endY, boolean clockwise) {
//        if ( startX != endX || startY != endY ){
//            double ax = startX - cx;
//            double ay = startY - cy;
//            double bx = endX - cx;
//            double by = endY- cy;
//
//            final double r1s = ax * ax + ay * ay;
//            final double r2s = bx * bx + by * by;
//            double ellipseScaleY = 0;
//            if (Math.abs(r1s - r2s) &gt; 2) {
//                // This is not a circle
//                // Let's get the arc for the circle
//                ellipseScaleY = Math.sqrt(((ax*ax) - (bx*bx)) / (by*by - ay*ay));
//                startY = cy + ellipseScaleY * (startY-cy);
//                endY = cy + ellipseScaleY * (endY-cy);
//
//                ay = startY - cy;
//                by = endY - cy;
//            } else {
//                double startAngle = MathUtil.atan2(ay, ax);
//                double endAngle = MathUtil.atan2(by, bx);
//
//                double dist = Math.abs(endAngle - startAngle);
//                if (clockwise) {
//                    if (startAngle &gt; endAngle) {
//                        dist = Math.PI*2-dist;
//                    }
//                } else {
//                    if (startAngle &lt; endAngle) {
//                        dist = Math.PI*2-dist;
//                    }
//                }
//
//                //System.out.println(&quot;dist: &quot;+dist+&quot; startAngle: &quot;+startAngle+&quot; endAngle: &quot;+endAngle);
//                if (dist &gt; Math.PI/3) {
//                    // We bisect
//                    double r = Math.sqrt(r1s);
//                    double bisectAngle = (startAngle + endAngle)/2;
//                    if (clockwise) {
//                        if (startAngle &gt; endAngle) {
//                            bisectAngle += Math.PI;
//                        }
//                    } else {
//                        if (startAngle &lt; endAngle) {
//                            bisectAngle += Math.PI;
//                        }
//                    }
//                    double bisectX = cx + r * Math.cos(bisectAngle);
//                    double bisectY = cy + r * Math.sin(bisectAngle);
//                    addBezierArcToPath(path, cx, cy, startX, startY, bisectX, bisectY, clockwise);
//                    addBezierArcToPath(path, cx, cy, bisectX, bisectY, endX, endY, clockwise);
//                    return;
//                }
//
//
//            }
//
//            final double q1 = r1s;//ax * ax + ay * ay;
//            final double q2 = q1 + ax * bx + ay * by;
//            final double k2 = 4d / 3d * (Math.sqrt(2d * q1 * q2) - q2) / (ax * by - ay * bx);
//            final float x2 = (float)(cx + ax - k2 * ay);
//            float y2 = (float)(cy + ay + k2 * ax);
//            final float x3 = (float)(cx + bx + k2 * by);
//             float y3 = (float)(cy + by - k2 * bx);
//            if (ellipseScaleY != 0) {
//                y2 = (float)(cy + (y2-cy)/ellipseScaleY);
//                y3 = (float)(cy + (y3-cy)/ellipseScaleY);
//                endY = (float)(cy + (endY-cy)/ellipseScaleY);
//            }
//            path.curveTo(x2, y2, x3, y3, endX, endY);
//
//        }
//    }


<span class="fc" id="L1647">    static class Ellipse {</span>
        private double a;
        private double b;
        private double cx;
        private double cy;
<span class="fc" id="L1652">        private final EPoint _tmp1 = new EPoint();</span>

        static void initWithBounds(Ellipse e, double x, double y, double w, double h) {
<span class="fc" id="L1655">            e.cx = x + w / 2;</span>
<span class="fc" id="L1656">            e.cy = y + h / 2;</span>
<span class="fc" id="L1657">            e.a = w / 2;</span>
<span class="fc" id="L1658">            e.b = h / 2;</span>
<span class="fc" id="L1659">        }</span>

        static void initWithPerimeterPoints(Ellipse e, double cx, double cy, double p1x, double p1y, double p2x, double p2y) {

            /*
            e.cx = cx;
            e.cy = cy;
            double x1 = p1x-cx;
            double y1 = p1y-cy;
            double x2 = p2x-cx;
            double y2 = p2y-cy;
            double x1s = x1*x1;
            double x2s = x2*x2;
            double y1s = y1*y1;
            double y2s = y2*y2;
            if (Math.abs(x1s-x2s) &lt; 0.001 ||Math.abs(y1s-y2s) &lt; 0.001) {
                a = b = Math.max(Math.sqrt(Math.abs(y2)));
            }
            if (Math.abs(x1s-x2s) &gt; 0.001) {
                e.b = Math.sqrt((x1s*y2s-x2s-y1s)/(x1s-x2s));
                double bs = e.b*e.b;
                e.a = Math.sqrt(x1s*bs/(bs-y1s));
            } else {
                e.a = Math.sqrt((y1s*x2s-y2s-x1s)/(y1s-y2s));
                double as = e.a*e.a;
                e.b = Math.sqrt(y1s*as/(as-x1s));
            }
            */

<span class="nc" id="L1688">        }</span>

        @Override
        public String toString() {

<span class="nc" id="L1693">            return &quot;Ellipse center=(&quot; + cx + &quot;,&quot; + cy + &quot;) a=&quot; + a + &quot;, b=&quot; + b + &quot;)&quot;;</span>
        }

        void getPointAtAngle(double theta, EPoint out) {
<span class="fc" id="L1697">            double tanTheta = Math.tan(theta);</span>
<span class="fc" id="L1698">            double tanThetas = tanTheta * tanTheta;</span>
<span class="fc" id="L1699">            double bs = b * b;</span>
<span class="fc" id="L1700">            double as = a * a;</span>
<span class="fc" id="L1701">            double x = a * b / Math.sqrt(bs + as * tanThetas);</span>
<span class="fc bfc" id="L1702" title="All 2 branches covered.">            if (Math.cos(theta) &lt; 0) {</span>
<span class="fc" id="L1703">                x = -x;</span>
            }
<span class="fc" id="L1705">            double y = a * b / Math.sqrt(as + bs / tanThetas);</span>
<span class="fc bfc" id="L1706" title="All 2 branches covered.">            if (Math.sin(theta) &lt; 0) {</span>
<span class="fc" id="L1707">                y = -y;</span>
            }
<span class="fc" id="L1709">            out.x = x + cx;</span>
<span class="fc" id="L1710">            out.y = y + cy;</span>
<span class="fc" id="L1711">        }</span>

        double getAngleAtPoint(double px, double py) {
<span class="fc" id="L1714">            px -= cx;</span>
<span class="fc" id="L1715">            py -= cy;</span>

<span class="fc" id="L1717">            return MathUtil.atan2(py, px);</span>
        }

        void addToPath(GeneralPath p, double startAngle, double sweepAngle, boolean join) {
<span class="fc" id="L1721">            getPointAtAngle(startAngle, _tmp1);</span>
<span class="fc bfc" id="L1722" title="All 2 branches covered.">            if (join) {</span>

<span class="fc" id="L1724">                p.lineTo(_tmp1.x, _tmp1.y);</span>
            } else {
<span class="fc" id="L1726">                p.moveTo(_tmp1.x, _tmp1.y);</span>
            }
<span class="fc" id="L1728">            _addToPath(p, startAngle, sweepAngle);</span>
<span class="pc bpc" id="L1729" title="1 of 4 branches missed.">            if (!join &amp;&amp; Math.abs(Math.abs(sweepAngle) - Math.PI * 2) &lt; 0.001) {</span>
<span class="fc" id="L1730">                p.closePath();</span>
            }
<span class="fc" id="L1732">        }</span>

        private void _addToPath(GeneralPath p, double startAngle, double sweepAngle) {
            //double _2pi = Math.PI*2;
<span class="fc" id="L1736">            double absSweepAngle = Math.abs(sweepAngle);</span>
<span class="fc bfc" id="L1737" title="All 2 branches covered.">            if (absSweepAngle &lt; 0.0001) {</span>
                // Basically zero sweep angle so we won't draw anytything here.
                // IOS seemed to choke when we tried to draw too small an arc
<span class="fc" id="L1740">                return;</span>
            }
<span class="fc bfc" id="L1742" title="All 2 branches covered.">            if (absSweepAngle &gt; Math.PI / 4) {</span>
                //double halfAngle = sweepAngle/2;
<span class="fc" id="L1744">                double diff = Math.PI / 4;</span>
<span class="fc bfc" id="L1745" title="All 2 branches covered.">                if (sweepAngle &lt; 0) {</span>
<span class="fc" id="L1746">                    diff = -diff;</span>
                }
<span class="fc" id="L1748">                _addToPath(p, startAngle, diff);</span>
<span class="fc" id="L1749">                _addToPath(p, startAngle + diff, sweepAngle - diff);</span>
<span class="fc" id="L1750">            } else {</span>
<span class="fc" id="L1751">                getPointAtAngle(startAngle + sweepAngle, _tmp1);</span>
                //System.out.println(&quot;Line to &quot;+_tmp1.x+&quot;, &quot;+_tmp1.y);
<span class="fc" id="L1753">                EPoint controlPoint = new EPoint();</span>
<span class="fc" id="L1754">                calculateBezierControlPoint(startAngle, sweepAngle, controlPoint);</span>
<span class="fc" id="L1755">                p.quadTo(controlPoint.x, controlPoint.y, _tmp1.x, _tmp1.y);</span>
                //p.lineTo(_tmp1.x, _tmp1.y);
            }
<span class="fc" id="L1758">        }</span>

        private void calculateBezierControlPoint(double startAngle, double sweepAngle, EPoint point) {
<span class="fc" id="L1761">            EPoint p1 = new EPoint();</span>

<span class="fc" id="L1763">            getPointAtAngle(startAngle, p1);</span>
<span class="fc" id="L1764">            p1.x -= cx;</span>
<span class="fc" id="L1765">            p1.y -= cy;</span>

<span class="fc" id="L1767">            EPoint p2 = new EPoint();</span>
<span class="fc" id="L1768">            getPointAtAngle(startAngle + sweepAngle, p2);</span>
<span class="fc" id="L1769">            p2.x -= cx;</span>
<span class="fc" id="L1770">            p2.y -= cy;</span>

            //System.out.println(&quot;p1: &quot;+p1.x+&quot;, &quot;+p1.y+&quot;, p2:&quot;+p2.x+&quot;,&quot;+p2.y);
<span class="fc" id="L1773">            double x1s = p1.x * p1.x;</span>
<span class="fc" id="L1774">            double y1s = p1.y * p1.y;</span>
<span class="fc" id="L1775">            double x2s = p2.x * p2.x;</span>
<span class="fc" id="L1776">            double y2s = p2.y * p2.y;</span>

<span class="fc" id="L1778">            double as = a * a;</span>
<span class="fc" id="L1779">            double bs = b * b;</span>
            //point.x = (x2s*bs/(p2.y*as) + p2.y - x1s*bs/(p1.y*as) - p1.y) / (-p1.x*bs/(p1.y*as) + p2.x*bs/(p2.y*as));
            //point.y = (-p1.x*bs/(p1.y*as))*point.x + x1s*bs/(p1.y*as) + p1.y;


<span class="fc" id="L1784">            point.x = -(p1.y * (-as * y2s - bs * x2s) + as * y1s * p2.y + bs * x1s * p2.y) / (bs * p2.x * p1.y - bs * p1.x * p2.y);</span>
<span class="fc" id="L1785">            point.y = (p1.x * (-as * y2s - bs * x2s) + as * p2.x * y1s + bs * x1s * p2.x) / (as * p2.x * p1.y - as * p1.x * p2.y);</span>

<span class="fc" id="L1787">            point.x += cx;</span>
<span class="fc" id="L1788">            point.y += cy;</span>
            //System.out.println(&quot;control: &quot;+point.x+&quot;,&quot;+point.y);
<span class="fc" id="L1790">        }</span>


    }

<span class="fc" id="L1795">    static class EPoint {</span>
        double x;
        double y;
    }

    /**
     * @author shannah
     */
<span class="nc" id="L1803">    static class ShapeUtil {</span>


        /**
         * Rectangle cross segment
         */
        public static final int CROSSING = 255;
        /**
         * Allowable tolerance for bounds comparison
         */
        static final double DELTA = 1E-5;
        /**
         * If roots have distance less then &lt;code&gt;ROOT_DELTA&lt;/code&gt; they are double
         */
        static final double ROOT_DELTA = 1E-10;
        /**
         * Unknown crossing result
         */
        static final int UNKNOWN = 254;

        /**
         * Generates the intersection of a given shape and a given rectangle.  Only supported convex polygons.
         *
         * @param r A rectangle.
         * @param s A shape
         * @return The shape that is the intersected area of the shape and
         * rectangle.
         */
        static Shape intersection(Rectangle r, Shape s) {
<span class="nc" id="L1832">            return intersection(r, s, new GeneralPath());</span>
        }

        private static Shape intersection(Rectangle r, Shape s, GeneralPath out) {
<span class="pc bpc" id="L1836" title="2 of 4 branches missed.">            if (r.getWidth() == 0 || r.getHeight() == 0) {</span>
<span class="nc" id="L1837">                out.setRect(r, null);</span>
<span class="nc" id="L1838">                return out;</span>
            }
<span class="fc" id="L1840">            Rectangle2D rect2D = null;</span>
<span class="fc" id="L1841">            Shape segmentedShape = segmentShape(r, s);</span>
<span class="fc" id="L1842">            Iterator it = createIteratorFromPool((GeneralPath) segmentedShape, null);</span>
            //GeneralPath out = new GeneralPath();
<span class="fc" id="L1844">            float[] buf = createFloatArrayFromPool(6);//new float[6];</span>
            try {
<span class="fc" id="L1846">                boolean started = false;</span>
<span class="fc" id="L1847">                float x1 = r.getX();</span>
<span class="fc" id="L1848">                float x2 = r.getX() + r.getWidth();</span>
<span class="fc" id="L1849">                float y1 = r.getY();</span>
<span class="fc" id="L1850">                float y2 = r.getY() + r.getHeight();</span>

<span class="fc" id="L1852">                float minX = -1;</span>
<span class="fc" id="L1853">                float minY = -1;</span>
<span class="fc" id="L1854">                float maxX = -1;</span>
<span class="fc" id="L1855">                float maxY = -1;</span>

<span class="fc" id="L1857">                float prevX = 0;</span>
<span class="fc" id="L1858">                float prevY = 0;</span>
<span class="fc" id="L1859">                double origPrevX = 0;</span>
<span class="fc" id="L1860">                double origPrevY = 0;</span>
<span class="fc" id="L1861">                BezierCurve curve = null;</span>

<span class="fc" id="L1863">                double epsilon = 0.01;</span>

<span class="fc bfc" id="L1865" title="All 2 branches covered.">                while (!it.isDone()) {</span>
<span class="fc" id="L1866">                    int type = it.currentSegment(buf);</span>

<span class="pc bpc" id="L1868" title="2 of 4 branches missed.">                    switch (type) {</span>

                        case PathIterator.SEG_CLOSE:
                            //System.out.println(&quot;Closing path&quot;);
<span class="fc" id="L1872">                            out.closePath();</span>
<span class="fc" id="L1873">                            break;</span>
                        case PathIterator.SEG_CUBICTO:
                        case PathIterator.SEG_QUADTO:
<span class="nc bnc" id="L1876" title="All 2 branches missed.">                            if (rect2D == null) {</span>
<span class="nc" id="L1877">                                rect2D = new Rectangle2D(r.getX(), r.getY(), r.getWidth(), r.getHeight());</span>
                            }
<span class="nc bnc" id="L1879" title="All 2 branches missed.">                            curve = type == PathIterator.SEG_QUADTO ? new BezierCurve(origPrevX, origPrevY, buf[0], buf[1], buf[2], buf[3]) :</span>
                                    new BezierCurve(origPrevX, origPrevY, buf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);
                            //Point2D curveStart = curve.getStartPoint();
<span class="nc" id="L1882">                            Point2D curveEnd = curve.getEndPoint();</span>
<span class="nc" id="L1883">                            Rectangle2D boundingRect = curve.getBoundingRect();</span>
<span class="nc bnc" id="L1884" title="All 4 branches missed.">                            if (!started || (boundingRect.getX() &lt; minX)) {</span>
<span class="nc" id="L1885">                                minX = (float) boundingRect.getX();</span>
                            }
<span class="nc bnc" id="L1887" title="All 4 branches missed.">                            if (!started || (boundingRect.getX() + boundingRect.getWidth() &gt; maxX)) {</span>
<span class="nc" id="L1888">                                maxX = (float) (boundingRect.getX() + boundingRect.getWidth());</span>
                            }

<span class="nc bnc" id="L1891" title="All 4 branches missed.">                            if (!started || (boundingRect.getY() &lt; minY)) {</span>
<span class="nc" id="L1892">                                minY = (float) (boundingRect.getY());</span>
                            }
<span class="nc bnc" id="L1894" title="All 4 branches missed.">                            if (!started || (boundingRect.getY() + boundingRect.getHeight() &gt; maxY)) {</span>
<span class="nc" id="L1895">                                maxY = (float) (boundingRect.getY() + boundingRect.getHeight());</span>
                            }
<span class="nc bnc" id="L1897" title="All 2 branches missed.">                            if (rect2D.contains(curve.x(0.5), curve.y(0.5))) {</span>
                                // It is fully inside, we can just add it to the out path
<span class="nc" id="L1899">                                curve.addToPath(out, false);</span>
<span class="nc" id="L1900">                                prevX = (float) curveEnd.getX();</span>
<span class="nc" id="L1901">                                prevY = (float) curveEnd.getY();</span>
<span class="nc" id="L1902">                                origPrevX = curveEnd.getX();</span>
<span class="nc" id="L1903">                                origPrevY = curveEnd.getY();</span>
<span class="nc" id="L1904">                                started = true;</span>
                            } else {
                                // It is fully outside.
                                // We will simply draw a line on the edge of the rectangle
                                // border

                                // Store end point of shadow lines into (buf[0], buf[1])
<span class="nc bnc" id="L1911" title="All 2 branches missed.">                                if (curveEnd.getX() &lt; x1) {</span>
<span class="nc" id="L1912">                                    buf[0] = x1;</span>
<span class="nc bnc" id="L1913" title="All 2 branches missed.">                                } else if (curveEnd.getX() &gt; x2) {</span>
<span class="nc" id="L1914">                                    buf[0] = x2;</span>
                                } else {
<span class="nc" id="L1916">                                    buf[0] = (float) curveEnd.getX();</span>
                                }
<span class="nc bnc" id="L1918" title="All 2 branches missed.">                                if (curveEnd.getY() &lt; y1) {</span>
<span class="nc" id="L1919">                                    buf[1] = y1;</span>
<span class="nc bnc" id="L1920" title="All 2 branches missed.">                                } else if (curveEnd.getY() &gt; y2) {</span>
<span class="nc" id="L1921">                                    buf[1] = y2;</span>
                                } else {
<span class="nc" id="L1923">                                    buf[1] = (float) curveEnd.getY();</span>
                                }

                                // Since the curve was segmented on the rect, the starting point
                                // of the curve must also be on the edge of the rectangle.

<span class="nc bnc" id="L1929" title="All 4 branches missed.">                                if (Math.abs(buf[0] - prevX) &lt; epsilon || Math.abs(buf[1] - prevY) &lt; epsilon) {</span>
                                    // Same edge.. we can just do a single line
<span class="nc" id="L1931">                                    out.lineTo(buf[0], buf[1]);</span>
                                } else {
                                    // Different edge.  We can't do a single line.
<span class="nc bnc" id="L1934" title="All 2 branches missed.">                                    if (Math.abs(buf[0] - x1) &lt; epsilon) {</span>
<span class="nc" id="L1935">                                        out.lineTo(x1, prevY);</span>
<span class="nc" id="L1936">                                        out.lineTo(buf[0], buf[1]);</span>
<span class="nc bnc" id="L1937" title="All 2 branches missed.">                                    } else if (Math.abs(buf[0] - x2) &lt; epsilon) {</span>
<span class="nc" id="L1938">                                        out.lineTo(x2, prevY);</span>
<span class="nc" id="L1939">                                        out.lineTo(buf[0], buf[1]);</span>
<span class="nc bnc" id="L1940" title="All 2 branches missed.">                                    } else if (Math.abs(buf[1] - y1) &lt; epsilon) {</span>
<span class="nc" id="L1941">                                        out.lineTo(prevX, y1);</span>
<span class="nc" id="L1942">                                        out.lineTo(buf[0], buf[1]);</span>
<span class="nc bnc" id="L1943" title="All 2 branches missed.">                                    } else if (Math.abs(buf[1] - y2) &lt; epsilon) {</span>
<span class="nc" id="L1944">                                        out.lineTo(prevX, y2);</span>
<span class="nc" id="L1945">                                        out.lineTo(buf[0], buf[1]);</span>
                                    } else {
<span class="nc" id="L1947">                                        Log.p(&quot;buf=&quot; + Arrays.toString(buf));</span>
<span class="nc" id="L1948">                                        Log.p(&quot;Curve: &quot; + curve);</span>
<span class="nc" id="L1949">                                        Log.p(&quot;Rect: &quot; + rect2D);</span>
<span class="nc" id="L1950">                                        Log.p(&quot;type: &quot; + type);</span>
<span class="nc" id="L1951">                                        throw new RuntimeException(&quot;Unexpected shape segmentation on curve-&quot;);</span>
                                    }

                                }

<span class="nc" id="L1956">                                prevX = buf[0];</span>
<span class="nc" id="L1957">                                prevY = buf[1];</span>
<span class="nc" id="L1958">                                origPrevX = curveEnd.getX();</span>
<span class="nc" id="L1959">                                origPrevY = curveEnd.getY();</span>
<span class="nc" id="L1960">                                started = true;</span>

                            }


<span class="nc" id="L1965">                            break;</span>
                        case PathIterator.SEG_MOVETO:
                        case PathIterator.SEG_LINETO:
<span class="fc" id="L1968">                            origPrevX = buf[0];</span>
<span class="fc" id="L1969">                            origPrevY = buf[1];</span>
<span class="fc bfc" id="L1970" title="All 2 branches covered.">                            if (buf[0] &lt; x1) {</span>
<span class="fc" id="L1971">                                buf[0] = x1;</span>
<span class="pc bpc" id="L1972" title="1 of 2 branches missed.">                            } else if (buf[0] &gt; x2) {</span>
<span class="nc" id="L1973">                                buf[0] = x2;</span>
                            }
<span class="fc bfc" id="L1975" title="All 2 branches covered.">                            if (buf[1] &lt; y1) {</span>
<span class="fc" id="L1976">                                buf[1] = y1;</span>
<span class="pc bpc" id="L1977" title="1 of 2 branches missed.">                            } else if (buf[1] &gt; y2) {</span>
<span class="nc" id="L1978">                                buf[1] = y2;</span>
                            }

<span class="pc bpc" id="L1981" title="1 of 4 branches missed.">                            if (!started || (buf[0] &lt; minX)) {</span>
<span class="fc" id="L1982">                                minX = buf[0];</span>
                            }
<span class="fc bfc" id="L1984" title="All 4 branches covered.">                            if (!started || (buf[0] &gt; maxX)) {</span>
<span class="fc" id="L1985">                                maxX = buf[0];</span>
                            }

<span class="pc bpc" id="L1988" title="1 of 4 branches missed.">                            if (!started || (buf[1] &lt; minY)) {</span>
<span class="fc" id="L1989">                                minY = buf[1];</span>
                            }
<span class="fc bfc" id="L1991" title="All 4 branches covered.">                            if (!started || (buf[1] &gt; maxY)) {</span>
<span class="fc" id="L1992">                                maxY = buf[1];</span>
                            }

<span class="fc bfc" id="L1995" title="All 2 branches covered.">                            if (type == PathIterator.SEG_MOVETO) {</span>

                                //System.out.println(&quot;Moving to &quot;+buf[0]+&quot;,&quot;+buf[1]);
<span class="fc" id="L1998">                                out.moveTo(buf[0], buf[1]);</span>
                            } else { // type == PathITerator.SEG_LINETO

<span class="fc bfc" id="L2001" title="All 4 branches covered.">                                if (prevX != buf[0] || prevY != buf[1]) {</span>
                                    //System.out.println(&quot;Line to &quot;+buf[0]+&quot;,&quot;+buf[1]);
<span class="fc" id="L2003">                                    out.lineTo(buf[0], buf[1]);</span>
                                }
                            }
<span class="fc" id="L2006">                            prevX = buf[0];</span>
<span class="fc" id="L2007">                            prevY = buf[1];</span>
<span class="fc" id="L2008">                            started = true;</span>
                            //count++;
<span class="fc" id="L2010">                            break;</span>
                        default:
<span class="nc" id="L2012">                            throw new RuntimeException(&quot;Unsupported segment type for intersection &quot; + type);</span>
                    }
<span class="fc" id="L2014">                    it.next();</span>

<span class="fc" id="L2016">                }</span>

<span class="pc bpc" id="L2018" title="1 of 4 branches missed.">                if (maxX - minX &lt;= 1f || maxY - minY &lt;= 1f) {</span>
<span class="fc" id="L2019">                    return null;</span>
                }

<span class="fc" id="L2022">                return out;</span>
            } finally {
<span class="fc" id="L2024">                recycle(it);</span>
<span class="fc" id="L2025">                recycle(buf);</span>
            }

        }

        /**
         * Segments a given shape so that all points of the shape that intersect the
         * provided rectangle edges are nodes of the shape path. This operation
         * makes it easier to form the intersection.
         * &lt;p&gt;
         * Only supports convex polygons.
         *
         * @param r A rectangle.
         * @param s A shape
         * @return A shape that is identical to the input shape except that it may
         * include additional path segments so that all points of intersection are
         * start/end points of a segment.
         */
        static Shape segmentShape(Rectangle r, Shape s) {
<span class="fc" id="L2044">            return segmentShape(r, s, new GeneralPath());</span>
        }

        private static GeneralPath segmentShape(Rectangle r, Shape s, GeneralPath out) {
<span class="fc" id="L2048">            Rectangle2D rect2D = null;</span>
<span class="fc" id="L2049">            java.util.List&lt;BezierCurve&gt; curveSegments = null;</span>
<span class="fc" id="L2050">            BezierCurve curve = null;</span>
<span class="fc" id="L2051">            GeneralPath tmpGeneralPath = null;</span>
<span class="pc bpc" id="L2052" title="1 of 2 branches missed.">            if (s.getClass() != GeneralPath.class) {</span>
<span class="nc" id="L2053">                tmpGeneralPath = createPathFromPool();</span>
<span class="nc" id="L2054">                tmpGeneralPath.setShape(s, null);</span>
<span class="nc" id="L2055">                s = tmpGeneralPath;</span>
            }
<span class="fc" id="L2057">            float[] tmp = null;</span>
<span class="fc" id="L2058">            Iterator it = createIteratorFromPool((GeneralPath) s, null);</span>
            //GeneralPath out = new GeneralPath();
<span class="fc" id="L2060">            float[] buf = createFloatArrayFromPool(6); // buffer to hold segment coordinates from PathIterator.currentSegment</span>
<span class="fc" id="L2061">            float[] curr = createFloatArrayFromPool(2);    // Placeholder for current point</span>
<span class="fc" id="L2062">            float[] prev = createFloatArrayFromPool(2);   // Placeholder for previous point</span>
<span class="fc" id="L2063">            float[] mark = createFloatArrayFromPool(2);   // Placeholder for the moveTo point</span>
            //float[] buf4 = new float[4];    // Reusable buffer to hold two points.
<span class="fc" id="L2065">            float[] intersects = createFloatArrayFromPool(9);</span>
            try {
<span class="fc" id="L2067">                float prevX = -1;               // Placeholder for previous X coord.</span>
<span class="fc" id="L2068">                float prevY = -1;               // Placeholder for previous Y coord.</span>
<span class="fc" id="L2069">                float currX = 0;                // Placeholder for current X coord.</span>
<span class="fc" id="L2070">                float currY = 0;                // Placeholder for current Y coord.</span>
                //float[] intersects = null;      // Placeholder for intersection points
<span class="fc bfc" id="L2072" title="All 2 branches covered.">                while (!it.isDone()) {</span>

<span class="fc" id="L2074">                    int type = it.currentSegment(buf);</span>
<span class="pc bpc" id="L2075" title="3 of 6 branches missed.">                    switch (type) {</span>

                        case PathIterator.SEG_MOVETO:
                            // Move to segment is transferred straight through
<span class="fc" id="L2079">                            prevX = prev[0] = mark[0] = buf[0];</span>
<span class="fc" id="L2080">                            prevY = prev[1] = mark[1] = buf[1];</span>
<span class="fc" id="L2081">                            out.moveTo(prevX, prevY);</span>

                            //System.out.println(&quot;Moving to &quot;+prevX+&quot;,&quot;+prevY);
<span class="fc" id="L2084">                            break;</span>

                        case PathIterator.SEG_QUADTO:
<span class="nc bnc" id="L2087" title="All 2 branches missed.">                            if (rect2D == null) {</span>
<span class="nc" id="L2088">                                rect2D = new Rectangle2D(r.getX(), r.getY(), r.getWidth(), r.getHeight());</span>
                            }
<span class="nc" id="L2090">                            currX = curr[0] = buf[2];</span>
<span class="nc" id="L2091">                            currY = curr[1] = buf[3];</span>
<span class="nc" id="L2092">                            curve = new BezierCurve(prevX, prevY, buf[0], buf[1], currX, currY);</span>
<span class="nc bnc" id="L2093" title="All 2 branches missed.">                            if (curveSegments == null) {</span>
<span class="nc" id="L2094">                                curveSegments = new ArrayList&lt;BezierCurve&gt;();</span>
                            } else {
<span class="nc" id="L2096">                                curveSegments.clear();</span>
                            }
<span class="nc" id="L2098">                            curve.segment(rect2D, curveSegments);</span>
<span class="nc bnc" id="L2099" title="All 2 branches missed.">                            for (BezierCurve segment : curveSegments) {</span>
<span class="nc" id="L2100">                                segment.addToPath(out, true);</span>
<span class="nc" id="L2101">                            }</span>
<span class="nc" id="L2102">                            prevX = currX;</span>
<span class="nc" id="L2103">                            prevY = currY;</span>
<span class="nc" id="L2104">                            tmp = curr;</span>
<span class="nc" id="L2105">                            curr = prev;</span>
<span class="nc" id="L2106">                            prev = tmp;</span>

<span class="nc" id="L2108">                            break;</span>
                        case PathIterator.SEG_CUBICTO:
<span class="nc bnc" id="L2110" title="All 2 branches missed.">                            if (rect2D == null) {</span>
<span class="nc" id="L2111">                                rect2D = new Rectangle2D(r.getX(), r.getY(), r.getWidth(), r.getHeight());</span>
                            }
<span class="nc" id="L2113">                            currX = curr[0] = buf[4];</span>
<span class="nc" id="L2114">                            currY = curr[1] = buf[5];</span>
<span class="nc" id="L2115">                            curve = new BezierCurve(prevX, prevY, buf[0], buf[1], buf[2], buf[3], currX, currY);</span>
<span class="nc bnc" id="L2116" title="All 2 branches missed.">                            if (curveSegments == null) {</span>
<span class="nc" id="L2117">                                curveSegments = new ArrayList&lt;BezierCurve&gt;();</span>
                            } else {
<span class="nc" id="L2119">                                curveSegments.clear();</span>
                            }
<span class="nc" id="L2121">                            curve.segment(rect2D, curveSegments);</span>
<span class="nc bnc" id="L2122" title="All 2 branches missed.">                            for (BezierCurve segment : curveSegments) {</span>
<span class="nc" id="L2123">                                segment.addToPath(out, true);</span>
<span class="nc" id="L2124">                            }</span>
                            // Set current position to prev for next iteration.
<span class="nc" id="L2126">                            prevX = currX;</span>
<span class="nc" id="L2127">                            prevY = currY;</span>
<span class="nc" id="L2128">                            tmp = curr;</span>
<span class="nc" id="L2129">                            curr = prev;</span>
<span class="nc" id="L2130">                            prev = tmp;</span>
<span class="nc" id="L2131">                            break;</span>
                        case PathIterator.SEG_LINETO:
                            // Line Segment may need to be partitioned if it crosses
                            // an edge of the rectangle.
<span class="fc" id="L2135">                            currX = curr[0] = buf[0];</span>
<span class="fc" id="L2136">                            currY = curr[1] = buf[1];</span>

                            // Check if line intersects rectangle
<span class="fc" id="L2139">                            intersectLineWithRectAsHash(prevX, prevY, currX, currY, r, intersects);</span>
                            //System.out.println(&quot;Looking for intersections between &quot;+prevX+&quot;,&quot;+prevY+&quot; and &quot;+currX+&quot;,&quot;+currY);
                            //System.out.println(&quot;Intersects: &quot;+intersects[0]+&quot;, &quot;+intersects[1]+&quot;  &quot;+intersects[2]+&quot;,&quot;+intersects[3]);
<span class="fc bfc" id="L2142" title="All 2 branches covered.">                            if (intersects[8] &gt;= 1) {</span>
<span class="fc" id="L2143">                                int num = (int) intersects[8];</span>
<span class="fc" id="L2144">                                int len = num * 2;</span>
<span class="fc bfc" id="L2145" title="All 2 branches covered.">                                for (int i = 0; i &lt; len; i += 2) {</span>
<span class="fc" id="L2146">                                    out.lineTo(intersects[i], intersects[i + 1]);</span>

                                }

                            }
                            //System.out.println(&quot;Line to &quot;+currX+&quot;,&quot;+currY);
<span class="fc" id="L2152">                            out.lineTo(currX, currY);</span>

                            // Set current position to prev for next iteration.
<span class="fc" id="L2155">                            prevX = currX;</span>
<span class="fc" id="L2156">                            prevY = currY;</span>
<span class="fc" id="L2157">                            tmp = curr;</span>
<span class="fc" id="L2158">                            curr = prev;</span>
<span class="fc" id="L2159">                            prev = tmp;</span>

<span class="fc" id="L2161">                            break;</span>
                        case PathIterator.SEG_CLOSE:

                            // Closing the path.  Need to check if there is an intersection
                            // on this last closing path.
<span class="fc" id="L2166">                            currX = curr[0] = mark[0];</span>
<span class="fc" id="L2167">                            currY = curr[1] = mark[1];</span>
<span class="fc" id="L2168">                            intersectLineWithRectAsHash(prevX, prevY, currX, currY, r, intersects);</span>
<span class="fc bfc" id="L2169" title="All 2 branches covered.">                            if (intersects[8] &gt;= 1) {</span>
<span class="fc" id="L2170">                                int num = (int) intersects[8];</span>
<span class="fc" id="L2171">                                int len = num * 2;</span>
<span class="fc bfc" id="L2172" title="All 2 branches covered.">                                for (int i = 0; i &lt; len; i += 2) {</span>
<span class="fc" id="L2173">                                    out.lineTo(intersects[i], intersects[i + 1]);</span>

                                }

                            }
<span class="fc" id="L2178">                            out.closePath();</span>

<span class="fc" id="L2180">                            break;</span>
                        default:
<span class="nc" id="L2182">                            throw new RuntimeException(&quot;Unsupported path segment type: &quot; + type);</span>
                    }
<span class="fc" id="L2184">                    it.next();</span>
<span class="fc" id="L2185">                }</span>
<span class="fc" id="L2186">                return out;</span>
            } finally {
<span class="fc" id="L2188">                recycle(it);</span>
<span class="fc" id="L2189">                recycle(buf);</span>
<span class="fc" id="L2190">                recycle(curr);</span>
<span class="fc" id="L2191">                recycle(prev);</span>
<span class="fc" id="L2192">                recycle(mark);</span>
<span class="fc" id="L2193">                recycle(intersects);</span>
<span class="fc" id="L2194">                recycle(tmpGeneralPath);</span>
            }
        }

        private static float[] intersectLineWithRectAsHash(float x1, float y1, float x2, float y2, Rectangle rect,
                                                           float[] out
        ) {
            //float[] out = new float[9]; // max 4 points here
<span class="fc" id="L2202">            float[] x = createFloatArrayFromPool(4);</span>
            try {
                //float[] y = new float[4];
<span class="fc" id="L2205">                float rx1 = rect.getX();</span>
<span class="fc" id="L2206">                float ry1 = rect.getY();</span>
<span class="fc" id="L2207">                float rx2 = rect.getX() + rect.getWidth();</span>
<span class="fc" id="L2208">                float ry2 = rect.getY() + rect.getHeight();</span>

<span class="fc" id="L2210">                float dx = x2 - x1;</span>
<span class="fc" id="L2211">                float dy = y2 - y1;</span>
<span class="fc" id="L2212">                int num = 0;</span>

<span class="fc" id="L2214">                float minY = Math.min(y1, y2);</span>
<span class="fc" id="L2215">                float maxY = Math.max(y1, y2);</span>
<span class="fc" id="L2216">                float minX = Math.min(x1, x2);</span>
<span class="fc" id="L2217">                float maxX = Math.max(x1, x2);</span>
<span class="fc" id="L2218">                int i = 0;</span>
<span class="fc bfc" id="L2219" title="All 2 branches covered.">                if (dx == 0) {</span>
<span class="pc bpc" id="L2220" title="1 of 4 branches missed.">                    if (ry1 &gt; minY &amp;&amp; ry1 &lt; maxY) {</span>
<span class="fc" id="L2221">                        num++;</span>
<span class="fc" id="L2222">                        x[i++] = ry1;</span>
                        //out[i++] = ry1;
                    }
<span class="pc bpc" id="L2225" title="2 of 4 branches missed.">                    if (ry2 &gt; minY &amp;&amp; ry2 &lt; maxY) {</span>
<span class="nc" id="L2226">                        num++;</span>
<span class="nc" id="L2227">                        x[i++] = ry2;</span>
                        //out[i++] = ry2;
                    }

<span class="fc" id="L2231">                    Arrays.sort(x, 0, num);</span>
<span class="fc bfc" id="L2232" title="All 2 branches covered.">                    if (y1 &lt;= y2) {</span>
<span class="fc bfc" id="L2233" title="All 2 branches covered.">                        for (i = 0; i &lt; num; i++) {</span>
<span class="fc" id="L2234">                            int j = 2 * i;</span>
<span class="fc" id="L2235">                            out[j] = x1;</span>
<span class="fc" id="L2236">                            out[j + 1] = x[i];</span>
                        }
                    } else {
<span class="fc bfc" id="L2239" title="All 2 branches covered.">                        for (i = 0; i &lt; num; i++) {</span>
<span class="fc" id="L2240">                            int j = 2 * (num - i - 1);</span>
<span class="fc" id="L2241">                            out[j] = x1;</span>
<span class="fc" id="L2242">                            out[j + 1] = x[i];</span>
                        }
                    }


<span class="fc" id="L2247">                    out[8] = num;</span>


<span class="pc bpc" id="L2250" title="1 of 2 branches missed.">                } else if (dy == 0) {</span>
<span class="pc bpc" id="L2251" title="1 of 4 branches missed.">                    if (rx1 &gt; minX &amp;&amp; rx1 &lt; maxX) {</span>
<span class="fc" id="L2252">                        num++;</span>
<span class="fc" id="L2253">                        x[i++] = rx1;</span>
                        //out[i++] = y1;
                    }
<span class="pc bpc" id="L2256" title="2 of 4 branches missed.">                    if (rx2 &gt; minX &amp;&amp; rx2 &lt; maxX) {</span>
<span class="nc" id="L2257">                        num++;</span>
<span class="nc" id="L2258">                        x[i++] = rx2;</span>
                        //out[i++] = y1;
                    }
<span class="fc" id="L2261">                    Arrays.sort(x, 0, num);</span>
<span class="fc bfc" id="L2262" title="All 2 branches covered.">                    if (x1 &lt;= x2) {</span>
<span class="fc bfc" id="L2263" title="All 2 branches covered.">                        for (i = 0; i &lt; num; i++) {</span>
<span class="fc" id="L2264">                            int j = 2 * i;</span>
<span class="fc" id="L2265">                            out[j] = x[i];</span>
<span class="fc" id="L2266">                            out[j + 1] = y1;</span>
                        }
                    } else {
<span class="fc bfc" id="L2269" title="All 2 branches covered.">                        for (i = 0; i &lt; num; i++) {</span>
<span class="fc" id="L2270">                            int j = 2 * (num - i - 1);</span>
<span class="fc" id="L2271">                            out[j] = x[i];</span>
<span class="fc" id="L2272">                            out[j + 1] = y1;</span>
                        }
                    }
<span class="fc" id="L2275">                    out[8] = num;</span>
                } else {
<span class="nc" id="L2277">                    float m = dy / dx;</span>

<span class="nc bnc" id="L2279" title="All 4 branches missed.">                    if (rx1 &gt; minX &amp;&amp; rx1 &lt; maxX) {</span>
<span class="nc" id="L2280">                        num++;</span>
<span class="nc" id="L2281">                        x[i] = rx1;</span>
                        //y[i] = y1+(rx1-x1)*m;
<span class="nc" id="L2283">                        i++;</span>
                    }
<span class="nc bnc" id="L2285" title="All 4 branches missed.">                    if (rx2 &gt; minX &amp;&amp; rx2 &lt; maxX) {</span>
<span class="nc" id="L2286">                        num++;</span>
<span class="nc" id="L2287">                        x[i] = rx2;</span>
                        //y[i++] = y1+(rx2-x1)*m;
<span class="nc" id="L2289">                        i++;</span>
                    }
<span class="nc bnc" id="L2291" title="All 4 branches missed.">                    if (ry1 &gt; minY &amp;&amp; ry1 &lt; maxY) {</span>
<span class="nc" id="L2292">                        num++;</span>
<span class="nc" id="L2293">                        x[i] = x1 + (ry1 - y1) / m;</span>
                        //out[i++] = ry1;
<span class="nc" id="L2295">                        i++;</span>
                    }
<span class="nc bnc" id="L2297" title="All 4 branches missed.">                    if (ry2 &gt; minY &amp;&amp; ry2 &lt; maxY) {</span>
<span class="nc" id="L2298">                        num++;</span>
<span class="nc" id="L2299">                        x[i] = x1 + (ry2 - y1) / m;</span>
                        //out[i++] = ry2;
<span class="nc" id="L2301">                        i++;</span>
                    }

<span class="nc" id="L2304">                    Arrays.sort(x, 0, num);</span>
<span class="nc bnc" id="L2305" title="All 2 branches missed.">                    if (x1 &lt; x2) {</span>
<span class="nc bnc" id="L2306" title="All 2 branches missed.">                        for (i = 0; i &lt; num; i++) {</span>
<span class="nc" id="L2307">                            int j = 2 * i;</span>
<span class="nc" id="L2308">                            out[j] = x[i];</span>
<span class="nc" id="L2309">                            out[j + 1] = y1 + (x[i] - x1) * m;</span>
                        }
                    } else {
<span class="nc bnc" id="L2312" title="All 2 branches missed.">                        for (i = 0; i &lt; num; i++) {</span>
<span class="nc" id="L2313">                            int j = 2 * (num - i - 1);</span>
<span class="nc" id="L2314">                            out[j] = x[i];</span>
<span class="nc" id="L2315">                            out[j + 1] = y1 + (x[i] - x1) * m;</span>
                        }
                    }
<span class="nc" id="L2318">                    out[8] = num;</span>
                }
<span class="fc" id="L2320">                return out;</span>
            } finally {
<span class="fc" id="L2322">                recycle(x);</span>
            }

        }

        /**
         * Solves quadratic equation
         *
         * @param eqn - the coefficients of the equation
         * @param res - the roots of the equation
         * @return a number of roots
         */
        public static int solveQuad(double[] eqn, double[] res) {
<span class="fc" id="L2335">            double a = eqn[2];</span>
<span class="fc" id="L2336">            double b = eqn[1];</span>
<span class="fc" id="L2337">            double c = eqn[0];</span>
<span class="fc" id="L2338">            int rc = 0;</span>
<span class="fc bfc" id="L2339" title="All 2 branches covered.">            if (a == 0.0) {</span>
<span class="fc bfc" id="L2340" title="All 2 branches covered.">                if (b == 0.0) {</span>
<span class="fc" id="L2341">                    return -1;</span>
                }
<span class="fc" id="L2343">                res[rc++] = -c / b;</span>
            } else {
<span class="fc" id="L2345">                double d = b * b - 4.0 * a * c;</span>
                // d &lt; 0.0
<span class="fc bfc" id="L2347" title="All 2 branches covered.">                if (d &lt; 0.0) {</span>
<span class="fc" id="L2348">                    return 0;</span>
                }
<span class="fc" id="L2350">                d = Math.sqrt(d);</span>
<span class="fc" id="L2351">                res[rc++] = (-b + d) / (a * 2.0);</span>
                // d != 0.0
<span class="fc bfc" id="L2353" title="All 2 branches covered.">                if (d != 0.0) {</span>
<span class="fc" id="L2354">                    res[rc++] = (-b - d) / (a * 2.0);</span>
                }
            }
<span class="fc" id="L2357">            return fixRoots(res, rc);</span>
        }

        /**
         * Solves cubic equation
         *
         * @param eqn - the coefficients of the equation
         * @param res - the roots of the equation
         * @return a number of roots
         */
        public static int solveCubic(double[] eqn, double[] res) {
<span class="nc" id="L2368">            double d = eqn[3];</span>
<span class="nc bnc" id="L2369" title="All 2 branches missed.">            if (d == 0) {</span>
<span class="nc" id="L2370">                return solveQuad(eqn, res);</span>
            }
<span class="nc" id="L2372">            double a = eqn[2] / d;</span>
<span class="nc" id="L2373">            double b = eqn[1] / d;</span>
<span class="nc" id="L2374">            double c = eqn[0] / d;</span>
<span class="nc" id="L2375">            int rc = 0;</span>

<span class="nc" id="L2377">            double Q = (a * a - 3.0 * b) / 9.0;</span>
<span class="nc" id="L2378">            double R = (2.0 * a * a * a - 9.0 * a * b + 27.0 * c) / 54.0;</span>
<span class="nc" id="L2379">            double Q3 = Q * Q * Q;</span>
<span class="nc" id="L2380">            double R2 = R * R;</span>
<span class="nc" id="L2381">            double n = -a / 3.0;</span>

<span class="nc bnc" id="L2383" title="All 2 branches missed.">            if (R2 &lt; Q3) {</span>

<span class="nc" id="L2385">                double t = MathUtil.acos(R / Math.sqrt(Q3)) / 3.0;</span>
<span class="nc" id="L2386">                double p = 2.0 * Math.PI / 3.0;</span>
<span class="nc" id="L2387">                double m = -2.0 * Math.sqrt(Q);</span>
<span class="nc" id="L2388">                res[rc++] = m * Math.cos(t) + n;</span>
<span class="nc" id="L2389">                res[rc++] = m * Math.cos(t + p) + n;</span>
<span class="nc" id="L2390">                res[rc++] = m * Math.cos(t - p) + n;</span>
<span class="nc" id="L2391">            } else {</span>
//          Debug.println(&quot;R2 &gt;= Q3 (&quot; + R2 + &quot;/&quot; + Q3 + &quot;)&quot;);

<span class="nc" id="L2394">                double A = MathUtil.pow(Math.abs(R) + Math.sqrt(R2 - Q3), 1.0 / 3.0);</span>

<span class="nc bnc" id="L2396" title="All 2 branches missed.">                if (R &gt; 0.0) {</span>
<span class="nc" id="L2397">                    A = -A;</span>
                }
//          if (A == 0.0) {
<span class="nc bnc" id="L2400" title="All 4 branches missed.">                if (-ROOT_DELTA &lt; A &amp;&amp; A &lt; ROOT_DELTA) {</span>
<span class="nc" id="L2401">                    res[rc++] = n;</span>
                } else {
<span class="nc" id="L2403">                    double B = Q / A;</span>
<span class="nc" id="L2404">                    res[rc++] = A + B + n;</span>
//              if (R2 == Q3) {
<span class="nc" id="L2406">                    double delta = R2 - Q3;</span>
<span class="nc bnc" id="L2407" title="All 4 branches missed.">                    if (-ROOT_DELTA &lt; delta &amp;&amp; delta &lt; ROOT_DELTA) {</span>
<span class="nc" id="L2408">                        res[rc++] = -(A + B) / 2.0 + n;</span>
                    }
                }

            }
<span class="nc" id="L2413">            return fixRoots(res, rc);</span>
        }

        /**
         * Excludes double roots. Roots are double if they lies enough close with each other.
         *
         * @param res - the roots
         * @param rc  - the roots count
         * @return new roots count
         */
        static int fixRoots(double[] res, int rc) {
<span class="fc" id="L2424">            int tc = 0;</span>
<span class="fc bfc" id="L2425" title="All 2 branches covered.">            for (int i = 0; i &lt; rc; i++) {</span>
                out:
                {
<span class="fc bfc" id="L2428" title="All 2 branches covered.">                    for (int j = i + 1; j &lt; rc; j++) {</span>
<span class="pc bpc" id="L2429" title="1 of 2 branches missed.">                        if (isZero(res[i] - res[j])) {</span>
<span class="nc" id="L2430">                            break out;</span>
                        }
                    }
<span class="fc" id="L2433">                    res[tc++] = res[i];</span>
                }
            }
<span class="fc" id="L2436">            return tc;</span>
        }

        /**
         * Returns how many times ray from point (x,y) cross line.
         */
        public static int crossLine(double x1, double y1, double x2, double y2, double x, double y) {

            // LEFT/RIGHT/UP/EMPTY
<span class="pc bpc" id="L2445" title="2 of 14 branches missed.">            if ((x &lt; x1 &amp;&amp; x &lt; x2) ||</span>
                    (x &gt; x1 &amp;&amp; x &gt; x2) ||
                    (y &gt; y1 &amp;&amp; y &gt; y2) ||
                    (x1 == x2)) {
<span class="fc" id="L2449">                return 0;</span>
            }

            // DOWN
<span class="pc bpc" id="L2453" title="2 of 4 branches missed.">            if (y &lt; y1 &amp;&amp; y &lt; y2) {</span>
            } else {
                // INSIDE
<span class="nc bnc" id="L2456" title="All 2 branches missed.">                if ((y2 - y1) * (x - x1) / (x2 - x1) &lt;= y - y1) {</span>
                    // INSIDE-UP
<span class="nc" id="L2458">                    return 0;</span>
                }
            }

            // START
<span class="pc bpc" id="L2463" title="1 of 2 branches missed.">            if (x == x1) {</span>
<span class="nc bnc" id="L2464" title="All 2 branches missed.">                return x1 &lt; x2 ? 0 : -1;</span>
            }

            // END
<span class="pc bpc" id="L2468" title="1 of 2 branches missed.">            if (x == x2) {</span>
<span class="nc bnc" id="L2469" title="All 2 branches missed.">                return x1 &lt; x2 ? 1 : 0;</span>
            }

            // INSIDE-DOWN
<span class="pc bpc" id="L2473" title="1 of 2 branches missed.">            return x1 &lt; x2 ? 1 : -1;</span>
        }

        /**
         * Returns how many times ray from point (x,y) cross quard curve
         */
        public static int crossQuad(double x1, double y1, double cx, double cy, double x2, double y2, double x, double y) {

            // LEFT/RIGHT/UP/EMPTY
<span class="nc bnc" id="L2482" title="All 22 branches missed.">            if ((x &lt; x1 &amp;&amp; x &lt; cx &amp;&amp; x &lt; x2) ||</span>
                    (x &gt; x1 &amp;&amp; x &gt; cx &amp;&amp; x &gt; x2) ||
                    (y &gt; y1 &amp;&amp; y &gt; cy &amp;&amp; y &gt; y2) ||
                    (x1 == cx &amp;&amp; cx == x2)) {
<span class="nc" id="L2486">                return 0;</span>
            }

            // DOWN
<span class="nc bnc" id="L2490" title="All 10 branches missed.">            if (y &lt; y1 &amp;&amp; y &lt; cy &amp;&amp; y &lt; y2 &amp;&amp; x != x1 &amp;&amp; x != x2) {</span>
<span class="nc bnc" id="L2491" title="All 2 branches missed.">                if (x1 &lt; x2) {</span>
<span class="nc bnc" id="L2492" title="All 4 branches missed.">                    return x1 &lt; x &amp;&amp; x &lt; x2 ? 1 : 0;</span>
                }
<span class="nc bnc" id="L2494" title="All 4 branches missed.">                return x2 &lt; x &amp;&amp; x &lt; x1 ? -1 : 0;</span>
            }

            // INSIDE
<span class="nc" id="L2498">            QuadCurve c = new QuadCurve(x1, y1, cx, cy, x2, y2);</span>
<span class="nc" id="L2499">            double px = x - x1;</span>
<span class="nc" id="L2500">            double py = y - y1;</span>
<span class="nc" id="L2501">            double[] res = new double[3];</span>
<span class="nc" id="L2502">            int rc = c.solvePoint(res, px);</span>

<span class="nc" id="L2504">            return c.cross(res, rc, py, py);</span>
        }

        /**
         * Returns how many times ray from point (x,y) cross cubic curve
         */
        public static int crossCubic(double x1, double y1, double cx1, double cy1, double cx2, double cy2, double x2, double y2, double x, double y) {

            // LEFT/RIGHT/UP/EMPTY
<span class="nc bnc" id="L2513" title="All 30 branches missed.">            if ((x &lt; x1 &amp;&amp; x &lt; cx1 &amp;&amp; x &lt; cx2 &amp;&amp; x &lt; x2) ||</span>
                    (x &gt; x1 &amp;&amp; x &gt; cx1 &amp;&amp; x &gt; cx2 &amp;&amp; x &gt; x2) ||
                    (y &gt; y1 &amp;&amp; y &gt; cy1 &amp;&amp; y &gt; cy2 &amp;&amp; y &gt; y2) ||
                    (x1 == cx1 &amp;&amp; cx1 == cx2 &amp;&amp; cx2 == x2)) {
<span class="nc" id="L2517">                return 0;</span>
            }

            // DOWN
<span class="nc bnc" id="L2521" title="All 12 branches missed.">            if (y &lt; y1 &amp;&amp; y &lt; cy1 &amp;&amp; y &lt; cy2 &amp;&amp; y &lt; y2 &amp;&amp; x != x1 &amp;&amp; x != x2) {</span>
<span class="nc bnc" id="L2522" title="All 2 branches missed.">                if (x1 &lt; x2) {</span>
<span class="nc bnc" id="L2523" title="All 4 branches missed.">                    return x1 &lt; x &amp;&amp; x &lt; x2 ? 1 : 0;</span>
                }
<span class="nc bnc" id="L2525" title="All 4 branches missed.">                return x2 &lt; x &amp;&amp; x &lt; x1 ? -1 : 0;</span>
            }

            // INSIDE
<span class="nc" id="L2529">            CubicCurve c = new CubicCurve(x1, y1, cx1, cy1, cx2, cy2, x2, y2);</span>
<span class="nc" id="L2530">            double px = x - x1;</span>
<span class="nc" id="L2531">            double py = y - y1;</span>
<span class="nc" id="L2532">            double[] res = new double[3];</span>
<span class="nc" id="L2533">            int rc = c.solvePoint(res, px);</span>
<span class="nc" id="L2534">            return c.cross(res, rc, py, py);</span>
        }

        /**
         * Returns how many times ray from point (x,y) cross path
         */
        public static int crossPath(PathIterator p, double x, double y) {
<span class="fc" id="L2541">            int cross = 0;</span>
            double mx, my, cx, cy;
<span class="fc" id="L2543">            mx = my = cx = cy = 0.0;</span>
<span class="fc" id="L2544">            double[] coords = new double[6];</span>

<span class="fc bfc" id="L2546" title="All 2 branches covered.">            while (!p.isDone()) {</span>
<span class="pc bpc" id="L2547" title="3 of 6 branches missed.">                switch (p.currentSegment(coords)) {</span>
                    case PathIterator.SEG_MOVETO:
<span class="pc bpc" id="L2549" title="2 of 4 branches missed.">                        if (cx != mx || cy != my) {</span>
<span class="nc" id="L2550">                            cross += crossLine(cx, cy, mx, my, x, y);</span>
                        }
<span class="fc" id="L2552">                        mx = cx = coords[0];</span>
<span class="fc" id="L2553">                        my = cy = coords[1];</span>
<span class="fc" id="L2554">                        break;</span>
                    case PathIterator.SEG_LINETO:
<span class="fc" id="L2556">                        cross += crossLine(cx, cy, cx = coords[0], cy = coords[1], x, y);</span>
<span class="fc" id="L2557">                        break;</span>
                    case PathIterator.SEG_QUADTO:
<span class="nc" id="L2559">                        cross += crossQuad(cx, cy, coords[0], coords[1], cx = coords[2], cy = coords[3], x, y);</span>
<span class="nc" id="L2560">                        break;</span>
                    case PathIterator.SEG_CUBICTO:
<span class="nc" id="L2562">                        cross += crossCubic(cx, cy, coords[0], coords[1], coords[2], coords[3], cx = coords[4], cy = coords[5], x, y);</span>
<span class="nc" id="L2563">                        break;</span>
                    case PathIterator.SEG_CLOSE:
<span class="pc bpc" id="L2565" title="3 of 4 branches missed.">                        if (cy != my || cx != mx) {</span>
<span class="fc" id="L2566">                            cross += crossLine(cx, cy, cx = mx, cy = my, x, y);</span>
                        }
                        break;
                }

                // checks if the point (x,y) is the vertex of shape with PathIterator p
<span class="pc bpc" id="L2572" title="3 of 4 branches missed.">                if (x == cx &amp;&amp; y == cy) {</span>
<span class="nc" id="L2573">                    cross = 0;</span>
<span class="nc" id="L2574">                    cy = my;</span>
<span class="nc" id="L2575">                    break;</span>
                }
<span class="fc" id="L2577">                p.next();</span>
            }
<span class="pc bpc" id="L2579" title="1 of 2 branches missed.">            if (cy != my) {</span>
<span class="nc" id="L2580">                cross += crossLine(cx, cy, mx, my, x, y);</span>
            }
<span class="fc" id="L2582">            return cross;</span>
        }

        /**
         * Returns how many times ray from point (x,y) cross shape
         */
        public static int crossShape(Shape s, double x, double y) {
<span class="fc bfc" id="L2589" title="All 2 branches covered.">            if (!s.getBounds().contains((int) x, (int) y)) {</span>
<span class="fc" id="L2590">                return 0;</span>
            }

<span class="fc" id="L2593">            return crossPath(s.getPathIterator(null), x, y);</span>
        }

        /**
         * Returns true if value enough small
         */
        public static boolean isZero(double val) {
<span class="pc bpc" id="L2600" title="3 of 4 branches missed.">            return -DELTA &lt; val &amp;&amp; val &lt; DELTA;</span>
        }

        /**
         * Sort bound array
         */
        static void sortBound(double[] bound, int bc) {
<span class="nc bnc" id="L2607" title="All 2 branches missed.">            for (int i = 0; i &lt; bc - 4; i += 4) {</span>
<span class="nc" id="L2608">                int k = i;</span>
<span class="nc bnc" id="L2609" title="All 2 branches missed.">                for (int j = i + 4; j &lt; bc; j += 4) {</span>
<span class="nc bnc" id="L2610" title="All 2 branches missed.">                    if (bound[k] &gt; bound[j]) {</span>
<span class="nc" id="L2611">                        k = j;</span>
                    }
                }
<span class="nc bnc" id="L2614" title="All 2 branches missed.">                if (k != i) {</span>
<span class="nc" id="L2615">                    double tmp = bound[i];</span>
<span class="nc" id="L2616">                    bound[i] = bound[k];</span>
<span class="nc" id="L2617">                    bound[k] = tmp;</span>
<span class="nc" id="L2618">                    tmp = bound[i + 1];</span>
<span class="nc" id="L2619">                    bound[i + 1] = bound[k + 1];</span>
<span class="nc" id="L2620">                    bound[k + 1] = tmp;</span>
<span class="nc" id="L2621">                    tmp = bound[i + 2];</span>
<span class="nc" id="L2622">                    bound[i + 2] = bound[k + 2];</span>
<span class="nc" id="L2623">                    bound[k + 2] = tmp;</span>
<span class="nc" id="L2624">                    tmp = bound[i + 3];</span>
<span class="nc" id="L2625">                    bound[i + 3] = bound[k + 3];</span>
<span class="nc" id="L2626">                    bound[k + 3] = tmp;</span>
                }
            }
<span class="nc" id="L2629">        }</span>

        /**
         * Returns are bounds intersect or not intersect rectangle
         */
        static int crossBound(double[] bound, int bc, double py1, double py2) {

            // LEFT/RIGHT
<span class="pc bpc" id="L2637" title="1 of 2 branches missed.">            if (bc == 0) {</span>
<span class="nc" id="L2638">                return 0;</span>
            }

            // Check Y coordinate
<span class="fc" id="L2642">            int up = 0;</span>
<span class="fc" id="L2643">            int down = 0;</span>
<span class="fc" id="L2644">            boolean intersects = false;</span>
            // PMD Fix (AvoidBranchingStatementAsLastInLoop): Guard the loop with the intersects flag instead of breaking at the end.
<span class="fc bfc" id="L2646" title="All 4 branches covered.">            for (int i = 2; i &lt; bc &amp;&amp; !intersects; i += 4) {</span>
<span class="pc bpc" id="L2647" title="1 of 2 branches missed.">                if (bound[i] &lt; py1) {</span>
<span class="nc" id="L2648">                    up++;</span>
<span class="nc" id="L2649">                    continue;</span>
                }
<span class="pc bpc" id="L2651" title="1 of 2 branches missed.">                if (bound[i] &gt; py2) {</span>
<span class="nc" id="L2652">                    down++;</span>
<span class="nc" id="L2653">                    continue;</span>
                }
<span class="fc" id="L2655">                intersects = true;</span>
            }

<span class="pc bpc" id="L2658" title="1 of 2 branches missed.">            if (intersects) {</span>
<span class="fc" id="L2659">                return CROSSING;</span>
            }

            // UP
<span class="nc bnc" id="L2663" title="All 2 branches missed.">            if (down == 0) {</span>
<span class="nc" id="L2664">                return 0;</span>
            }

<span class="nc bnc" id="L2667" title="All 2 branches missed.">            if (up != 0) {</span>
                // bc &gt;= 2
<span class="nc" id="L2669">                sortBound(bound, bc);</span>
<span class="nc bnc" id="L2670" title="All 2 branches missed.">                boolean sign = bound[2] &gt; py2;</span>
<span class="nc" id="L2671">                boolean crossing = false;</span>
                // PMD Fix (AvoidBranchingStatementAsLastInLoop): Guard the loop with the crossing flag instead of breaking at the end.
<span class="nc bnc" id="L2673" title="All 4 branches missed.">                for (int i = 6; i &lt; bc &amp;&amp; !crossing; i += 4) {</span>
<span class="nc bnc" id="L2674" title="All 2 branches missed.">                    boolean sign2 = bound[i] &gt; py2;</span>
<span class="nc bnc" id="L2675" title="All 4 branches missed.">                    if (sign != sign2 &amp;&amp; bound[i + 1] != bound[i - 3]) {</span>
<span class="nc" id="L2676">                        crossing = true;</span>
<span class="nc" id="L2677">                        sign = sign2;</span>
<span class="nc" id="L2678">                        continue;</span>
                    }
<span class="nc" id="L2680">                    sign = sign2;</span>
                }
<span class="nc bnc" id="L2682" title="All 2 branches missed.">                if (crossing) {</span>
<span class="nc" id="L2683">                    return CROSSING;</span>
                }
            }
<span class="nc" id="L2686">            return UNKNOWN;</span>
        }

        /**
         * Returns how many times rectangle stripe cross line or the are intersect
         */
        public static int intersectLine(double x1, double y1, double x2, double y2, double rx1, double ry1, double rx2, double ry2) {

            // LEFT/RIGHT/UP
<span class="nc bnc" id="L2695" title="All 12 branches missed.">            if ((rx2 &lt; x1 &amp;&amp; rx2 &lt; x2) ||</span>
                    (rx1 &gt; x1 &amp;&amp; rx1 &gt; x2) ||
                    (ry1 &gt; y1 &amp;&amp; ry1 &gt; y2)) {
<span class="nc" id="L2698">                return 0;</span>
            }

            // DOWN
<span class="nc bnc" id="L2702" title="All 4 branches missed.">            if (ry2 &lt; y1 &amp;&amp; ry2 &lt; y2) {</span>
            } else {

                // INSIDE
<span class="nc bnc" id="L2706" title="All 2 branches missed.">                if (x1 == x2) {</span>
<span class="nc" id="L2707">                    return CROSSING;</span>
                }

                // Build bound
                double bx1, bx2;
<span class="nc bnc" id="L2712" title="All 2 branches missed.">                if (x1 &lt; x2) {</span>
<span class="nc bnc" id="L2713" title="All 2 branches missed.">                    bx1 = x1 &lt; rx1 ? rx1 : x1;</span>
<span class="nc bnc" id="L2714" title="All 2 branches missed.">                    bx2 = x2 &lt; rx2 ? x2 : rx2;</span>
                } else {
<span class="nc bnc" id="L2716" title="All 2 branches missed.">                    bx1 = x2 &lt; rx1 ? rx1 : x2;</span>
<span class="nc bnc" id="L2717" title="All 2 branches missed.">                    bx2 = x1 &lt; rx2 ? x1 : rx2;</span>
                }
<span class="nc" id="L2719">                double k = (y2 - y1) / (x2 - x1);</span>
<span class="nc" id="L2720">                double by1 = k * (bx1 - x1) + y1;</span>
<span class="nc" id="L2721">                double by2 = k * (bx2 - x1) + y1;</span>

                // BOUND-UP
<span class="nc bnc" id="L2724" title="All 4 branches missed.">                if (by1 &lt; ry1 &amp;&amp; by2 &lt; ry1) {</span>
<span class="nc" id="L2725">                    return 0;</span>
                }

                // BOUND-DOWN
<span class="nc bnc" id="L2729" title="All 4 branches missed.">                if (by1 &gt; ry2 &amp;&amp; by2 &gt; ry2) {</span>
                } else {
<span class="nc" id="L2731">                    return CROSSING;</span>
                }
            }

            // EMPTY
<span class="nc bnc" id="L2736" title="All 2 branches missed.">            if (x1 == x2) {</span>
<span class="nc" id="L2737">                return 0;</span>
            }

            // CURVE-START
<span class="nc bnc" id="L2741" title="All 2 branches missed.">            if (rx1 == x1) {</span>
<span class="nc bnc" id="L2742" title="All 2 branches missed.">                return x1 &lt; x2 ? 0 : -1;</span>
            }

            // CURVE-END
<span class="nc bnc" id="L2746" title="All 2 branches missed.">            if (rx1 == x2) {</span>
<span class="nc bnc" id="L2747" title="All 2 branches missed.">                return x1 &lt; x2 ? 1 : 0;</span>
            }

<span class="nc bnc" id="L2750" title="All 2 branches missed.">            if (x1 &lt; x2) {</span>
<span class="nc bnc" id="L2751" title="All 4 branches missed.">                return x1 &lt; rx1 &amp;&amp; rx1 &lt; x2 ? 1 : 0;</span>
            }
<span class="nc bnc" id="L2753" title="All 4 branches missed.">            return x2 &lt; rx1 &amp;&amp; rx1 &lt; x1 ? -1 : 0;</span>

        }

        /**
         * Returns how many times rectangle stripe cross quad curve or the are intersect
         */
        public static int intersectQuad(double x1, double y1, double cx, double cy, double x2, double y2, double rx1, double ry1, double rx2, double ry2) {

            // LEFT/RIGHT/UP ------------------------------------------------------
<span class="pc bpc" id="L2763" title="9 of 18 branches missed.">            if ((rx2 &lt; x1 &amp;&amp; rx2 &lt; cx &amp;&amp; rx2 &lt; x2) ||</span>
                    (rx1 &gt; x1 &amp;&amp; rx1 &gt; cx &amp;&amp; rx1 &gt; x2) ||
                    (ry1 &gt; y1 &amp;&amp; ry1 &gt; cy &amp;&amp; ry1 &gt; y2)) {
<span class="fc" id="L2766">                return 0;</span>
            }

            // DOWN ---------------------------------------------------------------
<span class="pc bpc" id="L2770" title="9 of 10 branches missed.">            if (ry2 &lt; y1 &amp;&amp; ry2 &lt; cy &amp;&amp; ry2 &lt; y2 &amp;&amp; rx1 != x1 &amp;&amp; rx1 != x2) {</span>
<span class="nc bnc" id="L2771" title="All 2 branches missed.">                if (x1 &lt; x2) {</span>
<span class="nc bnc" id="L2772" title="All 4 branches missed.">                    return x1 &lt; rx1 &amp;&amp; rx1 &lt; x2 ? 1 : 0;</span>
                }
<span class="nc bnc" id="L2774" title="All 4 branches missed.">                return x2 &lt; rx1 &amp;&amp; rx1 &lt; x1 ? -1 : 0;</span>
            }

            // INSIDE -------------------------------------------------------------
<span class="fc" id="L2778">            QuadCurve c = new QuadCurve(x1, y1, cx, cy, x2, y2);</span>
<span class="fc" id="L2779">            double px1 = rx1 - x1;</span>
<span class="fc" id="L2780">            double py1 = ry1 - y1;</span>
<span class="fc" id="L2781">            double px2 = rx2 - x1;</span>
<span class="fc" id="L2782">            double py2 = ry2 - y1;</span>

<span class="fc" id="L2784">            double[] res1 = new double[3];</span>
<span class="fc" id="L2785">            double[] res2 = new double[3];</span>
<span class="fc" id="L2786">            int rc1 = c.solvePoint(res1, px1);</span>
<span class="fc" id="L2787">            int rc2 = c.solvePoint(res2, px2);</span>

            // INSIDE-LEFT/RIGHT
<span class="pc bpc" id="L2790" title="3 of 4 branches missed.">            if (rc1 == 0 &amp;&amp; rc2 == 0) {</span>
<span class="nc" id="L2791">                return 0;</span>
            }

            // Build bound --------------------------------------------------------
<span class="fc" id="L2795">            double minX = px1 - DELTA;</span>
<span class="fc" id="L2796">            double maxX = px2 + DELTA;</span>
<span class="fc" id="L2797">            double[] bound = new double[28];</span>
<span class="fc" id="L2798">            int bc = 0;</span>
            // Add roots
<span class="fc" id="L2800">            bc = c.addBound(bound, bc, res1, rc1, minX, maxX, false, 0);</span>
<span class="fc" id="L2801">            bc = c.addBound(bound, bc, res2, rc2, minX, maxX, false, 1);</span>
            // Add extremal points`
<span class="fc" id="L2803">            rc2 = c.solveExtrem(res2);</span>
<span class="fc" id="L2804">            bc = c.addBound(bound, bc, res2, rc2, minX, maxX, true, 2);</span>
            // Add start and end
<span class="pc bpc" id="L2806" title="1 of 4 branches missed.">            if (rx1 &lt; x1 &amp;&amp; x1 &lt; rx2) {</span>
<span class="nc" id="L2807">                bound[bc++] = 0.0;</span>
<span class="nc" id="L2808">                bound[bc++] = 0.0;</span>
<span class="nc" id="L2809">                bound[bc++] = 0.0;</span>
<span class="nc" id="L2810">                bound[bc++] = 4;</span>
            }
<span class="pc bpc" id="L2812" title="2 of 4 branches missed.">            if (rx1 &lt; x2 &amp;&amp; x2 &lt; rx2) {</span>
<span class="nc" id="L2813">                bound[bc++] = 1.0;</span>
<span class="nc" id="L2814">                bound[bc++] = c.ax;</span>
<span class="nc" id="L2815">                bound[bc++] = c.ay;</span>
<span class="nc" id="L2816">                bound[bc++] = 5;</span>
            }
            // End build bound ----------------------------------------------------

<span class="fc" id="L2820">            int cross = crossBound(bound, bc, py1, py2);</span>
<span class="pc bpc" id="L2821" title="1 of 2 branches missed.">            if (cross != UNKNOWN) {</span>
<span class="fc" id="L2822">                return cross;</span>
            }
<span class="nc" id="L2824">            return c.cross(res1, rc1, py1, py2);</span>
        }

        /**
         * Returns how many times rectangle stripe cross cubic curve or the are intersect
         */
        public static int intersectCubic(double x1, double y1, double cx1, double cy1, double cx2, double cy2, double x2, double y2, double rx1, double ry1, double rx2, double ry2) {

            // LEFT/RIGHT/UP
<span class="nc bnc" id="L2833" title="All 24 branches missed.">            if ((rx2 &lt; x1 &amp;&amp; rx2 &lt; cx1 &amp;&amp; rx2 &lt; cx2 &amp;&amp; rx2 &lt; x2) ||</span>
                    (rx1 &gt; x1 &amp;&amp; rx1 &gt; cx1 &amp;&amp; rx1 &gt; cx2 &amp;&amp; rx1 &gt; x2) ||
                    (ry1 &gt; y1 &amp;&amp; ry1 &gt; cy1 &amp;&amp; ry1 &gt; cy2 &amp;&amp; ry1 &gt; y2)) {
<span class="nc" id="L2836">                return 0;</span>
            }

            // DOWN
<span class="nc bnc" id="L2840" title="All 12 branches missed.">            if (ry2 &lt; y1 &amp;&amp; ry2 &lt; cy1 &amp;&amp; ry2 &lt; cy2 &amp;&amp; ry2 &lt; y2 &amp;&amp; rx1 != x1 &amp;&amp; rx1 != x2) {</span>
<span class="nc bnc" id="L2841" title="All 2 branches missed.">                if (x1 &lt; x2) {</span>
<span class="nc bnc" id="L2842" title="All 4 branches missed.">                    return x1 &lt; rx1 &amp;&amp; rx1 &lt; x2 ? 1 : 0;</span>
                }
<span class="nc bnc" id="L2844" title="All 4 branches missed.">                return x2 &lt; rx1 &amp;&amp; rx1 &lt; x1 ? -1 : 0;</span>
            }

            // INSIDE
<span class="nc" id="L2848">            CubicCurve c = new CubicCurve(x1, y1, cx1, cy1, cx2, cy2, x2, y2);</span>
<span class="nc" id="L2849">            double px1 = rx1 - x1;</span>
<span class="nc" id="L2850">            double py1 = ry1 - y1;</span>
<span class="nc" id="L2851">            double px2 = rx2 - x1;</span>
<span class="nc" id="L2852">            double py2 = ry2 - y1;</span>

<span class="nc" id="L2854">            double[] res1 = new double[3];</span>
<span class="nc" id="L2855">            double[] res2 = new double[3];</span>
<span class="nc" id="L2856">            int rc1 = c.solvePoint(res1, px1);</span>
<span class="nc" id="L2857">            int rc2 = c.solvePoint(res2, px2);</span>

            // LEFT/RIGHT
<span class="nc bnc" id="L2860" title="All 4 branches missed.">            if (rc1 == 0 &amp;&amp; rc2 == 0) {</span>
<span class="nc" id="L2861">                return 0;</span>
            }

<span class="nc" id="L2864">            double minX = px1 - DELTA;</span>
<span class="nc" id="L2865">            double maxX = px2 + DELTA;</span>

            // Build bound --------------------------------------------------------
<span class="nc" id="L2868">            double[] bound = new double[40];</span>
<span class="nc" id="L2869">            int bc = 0;</span>
            // Add roots
<span class="nc" id="L2871">            bc = c.addBound(bound, bc, res1, rc1, minX, maxX, false, 0);</span>
<span class="nc" id="L2872">            bc = c.addBound(bound, bc, res2, rc2, minX, maxX, false, 1);</span>
            // Add extrimal points
<span class="nc" id="L2874">            rc2 = c.solveExtremX(res2);</span>
<span class="nc" id="L2875">            bc = c.addBound(bound, bc, res2, rc2, minX, maxX, true, 2);</span>
<span class="nc" id="L2876">            rc2 = c.solveExtremY(res2);</span>
<span class="nc" id="L2877">            bc = c.addBound(bound, bc, res2, rc2, minX, maxX, true, 4);</span>
            // Add start and end
<span class="nc bnc" id="L2879" title="All 4 branches missed.">            if (rx1 &lt; x1 &amp;&amp; x1 &lt; rx2) {</span>
<span class="nc" id="L2880">                bound[bc++] = 0.0;</span>
<span class="nc" id="L2881">                bound[bc++] = 0.0;</span>
<span class="nc" id="L2882">                bound[bc++] = 0.0;</span>
<span class="nc" id="L2883">                bound[bc++] = 6;</span>
            }
<span class="nc bnc" id="L2885" title="All 4 branches missed.">            if (rx1 &lt; x2 &amp;&amp; x2 &lt; rx2) {</span>
<span class="nc" id="L2886">                bound[bc++] = 1.0;</span>
<span class="nc" id="L2887">                bound[bc++] = c.ax;</span>
<span class="nc" id="L2888">                bound[bc++] = c.ay;</span>
<span class="nc" id="L2889">                bound[bc++] = 7;</span>
            }
            // End build bound ----------------------------------------------------

<span class="nc" id="L2893">            int cross = crossBound(bound, bc, py1, py2);</span>
<span class="nc bnc" id="L2894" title="All 2 branches missed.">            if (cross != UNKNOWN) {</span>
<span class="nc" id="L2895">                return cross;</span>
            }
<span class="nc" id="L2897">            return c.cross(res1, rc1, py1, py2);</span>
        }

        /**
         * Returns how many times rectangle stripe cross path or the are intersect
         */
        public static int intersectPath(PathIterator p, double x, double y, double w, double h) {

<span class="nc" id="L2905">            int cross = 0;</span>
            int count;
            double mx, my, cx, cy;
<span class="nc" id="L2908">            mx = my = cx = cy = 0.0;</span>
<span class="nc" id="L2909">            double[] coords = new double[6];</span>

<span class="nc" id="L2911">            double rx1 = x;</span>
<span class="nc" id="L2912">            double ry1 = y;</span>
<span class="nc" id="L2913">            double rx2 = x + w;</span>
<span class="nc" id="L2914">            double ry2 = y + h;</span>

<span class="nc bnc" id="L2916" title="All 2 branches missed.">            while (!p.isDone()) {</span>
<span class="nc" id="L2917">                count = 0;</span>
<span class="nc bnc" id="L2918" title="All 6 branches missed.">                switch (p.currentSegment(coords)) {</span>
                    case PathIterator.SEG_MOVETO:
<span class="nc bnc" id="L2920" title="All 4 branches missed.">                        if (cx != mx || cy != my) {</span>
<span class="nc" id="L2921">                            count = intersectLine(cx, cy, mx, my, rx1, ry1, rx2, ry2);</span>
                        }
<span class="nc" id="L2923">                        mx = cx = coords[0];</span>
<span class="nc" id="L2924">                        my = cy = coords[1];</span>
<span class="nc" id="L2925">                        break;</span>
                    case PathIterator.SEG_LINETO:
<span class="nc" id="L2927">                        count = intersectLine(cx, cy, cx = coords[0], cy = coords[1], rx1, ry1, rx2, ry2);</span>
<span class="nc" id="L2928">                        break;</span>
                    case PathIterator.SEG_QUADTO:
<span class="nc" id="L2930">                        count = intersectQuad(cx, cy, coords[0], coords[1], cx = coords[2], cy = coords[3], rx1, ry1, rx2, ry2);</span>
<span class="nc" id="L2931">                        break;</span>
                    case PathIterator.SEG_CUBICTO:
<span class="nc" id="L2933">                        count = intersectCubic(cx, cy, coords[0], coords[1], coords[2], coords[3], cx = coords[4], cy = coords[5], rx1, ry1, rx2, ry2);</span>
<span class="nc" id="L2934">                        break;</span>
                    case PathIterator.SEG_CLOSE:
<span class="nc bnc" id="L2936" title="All 4 branches missed.">                        if (cy != my || cx != mx) {</span>
<span class="nc" id="L2937">                            count = intersectLine(cx, cy, mx, my, rx1, ry1, rx2, ry2);</span>
                        }
<span class="nc" id="L2939">                        cx = mx;</span>
<span class="nc" id="L2940">                        cy = my;</span>
                        break;
                }
<span class="nc bnc" id="L2943" title="All 2 branches missed.">                if (count == CROSSING) {</span>
<span class="nc" id="L2944">                    return CROSSING;</span>
                }
<span class="nc" id="L2946">                cross += count;</span>
<span class="nc" id="L2947">                p.next();</span>
            }
<span class="nc bnc" id="L2949" title="All 2 branches missed.">            if (cy != my) {</span>
<span class="nc" id="L2950">                count = intersectLine(cx, cy, mx, my, rx1, ry1, rx2, ry2);</span>
<span class="nc bnc" id="L2951" title="All 2 branches missed.">                if (count == CROSSING) {</span>
<span class="nc" id="L2952">                    return CROSSING;</span>
                }
<span class="nc" id="L2954">                cross += count;</span>
            }
<span class="nc" id="L2956">            return cross;</span>
        }

        /**
         * Returns how many times rectangle stripe cross shape or the are intersect
         */
        public static int intersectShape(Shape s, double x, double y, double w, double h) {
<span class="nc bnc" id="L2963" title="All 2 branches missed.">            if (!s.getBounds().intersects((int) x, (int) y, (int) w, (int) h)) {</span>
<span class="nc" id="L2964">                return 0;</span>
            }
<span class="nc" id="L2966">            return intersectPath(s.getPathIterator(null), x, y, w, h);</span>
        }

        /**
         * Returns true if cross count correspond inside location for non zero path rule
         */
        public static boolean isInsideNonZero(int cross) {
<span class="fc bfc" id="L2973" title="All 2 branches covered.">            return cross != 0;</span>
        }

        /**
         * Returns true if cross count correspond inside location for even-odd path rule
         */
        public static boolean isInsideEvenOdd(int cross) {
<span class="nc bnc" id="L2980" title="All 2 branches missed.">            return (cross &amp; 1) != 0;</span>
        }

        /**
         * QuadCurve class provides basic functionality to find curve crossing and calculating bounds
         */
        public static class QuadCurve {

            double ax, ay, bx, by;
            double Ax, Ay, Bx, By;

<span class="fc" id="L2991">            public QuadCurve(double x1, double y1, double cx, double cy, double x2, double y2) {</span>
<span class="fc" id="L2992">                ax = x2 - x1;</span>
<span class="fc" id="L2993">                ay = y2 - y1;</span>
<span class="fc" id="L2994">                bx = cx - x1;</span>
<span class="fc" id="L2995">                by = cy - y1;</span>

<span class="fc" id="L2997">                Bx = bx + bx;   // Bx = 2.0 * bx</span>
<span class="fc" id="L2998">                Ax = ax - Bx;   // Ax = ax - 2.0 * bx</span>

<span class="fc" id="L3000">                By = by + by;   // By = 2.0 * by</span>
<span class="fc" id="L3001">                Ay = ay - By;   // Ay = ay - 2.0 * by</span>
<span class="fc" id="L3002">            }</span>

            int cross(double[] res, int rc, double py1, double py2) {
<span class="nc" id="L3005">                int cross = 0;</span>

<span class="nc bnc" id="L3007" title="All 2 branches missed.">                for (int i = 0; i &lt; rc; i++) {</span>
<span class="nc" id="L3008">                    double t = res[i];</span>

                    // CURVE-OUTSIDE
<span class="nc bnc" id="L3011" title="All 4 branches missed.">                    if (t &lt; -DELTA || t &gt; 1 + DELTA) {</span>
<span class="nc" id="L3012">                        continue;</span>
                    }
                    // CURVE-START
<span class="nc bnc" id="L3015" title="All 2 branches missed.">                    if (t &lt; DELTA) {</span>
<span class="nc bnc" id="L3016" title="All 6 branches missed.">                        if (py1 &lt; 0.0 &amp;&amp; (bx != 0.0 ? bx : ax - bx) &lt; 0.0) {</span>
<span class="nc" id="L3017">                            cross--;</span>
                        }
                        continue;
                    }
                    // CURVE-END
<span class="nc bnc" id="L3022" title="All 2 branches missed.">                    if (t &gt; 1 - DELTA) {</span>
<span class="nc bnc" id="L3023" title="All 6 branches missed.">                        if (py1 &lt; ay &amp;&amp; (ax != bx ? ax - bx : bx) &gt; 0.0) {</span>
<span class="nc" id="L3024">                            cross++;</span>
                        }
                        continue;
                    }
                    // CURVE-INSIDE
<span class="nc" id="L3029">                    double ry = t * (t * Ay + By);</span>
                    // ry = t * t * Ay + t * By
<span class="nc bnc" id="L3031" title="All 2 branches missed.">                    if (ry &gt; py2) {</span>
<span class="nc" id="L3032">                        double rxt = t * Ax + bx;</span>
                        // rxt = 2.0 * t * Ax + Bx = 2.0 * t * Ax + 2.0 * bx
<span class="nc bnc" id="L3034" title="All 4 branches missed.">                        if (rxt &gt; -DELTA &amp;&amp; rxt &lt; DELTA) {</span>
<span class="nc" id="L3035">                            continue;</span>
                        }
<span class="nc bnc" id="L3037" title="All 2 branches missed.">                        cross += rxt &gt; 0.0 ? 1 : -1;</span>
                    }
                } // for

<span class="nc" id="L3041">                return cross;</span>
            }

            int solvePoint(double[] res, double px) {
<span class="fc" id="L3045">                double[] eqn = {-px, Bx, Ax};</span>
<span class="fc" id="L3046">                return solveQuad(eqn, res);</span>
            }

            int solveExtrem(double[] res) {
<span class="fc" id="L3050">                int rc = 0;</span>
<span class="pc bpc" id="L3051" title="1 of 2 branches missed.">                if (Ax != 0.0) {</span>
<span class="nc" id="L3052">                    res[rc++] = -Bx / (Ax + Ax);</span>
                }
<span class="pc bpc" id="L3054" title="1 of 2 branches missed.">                if (Ay != 0.0) {</span>
<span class="fc" id="L3055">                    res[rc++] = -By / (Ay + Ay);</span>
                }
<span class="fc" id="L3057">                return rc;</span>
            }

            int addBound(double[] bound, int bc, double[] res, int rc, double minX, double maxX, boolean changeId, int id) {
<span class="fc bfc" id="L3061" title="All 2 branches covered.">                for (int i = 0; i &lt; rc; i++) {</span>
<span class="fc" id="L3062">                    double t = res[i];</span>
<span class="pc bpc" id="L3063" title="1 of 4 branches missed.">                    if (t &gt; -DELTA &amp;&amp; t &lt; 1 + DELTA) {</span>
<span class="fc" id="L3064">                        double rx = t * (t * Ax + Bx);</span>
<span class="pc bpc" id="L3065" title="2 of 4 branches missed.">                        if (minX &lt;= rx &amp;&amp; rx &lt;= maxX) {</span>
<span class="fc" id="L3066">                            bound[bc++] = t;</span>
<span class="fc" id="L3067">                            bound[bc++] = rx;</span>
<span class="fc" id="L3068">                            bound[bc++] = t * (t * Ay + By);</span>
<span class="fc" id="L3069">                            bound[bc++] = id;</span>
<span class="fc bfc" id="L3070" title="All 2 branches covered.">                            if (changeId) {</span>
<span class="fc" id="L3071">                                id++;</span>
                            }
                        }
                    }
                }
<span class="fc" id="L3076">                return bc;</span>
            }

        }

        /**
         * CubicCurve class provides basic functionality to find curve crossing and calculating bounds
         */
        public static class CubicCurve {

            double ax, ay, bx, by, cx, cy;
            double Ax, Ay, Bx, By, Cx, Cy;
            double Ax3, Bx2;

<span class="nc" id="L3090">            public CubicCurve(double x1, double y1, double cx1, double cy1, double cx2, double cy2, double x2, double y2) {</span>
<span class="nc" id="L3091">                ax = x2 - x1;</span>
<span class="nc" id="L3092">                ay = y2 - y1;</span>
<span class="nc" id="L3093">                bx = cx1 - x1;</span>
<span class="nc" id="L3094">                by = cy1 - y1;</span>
<span class="nc" id="L3095">                cx = cx2 - x1;</span>
<span class="nc" id="L3096">                cy = cy2 - y1;</span>

<span class="nc" id="L3098">                Cx = bx + bx + bx;           // Cx = 3.0 * bx</span>
<span class="nc" id="L3099">                Bx = cx + cx + cx - Cx - Cx; // Bx = 3.0 * cx - 6.0 * bx</span>
<span class="nc" id="L3100">                Ax = ax - Bx - Cx;           // Ax = ax - 3.0 * cx + 3.0 * bx</span>

<span class="nc" id="L3102">                Cy = by + by + by;           // Cy = 3.0 * by</span>
<span class="nc" id="L3103">                By = cy + cy + cy - Cy - Cy; // By = 3.0 * cy - 6.0 * by</span>
<span class="nc" id="L3104">                Ay = ay - By - Cy;           // Ay = ay - 3.0 * cy + 3.0 * by</span>

<span class="nc" id="L3106">                Ax3 = Ax + Ax + Ax;</span>
<span class="nc" id="L3107">                Bx2 = Bx + Bx;</span>
<span class="nc" id="L3108">            }</span>

            int cross(double[] res, int rc, double py1, double py2) {
<span class="nc" id="L3111">                int cross = 0;</span>
<span class="nc bnc" id="L3112" title="All 2 branches missed.">                for (int i = 0; i &lt; rc; i++) {</span>
<span class="nc" id="L3113">                    double t = res[i];</span>

                    // CURVE-OUTSIDE
<span class="nc bnc" id="L3116" title="All 4 branches missed.">                    if (t &lt; -DELTA || t &gt; 1 + DELTA) {</span>
<span class="nc" id="L3117">                        continue;</span>
                    }
                    // CURVE-START
<span class="nc bnc" id="L3120" title="All 2 branches missed.">                    if (t &lt; DELTA) {</span>
<span class="nc bnc" id="L3121" title="All 8 branches missed.">                        if (py1 &lt; 0.0 &amp;&amp; (bx != 0.0 ? bx : (cx != bx ? cx - bx : ax - cx)) &lt; 0.0) {</span>
<span class="nc" id="L3122">                            cross--;</span>
                        }
                        continue;
                    }
                    // CURVE-END
<span class="nc bnc" id="L3127" title="All 2 branches missed.">                    if (t &gt; 1 - DELTA) {</span>
<span class="nc bnc" id="L3128" title="All 8 branches missed.">                        if (py1 &lt; ay &amp;&amp; (ax != cx ? ax - cx : (cx != bx ? cx - bx : bx)) &gt; 0.0) {</span>
<span class="nc" id="L3129">                            cross++;</span>
                        }
                        continue;
                    }
                    // CURVE-INSIDE
<span class="nc" id="L3134">                    double ry = t * (t * (t * Ay + By) + Cy);</span>
                    // ry = t * t * t * Ay + t * t * By + t * Cy
<span class="nc bnc" id="L3136" title="All 2 branches missed.">                    if (ry &gt; py2) {</span>
<span class="nc" id="L3137">                        double rxt = t * (t * Ax3 + Bx2) + Cx;</span>
                        // rxt = 3.0 * t * t * Ax + 2.0 * t * Bx + Cx
<span class="nc bnc" id="L3139" title="All 4 branches missed.">                        if (rxt &gt; -DELTA &amp;&amp; rxt &lt; DELTA) {</span>
<span class="nc" id="L3140">                            rxt = t * (Ax3 + Ax3) + Bx2;</span>
                            // rxt = 6.0 * t * Ax + 2.0 * Bx
<span class="nc bnc" id="L3142" title="All 4 branches missed.">                            if (rxt &lt; -DELTA || rxt &gt; DELTA) {</span>
                                // Inflection point
<span class="nc" id="L3144">                                continue;</span>
                            }
<span class="nc" id="L3146">                            rxt = ax;</span>
                        }
<span class="nc bnc" id="L3148" title="All 2 branches missed.">                        cross += rxt &gt; 0.0 ? 1 : -1;</span>
                    }
                } //for

<span class="nc" id="L3152">                return cross;</span>
            }

            int solvePoint(double[] res, double px) {
<span class="nc" id="L3156">                double[] eqn = {-px, Cx, Bx, Ax};</span>
<span class="nc" id="L3157">                return solveCubic(eqn, res);</span>
            }

            int solveExtremX(double[] res) {
<span class="nc" id="L3161">                double[] eqn = {Cx, Bx2, Ax3};</span>
<span class="nc" id="L3162">                return solveQuad(eqn, res);</span>
            }

            int solveExtremY(double[] res) {
<span class="nc" id="L3166">                double[] eqn = {Cy, By + By, Ay + Ay + Ay};</span>
<span class="nc" id="L3167">                return solveQuad(eqn, res);</span>
            }

            int addBound(double[] bound, int bc, double[] res, int rc, double minX, double maxX, boolean changeId, int id) {
<span class="nc bnc" id="L3171" title="All 2 branches missed.">                for (int i = 0; i &lt; rc; i++) {</span>
<span class="nc" id="L3172">                    double t = res[i];</span>
<span class="nc bnc" id="L3173" title="All 4 branches missed.">                    if (t &gt; -DELTA &amp;&amp; t &lt; 1 + DELTA) {</span>
<span class="nc" id="L3174">                        double rx = t * (t * (t * Ax + Bx) + Cx);</span>
<span class="nc bnc" id="L3175" title="All 4 branches missed.">                        if (minX &lt;= rx &amp;&amp; rx &lt;= maxX) {</span>
<span class="nc" id="L3176">                            bound[bc++] = t;</span>
<span class="nc" id="L3177">                            bound[bc++] = rx;</span>
<span class="nc" id="L3178">                            bound[bc++] = t * (t * (t * Ay + By) + Cy);</span>
<span class="nc" id="L3179">                            bound[bc++] = id;</span>
<span class="nc bnc" id="L3180" title="All 2 branches missed.">                            if (changeId) {</span>
<span class="nc" id="L3181">                                id++;</span>
                            }
                        }
                    }
                }
<span class="nc" id="L3186">                return bc;</span>
            }

        }
//}

    }

    private static class Pt {

        double x, y;

        void clone(Pt target) {
<span class="nc" id="L3199">            target.x = x;</span>
<span class="nc" id="L3200">            target.y = y;</span>
<span class="nc" id="L3201">        }</span>
    }

    /*
     * GeneralPath path iterator
     */
    private class Iterator implements PathIterator {

        /**
         * The current cursor position in types buffer
         */
        int typeIndex;

        /**
         * The current cursor position in points buffer
         */
        int pointIndex;

        /**
         * The source GeneralPath object
         */
        GeneralPath p;

        Transform transform;
<span class="fc" id="L3225">        private final float[] buf = new float[2];</span>

        /**
         * Constructs a new GeneralPath.Iterator for given general path
         *
         * @param path - the source GeneralPath object
         */
<span class="fc" id="L3232">        Iterator(GeneralPath path) {</span>
<span class="fc" id="L3233">            this.p = path;</span>

<span class="fc" id="L3235">        }</span>

        private void reset() {
<span class="fc" id="L3238">            typeIndex = 0;</span>
<span class="fc" id="L3239">            pointIndex = 0;</span>
<span class="fc" id="L3240">        }</span>

        public int getWindingRule() {
<span class="nc" id="L3243">            return p.getWindingRule();</span>
        }

        public boolean isDone() {
<span class="fc bfc" id="L3247" title="All 2 branches covered.">            return typeIndex &gt;= p.typeSize;</span>
        }

        public void next() {
<span class="fc" id="L3251">            typeIndex++;</span>
<span class="fc" id="L3252">        }</span>

        private void transformSegmentInPlace() {
<span class="nc bnc" id="L3255" title="All 2 branches missed.">            if (isDone()) {</span>
                // awt.4B=Iterator out of bounds
<span class="nc" id="L3257">                throw new IndexOutOfBoundsException(&quot;Path done&quot;); //$NON-NLS-1$</span>
            }
<span class="nc bnc" id="L3259" title="All 2 branches missed.">            if (transform == null) {</span>
<span class="nc" id="L3260">                return;</span>
            }
<span class="nc" id="L3262">            int type = p.types[typeIndex];</span>
<span class="nc" id="L3263">            int count = GeneralPath.pointShift[type];</span>
<span class="nc bnc" id="L3264" title="All 2 branches missed.">            for (int i = 0; i &lt; count; i += 2) {</span>
<span class="nc" id="L3265">                buf[0] = p.points[pointIndex + i];</span>
<span class="nc" id="L3266">                buf[1] = p.points[pointIndex + i + 1];</span>
<span class="nc" id="L3267">                transform.transformPoint(buf, buf);</span>
<span class="nc" id="L3268">                p.points[pointIndex + i] = buf[0];</span>
<span class="nc" id="L3269">                p.points[pointIndex + i + 1] = buf[1];</span>
            }
<span class="nc" id="L3271">        }</span>

        public int currentSegment(double[] coords) {
<span class="fc" id="L3274">            float[] fcoords = createFloatArrayFromPool(6);</span>
            try {
<span class="fc" id="L3276">                int res = currentSegment(fcoords);</span>
<span class="fc" id="L3277">                int type = p.types[typeIndex];</span>
<span class="fc" id="L3278">                int count = GeneralPath.pointShift[type];</span>

<span class="fc bfc" id="L3280" title="All 2 branches covered.">                for (int i = 0; i &lt; count; i++) {</span>
<span class="fc" id="L3281">                    coords[i] = fcoords[i];</span>
                }
<span class="fc" id="L3283">                return res;</span>
            } finally {
<span class="fc" id="L3285">                recycle(fcoords);</span>
            }
        }

        public int currentSegment(float[] coords) {
<span class="pc bpc" id="L3290" title="1 of 2 branches missed.">            if (isDone()) {</span>
                // awt.4B=Iterator out of bounds
<span class="nc" id="L3292">                throw new IndexOutOfBoundsException(&quot;Path done&quot;); //$NON-NLS-1$</span>
            }
<span class="fc" id="L3294">            int type = p.types[typeIndex];</span>
<span class="fc" id="L3295">            int count = GeneralPath.pointShift[type];</span>
<span class="fc bfc" id="L3296" title="All 2 branches covered.">            if (transform == null) {</span>
<span class="fc" id="L3297">                System.arraycopy(p.points, pointIndex, coords, 0, count);</span>
            } else {
<span class="fc" id="L3299">                transform.transformPoints(2, p.points, pointIndex, coords, 0, count / 2);</span>
            }
<span class="fc" id="L3301">            pointIndex += count;</span>
<span class="fc" id="L3302">            return type;</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>