<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LookAndFeel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codenameone-core-unittests</a> &gt; <a href="index.source.html" class="el_package">com.codename1.ui.plaf</a> &gt; <span class="el_source">LookAndFeel.java</span></div><h1>LookAndFeel.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores
 * CA 94065 USA or visit www.oracle.com if you need additional information or
 * have any questions.
 */
package com.codename1.ui.plaf;

import com.codename1.components.InfiniteProgress;
import com.codename1.io.Log;
import com.codename1.io.Util;
import com.codename1.ui.Button;
import com.codename1.ui.Component;
import com.codename1.ui.Dialog;
import com.codename1.ui.Display;
import com.codename1.ui.Graphics;
import com.codename1.ui.Image;
import com.codename1.ui.InputComponent;
import com.codename1.ui.Label;
import com.codename1.ui.List;
import com.codename1.ui.MenuBar;
import com.codename1.ui.SideMenuBar;
import com.codename1.ui.TextArea;
import com.codename1.ui.TextSelection;
import com.codename1.ui.TextSelection.Span;
import com.codename1.ui.TextSelection.Spans;
import com.codename1.ui.Toolbar;
import com.codename1.ui.animations.BubbleTransition;
import com.codename1.ui.animations.CommonTransitions;
import com.codename1.ui.animations.Transition;
import com.codename1.ui.geom.Dimension;
import com.codename1.ui.list.ListCellRenderer;

/**
 * Allows a UI developer to completely customize the look of the application by
 * overriding drawing/sizing methods appropriately.
 *
 * @author Chen Fishbein
 * @deprecated this class is still crucial for some features in Codename One. The deprecation is here to indicate
 * our desire to reduce usage/reliance on this class.
 */
public abstract class LookAndFeel {
    private Component verticalScroll;
    private Component horizontalScroll;
    private Component verticalScrollThumb;
    private Component horizontalScrollThumb;

    /**
     * Right-To-Left. Default false.
     */
    private boolean rtl;

<span class="fc" id="L70">    private long tickerSpeed = 50;</span>
    /**
     * Tint color is set when a form is partially covered be it by a menu or by a
     * dialog. A look and feel can override this default value.
     */
<span class="fc" id="L75">    private int defaultFormTintColor = 0x77000000;</span>
    /**
     * This color is used to paint disable mode.
     */
<span class="fc" id="L79">    private int disableColor = 0xcccccc;</span>
    /**
     * This member allows us to define a default animation that will draw the transition for
     * entering a form
     */
    private Transition defaultFormTransitionIn;
    /**
     * This member allows us to define a default animation that will draw the transition for
     * exiting a form
     */
    private Transition defaultFormTransitionOut;
    /**
     * This member allows us to define a default animation that will draw the transition for
     * entering a menu
     */
    private Transition defaultMenuTransitionIn;
    /**
     * This member allows us to define a default animation that will draw the transition for
     * exiting a menu
     */
    private Transition defaultMenuTransitionOut;
    /**
     * This member allows us to define a default animation that will draw the transition for
     * entering a dialog
     */
    private Transition defaultDialogTransitionIn;
    /**
     * This member allows us to define a default animation that will draw the transition for
     * exiting a form
     */
    private Transition defaultDialogTransitionOut;
    /**
     * Indicates whether lists and containers should have smooth scrolling by default
     */
<span class="fc" id="L113">    private boolean defaultSmoothScrolling = true;</span>
    /**
     * Indicates whether lists and containers should scroll only via focus and thus &quot;jump&quot; when
     * moving to a larger component as was the case in older versions of Codename One.
     */
    private boolean focusScrolling;
    /**
     * Indicates the default speed for smooth scrolling
     */
<span class="fc" id="L122">    private int defaultSmoothScrollingSpeed = 150;</span>

    private boolean scrollVisible;
    private boolean fadeScrollEdge;
    private boolean fadeScrollBar;
<span class="fc" id="L127">    private int fadeScrollBarSpeed = 5;</span>
<span class="fc" id="L128">    private int fadeScrollEdgeLength = 15;</span>
    private Image fadeScrollTop;
    private Image fadeScrollBottom;
    private Image fadeScrollRight;
    private Image fadeScrollLeft;
<span class="fc" id="L133">    private final int fadeScrollEdgeStartAlpha = 0x999999;</span>
<span class="fc" id="L134">    private final int fadeScrollEdgeEndAlpha = 0;</span>
    private int textFieldCursorColor;

    private boolean backgroundImageDetermineSize;

    /**
     * Indicates whether softbuttons should be reversed from their default orientation
     */
    private boolean reverseSoftButtons;
    /**
     * This renderer is assigned to all Forms Menu's by default.
     */
    private ListCellRenderer menuRenderer;
<span class="fc" id="L147">    private final Image[] menuIcons = new Image[3];</span>

    /**
     * Allows defining a tactile touch device that vibrates when the user presses a component
     * that should respond with tactile feedback on a touch device (e.g. vibrate).
     * Setting this to 0 disables tactile feedback completely
     */
<span class="fc" id="L154">    private int tactileTouchDuration = 0;</span>

    /**
     * Indicates whether labels should end with 3 points by default
     */
<span class="fc" id="L159">    private boolean defaultEndsWith3Points = true;</span>

    /**
     * Indicates whether tensile drag should be active by default
     */
<span class="fc" id="L164">    private boolean defaultTensileDrag = true;</span>

    /**
     * Indicates whether tensile highlight should be active by default
     */
<span class="fc" id="L169">    private boolean defaultTensileHighlight = false;</span>

    /**
     * The MenuBar class
     */
<span class="fc" id="L174">    private Class menuBar = MenuBar.class;</span>

    private boolean defaultSnapToGrid;
    private boolean defaultAlwaysTensile;

    private Image tensileHighlightTopImage;
    private Image tensileHighlightBottomImage;
    private Image tensileGlowTopImage;
    private Image tensileGlowBottomImage;

    private final UIManager manager;

<span class="fc" id="L186">    public LookAndFeel(UIManager manager) {</span>
<span class="fc" id="L187">        this.manager = manager;</span>
<span class="fc" id="L188">    }</span>

    /**
     * Every component binds itself to the look and feel thus allowing the look
     * and feel to customize the component.  Binding occurs at the end of the
     * constructor when the component is in a valid state and ready to be used.
     * Notice that a component might be bound twice or more and it is the
     * responsibility of the LookAndFeel to protect against that.
     *
     * @param cmp component instance that may be customized by the look and feel
     */
    public void bind(Component cmp) {
<span class="nc" id="L200">    }</span>

    /**
     * Invoked when a look and feel is removed, allows a look and feel to release
     * resources related to binding components.
     *
     * @see #bind(Component)
     */
    public void uninstall() {
<span class="fc" id="L209">    }</span>

    /**
     * Invoked for drawing a button widget
     *
     * @param g graphics context
     * @param b component to draw
     * @deprecated this method is no longer used by the implementation, we shifted code away to improve performance
     */
    public abstract void drawButton(Graphics g, Button b);

    /**
     * Invoked for drawing a checkbox widget
     *
     * @param g  graphics context
     * @param cb component to draw
     */
    public abstract void drawCheckBox(Graphics g, Button cb);

    /**
     * Invoked for drawing a combo box widget
     *
     * @param g  graphics context
     * @param cb component to draw
     */
    public abstract void drawComboBox(Graphics g, List cb);

    /**
     * Invoked for drawing a label widget
     *
     * @param g graphics context
     * @param l component to draw
     * @deprecated this method is no longer used by the implementation, we shifted code away to improve performance
     */
    public abstract void drawLabel(Graphics g, Label l);

    /**
     * Calculates the text selection spans for a given label
     *
     * @param sel TextSelection instance
     * @param l   Label
     * @return A span representing the positions of characters in the label
     * @see TextSelection
     * @since 7.0
     */
    public abstract Span calculateLabelSpan(TextSelection sel, Label l);

    /**
     * Invoked for drawing a list widget
     *
     * @param g graphics context
     * @param l component to draw
     */
    public abstract void drawList(Graphics g, List l);

    /**
     * Invoked for drawing the radio button widget
     *
     * @param g  graphics context
     * @param rb component to draw
     */
    public abstract void drawRadioButton(Graphics g, Button rb);

    /**
     * Draw the given text area
     *
     * @param g  graphics context
     * @param ta component to draw
     */
    public abstract void drawTextArea(Graphics g, TextArea ta);

    /**
     * Calculates the Spans used in text selection for a given text area.
     *
     * @param sel The current TextSelection instance.
     * @param ta  The TextArea to calculate spans for.
     * @return The spans for the given text field.
     * @since 7.0
     */
    public abstract Spans calculateTextAreaSpan(TextSelection sel, TextArea ta);

    /**
     * Draws the text field without its cursor which is drawn in a separate method
     * input mode indication can also be drawn using this method.
     *
     * @param g  graphics context
     * @param ta component to draw
     */
    public abstract void drawTextField(Graphics g, TextArea ta);

    /**
     * Calculates the Spans used in text selection for a given text field.
     *
     * @param sel The current TextSelection instance.
     * @param ta  The textfield to calculate spans for.
     * @return The spans for the given text field.
     * @since 7.0
     */
    public abstract Spans calculateTextFieldSpan(TextSelection sel, TextArea ta);

    /**
     * Draws the cursor of the text field, blinking is handled simply by avoiding
     * a call to this method.
     *
     * @param g  graphics context
     * @param ta component to draw
     */
    public abstract void drawTextFieldCursor(Graphics g, TextArea ta);

    /**
     * Calculate the preferred size of the component
     *
     * @param b component whose size should be calculated
     * @return the preferred size for the button
     */
    public abstract Dimension getButtonPreferredSize(Button b);

    /**
     * Calculate the preferred size of the component
     *
     * @param cb component whose size should be calculated
     * @return the preferred size for the component
     */
    public abstract Dimension getCheckBoxPreferredSize(Button cb);

    /**
     * Calculate the preferred size of the component
     *
     * @param l component whose size should be calculated
     * @return the preferred size for the component
     */
    public abstract Dimension getLabelPreferredSize(Label l);

    /**
     * Calculate the preferred size of the component
     *
     * @param l component whose size should be calculated
     * @return the preferred size for the component
     */
    public abstract Dimension getListPreferredSize(List l);

    /**
     * Calculate the preferred size of the component
     *
     * @param rb component whose size should be calculated
     * @return the preferred size for the component
     */
    public abstract Dimension getRadioButtonPreferredSize(Button rb);

    //public abstract Dimension getSpinnerPreferredSize(Spinner sp);

    /**
     * Calculate the preferred size of the component
     *
     * @param ta   component whose size should be calculated
     * @param pref indicates whether preferred or scroll size should be returned
     * @return the preferred size for the component
     */
    public abstract Dimension getTextAreaSize(TextArea ta, boolean pref);

    /**
     * Calculate the preferred size of the component
     *
     * @param ta component whose size should be calculated
     * @return the preferred size for the component
     */
    public abstract Dimension getTextFieldPreferredSize(TextArea ta);

    /**
     * Calculate the preferred size of the component
     *
     * @param box component whose size should be calculated
     * @return the preferred size for the component
     */
    public abstract Dimension getComboBoxPreferredSize(List box);

    /**
     * Draws a vertical scroll bar in the given component
     *
     * @param g              graphics context
     * @param c              component to draw on
     * @param offsetRatio    ratio of the scroll bar from 0 to 1
     * @param blockSizeRatio block size for the scroll from 0 to 1
     */
    public void drawVerticalScroll(Graphics g, Component c, float offsetRatio, float blockSizeRatio) {
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">        if (verticalScroll == null) {</span>
<span class="nc" id="L395">            initScroll();</span>
        }
<span class="fc" id="L397">        int borderW = 0;</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">        if (c.getStyle().getBorder() != null) {</span>
<span class="fc" id="L399">            borderW = c.getStyle().getBorder().getThickness();</span>
        }
<span class="fc" id="L401">        int x = c.getX();</span>
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">        if (!c.isRTL()) {</span>
<span class="fc" id="L403">            x += c.getWidth() - getVerticalScrollWidth() - borderW;</span>
        } else {
<span class="nc" id="L405">            x += borderW;</span>
        }
<span class="fc" id="L407">        int y = c.getY();</span>
<span class="fc" id="L408">        int height = c.getHeight();</span>
<span class="fc" id="L409">        int width = getVerticalScrollWidth();</span>
<span class="fc" id="L410">        drawScroll(g, c, offsetRatio, blockSizeRatio, true, x, y, width, height, verticalScroll, verticalScrollThumb);</span>
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">        if (fadeScrollEdge) {</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">            if (offsetRatio &gt; 0) {</span>
<span class="nc bnc" id="L413" title="All 4 branches missed.">                if (fadeScrollTop == null || Display.getInstance().getDisplayWidth() != fadeScrollTop.getWidth()) {</span>
<span class="nc" id="L414">                    fadeScrollTop = generateFadeImage(fadeScrollEdgeStartAlpha, fadeScrollEdgeEndAlpha, c.getStyle().getBgColor(), false,</span>
<span class="nc" id="L415">                            Display.getInstance().getDisplayWidth(), fadeScrollEdgeLength);</span>
                }
<span class="nc" id="L417">                g.drawImage(fadeScrollTop, c.getX(), c.getY());</span>
            }
<span class="nc bnc" id="L419" title="All 2 branches missed.">            if (offsetRatio &lt; 1 - blockSizeRatio) {</span>
                // special case since when scrolling with the physical keys we leave
                // the margin out of the equasion
<span class="nc" id="L422">                int l = c.getScrollY() + c.getHeight() +</span>
<span class="nc" id="L423">                        c.getStyle().getVerticalMargins() +</span>
<span class="nc" id="L424">                        c.getStyle().getVerticalPadding();</span>

<span class="nc" id="L426">                int totalScroll = c.getScrollDimension().getHeight();</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">                if (l &gt;= totalScroll) {</span>
<span class="nc" id="L428">                    return;</span>
                }
<span class="nc bnc" id="L430" title="All 4 branches missed.">                if (fadeScrollBottom == null || Display.getInstance().getDisplayWidth() != fadeScrollBottom.getWidth()) {</span>
<span class="nc" id="L431">                    fadeScrollBottom = generateFadeImage(fadeScrollEdgeEndAlpha, fadeScrollEdgeStartAlpha, c.getStyle().getBgColor(), false,</span>
<span class="nc" id="L432">                            Display.getInstance().getDisplayWidth(), fadeScrollEdgeLength);</span>
                }
<span class="nc" id="L434">                g.drawImage(fadeScrollBottom, c.getX(), c.getY() + c.getHeight() - fadeScrollBottom.getHeight());</span>
            }
        }
<span class="fc" id="L437">    }</span>

    private Image generateFadeImage(int startColor, int endColor, int bgColor, boolean horizontal, int width, int height) {
<span class="nc" id="L440">        Image mute = Image.createImage(width, height);</span>
<span class="nc" id="L441">        mute.getGraphics().fillLinearGradient(startColor, endColor, 0, 0, width, height, horizontal);</span>
<span class="nc" id="L442">        Object mask = mute.createMask();</span>
<span class="nc" id="L443">        mute = Image.createImage(width, height);</span>
<span class="nc" id="L444">        Graphics gr = mute.getGraphics();</span>
<span class="nc" id="L445">        gr.setColor(bgColor);</span>
<span class="nc" id="L446">        gr.fillRect(0, 0, width, height);</span>
<span class="nc" id="L447">        return mute.applyMask(mask);</span>
    }

    /**
     * Draws a horizontal scroll bar in the given component
     *
     * @param g              graphics context
     * @param c              component to draw on
     * @param offsetRatio    ratio of the scroll bar from 0 to 1
     * @param blockSizeRatio block size for the scroll from 0 to 1
     */
    public void drawHorizontalScroll(Graphics g, Component c, float offsetRatio, float blockSizeRatio) {
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">        if (horizontalScroll == null) {</span>
<span class="nc" id="L460">            initScroll();</span>
        }
<span class="fc" id="L462">        int borderH = 0;</span>
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">        if (c.getStyle().getBorder() != null) {</span>
<span class="nc" id="L464">            borderH = c.getStyle().getBorder().getThickness();</span>
        }
<span class="fc" id="L466">        int x = c.getX();</span>
<span class="fc" id="L467">        int y = c.getY() + c.getHeight() - getHorizontalScrollHeight() - borderH;</span>

<span class="fc" id="L469">        int width = c.getWidth();</span>
<span class="fc" id="L470">        int height = getHorizontalScrollHeight();</span>
<span class="fc" id="L471">        drawScroll(g, c, offsetRatio, blockSizeRatio, false, x, y, width, height, horizontalScroll, horizontalScrollThumb);</span>
<span class="pc bpc" id="L472" title="1 of 2 branches missed.">        if (fadeScrollEdge) {</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">            if (offsetRatio &gt; 0) {</span>
<span class="nc bnc" id="L474" title="All 4 branches missed.">                if (fadeScrollLeft == null || Display.getInstance().getDisplayHeight() != fadeScrollLeft.getHeight()) {</span>
<span class="nc" id="L475">                    fadeScrollLeft = generateFadeImage(fadeScrollEdgeStartAlpha, fadeScrollEdgeEndAlpha, c.getStyle().getBgColor(), true, fadeScrollEdgeLength,</span>
<span class="nc" id="L476">                            Display.getInstance().getDisplayHeight());</span>
                }
<span class="nc" id="L478">                g.drawImage(fadeScrollLeft, c.getX(), c.getY());</span>
            }
<span class="nc bnc" id="L480" title="All 2 branches missed.">            if (offsetRatio &lt; 1 - blockSizeRatio) {</span>
                // special case since when scrolling with the physical keys we leave
                // the margin out of the equasion
<span class="nc" id="L483">                int l = c.getScrollX() + c.getWidth() +</span>
<span class="nc" id="L484">                        c.getStyle().getHorizontalMargins() +</span>
<span class="nc" id="L485">                        c.getStyle().getHorizontalPadding();</span>
<span class="nc" id="L486">                int totalScroll = c.getScrollDimension().getWidth();</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">                if (l &gt;= totalScroll) {</span>
<span class="nc" id="L488">                    return;</span>
                }
<span class="nc bnc" id="L490" title="All 4 branches missed.">                if (fadeScrollRight == null || Display.getInstance().getDisplayHeight() != fadeScrollRight.getHeight()) {</span>
<span class="nc" id="L491">                    fadeScrollRight = generateFadeImage(fadeScrollEdgeEndAlpha, fadeScrollEdgeStartAlpha, c.getStyle().getBgColor(), true, fadeScrollEdgeLength,</span>
<span class="nc" id="L492">                            Display.getInstance().getDisplayHeight());</span>
                }
<span class="nc" id="L494">                g.drawImage(fadeScrollRight, c.getX() + c.getWidth() - fadeScrollRight.getWidth(), c.getY());</span>
            }
        }
<span class="fc" id="L497">    }</span>

    private void drawScroll(Graphics g, Component c, float offsetRatio,
                            float blockSizeRatio, boolean isVertical, int x, int y, int width, int height,
                            Component scroll, Component scrollThumb) {
<span class="fc" id="L502">        Style scrollStyle = scroll.getUnselectedStyle();</span>
<span class="fc" id="L503">        Style scrollThumbStyle = scrollThumb.getUnselectedStyle();</span>

<span class="fc" id="L505">        int alpha = scrollStyle.getBgTransparency() &amp; 0xff;</span>
<span class="fc" id="L506">        int thumbAlpha = scrollThumbStyle.getBgTransparency() &amp; 0xff;</span>
<span class="fc" id="L507">        int originalAlpha = g.getAlpha();</span>
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">        if (fadeScrollBar) {</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">            if (scrollStyle.getBgTransparency() != 0) {</span>
<span class="nc" id="L510">                scrollStyle.setBgTransparency(c.getScrollOpacity(), true);</span>
            }
<span class="nc" id="L512">            scrollThumbStyle.setBgTransparency(c.getScrollOpacity(), true);</span>
<span class="nc" id="L513">            g.setAlpha(c.getScrollOpacity());</span>
        }
        // take margin into consideration when positioning the scroll
<span class="fc" id="L516">        int marginLeft = scrollStyle.getMarginLeft(c.isRTL());</span>
<span class="fc" id="L517">        int marginTop = scrollStyle.getMarginTop();</span>
<span class="fc" id="L518">        x += marginLeft;</span>
<span class="fc" id="L519">        width -= (marginLeft + scrollStyle.getMarginRight(c.isRTL()));</span>
<span class="fc" id="L520">        y += marginTop;</span>
<span class="fc" id="L521">        height -= (marginTop + scrollStyle.getMarginBottom());</span>

<span class="fc" id="L523">        scroll.setX(x);</span>
<span class="fc" id="L524">        scroll.setY(y);</span>
<span class="fc" id="L525">        scroll.setWidth(width);</span>
<span class="fc" id="L526">        scroll.setHeight(height);</span>

<span class="fc" id="L528">        int cx = g.getClipX();</span>
<span class="fc" id="L529">        int cy = g.getClipY();</span>
<span class="fc" id="L530">        int cw = g.getClipWidth();</span>
<span class="fc" id="L531">        int ch = g.getClipHeight();</span>

<span class="fc" id="L533">        scroll.paintComponent(g);</span>

<span class="fc" id="L535">        marginLeft = scrollThumbStyle.getMarginLeft(c.isRTL());</span>
<span class="fc" id="L536">        marginTop = scrollThumbStyle.getMarginTop();</span>
<span class="fc" id="L537">        x += marginLeft;</span>
<span class="fc" id="L538">        width -= (marginLeft + scrollThumbStyle.getMarginRight(c.isRTL()));</span>
<span class="fc" id="L539">        y += marginTop;</span>
<span class="fc" id="L540">        height -= (marginTop + scrollThumbStyle.getMarginBottom());</span>

        int offset, blockSize;

<span class="fc bfc" id="L544" title="All 2 branches covered.">        if (isVertical) {</span>
<span class="fc" id="L545">            blockSize = (int) (c.getHeight() * blockSizeRatio) + 2;</span>
<span class="fc" id="L546">            offset = (int) ((c.getHeight()) * offsetRatio);</span>
        } else {
<span class="fc" id="L548">            blockSize = (int) (c.getWidth() * blockSizeRatio) + 2;</span>
<span class="fc" id="L549">            offset = (int) ((c.getWidth()) * offsetRatio);</span>
        }

<span class="fc bfc" id="L552" title="All 2 branches covered.">        if (isVertical) {</span>
<span class="fc" id="L553">            scrollThumb.setX(x);</span>
<span class="fc" id="L554">            scrollThumb.setY(y + offset);</span>
<span class="fc" id="L555">            scrollThumb.setWidth(width);</span>
<span class="fc" id="L556">            scrollThumb.setHeight(blockSize);</span>
        } else {
<span class="fc" id="L558">            scrollThumb.setX(x + offset);</span>
<span class="fc" id="L559">            scrollThumb.setY(y);</span>
<span class="fc" id="L560">            scrollThumb.setWidth(blockSize);</span>
<span class="fc" id="L561">            scrollThumb.setHeight(height);</span>
        }

<span class="fc" id="L564">        g.setClip(cx, cy, cw, ch);</span>
<span class="fc" id="L565">        scrollThumb.paintComponent(g);</span>
<span class="fc" id="L566">        g.setClip(cx, cy, cw, ch);</span>
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">        if (fadeScrollBar) {</span>
<span class="nc" id="L568">            scrollStyle.setBgTransparency(alpha, true);</span>
<span class="nc" id="L569">            scrollThumbStyle.setBgTransparency(thumbAlpha, true);</span>
<span class="nc" id="L570">            g.setAlpha(originalAlpha);</span>
        }
<span class="fc" id="L572">    }</span>


    /**
     * Sets the foreground color and font for a generic component, reuse-able by most component
     * drawing code
     *
     * @param g graphics context
     * @param c component from which fg styles should be set
     */
    public void setFG(Graphics g, Component c) {
<span class="fc" id="L583">        Style s = c.getStyle();</span>
<span class="fc" id="L584">        g.setFont(s.getFont());</span>
<span class="fc" id="L585">        g.setColor(s.getFgColor());</span>
<span class="fc" id="L586">    }</span>

    /**
     * Returns the default width of a vertical scroll bar
     *
     * @return default width of a vertical scroll bar
     */
    public int getVerticalScrollWidth() {
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">        if (verticalScroll == null) {</span>
<span class="nc" id="L595">            initScroll();</span>
        }
<span class="fc" id="L597">        Style scrollStyle = verticalScroll.getStyle();</span>

        // bidi doesn't matter for width calculations
<span class="fc" id="L600">        return scrollStyle.getMarginLeftNoRTL() + scrollStyle.getMarginRightNoRTL() +</span>
<span class="fc" id="L601">                scrollStyle.getPaddingLeftNoRTL() + scrollStyle.getPaddingRightNoRTL();</span>
    }

    /**
     * Returns the default height of a horizontal scroll bar
     *
     * @return default height of a horizontal scroll bar
     */
    public int getHorizontalScrollHeight() {
<span class="pc bpc" id="L610" title="1 of 2 branches missed.">        if (horizontalScroll == null) {</span>
<span class="nc" id="L611">            initScroll();</span>
        }
<span class="fc" id="L613">        Style scrollStyle = horizontalScroll.getStyle();</span>

        // bidi doesn't matter for height calculations
<span class="fc" id="L616">        return scrollStyle.getMarginTop() + scrollStyle.getMarginBottom() +</span>
<span class="fc" id="L617">                scrollStyle.getPaddingTop() + scrollStyle.getPaddingBottom();</span>
    }

    /**
     * Draws generic component border
     */
    void drawBorder(Graphics g, Component c, int color, int borderWidth) {
<span class="nc" id="L624">        drawBorder(g, c, color, color, borderWidth);</span>
<span class="nc" id="L625">    }</span>

    /**
     * Draws generic component border
     */
    void drawBorder(Graphics g, Component c, int topAndRightColor, int bottomAndLeftColor, int borderWidth) {
<span class="nc" id="L631">        g.setColor(topAndRightColor);     //Text Component upper border color</span>

<span class="nc" id="L633">        g.fillRect(c.getX(), c.getY(), c.getWidth(), borderWidth);</span>
<span class="nc" id="L634">        g.fillRect(c.getX(), c.getY(), borderWidth, c.getHeight());</span>
<span class="nc" id="L635">        g.setColor(bottomAndLeftColor);     //Text Component lower border color</span>

<span class="nc" id="L637">        g.fillRect(c.getX(), c.getY() + c.getHeight() - borderWidth, c.getWidth(), borderWidth);</span>
<span class="nc" id="L638">        g.fillRect(c.getX() + c.getWidth() - borderWidth, c.getY(), borderWidth, c.getHeight());</span>
<span class="nc" id="L639">    }</span>

    /**
     * Allows us to define a default animation that will draw the transition for
     * entering a form
     *
     * @return default transition
     */
    public Transition getDefaultFormTransitionIn() {
<span class="fc" id="L648">        return defaultFormTransitionIn;</span>
    }

    /**
     * Allows us to define a default animation that will draw the transition for
     * entering a form
     *
     * @param defaultFormTransitionIn the default transition
     */
    public void setDefaultFormTransitionIn(Transition defaultFormTransitionIn) {
<span class="nc" id="L658">        this.defaultFormTransitionIn = defaultFormTransitionIn;</span>
<span class="nc" id="L659">    }</span>

    /**
     * Allows us to define a default animation that will draw the transition for
     * exiting a form
     *
     * @return default transition
     */
    public Transition getDefaultFormTransitionOut() {
<span class="fc" id="L668">        return defaultFormTransitionOut;</span>
    }

    /**
     * Allows us to define a default animation that will draw the transition for
     * exiting a form
     *
     * @param defaultFormTransitionOut the default transition
     */
    public void setDefaultFormTransitionOut(Transition defaultFormTransitionOut) {
<span class="nc" id="L678">        this.defaultFormTransitionOut = defaultFormTransitionOut;</span>
<span class="nc" id="L679">    }</span>

    /**
     * Allows us to define a default animation that will draw the transition for
     * entering a Menu
     *
     * @return default transition
     */
    public Transition getDefaultMenuTransitionIn() {
<span class="fc" id="L688">        return defaultMenuTransitionIn;</span>
    }

    /**
     * Allows us to define a default animation that will draw the transition for
     * entering a Menu
     *
     * @param defaultMenuTransitionIn the default transition
     */
    public void setDefaultMenuTransitionIn(Transition defaultMenuTransitionIn) {
<span class="nc" id="L698">        this.defaultMenuTransitionIn = defaultMenuTransitionIn;</span>
<span class="nc" id="L699">    }</span>

    /**
     * Allows us to define a default animation that will draw the transition for
     * exiting a Menu
     *
     * @return default transition
     */
    public Transition getDefaultMenuTransitionOut() {
<span class="fc" id="L708">        return defaultMenuTransitionOut;</span>
    }

    /**
     * Allows us to define a default animation that will draw the transition for
     * exiting a Menu
     *
     * @param defaultMenuTransitionOut the default transition
     */
    public void setDefaultMenuTransitionOut(Transition defaultMenuTransitionOut) {
<span class="nc" id="L718">        this.defaultMenuTransitionOut = defaultMenuTransitionOut;</span>
<span class="nc" id="L719">    }</span>

    /**
     * Allows us to define a default animation that will draw the transition for
     * entering a dialog
     *
     * @return default transition
     */
    public Transition getDefaultDialogTransitionIn() {
<span class="fc" id="L728">        return defaultDialogTransitionIn;</span>
    }

    /**
     * Allows us to define a default animation that will draw the transition for
     * entering a dialog
     *
     * @param defaultDialogTransitionIn the default transition
     */
    public void setDefaultDialogTransitionIn(Transition defaultDialogTransitionIn) {
<span class="nc" id="L738">        this.defaultDialogTransitionIn = defaultDialogTransitionIn;</span>
<span class="nc" id="L739">    }</span>

    /**
     * Allows us to define a default animation that will draw the transition for
     * exiting a dialog
     *
     * @return default transition
     */
    public Transition getDefaultDialogTransitionOut() {
<span class="fc" id="L748">        return defaultDialogTransitionOut;</span>
    }

    /**
     * Allows us to define a default animation that will draw the transition for
     * exiting a dialog
     *
     * @param defaultDialogTransitionOut the default transition
     */
    public void setDefaultDialogTransitionOut(Transition defaultDialogTransitionOut) {
<span class="nc" id="L758">        this.defaultDialogTransitionOut = defaultDialogTransitionOut;</span>
<span class="nc" id="L759">    }</span>

    /**
     * Tint color is set when a form is partially covered be it by a menu or by a
     * dialog. A look and feel can override this default value.
     *
     * @return default tint color
     */
    public int getDefaultFormTintColor() {
<span class="fc" id="L768">        return defaultFormTintColor;</span>
    }

    /**
     * Tint color is set when a form is partially covered be it by a menu or by a
     * dialog. A look and feel can override this default value.
     *
     * @param defaultFormTintColor the default tint color
     */
    public void setDefaultFormTintColor(int defaultFormTintColor) {
<span class="nc" id="L778">        this.defaultFormTintColor = defaultFormTintColor;</span>
<span class="nc" id="L779">    }</span>

    /**
     * This color is used to paint disable mode text color.
     *
     * @return the color value
     */
    public int getDisableColor() {
<span class="fc" id="L787">        return disableColor;</span>
    }

    /**
     * Simple setter to disable color
     *
     * @param disableColor the disable color value
     */
    public void setDisableColor(int disableColor) {
<span class="nc" id="L796">        this.disableColor = disableColor;</span>
<span class="nc" id="L797">    }</span>

    /**
     * Indicates whether lists and containers should have smooth scrolling by default
     *
     * @return true if smooth scrolling should be on by default
     */
    public boolean isDefaultSmoothScrolling() {
<span class="fc" id="L805">        return defaultSmoothScrolling;</span>
    }

    /**
     * Indicates whether lists and containers should have smooth scrolling by default
     *
     * @param defaultSmoothScrolling true if smooth scrolling should be on by default
     */
    public void setDefaultSmoothScrolling(boolean defaultSmoothScrolling) {
<span class="nc" id="L814">        this.defaultSmoothScrolling = defaultSmoothScrolling;</span>
<span class="nc" id="L815">    }</span>

    /**
     * Indicates the default speed for smooth scrolling
     *
     * @return speed for smooth scrollin
     */
    public int getDefaultSmoothScrollingSpeed() {
<span class="fc" id="L823">        return defaultSmoothScrollingSpeed;</span>
    }

    /**
     * Indicates the default speed for smooth scrolling
     *
     * @param defaultSmoothScrollingSpeed speed for smooth scrollin
     */
    public void setDefaultSmoothScrollingSpeed(int defaultSmoothScrollingSpeed) {
<span class="nc" id="L832">        this.defaultSmoothScrollingSpeed = defaultSmoothScrollingSpeed;</span>
<span class="nc" id="L833">    }</span>

    /**
     * Indicates whether softbuttons should be reversed from their default orientation
     *
     * @return true if softbuttons should be reversed
     */
    public boolean isReverseSoftButtons() {
<span class="fc" id="L841">        return reverseSoftButtons;</span>
    }

    /**
     * Indicates whether softbuttons should be reversed from their default orientation
     *
     * @param reverseSoftButtons true if softbuttons should be reversed
     */
    public void setReverseSoftButtons(boolean reverseSoftButtons) {
<span class="nc" id="L850">        this.reverseSoftButtons = reverseSoftButtons;</span>
<span class="nc" id="L851">    }</span>

    /**
     * This method returns the MenuBar class.
     *
     * @return the MenuBar class.
     * @deprecated this is no longer supported, Toolbar should be used as
     * the extension point
     */
    public Class getMenuBarClass() {
<span class="fc" id="L861">        return menuBar;</span>
    }

    /**
     * Simple setter for the MenuBar Class
     *
     * @param menuBar
     * @deprecated this is no longer supported, Toolbar should be used as
     * the extension point
     */
    public void setMenuBarClass(Class menuBar) {
<span class="nc" id="L872">        this.menuBar = menuBar;</span>
<span class="nc" id="L873">    }</span>


    /**
     * Returns the Menu default renderer
     *
     * @return default renderer for the menu
     */
    public ListCellRenderer getMenuRenderer() {
<span class="fc" id="L882">        return menuRenderer;</span>
    }

    /**
     * Sets the Menu default renderer
     *
     * @param menuRenderer default renderer for the menu
     */
    public void setMenuRenderer(ListCellRenderer menuRenderer) {
<span class="nc" id="L891">        this.menuRenderer = menuRenderer;</span>
<span class="nc" id="L892">    }</span>

    /**
     * Sets globally the Menu icons
     *
     * @param select select icon
     * @param cancel cancel icon
     * @param menu   menu icon
     */
    public void setMenuIcons(Image select, Image cancel, Image menu) {
<span class="nc" id="L902">        menuIcons[0] = select;</span>
<span class="nc" id="L903">        menuIcons[1] = cancel;</span>
<span class="nc" id="L904">        menuIcons[2] = menu;</span>

<span class="nc" id="L906">    }</span>

    /**
     * Simple getter for the menu icons
     *
     * @return an Image array at size of 3, where the first is the select image
     * the second is the cancel image and the last is the menu image.
     */
    public Image[] getMenuIcons() {
<span class="fc" id="L915">        return menuIcons;</span>
    }

    /**
     * Gets the ticker speed
     *
     * @return ticker speed in milliseconds
     */
    public long getTickerSpeed() {
<span class="fc" id="L924">        return tickerSpeed;</span>
    }

    /**
     * Sets the ticker speed
     *
     * @param tickerSpeed the speed in milliseconds
     */
    public void setTickerSpeed(long tickerSpeed) {
<span class="nc" id="L933">        this.tickerSpeed = tickerSpeed;</span>
<span class="nc" id="L934">    }</span>

    private void initScroll() {
<span class="fc" id="L937">        verticalScroll = new Label();</span>
<span class="fc" id="L938">        verticalScroll.setUIID(&quot;Scroll&quot;);</span>
<span class="fc" id="L939">        horizontalScroll = new Label();</span>
<span class="fc" id="L940">        horizontalScroll.setUIID(&quot;HorizontalScroll&quot;);</span>
<span class="fc" id="L941">        verticalScrollThumb = new Label();</span>
<span class="fc" id="L942">        verticalScrollThumb.setUIID(&quot;ScrollThumb&quot;);</span>
<span class="fc" id="L943">        horizontalScrollThumb = new Label();</span>
<span class="fc" id="L944">        horizontalScrollThumb.setUIID(&quot;HorizontalScrollThumb&quot;);</span>
<span class="fc" id="L945">    }</span>

    /**
     * This method is a callback to the LookAndFeel when a theme is being
     * changed in the UIManager
     *
     * @param completeClear indicates that the theme is set and not added
     */
    public void refreshTheme(boolean completeClear) {
<span class="fc" id="L954">        fadeScrollTop = null;</span>
<span class="fc" id="L955">        fadeScrollBottom = null;</span>
<span class="fc" id="L956">        fadeScrollRight = null;</span>
<span class="fc" id="L957">        fadeScrollLeft = null;</span>
<span class="fc" id="L958">        initScroll();</span>
<span class="pc bpc" id="L959" title="1 of 2 branches missed.">        if (menuRenderer != null) {</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">            if (menuRenderer instanceof Component) {</span>
<span class="nc" id="L961">                ((Component) menuRenderer).refreshTheme();</span>
            }
        }

<span class="fc" id="L965">        Toolbar.setGlobalToolbar(manager.isThemeConstant(&quot;globalToobarBool&quot;, Toolbar.isGlobalToolbar()));</span>

<span class="fc" id="L967">        boolean isTouch = Display.getInstance().isTouchScreenDevice();</span>
<span class="fc" id="L968">        scrollVisible = manager.isThemeConstant(&quot;scrollVisibleBool&quot;, true);</span>
<span class="fc" id="L969">        fadeScrollEdge = manager.isThemeConstant(&quot;fadeScrollEdgeBool&quot;, false);</span>
<span class="fc" id="L970">        fadeScrollEdgeLength = manager.getThemeConstant(&quot;fadeScrollEdgeInt&quot;, fadeScrollEdgeLength);</span>
<span class="fc" id="L971">        fadeScrollBar = manager.isThemeConstant(&quot;fadeScrollBarBool&quot;, false);</span>

<span class="fc" id="L973">        InputComponent.setMultiLineErrorMessage(manager.isThemeConstant(&quot;inputComponentErrorMultilineBool&quot;, false));</span>

        try {
<span class="fc" id="L976">            tickerSpeed = Long.parseLong(manager.getThemeConstant(&quot;tickerSpeedInt&quot;, &quot;&quot; + tickerSpeed));</span>
<span class="pc bpc" id="L977" title="1 of 2 branches missed.">            Label.setDefaultTickerEnabled(tickerSpeed &gt;= 1);</span>
<span class="nc" id="L978">        } catch (NumberFormatException err) {</span>
<span class="nc" id="L979">            Log.e(err);</span>
<span class="fc" id="L980">        }</span>

<span class="fc" id="L982">        Button.setCapsTextDefault(manager.isThemeConstant(&quot;capsButtonTextBool&quot;, false));</span>
<span class="fc" id="L983">        Button.setButtonRippleEffectDefault(manager.isThemeConstant(&quot;buttonRippleBool&quot;, false));</span>

<span class="fc" id="L985">        defaultFormTintColor = (int) Long.parseLong(manager.getThemeConstant(&quot;tintColor&quot;, Integer.toHexString(defaultFormTintColor)), 16);</span>
<span class="fc" id="L986">        disableColor = Integer.parseInt(manager.getThemeConstant(&quot;disabledColor&quot;, Integer.toHexString(disableColor)), 16);</span>
<span class="fc" id="L987">        Dialog.setDefaultDialogPosition(manager.getThemeConstant(&quot;dialogPosition&quot;, Dialog.getDefaultDialogPosition()));</span>
<span class="fc" id="L988">        Dialog.setCommandsAsButtons(manager.isThemeConstant(&quot;dialogButtonCommandsBool&quot;, Dialog.isCommandsAsButtons()));</span>
<span class="fc" id="L989">        Dialog.setDefaultBlurBackgroundRadius(manager.getThemeConstant(&quot;dialogBlurRadiusInt&quot;, (int) Dialog.getDefaultBlurBackgroundRadius()));</span>

<span class="fc" id="L991">        List.setDefaultIgnoreFocusComponentWhenUnfocused(manager.isThemeConstant(&quot;ignorListFocusBool&quot;, List.isDefaultIgnoreFocusComponentWhenUnfocused()));</span>

<span class="pc bpc" id="L993" title="1 of 2 branches missed.">        if (isTouch) {</span>
<span class="fc" id="L994">            Display.getInstance().setPureTouch(manager.isThemeConstant(&quot;pureTouchBool&quot;, Display.getInstance().isPureTouch()));</span>
        }

<span class="fc" id="L997">        int defaultTransitionSpeed = Integer.parseInt(manager.getThemeConstant(&quot;transitionSpeedInt&quot;, &quot;220&quot;));</span>
<span class="fc" id="L998">        String slideDir = manager.getThemeConstant(&quot;slideDirection&quot;, &quot;horizontal&quot;);</span>
<span class="fc" id="L999">        String dialogSlideDir = manager.getThemeConstant(&quot;dlgSlideDirection&quot;, &quot;vertical&quot;);</span>
<span class="fc" id="L1000">        String menuSlideDir = manager.getThemeConstant(&quot;menuSlideDirection&quot;, dialogSlideDir);</span>
<span class="fc" id="L1001">        boolean outdir = manager.isThemeConstant(&quot;slideOutDirBool&quot;, false);</span>
<span class="fc" id="L1002">        boolean indir = manager.isThemeConstant(&quot;slideInDirBool&quot;, true);</span>
<span class="fc" id="L1003">        boolean dialogOutdir = manager.isThemeConstant(&quot;dlgSlideOutDirBool&quot;, false);</span>
<span class="fc" id="L1004">        boolean dialogIndir = manager.isThemeConstant(&quot;dlgSlideInDirBool&quot;, true);</span>
<span class="fc" id="L1005">        boolean menuOutdir = manager.isThemeConstant(&quot;menuSlideOutDirBool&quot;, false);</span>
<span class="fc" id="L1006">        boolean menuIndir = manager.isThemeConstant(&quot;menuSlideInDirBool&quot;, true);</span>
<span class="fc" id="L1007">        defaultFormTransitionIn = getTransitionConstant(defaultFormTransitionIn, &quot;formTransitionIn&quot;, slideDir, defaultTransitionSpeed, indir);</span>
<span class="fc" id="L1008">        defaultFormTransitionOut = getTransitionConstant(defaultFormTransitionOut, &quot;formTransitionOut&quot;, slideDir, defaultTransitionSpeed, outdir);</span>
<span class="fc" id="L1009">        defaultMenuTransitionIn = getTransitionConstant(defaultMenuTransitionIn, &quot;menuTransitionIn&quot;, menuSlideDir, defaultTransitionSpeed, menuIndir);</span>
<span class="fc" id="L1010">        defaultMenuTransitionOut = getTransitionConstant(defaultMenuTransitionOut, &quot;menuTransitionOut&quot;, menuSlideDir, defaultTransitionSpeed, menuOutdir);</span>
<span class="fc" id="L1011">        defaultDialogTransitionIn = getTransitionConstant(defaultDialogTransitionIn, &quot;dialogTransitionIn&quot;, dialogSlideDir, defaultTransitionSpeed, dialogIndir);</span>
<span class="fc" id="L1012">        defaultDialogTransitionOut = getTransitionConstant(defaultDialogTransitionOut, &quot;dialogTransitionOut&quot;, dialogSlideDir, defaultTransitionSpeed, dialogOutdir);</span>
<span class="fc" id="L1013">        initCommandBehaviorConstant(manager.getThemeConstant(&quot;commandBehavior&quot;, null), completeClear);</span>
<span class="fc" id="L1014">        reverseSoftButtons = manager.isThemeConstant(&quot;reverseSoftButtonsBool&quot;, reverseSoftButtons);</span>
<span class="fc" id="L1015">        textFieldCursorColor = manager.getThemeConstant(&quot;textFieldCursorColorInt&quot;, 0);</span>

<span class="fc" id="L1017">        String gap = manager.getThemeConstant(&quot;labelGap&quot;, null);</span>
<span class="pc bpc" id="L1018" title="1 of 2 branches missed.">        if (gap != null) {</span>
<span class="nc" id="L1019">            Label.setDefaultGap(Display.getInstance().convertToPixels(Util.toFloatValue(gap)));</span>
        }

<span class="fc" id="L1022">        InfiniteProgress.setDefaultMaterialDesignMode(</span>
<span class="fc" id="L1023">                manager.isThemeConstant(&quot;infiniteProgressMaterialModeBool&quot;, false));</span>
<span class="fc" id="L1024">        InfiniteProgress.setDefaultMaterialDesignColor(</span>
<span class="fc" id="L1025">                manager.getThemeConstant(&quot;infiniteProgressMaterialColorInt&quot;, 0x6200ee));</span>

<span class="fc" id="L1027">        TextArea.setDefaultValign(manager.getThemeConstant(&quot;textCmpVAlignInt&quot;, TextArea.getDefaultValign()));</span>
<span class="fc" id="L1028">        defaultSnapToGrid = manager.isThemeConstant(&quot;snapGridBool&quot;, false);</span>
<span class="fc" id="L1029">        defaultAlwaysTensile = manager.isThemeConstant(&quot;alwaysTensileBool&quot;, false);</span>
<span class="fc" id="L1030">        defaultTensileDrag = manager.isThemeConstant(&quot;tensileDragBool&quot;, true);</span>
<span class="fc" id="L1031">        defaultEndsWith3Points = manager.isThemeConstant(&quot;endsWith3PointsBool&quot;, false);</span>
<span class="fc" id="L1032">        defaultTensileHighlight = manager.isThemeConstant(&quot;tensileHighlightBool&quot;, false);</span>
<span class="fc" id="L1033">        tensileHighlightBottomImage = null;</span>
<span class="fc" id="L1034">        tensileHighlightTopImage = null;</span>
<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">        if (defaultTensileHighlight) {</span>
<span class="nc" id="L1036">            tensileHighlightBottomImage = manager.getThemeImageConstant(&quot;tensileHighlightBottomImage&quot;);</span>
<span class="nc" id="L1037">            tensileHighlightTopImage = manager.getThemeImageConstant(&quot;tensileHighlightTopImage&quot;);</span>
<span class="nc" id="L1038">            tensileGlowBottomImage = manager.getThemeImageConstant(&quot;tensileGlowBottomImage&quot;);</span>
<span class="nc" id="L1039">            tensileGlowTopImage = manager.getThemeImageConstant(&quot;tensileGlowTopImage&quot;);</span>
<span class="nc bnc" id="L1040" title="All 4 branches missed.">            if (tensileHighlightBottomImage != null &amp;&amp; tensileHighlightTopImage != null) {</span>
<span class="nc" id="L1041">                defaultTensileDrag = true;</span>
<span class="nc" id="L1042">                defaultAlwaysTensile = false;</span>
            } else {
<span class="nc" id="L1044">                defaultTensileHighlight = false;</span>
            }
        }
<span class="fc" id="L1047">        backgroundImageDetermineSize = manager.isThemeConstant(&quot;bgImageSizeBool&quot;, false);</span>
<span class="fc" id="L1048">    }</span>

    private void initCommandBehaviorConstant(String c, boolean complete) {
<span class="pc bpc" id="L1051" title="1 of 2 branches missed.">        if (c != null) {</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">            if (c.equalsIgnoreCase(&quot;SoftKey&quot;)) {</span>
<span class="nc" id="L1053">                Display.getInstance().setCommandBehavior(Display.COMMAND_BEHAVIOR_SOFTKEY);</span>
<span class="nc" id="L1054">                return;</span>
            }
<span class="nc bnc" id="L1056" title="All 2 branches missed.">            if (c.equalsIgnoreCase(&quot;Touch&quot;)) {</span>
<span class="nc" id="L1057">                Display.getInstance().setCommandBehavior(Display.COMMAND_BEHAVIOR_TOUCH_MENU);</span>
<span class="nc" id="L1058">                return;</span>
            }
<span class="nc bnc" id="L1060" title="All 2 branches missed.">            if (c.equalsIgnoreCase(&quot;Bar&quot;)) {</span>
<span class="nc" id="L1061">                Display.getInstance().setCommandBehavior(Display.COMMAND_BEHAVIOR_BUTTON_BAR);</span>
<span class="nc" id="L1062">                return;</span>
            }
<span class="nc bnc" id="L1064" title="All 2 branches missed.">            if (c.equalsIgnoreCase(&quot;Title&quot;)) {</span>
<span class="nc" id="L1065">                Display.getInstance().setCommandBehavior(Display.COMMAND_BEHAVIOR_BUTTON_BAR_TITLE_BACK);</span>
<span class="nc" id="L1066">                return;</span>
            }
<span class="nc bnc" id="L1068" title="All 2 branches missed.">            if (c.equalsIgnoreCase(&quot;Right&quot;)) {</span>
<span class="nc" id="L1069">                Display.getInstance().setCommandBehavior(Display.COMMAND_BEHAVIOR_BUTTON_BAR_TITLE_RIGHT);</span>
<span class="nc" id="L1070">                return;</span>
            }
<span class="nc bnc" id="L1072" title="All 2 branches missed.">            if (c.equalsIgnoreCase(&quot;Native&quot;)) {</span>
<span class="nc" id="L1073">                Display.getInstance().setCommandBehavior(Display.COMMAND_BEHAVIOR_NATIVE);</span>
<span class="nc" id="L1074">                return;</span>
            }
<span class="nc bnc" id="L1076" title="All 2 branches missed.">            if (c.equalsIgnoreCase(&quot;ICS&quot;)) {</span>
<span class="nc" id="L1077">                Display.getInstance().setCommandBehavior(Display.COMMAND_BEHAVIOR_ICS);</span>
<span class="nc" id="L1078">                return;</span>
            }
<span class="nc bnc" id="L1080" title="All 2 branches missed.">            if (c.equalsIgnoreCase(&quot;SIDE&quot;)) {</span>
<span class="nc" id="L1081">                Log.p(&quot;WARNING: Theme sets the commandBehavior constant which is deprecated.  Please update the theme to NOT include this theme constant.  Using commandBehavior may cause your app to perform in unexpected ways.  In particular, using SIDE command behavior in conjunction with Toolbar.setOnTopSideMenu(true) may result in runtime exceptions.&quot;, Log.WARNING);</span>
<span class="nc" id="L1082">                Display.getInstance().setCommandBehavior(Display.COMMAND_BEHAVIOR_SIDE_NAVIGATION);</span>
<span class="nc" id="L1083">                setMenuBarClass(SideMenuBar.class);</span>
            }
        } else {
<span class="pc bpc" id="L1086" title="1 of 2 branches missed.">            if (complete) {</span>
<span class="fc" id="L1087">                Display.getInstance().setCommandBehavior(Display.COMMAND_BEHAVIOR_DEFAULT);</span>
            }
        }
<span class="fc" id="L1090">    }</span>

    private Transition getTransitionConstant(Transition t, String constant, String slideDir, int speed, boolean forward) {
<span class="fc" id="L1093">        Image img = manager.getThemeImageConstant(constant + &quot;Image&quot;);</span>
<span class="pc bpc" id="L1094" title="1 of 2 branches missed.">        if (img != null) {</span>
<span class="nc" id="L1095">            return CommonTransitions.createTimeline(img);</span>
        }
<span class="fc" id="L1097">        String val = manager.getThemeConstant(constant, null);</span>
<span class="pc bpc" id="L1098" title="1 of 2 branches missed.">        if (val == null) {</span>
<span class="fc" id="L1099">            return t;</span>
        }
<span class="nc bnc" id="L1101" title="All 2 branches missed.">        if (val.equalsIgnoreCase(&quot;empty&quot;)) {</span>
<span class="nc" id="L1102">            return CommonTransitions.createEmpty();</span>
        }
<span class="nc bnc" id="L1104" title="All 2 branches missed.">        if (val.equalsIgnoreCase(&quot;slide&quot;)) {</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">            if (slideDir.equalsIgnoreCase(&quot;horizontal&quot;)) {</span>
<span class="nc" id="L1106">                return CommonTransitions.createSlide(CommonTransitions.SLIDE_HORIZONTAL, forward, speed);</span>
            } else {
<span class="nc" id="L1108">                return CommonTransitions.createSlide(CommonTransitions.SLIDE_VERTICAL, forward, speed);</span>
            }
        }
<span class="nc bnc" id="L1111" title="All 2 branches missed.">        if (val.equalsIgnoreCase(&quot;cover&quot;)) {</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">            if (slideDir.equalsIgnoreCase(&quot;horizontal&quot;)) {</span>
<span class="nc" id="L1113">                return CommonTransitions.createCover(CommonTransitions.SLIDE_HORIZONTAL, forward, speed);</span>
            } else {
<span class="nc" id="L1115">                return CommonTransitions.createCover(CommonTransitions.SLIDE_VERTICAL, forward, speed);</span>
            }
        }
<span class="nc bnc" id="L1118" title="All 2 branches missed.">        if (val.equalsIgnoreCase(&quot;uncover&quot;)) {</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">            if (slideDir.equalsIgnoreCase(&quot;horizontal&quot;)) {</span>
<span class="nc" id="L1120">                return CommonTransitions.createUncover(CommonTransitions.SLIDE_HORIZONTAL, forward, speed);</span>
            } else {
<span class="nc" id="L1122">                return CommonTransitions.createUncover(CommonTransitions.SLIDE_VERTICAL, forward, speed);</span>
            }
        }
<span class="nc bnc" id="L1125" title="All 2 branches missed.">        if (val.equalsIgnoreCase(&quot;fslide&quot;)) {</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">            if (slideDir.equalsIgnoreCase(&quot;horizontal&quot;)) {</span>
<span class="nc" id="L1127">                return CommonTransitions.createFastSlide(CommonTransitions.SLIDE_HORIZONTAL, forward, speed);</span>
            } else {
<span class="nc" id="L1129">                return CommonTransitions.createFastSlide(CommonTransitions.SLIDE_VERTICAL, forward, speed);</span>
            }
        }
<span class="nc bnc" id="L1132" title="All 2 branches missed.">        if (val.equalsIgnoreCase(&quot;fade&quot;)) {</span>
<span class="nc" id="L1133">            return CommonTransitions.createFade(speed);</span>
        }
<span class="nc bnc" id="L1135" title="All 2 branches missed.">        if (val.equalsIgnoreCase(&quot;slidefade&quot;)) {</span>
<span class="nc" id="L1136">            return CommonTransitions.createSlideFadeTitle(forward, speed);</span>
        }
<span class="nc bnc" id="L1138" title="All 2 branches missed.">        if (val.equalsIgnoreCase(&quot;pulse&quot;)) {</span>
<span class="nc" id="L1139">            return CommonTransitions.createDialogPulsate();</span>
        }
<span class="nc bnc" id="L1141" title="All 2 branches missed.">        if (val.equalsIgnoreCase(&quot;bubble&quot;)) {</span>
<span class="nc" id="L1142">            BubbleTransition transition = new BubbleTransition(speed);</span>
<span class="nc" id="L1143">            transition.setRoundBubble(false);</span>
<span class="nc" id="L1144">            return transition;</span>
        }
<span class="nc" id="L1146">        return t;</span>
    }

    /**
     * Indicates whether the menu UI should target a touch based device or a
     * standard cell phone
     *
     * @return true for touch menus
     * @deprecated use Display.getCommandBehavior() == Display.COMMAND_BEHAVIOR_TOUCH_MENU
     */
    public boolean isTouchMenus() {
<span class="nc" id="L1157">        int t = Display.getInstance().getCommandBehavior();</span>
<span class="nc bnc" id="L1158" title="All 4 branches missed.">        return t == Display.COMMAND_BEHAVIOR_TOUCH_MENU ||</span>
<span class="nc bnc" id="L1159" title="All 2 branches missed.">                (t == Display.COMMAND_BEHAVIOR_DEFAULT &amp;&amp; Display.getInstance().isTouchScreenDevice());</span>
    }

    /**
     * Indicates whether the menu UI should target a touch based device or a
     * standard cell phone
     *
     * @param touchMenus true to enable touch menus false to disable
     * @deprecated use Display.setCommandBehavior(Display.COMMAND_BEHAVIOR_TOUCH_MENU)
     */
    public void setTouchMenus(boolean touchMenus) {
<span class="nc bnc" id="L1170" title="All 2 branches missed.">        if (touchMenus) {</span>
<span class="nc" id="L1171">            Display.getInstance().setCommandBehavior(Display.COMMAND_BEHAVIOR_TOUCH_MENU);</span>
        } else {
<span class="nc" id="L1173">            Display.getInstance().setCommandBehavior(Display.COMMAND_BEHAVIOR_SOFTKEY);</span>
        }
<span class="nc" id="L1175">    }</span>

    /**
     * Use this to check if the LookAndFeel is in RTL mode
     *
     * @return true if the LookAndFeel is in right-to-left mode, false otherwise
     */
    public boolean isRTL() {
<span class="fc" id="L1183">        return rtl;</span>
    }

    /**
     * Sets this LookAndFeel to operate in right-to-left mode.
     *
     * @param rtl - true if right-to-left, false if left-to-right
     */
    public void setRTL(boolean rtl) {
<span class="pc bpc" id="L1192" title="1 of 2 branches missed.">        if (UIManager.localeAccessible) {</span>
<span class="fc" id="L1193">            this.rtl = rtl;</span>
<span class="fc bfc" id="L1194" title="All 2 branches covered.">            if (rtl) {</span>
<span class="fc" id="L1195">                Display.getInstance().setBidiAlgorithm(true);</span>
            }
        }
<span class="fc" id="L1198">    }</span>

    /**
     * Allows defining a tactile touch device that vibrates when the user presses a component
     * that should respond with tactile feedback on a touch device (e.g. vibrate).
     * Setting this to 0 disables tactile feedback completely
     *
     * @return the tactileTouchDuration
     */
    public int getTactileTouchDuration() {
<span class="fc" id="L1208">        return tactileTouchDuration;</span>
    }

    /**
     * Allows defining a tactile touch device that vibrates when the user presses a component
     * that should respond with tactile feedback on a touch device (e.g. vibrate).
     * Setting this to 0 disables tactile feedback completely
     *
     * @param tactileTouchDuration the duration of vibration
     */
    public void setTactileTouchDuration(int tactileTouchDuration) {
<span class="nc" id="L1219">        this.tactileTouchDuration = tactileTouchDuration;</span>
<span class="nc" id="L1220">    }</span>

    /**
     * Indicates whether labels should end with 3 points by default
     *
     * @return whether labels should end with 3 points by default
     */
    public boolean isDefaultEndsWith3Points() {
<span class="fc" id="L1228">        return defaultEndsWith3Points;</span>
    }

    /**
     * Indicates whether labels should end with 3 points by default
     *
     * @param defaultEndsWith3Points True to indicates that labels should end with 3 points by default
     */
    public void setDefaultEndsWith3Points(boolean defaultEndsWith3Points) {
<span class="nc" id="L1237">        this.defaultEndsWith3Points = defaultEndsWith3Points;</span>
<span class="nc" id="L1238">    }</span>

    /**
     * Indicates whether tensile drag should be active by default
     *
     * @return whether tensile drag should be active by default
     */
    public boolean isDefaultTensileDrag() {
<span class="fc" id="L1246">        return defaultTensileDrag;</span>
    }

    /**
     * Indicates whether tensile drag should be active by default
     *
     * @param defaultTensileDrag true if tensile drag should be active by default
     */
    public void setDefaultTensileDrag(boolean defaultTensileDrag) {
<span class="nc" id="L1255">        this.defaultTensileDrag = defaultTensileDrag;</span>
<span class="nc" id="L1256">    }</span>

    /**
     * Indicates whether lists and containers should scroll only via focus and thus &quot;jump&quot; when
     * moving to a larger component as was the case in older versions of Codename One.
     *
     * @return true if focus scrolling is enabled
     */
    public boolean isFocusScrolling() {
<span class="fc" id="L1265">        return focusScrolling;</span>
    }

    /**
     * Indicates whether lists and containers should scroll only via focus and thus &quot;jump&quot; when
     * moving to a larger component as was the case in older versions of Codename One.
     *
     * @param focusScrolling true to enable focus scrolling
     */
    public void setFocusScrolling(boolean focusScrolling) {
<span class="nc" id="L1275">        this.focusScrolling = focusScrolling;</span>
<span class="nc" id="L1276">    }</span>

    /**
     * Indicates whether the edge of a scrollable area should fade out
     *
     * @return the fadeScrollEdge
     */
    public boolean isFadeScrollEdge() {
<span class="nc" id="L1284">        return fadeScrollEdge;</span>
    }

    /**
     * Indicates whether the edge of a scrollable area should fade out
     *
     * @param fadeScrollEdge the fadeScrollEdge to set
     */
    public void setFadeScrollEdge(boolean fadeScrollEdge) {
<span class="nc" id="L1293">        this.fadeScrollEdge = fadeScrollEdge;</span>
<span class="nc" id="L1294">    }</span>

    /**
     * Indicates whether the scrollbar should fade when unused
     *
     * @return the fadeScrollBar
     */
    public boolean isFadeScrollBar() {
<span class="fc" id="L1302">        return fadeScrollBar;</span>
    }

    /**
     * Indicates whether the scrollbar should fade when unused
     *
     * @param fadeScrollBar the fadeScrollBar to set
     */
    public void setFadeScrollBar(boolean fadeScrollBar) {
<span class="nc" id="L1311">        this.fadeScrollBar = fadeScrollBar;</span>
<span class="nc" id="L1312">    }</span>

    /**
     * Indicates the width/height of the fading edge to indicate scrolling
     *
     * @return the fadeScrollEdgeLength
     */
    public int getFadeScrollEdgeLength() {
<span class="nc" id="L1320">        return fadeScrollEdgeLength;</span>
    }

    /**
     * Indicates the width/height of the fading edge to indicate scrolling
     *
     * @param fadeScrollEdgeLength the fadeScrollEdgeLength to set
     */
    public void setFadeScrollEdgeLength(int fadeScrollEdgeLength) {
<span class="nc" id="L1329">        this.fadeScrollEdgeLength = fadeScrollEdgeLength;</span>
<span class="nc" id="L1330">    }</span>

    /**
     * The color of the text field cursor
     *
     * @return the textFieldCursorColor
     */
    public int getTextFieldCursorColor() {
<span class="fc" id="L1338">        return textFieldCursorColor;</span>
    }

    /**
     * The color of the text field cursor
     *
     * @param textFieldCursorColor the textFieldCursorColor to set
     */
    public void setTextFieldCursorColor(int textFieldCursorColor) {
<span class="nc" id="L1347">        this.textFieldCursorColor = textFieldCursorColor;</span>
<span class="nc" id="L1348">    }</span>

    /**
     * Indicates whether scrolling this component should jump to a specific location
     * in a grid
     *
     * @return the defaultSnapToGrid
     */
    public boolean isDefaultSnapToGrid() {
<span class="fc" id="L1357">        return defaultSnapToGrid;</span>
    }

    /**
     * Indicates whether scrolling this component should jump to a specific location
     * in a grid
     *
     * @param defaultSnapToGrid the defaultSnapToGrid to set
     */
    public void setDefaultSnapToGrid(boolean defaultSnapToGrid) {
<span class="nc" id="L1367">        this.defaultSnapToGrid = defaultSnapToGrid;</span>
<span class="nc" id="L1368">    }</span>

    /**
     * Enable the tensile drag to work even when a component doesn't have a scroll showable (scrollable flag still needs to be set to true)
     *
     * @return the defaultAlwaysTensile
     */
    public boolean isDefaultAlwaysTensile() {
<span class="fc" id="L1376">        return defaultAlwaysTensile;</span>
    }

    /**
     * Enable the tensile drag to work even when a component doesn't have a scroll showable (scrollable flag still needs to be set to true)
     *
     * @param defaultAlwaysTensile the defaultAlwaysTensile to set
     */
    public void setDefaultAlwaysTensile(boolean defaultAlwaysTensile) {
<span class="nc" id="L1385">        this.defaultAlwaysTensile = defaultAlwaysTensile;</span>
<span class="nc" id="L1386">    }</span>

    /**
     * Indicates whether tensile highlight should be active by default
     *
     * @return the defaultTensileHighlight
     */
    public boolean isDefaultTensileHighlight() {
<span class="fc" id="L1394">        return defaultTensileHighlight;</span>
    }

    /**
     * Paints the tensile hightlight image
     *
     * @param g       graphics destination for the tensile highlight image
     * @param top     destination of the tensile highlight image
     * @param opacity the opacity of the image
     */
    public void paintTensileHighlight(Component t, Graphics g, boolean top, int opacity) {
<span class="nc bnc" id="L1405" title="All 6 branches missed.">        if (opacity &gt; 0 &amp;&amp; tensileHighlightTopImage != null &amp;&amp; tensileHighlightBottomImage != null) {</span>
<span class="nc" id="L1406">            int absX = t.getAbsoluteX();</span>
<span class="nc" id="L1407">            int absY = t.getAbsoluteY();</span>
<span class="nc bnc" id="L1408" title="All 2 branches missed.">            if (tensileGlowTopImage != null) {</span>
<span class="nc" id="L1409">                int a = g.getAlpha();</span>
<span class="nc" id="L1410">                float aspect = ((float) tensileGlowTopImage.getWidth()) / ((float) Display.getInstance().getDisplayWidth());</span>
<span class="nc" id="L1411">                int newHeight = (int) (((float) tensileGlowTopImage.getHeight()) * aspect);</span>
<span class="nc bnc" id="L1412" title="All 2 branches missed.">                if (top) {</span>
                    // this is a pull to refresh operation
<span class="nc bnc" id="L1414" title="All 2 branches missed.">                    if (t.isAlwaysTensile()) {</span>
<span class="nc" id="L1415">                        return;</span>
                    }
<span class="nc" id="L1417">                    g.drawImage(tensileHighlightTopImage, absX, absY, t.getWidth(), tensileHighlightTopImage.getHeight());</span>
<span class="nc" id="L1418">                    g.setAlpha(opacity / 3);</span>
<span class="nc" id="L1419">                    g.drawImage(tensileGlowTopImage, absX, absY, t.getWidth(), newHeight);</span>
<span class="nc" id="L1420">                    g.setAlpha(a);</span>
                } else {
<span class="nc" id="L1422">                    g.drawImage(tensileHighlightBottomImage, absX, absY + t.getScrollY() + (t.getHeight() - tensileHighlightBottomImage.getHeight()), t.getWidth(), tensileHighlightBottomImage.getHeight());</span>
<span class="nc" id="L1423">                    g.setAlpha(opacity / 3);</span>
<span class="nc" id="L1424">                    g.drawImage(tensileGlowBottomImage, absX, absY + t.getScrollY() + (t.getHeight() - newHeight), t.getWidth(), newHeight);</span>
<span class="nc" id="L1425">                    g.setAlpha(a);</span>
                }
<span class="nc" id="L1427">            } else {</span>
<span class="nc" id="L1428">                int a = g.getAlpha();</span>
<span class="nc" id="L1429">                g.setAlpha(opacity);</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">                if (top) {</span>
                    // this is a pull to refresh operation
<span class="nc bnc" id="L1432" title="All 2 branches missed.">                    if (t.isAlwaysTensile()) {</span>
<span class="nc" id="L1433">                        g.setAlpha(a);</span>
<span class="nc" id="L1434">                        return;</span>
                    }
<span class="nc" id="L1436">                    g.drawImage(tensileHighlightTopImage, absX, absY, Display.getInstance().getDisplayWidth(), tensileHighlightTopImage.getHeight());</span>
                } else {
<span class="nc" id="L1438">                    g.drawImage(tensileHighlightBottomImage, absX, absY + t.getScrollY() + t.getHeight() - tensileHighlightBottomImage.getHeight(), Display.getInstance().getDisplayWidth(), tensileHighlightBottomImage.getHeight());</span>
                }
<span class="nc" id="L1440">                g.setAlpha(a);</span>
            }
        }
<span class="nc" id="L1443">    }</span>


    UIManager getUIManager() {
<span class="fc" id="L1447">        return manager;</span>
    }

    /**
     * @return the fadeScrollBarSpeed
     */
    public int getFadeScrollBarSpeed() {
<span class="fc" id="L1454">        return fadeScrollBarSpeed;</span>
    }

    /**
     * @param fadeScrollBarSpeed the fadeScrollBarSpeed to set
     */
    public void setFadeScrollBarSpeed(int fadeScrollBarSpeed) {
<span class="nc" id="L1461">        this.fadeScrollBarSpeed = fadeScrollBarSpeed;</span>
<span class="nc" id="L1462">    }</span>

    /**
     * @return scrollVisible
     */
    public boolean isScrollVisible() {
<span class="fc" id="L1468">        return scrollVisible;</span>
    }

    /**
     * Indicates if the bg image of a style should determine the minimum preferred size according to the theme
     *
     * @return the backgroundImageDetermineSize
     */
    public boolean isBackgroundImageDetermineSize() {
<span class="fc" id="L1477">        return backgroundImageDetermineSize;</span>
    }

    /**
     * Indicates if the bg image of a style should determine the minimum preferred size according to the theme
     *
     * @param backgroundImageDetermineSize the backgroundImageDetermineSize to set
     */
    public void setBackgroundImageDetermineSize(boolean backgroundImageDetermineSize) {
<span class="nc" id="L1486">        this.backgroundImageDetermineSize = backgroundImageDetermineSize;</span>
<span class="nc" id="L1487">    }</span>

    /**
     * Paints the pull to refresh
     *
     * @param g            graphics context
     * @param cmp          the Component which we draw the pull to refresh beneath it
     * @param taskExecuted an indication if the refresh task is currently running
     */
    public abstract void drawPullToRefresh(Graphics g, Component cmp, boolean taskExecuted);

    /**
     * Returns the required height of the pull to refresh feature
     */
    public abstract int getPullToRefreshHeight();

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>