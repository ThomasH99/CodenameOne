<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TBigInteger.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codenameone-core-unittests</a> &gt; <a href="index.source.html" class="el_package">com.codename1.util</a> &gt; <span class="el_source">TBigInteger.java</span></div><h1>TBigInteger.java</h1><pre class="source lang-java linenums">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the &quot;License&quot;); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.codename1.util;

import java.util.Random;

/**
 * This class represents immutable integer numbers of arbitrary length. Large
 * numbers are typically used in security applications and therefore BigIntegers
 * offer dedicated functionality like the generation of large prime numbers or
 * the computation of modular inverse.
 * &lt;p&gt;
 * Since the class was modeled to offer all the functionality as the
 * {@link Integer} class does, it provides even methods that operate bitwise on
 * a two's complement representation of large integers. Note however that the
 * implementations favors an internal representation where magnitude and sign
 * are treated separately. Hence such operations are inefficient and should be
 * discouraged. In simple words: Do NOT implement any bit fields based on
 * BigInteger.
 */
class TBigInteger {


    /* Fields used for the internal representation. */

    /**
     * The {@code BigInteger} constant 0.
     */
<span class="fc" id="L44">    public static final TBigInteger ZERO = new TBigInteger(0, 0);</span>
    /**
     * The {@code BigInteger} constant 1.
     */
<span class="fc" id="L48">    public static final TBigInteger ONE = new TBigInteger(1, 1);</span>
    /**
     * The {@code BigInteger} constant 10.
     */
<span class="fc" id="L52">    public static final TBigInteger TEN = new TBigInteger(1, 10);</span>
    /**
     * The {@code BigInteger} constant -1.
     */
<span class="fc" id="L56">    static final TBigInteger MINUS_ONE = new TBigInteger(-1, 1);</span>
    /**
     * The {@code BigInteger} constant 0 used for comparison.
     */
    static final int EQUALS = 0;
    /**
     * The {@code BigInteger} constant 1 used for comparison.
     */
    static final int GREATER = 1;
    /**
     * The {@code BigInteger} constant -1 used for comparison.
     */
    static final int LESS = -1;
    /**
     * All the {@code BigInteger} numbers in the range [0,10] are cached.
     */
<span class="fc" id="L72">    static final TBigInteger[] SMALL_VALUES = {ZERO, ONE, new TBigInteger(1, 2), new TBigInteger(1, 3),</span>
            new TBigInteger(1, 4), new TBigInteger(1, 5), new TBigInteger(1, 6), new TBigInteger(1, 7),
            new TBigInteger(1, 8), new TBigInteger(1, 9), TEN};
    static final TBigInteger[] TWO_POWS;

    static {
<span class="fc" id="L78">        TWO_POWS = new TBigInteger[32];</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">        for (int i = 0; i &lt; TWO_POWS.length; i++) {</span>
<span class="fc" id="L80">            TWO_POWS[i] = TBigInteger.valueOf(1L &lt;&lt; i);</span>
        }
<span class="fc" id="L82">    }</span>

    /**
     * The magnitude of this big integer. This array holds unsigned little
     * endian digits. For example: {@code 13} is represented as [ 13 ]
     * {@code -13} is represented as [ 13 ] {@code 2^32 + 13} is represented as
     * [ 13, 1 ] {@code 2^64 + 13} is represented as [ 13, 0, 1 ] {@code 2^31}
     * is represented as [ Integer.MIN_VALUE ] The magnitude array may be longer
     * than strictly necessary, which results in additional trailing zeros.
     */
    transient int[] digits;
    /**
     * The length of this in measured in ints. Can be less than digits.length().
     */
    transient int numberLength;
    /**
     * The sign of this.
     */
    transient int sign;
<span class="pc" id="L101">    private transient int firstNonzeroDigit = -2;</span>

    /**
     * Cache for the hash code.
     */
<span class="pc" id="L106">    private transient int hashCode = 0;</span>

    /**
     * Constructs a random non-negative {@code BigInteger} instance in the range
     * [0, 2^(numBits)-1].
     *
     * @param numBits maximum length of the new {@code BigInteger} in bits.
     * @param rnd     is an optional random generator to be used.
     * @throws IllegalArgumentException if {@code numBits} &lt; 0.
     */
<span class="nc" id="L116">    public TBigInteger(int numBits, Random rnd) {</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">        if (numBits &lt; 0) {</span>
<span class="nc" id="L118">            throw new IllegalArgumentException(&quot;numBits must be non-negative&quot;);</span>
        }
<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (numBits == 0) {</span>
<span class="nc" id="L121">            sign = 0;</span>
<span class="nc" id="L122">            numberLength = 1;</span>
<span class="nc" id="L123">            digits = new int[]{0};</span>
        } else {
<span class="nc" id="L125">            sign = 1;</span>
<span class="nc" id="L126">            numberLength = (numBits + 31) &gt;&gt; 5;</span>
<span class="nc" id="L127">            digits = new int[numberLength];</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">            for (int i = 0; i &lt; numberLength; i++) {</span>
<span class="nc" id="L129">                digits[i] = rnd.nextInt();</span>
            }
            // Using only the necessary bits
<span class="nc" id="L132">            digits[numberLength - 1] &gt;&gt;&gt;= (-numBits) &amp; 31;</span>
<span class="nc" id="L133">            cutOffLeadingZeroes();</span>
        }
<span class="nc" id="L135">    }</span>

    /**
     * Constructs a random {@code BigInteger} instance in the range [0,
     * 2^(bitLength)-1] which is probably prime. The probability that the
     * returned {@code BigInteger} is prime is beyond (1-1/2^certainty).
     *
     * @param bitLength length of the new {@code BigInteger} in bits.
     * @param certainty tolerated primality uncertainty.
     * @param rnd       is an optional random generator to be used.
     * @throws ArithmeticException if {@code bitLength} &lt; 2.
     */
<span class="fc" id="L147">    public TBigInteger(int bitLength, int certainty, Random rnd) {</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">        if (bitLength &lt; 2) {</span>
<span class="nc" id="L149">            throw new ArithmeticException(&quot;bitLength &lt; 2&quot;);</span>
        }
<span class="fc" id="L151">        TBigInteger me = TPrimality.consBigInteger(bitLength, certainty, rnd);</span>
<span class="fc" id="L152">        sign = me.sign;</span>
<span class="fc" id="L153">        numberLength = me.numberLength;</span>
<span class="fc" id="L154">        digits = me.digits;</span>
<span class="fc" id="L155">    }</span>

    /**
     * Constructs a new {@code BigInteger} instance from the string
     * representation. The string representation consists of an optional minus
     * sign followed by a non-empty sequence of decimal digits.
     *
     * @param val string representation of the new {@code BigInteger}.
     * @throws NullPointerException  if {@code val == null}.
     * @throws NumberFormatException if {@code val} is not a valid representation of a
     *                               {@code BigInteger}.
     */
    public TBigInteger(String val) {
<span class="fc" id="L168">        this(val, 10);</span>
<span class="fc" id="L169">    }</span>

    /**
     * Constructs a new {@code BigInteger} instance from the string
     * representation. The string representation consists of an optional minus
     * sign followed by a non-empty sequence of digits in the specified radix.
     * For the conversion the method {@code Character.digit(char, radix)} is
     * used.
     *
     * @param val   string representation of the new {@code BigInteger}.
     * @param radix the base to be used for the conversion.
     * @throws NullPointerException  if {@code val == null}.
     * @throws NumberFormatException if {@code val} is not a valid representation of a
     *                               {@code BigInteger} or if {@code radix &lt; Character.MIN_RADIX}
     *                               or {@code radix &gt; Character.MAX_RADIX}.
     */
<span class="fc" id="L185">    public TBigInteger(String val, int radix) {</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        if (val == null) {</span>
<span class="nc" id="L187">            throw new NullPointerException();</span>
        }
<span class="pc bpc" id="L189" title="2 of 4 branches missed.">        if ((radix &lt; Character.MIN_RADIX) || (radix &gt; Character.MAX_RADIX)) {</span>
<span class="nc" id="L190">            throw new NumberFormatException(&quot;Radix out of range&quot;);</span>
        }
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        if (val.length() == 0) {</span>
<span class="nc" id="L193">            throw new NumberFormatException(&quot;Zero length BigInteger&quot;);</span>
        }
<span class="fc" id="L195">        setFromString(this, val, radix);</span>
<span class="fc" id="L196">    }</span>

    /**
     * Constructs a new {@code BigInteger} instance with the given sign and the
     * given magnitude. The sign is given as an integer (-1 for negative, 0 for
     * zero, 1 for positive). The magnitude is specified as a byte array. The
     * most significant byte is the entry at index 0.
     *
     * @param signum    sign of the new {@code BigInteger} (-1 for negative, 0 for
     *                  zero, 1 for positive).
     * @param magnitude magnitude of the new {@code BigInteger} with the most
     *                  significant byte first.
     * @throws NullPointerException  if {@code magnitude == null}.
     * @throws NumberFormatException if the sign is not one of -1, 0, 1 or if the sign is zero and
     *                               the magnitude contains non-zero entries.
     */
<span class="nc" id="L212">    public TBigInteger(int signum, byte[] magnitude) {</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (magnitude == null) {</span>
<span class="nc" id="L214">            throw new NullPointerException();</span>
        }
<span class="nc bnc" id="L216" title="All 4 branches missed.">        if ((signum &lt; -1) || (signum &gt; 1)) {</span>
<span class="nc" id="L217">            throw new NumberFormatException(&quot;Invalid signum value&quot;);</span>
        }
<span class="nc bnc" id="L219" title="All 2 branches missed.">        if (signum == 0) {</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">            for (byte element : magnitude) {</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">                if (element != 0) {</span>
<span class="nc" id="L222">                    throw new NumberFormatException(&quot;signum-magnitude mismatch&quot;);</span>
                }
            }
        }
<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (magnitude.length == 0) {</span>
<span class="nc" id="L227">            sign = 0;</span>
<span class="nc" id="L228">            numberLength = 1;</span>
<span class="nc" id="L229">            digits = new int[]{0};</span>
        } else {
<span class="nc" id="L231">            sign = signum;</span>
<span class="nc" id="L232">            putBytesPositiveToIntegers(magnitude);</span>
<span class="nc" id="L233">            cutOffLeadingZeroes();</span>
        }
<span class="nc" id="L235">    }</span>

    /**
     * Constructs a new {@code BigInteger} from the given two's complement
     * representation. The most significant byte is the entry at index 0. The
     * most significant bit of this entry determines the sign of the new
     * {@code BigInteger} instance. The given array must not be empty.
     *
     * @param val two's complement representation of the new {@code BigInteger}.
     * @throws NullPointerException  if {@code val == null}.
     * @throws NumberFormatException if the length of {@code val} is zero.
     */
<span class="fc" id="L247">    public TBigInteger(byte[] val) {</span>
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        if (val.length == 0) {</span>
<span class="nc" id="L249">            throw new NumberFormatException(&quot;Zero length BigInteger&quot;);</span>
        }
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">        if (val[0] &lt; 0) {</span>
<span class="nc" id="L252">            sign = -1;</span>
<span class="nc" id="L253">            putBytesNegativeToIntegers(val);</span>
        } else {
<span class="fc" id="L255">            sign = 1;</span>
<span class="fc" id="L256">            putBytesPositiveToIntegers(val);</span>
        }
<span class="fc" id="L258">        cutOffLeadingZeroes();</span>
<span class="fc" id="L259">    }</span>

    /**
     * Constructs a number which array is of size 1.
     *
     * @param sign  the sign of the number
     * @param value the only one digit of array
     */
<span class="fc" id="L267">    TBigInteger(int sign, int value) {</span>
<span class="fc" id="L268">        this.sign = sign;</span>
<span class="fc" id="L269">        numberLength = 1;</span>
<span class="fc" id="L270">        digits = new int[]{value};</span>
<span class="fc" id="L271">    }</span>

    /**
     * Constructs a number without to create new space. This construct should be
     * used only if the three fields of representation are known.
     *
     * @param sign         the sign of the number
     * @param numberLength the length of the internal array
     * @param digits       a reference of some array created before
     */
<span class="fc" id="L281">    TBigInteger(int sign, int numberLength, int[] digits) {</span>
<span class="fc" id="L282">        this.sign = sign;</span>
<span class="fc" id="L283">        this.numberLength = numberLength;</span>
<span class="fc" id="L284">        this.digits = digits;</span>
<span class="fc" id="L285">    }</span>

    /**
     * Creates a new {@code BigInteger} whose value is equal to the specified
     * {@code long}.
     *
     * @param sign the sign of the number
     * @param val  the value of the new {@code BigInteger}.
     */
<span class="fc" id="L294">    TBigInteger(int sign, long val) {</span>
        // PRE: (val &gt;= 0) &amp;&amp; (sign &gt;= -1) &amp;&amp; (sign &lt;= 1)
<span class="fc" id="L296">        this.sign = sign;</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">        if ((val &amp; 0xFFFFFFFF00000000L) == 0) {</span>
            // It fits in one 'int'
<span class="fc" id="L299">            numberLength = 1;</span>
<span class="fc" id="L300">            digits = new int[]{(int) val};</span>
        } else {
<span class="fc" id="L302">            numberLength = 2;</span>
<span class="fc" id="L303">            digits = new int[]{(int) val, (int) (val &gt;&gt; 32)};</span>
        }
<span class="fc" id="L305">    }</span>

    /**
     * Creates a new {@code BigInteger} with the given sign and magnitude. This
     * constructor does not create a copy, so any changes to the reference will
     * affect the new number.
     *
     * @param signum The sign of the number represented by {@code digits}
     * @param digits The magnitude of the number
     */
<span class="fc" id="L315">    TBigInteger(int signum, int[] digits) {</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">        if (digits.length == 0) {</span>
<span class="fc" id="L317">            sign = 0;</span>
<span class="fc" id="L318">            numberLength = 1;</span>
<span class="fc" id="L319">            this.digits = new int[]{0};</span>
        } else {
<span class="nc" id="L321">            sign = signum;</span>
<span class="nc" id="L322">            numberLength = digits.length;</span>
<span class="nc" id="L323">            this.digits = digits;</span>
<span class="nc" id="L324">            cutOffLeadingZeroes();</span>
        }
<span class="fc" id="L326">    }</span>

    public static TBigInteger valueOf(long val) {
<span class="fc bfc" id="L329" title="All 2 branches covered.">        if (val &lt; 0) {</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">            if (val != -1) {</span>
<span class="fc" id="L331">                return new TBigInteger(-1, -val);</span>
            }
<span class="nc" id="L333">            return MINUS_ONE;</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">        } else if (val &lt;= 10) {</span>
<span class="fc" id="L335">            return SMALL_VALUES[(int) val];</span>
        } else {// (val &gt; 10)
<span class="fc" id="L337">            return new TBigInteger(1, val);</span>
        }
    }

    /**
     * @see TBigInteger#BigInteger(String, int)
     */
    private static void setFromString(TBigInteger bi, String val, int radix) {
        int sign;
        int[] digits;
        int numberLength;
<span class="fc" id="L348">        int stringLength = val.length();</span>
        int startChar;
<span class="fc" id="L350">        int endChar = stringLength;</span>

<span class="pc bpc" id="L352" title="1 of 2 branches missed.">        if (val.charAt(0) == '-') {</span>
<span class="nc" id="L353">            sign = -1;</span>
<span class="nc" id="L354">            startChar = 1;</span>
<span class="nc" id="L355">            stringLength--;</span>
        } else {
<span class="fc" id="L357">            sign = 1;</span>
<span class="fc" id="L358">            startChar = 0;</span>
        }
        /*
         * We use the following algorithm: split a string into portions of n
         * characters and convert each portion to an integer according to the
         * radix. Then convert an exp(radix, n) based number to binary using the
         * multiplication method. See D. Knuth, The Art of Computer Programming,
         * vol. 2.
         */

<span class="fc" id="L368">        int charsPerInt = TConversion.digitFitInInt[radix];</span>
<span class="fc" id="L369">        int bigRadixDigitsLength = stringLength / charsPerInt;</span>
<span class="fc" id="L370">        int topChars = stringLength % charsPerInt;</span>

<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (topChars != 0) {</span>
<span class="fc" id="L373">            bigRadixDigitsLength++;</span>
        }
<span class="fc" id="L375">        digits = new int[bigRadixDigitsLength];</span>
        // Get the maximal power of radix that fits in int
<span class="fc" id="L377">        int bigRadix = TConversion.bigRadices[radix - 2];</span>
        // Parse an input string and accumulate the BigInteger's magnitude
<span class="fc" id="L379">        int digitIndex = 0; // index of digits array</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">        int substrEnd = startChar + ((topChars == 0) ? charsPerInt : topChars);</span>
        int newDigit;

<span class="fc bfc" id="L383" title="All 2 branches covered.">        for (int substrStart = startChar; substrStart &lt; endChar; substrStart = substrEnd, substrEnd = substrStart +</span>
                charsPerInt) {
<span class="fc" id="L385">            int bigRadixDigit = Integer.parseInt(val.substring(substrStart, substrEnd), radix);</span>
<span class="fc" id="L386">            newDigit = TMultiplication.multiplyByInt(digits, digitIndex, bigRadix);</span>
<span class="fc" id="L387">            newDigit += TElementary.inplaceAdd(digits, digitIndex, bigRadixDigit);</span>
<span class="fc" id="L388">            digits[digitIndex++] = newDigit;</span>
        }
<span class="fc" id="L390">        numberLength = digitIndex;</span>
<span class="fc" id="L391">        bi.sign = sign;</span>
<span class="fc" id="L392">        bi.numberLength = numberLength;</span>
<span class="fc" id="L393">        bi.digits = digits;</span>
<span class="fc" id="L394">        bi.cutOffLeadingZeroes();</span>
<span class="fc" id="L395">    }</span>

    /**
     * Returns a random positive {@code BigInteger} instance in the range [0,
     * 2^(bitLength)-1] which is probably prime. The probability that the
     * returned {@code BigInteger} is prime is beyond (1-1/2^80).
     * &lt;p&gt;
     * &lt;b&gt;Implementation Note:&lt;/b&gt; Currently {@code rnd} is ignored.
     *
     * @param bitLength length of the new {@code BigInteger} in bits.
     * @param rnd       random generator used to generate the new {@code BigInteger}.
     * @return probably prime random {@code BigInteger} instance.
     * @throws IllegalArgumentException if {@code bitLength &lt; 2}.
     */
    public static TBigInteger probablePrime(int bitLength, Random rnd) {
<span class="fc" id="L410">        return new TBigInteger(bitLength, 100, rnd);</span>
    }

    static TBigInteger getPowerOfTwo(int exp) {
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">        if (exp &lt; TWO_POWS.length) {</span>
<span class="nc" id="L415">            return TWO_POWS[exp];</span>
        }
<span class="fc" id="L417">        int intCount = exp &gt;&gt; 5;</span>
<span class="fc" id="L418">        int bitN = exp &amp; 31;</span>
<span class="fc" id="L419">        int[] resDigits = new int[intCount + 1];</span>
<span class="fc" id="L420">        resDigits[intCount] = 1 &lt;&lt; bitN;</span>
<span class="fc" id="L421">        return new TBigInteger(1, intCount + 1, resDigits);</span>
    }

    /**
     * Returns the two's complement representation of this BigInteger in a byte
     * array.
     *
     * @return two's complement representation of {@code this}.
     */
    public byte[] toByteArray() {
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">        if (this.sign == 0) {</span>
<span class="nc" id="L432">            return new byte[]{0};</span>
        }
<span class="fc" id="L434">        TBigInteger temp = this;</span>
<span class="fc" id="L435">        int bitLen = bitLength();</span>
<span class="fc" id="L436">        int iThis = getFirstNonzeroDigit();</span>
<span class="fc" id="L437">        int bytesLen = (bitLen &gt;&gt; 3) + 1;</span>
        /*
         * Puts the little-endian int array representing the magnitude of this
         * BigInteger into the big-endian byte array.
         */
<span class="fc" id="L442">        byte[] bytes = new byte[bytesLen];</span>
<span class="fc" id="L443">        int firstByteNumber = 0;</span>
        int highBytes;
<span class="fc" id="L445">        int digitIndex = 0;</span>
<span class="fc" id="L446">        int bytesInInteger = 4;</span>
        int digit;
        int hB;

<span class="pc bpc" id="L450" title="1 of 2 branches missed.">        if (bytesLen - (numberLength &lt;&lt; 2) == 1) {</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">            bytes[0] = (byte) ((sign &lt; 0) ? -1 : 0);</span>
<span class="nc" id="L452">            highBytes = 4;</span>
<span class="nc" id="L453">            firstByteNumber++;</span>
        } else {
<span class="fc" id="L455">            hB = bytesLen &amp; 3;</span>
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">            highBytes = (hB == 0) ? 4 : hB;</span>
        }

<span class="fc" id="L459">        digitIndex = iThis;</span>
<span class="fc" id="L460">        bytesLen -= iThis &lt;&lt; 2;</span>

<span class="pc bpc" id="L462" title="1 of 2 branches missed.">        if (sign &lt; 0) {</span>
<span class="nc" id="L463">            digit = -temp.digits[digitIndex];</span>
<span class="nc" id="L464">            digitIndex++;</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">            if (digitIndex == numberLength) {</span>
<span class="nc" id="L466">                bytesInInteger = highBytes;</span>
            }
<span class="nc bnc" id="L468" title="All 2 branches missed.">            for (int i = 0; i &lt; bytesInInteger; i++, digit &gt;&gt;= 8) {</span>
<span class="nc" id="L469">                bytes[--bytesLen] = (byte) digit;</span>
            }
<span class="nc bnc" id="L471" title="All 2 branches missed.">            while (bytesLen &gt; firstByteNumber) {</span>
<span class="nc" id="L472">                digit = ~temp.digits[digitIndex];</span>
<span class="nc" id="L473">                digitIndex++;</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">                if (digitIndex == numberLength) {</span>
<span class="nc" id="L475">                    bytesInInteger = highBytes;</span>
                }
<span class="nc bnc" id="L477" title="All 2 branches missed.">                for (int i = 0; i &lt; bytesInInteger; i++, digit &gt;&gt;= 8) {</span>
<span class="nc" id="L478">                    bytes[--bytesLen] = (byte) digit;</span>
                }
            }
        } else {
<span class="fc bfc" id="L482" title="All 2 branches covered.">            while (bytesLen &gt; firstByteNumber) {</span>
<span class="fc" id="L483">                digit = temp.digits[digitIndex];</span>
<span class="fc" id="L484">                digitIndex++;</span>
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">                if (digitIndex == numberLength) {</span>
<span class="fc" id="L486">                    bytesInInteger = highBytes;</span>
                }
<span class="fc bfc" id="L488" title="All 2 branches covered.">                for (int i = 0; i &lt; bytesInInteger; i++, digit &gt;&gt;= 8) {</span>
<span class="fc" id="L489">                    bytes[--bytesLen] = (byte) digit;</span>
                }
            }
        }
<span class="fc" id="L493">        return bytes;</span>
    }

    /**
     * Returns a (new) {@code BigInteger} whose value is the absolute value of
     * {@code this}.
     *
     * @return {@code abs(this)}.
     */
    public TBigInteger abs() {
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">        return ((sign &lt; 0) ? new TBigInteger(1, numberLength, digits) : this);</span>
    }

    /**
     * Returns a new {@code BigInteger} whose value is the {@code -this}.
     *
     * @return {@code -this}.
     */
    public TBigInteger negate() {
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">        return ((sign == 0) ? this : new TBigInteger(-sign, numberLength, digits));</span>
    }

    /**
     * Returns a new {@code BigInteger} whose value is {@code this + val}.
     *
     * @param val value to be added to {@code this}.
     * @return {@code this + val}.
     * @throws NullPointerException if {@code val == null}.
     */
    public TBigInteger add(TBigInteger val) {
<span class="fc" id="L523">        return TElementary.add(this, val);</span>
    }

    /**
     * Returns a new {@code BigInteger} whose value is {@code this - val}.
     *
     * @param val value to be subtracted from {@code this}.
     * @return {@code this - val}.
     * @throws NullPointerException if {@code val == null}.
     */
    public TBigInteger subtract(TBigInteger val) {
<span class="fc" id="L534">        return TElementary.subtract(this, val);</span>
    }

    /**
     * Returns the sign of this {@code BigInteger}.
     *
     * @return {@code -1} if {@code this &lt; 0}, {@code 0} if {@code this == 0},
     * {@code 1} if {@code this &gt; 0}.
     */
    public int signum() {
<span class="fc" id="L544">        return sign;</span>
    }

    /**
     * Returns a new {@code BigInteger} whose value is {@code this &gt;&gt; n}. For
     * negative arguments, the result is also negative. The shift distance may
     * be negative which means that {@code this} is shifted left.
     * &lt;p&gt;
     * &lt;b&gt;Implementation Note:&lt;/b&gt; Usage of this method on negative values is
     * not recommended as the current implementation is not efficient.
     *
     * @param n shift distance
     * @return {@code this &gt;&gt; n} if {@code n &gt;= 0}; {@code this &lt;&lt; (-n)}
     * otherwise
     */
    public TBigInteger shiftRight(int n) {
<span class="pc bpc" id="L560" title="1 of 4 branches missed.">        if ((n == 0) || (sign == 0)) {</span>
<span class="fc" id="L561">            return this;</span>
        }
<span class="pc bpc" id="L563" title="1 of 2 branches missed.">        return ((n &gt; 0) ? TBitLevel.shiftRight(this, n) : TBitLevel.shiftLeft(this, -n));</span>
    }

    /**
     * Returns a new {@code BigInteger} whose value is {@code this &lt;&lt; n}. The
     * result is equivalent to {@code this * 2^n} if n &gt;= 0. The shift distance
     * may be negative which means that {@code this} is shifted right. The
     * result then corresponds to {@code floor(this / 2^(-n))}.
     * &lt;p&gt;
     * &lt;b&gt;Implementation Note:&lt;/b&gt; Usage of this method on negative values is
     * not recommended as the current implementation is not efficient.
     *
     * @param n shift distance.
     * @return {@code this &lt;&lt; n} if {@code n &gt;= 0}; {@code this &gt;&gt; (-n)}.
     * otherwise
     */
    public TBigInteger shiftLeft(int n) {
<span class="pc bpc" id="L580" title="1 of 4 branches missed.">        if ((n == 0) || (sign == 0)) {</span>
<span class="fc" id="L581">            return this;</span>
        }
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">        return ((n &gt; 0) ? TBitLevel.shiftLeft(this, n) : TBitLevel.shiftRight(this, -n));</span>
    }

    TBigInteger shiftLeftOneBit() {
<span class="nc bnc" id="L587" title="All 2 branches missed.">        return (sign == 0) ? this : TBitLevel.shiftLeftOneBit(this);</span>
    }

    /**
     * Returns the length of the value's two's complement representation without
     * leading zeros for positive numbers / without leading ones for negative
     * values.
     * &lt;p&gt;
     * The two's complement representation of {@code this} will be at least
     * {@code bitLength() + 1} bits long.
     * &lt;p&gt;
     * The value will fit into an {@code int} if {@code bitLength() &lt; 32} or
     * into a {@code long} if {@code bitLength() &lt; 64}.
     *
     * @return the length of the minimal two's complement representation for
     * {@code this} without the sign bit.
     */
    public int bitLength() {
<span class="fc" id="L605">        return TBitLevel.bitLength(this);</span>
    }

    /**
     * Tests whether the bit at position n in {@code this} is set. The result is
     * equivalent to {@code this &amp; (2^n) != 0}.
     * &lt;p&gt;
     * &lt;b&gt;Implementation Note:&lt;/b&gt; Usage of this method is not recommended as
     * the current implementation is not efficient.
     *
     * @param n position where the bit in {@code this} has to be inspected.
     * @return {@code this &amp; (2^n) != 0}.
     * @throws ArithmeticException if {@code n &lt; 0}.
     */
    public boolean testBit(int n) {
<span class="pc bpc" id="L620" title="1 of 2 branches missed.">        if (n == 0) {</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">            return ((digits[0] &amp; 1) != 0);</span>
        }
<span class="nc bnc" id="L623" title="All 2 branches missed.">        if (n &lt; 0) {</span>
<span class="nc" id="L624">            throw new ArithmeticException(&quot;Negative bit address&quot;);</span>
        }
<span class="nc" id="L626">        int intCount = n &gt;&gt; 5;</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">        if (intCount &gt;= numberLength) {</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">            return (sign &lt; 0);</span>
        }
<span class="nc" id="L630">        int digit = digits[intCount];</span>
<span class="nc" id="L631">        n = (1 &lt;&lt; (n &amp; 31)); // int with 1 set to the needed position</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">        if (sign &lt; 0) {</span>
<span class="nc" id="L633">            int firstNonZeroDigit = getFirstNonzeroDigit();</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">            if (intCount &lt; firstNonZeroDigit) {</span>
<span class="nc" id="L635">                return false;</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">            } else if (firstNonZeroDigit == intCount) {</span>
<span class="nc" id="L637">                digit = -digit;</span>
            } else {
<span class="nc" id="L639">                digit = ~digit;</span>
            }
        }
<span class="nc bnc" id="L642" title="All 2 branches missed.">        return ((digit &amp; n) != 0);</span>
    }

    /**
     * Returns a new {@code BigInteger} which has the same binary representation
     * as {@code this} but with the bit at position n set. The result is
     * equivalent to {@code this | 2^n}.
     * &lt;p&gt;
     * &lt;b&gt;Implementation Note:&lt;/b&gt; Usage of this method is not recommended as
     * the current implementation is not efficient.
     *
     * @param n position where the bit in {@code this} has to be set.
     * @return {@code this | 2^n}.
     * @throws ArithmeticException if {@code n &lt; 0}.
     */
    public TBigInteger setBit(int n) {
<span class="pc bpc" id="L658" title="1 of 2 branches missed.">        if (!testBit(n)) {</span>
<span class="nc" id="L659">            return TBitLevel.flipBit(this, n);</span>
        }
<span class="fc" id="L661">        return this;</span>
    }

    /**
     * Returns a new {@code BigInteger} which has the same binary representation
     * as {@code this} but with the bit at position n cleared. The result is
     * equivalent to {@code this &amp; ~(2^n)}.
     * &lt;p&gt;
     * &lt;b&gt;Implementation Note:&lt;/b&gt; Usage of this method is not recommended as
     * the current implementation is not efficient.
     *
     * @param n position where the bit in {@code this} has to be cleared.
     * @return {@code this &amp; ~(2^n)}.
     * @throws ArithmeticException if {@code n &lt; 0}.
     */
    public TBigInteger clearBit(int n) {
<span class="pc bpc" id="L677" title="1 of 2 branches missed.">        if (testBit(n)) {</span>
<span class="fc" id="L678">            return TBitLevel.flipBit(this, n);</span>
        }
<span class="nc" id="L680">        return this;</span>
    }

    /**
     * Returns a new {@code BigInteger} which has the same binary representation
     * as {@code this} but with the bit at position n flipped. The result is
     * equivalent to {@code this ^ 2^n}.
     * &lt;p&gt;
     * &lt;b&gt;Implementation Note:&lt;/b&gt; Usage of this method is not recommended as
     * the current implementation is not efficient.
     *
     * @param n position where the bit in {@code this} has to be flipped.
     * @return {@code this ^ 2^n}.
     * @throws ArithmeticException if {@code n &lt; 0}.
     */
    public TBigInteger flipBit(int n) {
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">        if (n &lt; 0) {</span>
<span class="nc" id="L697">            throw new ArithmeticException(&quot;Negative bit address&quot;);</span>
        }
<span class="fc" id="L699">        return TBitLevel.flipBit(this, n);</span>
    }

    /**
     * Returns the position of the lowest set bit in the two's complement
     * representation of this {@code BigInteger}. If all bits are zero (this=0)
     * then -1 is returned as result.
     * &lt;p&gt;
     * &lt;b&gt;Implementation Note:&lt;/b&gt; Usage of this method is not recommended as
     * the current implementation is not efficient.
     *
     * @return position of lowest bit if {@code this != 0}, {@code -1} otherwise
     */
    public int getLowestSetBit() {
<span class="pc bpc" id="L713" title="1 of 2 branches missed.">        if (sign == 0) {</span>
<span class="nc" id="L714">            return -1;</span>
        }
        // (sign != 0) implies that exists some non zero digit
<span class="fc" id="L717">        int i = getFirstNonzeroDigit();</span>
<span class="fc" id="L718">        return ((i &lt;&lt; 5) + TBigDecimal.numberOfTrailingZeros(digits[i]));</span>
    }

    /**
     * Use {@code bitLength(0)} if you want to know the length of the binary
     * value in bits.
     * &lt;p&gt;
     * Returns the number of bits in the binary representation of {@code this}
     * which differ from the sign bit. If {@code this} is positive the result is
     * equivalent to the number of bits set in the binary representation of
     * {@code this}. If {@code this} is negative the result is equivalent to the
     * number of bits set in the binary representation of {@code -this-1}.
     * &lt;p&gt;
     * &lt;b&gt;Implementation Note:&lt;/b&gt; Usage of this method is not recommended as
     * the current implementation is not efficient.
     *
     * @return number of bits in the binary representation of {@code this} which
     * differ from the sign bit
     */
    public int bitCount() {
<span class="nc" id="L738">        return TBitLevel.bitCount(this);</span>
    }

    /**
     * Returns a new {@code BigInteger} whose value is {@code ~this}. The result
     * of this operation is {@code -this-1}.
     * &lt;p&gt;
     * &lt;b&gt;Implementation Note:&lt;/b&gt; Usage of this method is not recommended as
     * the current implementation is not efficient.
     *
     * @return {@code ~this}.
     */
    public TBigInteger not() {
<span class="nc" id="L751">        return TLogical.not(this);</span>
    }

    /**
     * Returns a new {@code BigInteger} whose value is {@code this &amp; val}.
     * &lt;p&gt;
     * &lt;b&gt;Implementation Note:&lt;/b&gt; Usage of this method is not recommended as
     * the current implementation is not efficient.
     *
     * @param val value to be and'ed with {@code this}.
     * @return {@code this &amp; val}.
     * @throws NullPointerException if {@code val == null}.
     */
    public TBigInteger and(TBigInteger val) {
<span class="fc" id="L765">        return TLogical.and(this, val);</span>
    }

    /**
     * Returns a new {@code BigInteger} whose value is {@code this | val}.
     * &lt;p&gt;
     * &lt;b&gt;Implementation Note:&lt;/b&gt; Usage of this method is not recommended as
     * the current implementation is not efficient.
     *
     * @param val value to be or'ed with {@code this}.
     * @return {@code this | val}.
     * @throws NullPointerException if {@code val == null}.
     */
    public TBigInteger or(TBigInteger val) {
<span class="fc" id="L779">        return TLogical.or(this, val);</span>
    }

    /**
     * Returns a new {@code BigInteger} whose value is {@code this ^ val}.
     * &lt;p&gt;
     * &lt;b&gt;Implementation Note:&lt;/b&gt; Usage of this method is not recommended as
     * the current implementation is not efficient.
     *
     * @param val value to be xor'ed with {@code this}
     * @return {@code this ^ val}
     * @throws NullPointerException if {@code val == null}
     */
    public TBigInteger xor(TBigInteger val) {
<span class="fc" id="L793">        return TLogical.xor(this, val);</span>
    }

    /**
     * Returns a new {@code BigInteger} whose value is {@code this &amp; ~val}.
     * Evaluating {@code x.andNot(val)} returns the same result as
     * {@code x.and(val.not())}.
     * &lt;p&gt;
     * &lt;b&gt;Implementation Note:&lt;/b&gt; Usage of this method is not recommended as
     * the current implementation is not efficient.
     *
     * @param val value to be not'ed and then and'ed with {@code this}.
     * @return {@code this &amp; ~val}.
     * @throws NullPointerException if {@code val == null}.
     */
    public TBigInteger andNot(TBigInteger val) {
<span class="nc" id="L809">        return TLogical.andNot(this, val);</span>
    }

    /**
     * Returns this {@code BigInteger} as an int value. If {@code this} is too
     * big to be represented as an int, then {@code this} % 2^32 is returned.
     *
     * @return this {@code BigInteger} as an int value.
     */
    //@Override
    public int intValue() {
<span class="fc" id="L820">        return (sign * digits[0]);</span>
    }

    /**
     * Returns this {@code BigInteger} as a long value. If {@code this} is too
     * big to be represented as a long, then {@code this} % 2^64 is returned.
     *
     * @return this {@code BigInteger} as a long value.
     */
    //@Override
    public long longValue() {
<span class="pc bpc" id="L831" title="1 of 2 branches missed.">        long value = (numberLength &gt; 1) ? (((long) digits[1]) &lt;&lt; 32) | (digits[0] &amp; 0xFFFFFFFFL)</span>
                : (digits[0] &amp; 0xFFFFFFFFL);
<span class="fc" id="L833">        return (sign * value);</span>
    }

    /**
     * Returns this {@code BigInteger} as a float value. If {@code this} is too
     * big to be represented as a float, then {@code Float.POSITIVE_INFINITY}
     * or {@code Float.NEGATIVE_INFINITY} is returned. Note, that not all
     * integers x in the range [-Float.MAX_VALUE, Float.MAX_VALUE] can be
     * represented as a float. The float representation has a mantissa of length
     * 24. For example, 2^24+1 = 16777217 is returned as float 16777216.0.
     *
     * @return this {@code BigInteger} as a float value.
     */
    //@Override
    public float floatValue() {
<span class="nc" id="L848">        return (float) doubleValue();</span>
    }

    /**
     * Returns this {@code BigInteger} as a double value. If {@code this} is
     * too big to be represented as a double, then
     * {@code Double.POSITIVE_INFINITY} or {@code Double.NEGATIVE_INFINITY} is
     * returned. Note, that not all integers x in the range [-Double.MAX_VALUE,
     * Double.MAX_VALUE] can be represented as a double. The double
     * representation has a mantissa of length 53. For example, 2^53+1 =
     * 9007199254740993 is returned as double 9007199254740992.0.
     *
     * @return this {@code BigInteger} as a double value
     */
    //@Override
    public double doubleValue() {
<span class="nc" id="L864">        return TConversion.bigInteger2Double(this);</span>
    }

    /**
     * Compares this {@code BigInteger} with {@code val}. Returns one of the
     * three values 1, 0, or -1.
     *
     * @param val value to be compared with {@code this}.
     * @return {@code 1} if {@code this &gt; val}, {@code -1} if {@code this &lt; val}
     * , {@code 0} if {@code this == val}.
     * @throws NullPointerException if {@code val == null}.
     */
    //@Override
    public int compareTo(TBigInteger val) {
<span class="pc bpc" id="L878" title="1 of 2 branches missed.">        if (sign &gt; val.sign) {</span>
<span class="nc" id="L879">            return GREATER;</span>
        }
<span class="pc bpc" id="L881" title="1 of 2 branches missed.">        if (sign &lt; val.sign) {</span>
<span class="fc" id="L882">            return LESS;</span>
        }
<span class="nc bnc" id="L884" title="All 2 branches missed.">        if (numberLength &gt; val.numberLength) {</span>
<span class="nc" id="L885">            return sign;</span>
        }
<span class="nc bnc" id="L887" title="All 2 branches missed.">        if (numberLength &lt; val.numberLength) {</span>
<span class="nc" id="L888">            return -val.sign;</span>
        }
        // Equal sign and equal numberLength
<span class="nc" id="L891">        return (sign * TElementary.compareArrays(digits, val.digits, numberLength));</span>
    }

    /**
     * Returns the minimum of this {@code BigInteger} and {@code val}.
     *
     * @param val value to be used to compute the minimum with {@code this}.
     * @return {@code min(this, val)}.
     * @throws NullPointerException if {@code val == null}.
     */
    public TBigInteger min(TBigInteger val) {
<span class="nc bnc" id="L902" title="All 2 branches missed.">        return ((this.compareTo(val) == LESS) ? this : val);</span>
    }

    /**
     * Returns the maximum of this {@code BigInteger} and {@code val}.
     *
     * @param val value to be used to compute the maximum with {@code this}
     * @return {@code max(this, val)}
     * @throws NullPointerException if {@code val == null}
     */
    public TBigInteger max(TBigInteger val) {
<span class="nc bnc" id="L913" title="All 2 branches missed.">        return ((this.compareTo(val) == GREATER) ? this : val);</span>
    }

    /**
     * Returns a hash code for this {@code BigInteger}.
     *
     * @return hash code for {@code this}.
     */
    @Override
    public int hashCode() {
<span class="nc bnc" id="L923" title="All 2 branches missed.">        if (hashCode != 0) {</span>
<span class="nc" id="L924">            return hashCode;</span>
        }
<span class="nc bnc" id="L926" title="All 2 branches missed.">        for (int i = 0; i &lt; digits.length; i++) {</span>
<span class="nc" id="L927">            hashCode = (hashCode * 33 + (digits[i] &amp; 0xffffffff));</span>
        }
<span class="nc" id="L929">        hashCode = hashCode * sign;</span>
<span class="nc" id="L930">        return hashCode;</span>
    }

    /**
     * Returns {@code true} if {@code x} is a BigInteger instance and if this
     * instance is equal to this {@code BigInteger}.
     *
     * @param x object to be compared with {@code this}.
     * @return true if {@code x} is a BigInteger and {@code this == x},
     * {@code false} otherwise.
     */
    @Override
    public boolean equals(Object x) {
<span class="fc bfc" id="L943" title="All 2 branches covered.">        if (this == x) {</span>
<span class="fc" id="L944">            return true;</span>
        }
<span class="pc bpc" id="L946" title="1 of 2 branches missed.">        if (x instanceof TBigInteger) {</span>
<span class="fc" id="L947">            TBigInteger x1 = (TBigInteger) x;</span>
<span class="pc bpc" id="L948" title="1 of 6 branches missed.">            return sign == x1.sign &amp;&amp; numberLength == x1.numberLength &amp;&amp; equalsArrays(x1.digits);</span>
        }
<span class="nc" id="L950">        return false;</span>
    }

    boolean equalsArrays(final int[] b) {
        int i;
<span class="fc bfc" id="L955" title="All 4 branches covered.">        for (i = numberLength - 1; (i &gt;= 0) &amp;&amp; (digits[i] == b[i]); i--) {</span>
            // Empty
        }
<span class="fc bfc" id="L958" title="All 2 branches covered.">        return i &lt; 0;</span>
    }

    /**
     * Returns a string representation of this {@code BigInteger} in decimal
     * form.
     *
     * @return a string representation of {@code this} in decimal form.
     */
    @Override
    public String toString() {
<span class="fc" id="L969">        return TConversion.toDecimalScaledString(this, 0);</span>
    }

    /**
     * Returns a string containing a string representation of this
     * {@code BigInteger} with base radix. If
     * {@code radix &lt; Character.MIN_RADIX} or
     * {@code radix &gt; Character.MAX_RADIX} then a decimal representation is
     * returned. The characters of the string representation are generated with
     * method {@code Character.forDigit}.
     *
     * @param radix base to be used for the string representation.
     * @return a string representation of this with radix 10.
     */
    public String toString(int radix) {
<span class="nc" id="L984">        return TConversion.bigInteger2String(this, radix);</span>
    }

    /**
     * Returns a new {@code BigInteger} whose value is greatest common divisor
     * of {@code this} and {@code val}. If {@code this==0} and {@code val==0}
     * then zero is returned, otherwise the result is positive.
     *
     * @param val value with which the greatest common divisor is computed.
     * @return {@code gcd(this, val)}.
     * @throws NullPointerException if {@code val == null}.
     */
    public TBigInteger gcd(TBigInteger val) {
<span class="fc" id="L997">        TBigInteger val1 = this.abs();</span>
<span class="fc" id="L998">        TBigInteger val2 = val.abs();</span>
        // To avoid a possible division by zero
<span class="pc bpc" id="L1000" title="1 of 2 branches missed.">        if (val1.signum() == 0) {</span>
<span class="nc" id="L1001">            return val2;</span>
<span class="pc bpc" id="L1002" title="1 of 2 branches missed.">        } else if (val2.signum() == 0) {</span>
<span class="nc" id="L1003">            return val1;</span>
        }

        // Optimization for small operands
        // (op2.bitLength() &lt; 64) and (op1.bitLength() &lt; 64)
<span class="pc bpc" id="L1008" title="10 of 12 branches missed.">        if (((val1.numberLength == 1) || ((val1.numberLength == 2) &amp;&amp; (val1.digits[1] &gt; 0))) &amp;&amp;</span>
                (val2.numberLength == 1 || (val2.numberLength == 2 &amp;&amp; val2.digits[1] &gt; 0))) {
<span class="fc" id="L1010">            return TBigInteger.valueOf(TDivision.gcdBinary(val1.longValue(), val2.longValue()));</span>
        }

<span class="nc" id="L1013">        return TDivision.gcdBinary(val1.copy(), val2.copy());</span>

    }

    /**
     * Returns a new {@code BigInteger} whose value is {@code this * val}.
     *
     * @param val value to be multiplied with {@code this}.
     * @return {@code this * val}.
     * @throws NullPointerException if {@code val == null}.
     */
    public TBigInteger multiply(TBigInteger val) {
        // This let us to throw NullPointerException when val == null
<span class="pc bpc" id="L1026" title="1 of 2 branches missed.">        if (val.sign == 0) {</span>
<span class="nc" id="L1027">            return ZERO;</span>
        }
<span class="pc bpc" id="L1029" title="1 of 2 branches missed.">        if (sign == 0) {</span>
<span class="nc" id="L1030">            return ZERO;</span>
        }
<span class="fc" id="L1032">        return TMultiplication.multiply(this, val);</span>
    }

    /**
     * Returns a new {@code BigInteger} whose value is {@code this ^ exp}.
     *
     * @param exp exponent to which {@code this} is raised.
     * @return {@code this ^ exp}.
     * @throws ArithmeticException if {@code exp &lt; 0}.
     */
    public TBigInteger pow(int exp) {
<span class="pc bpc" id="L1043" title="1 of 2 branches missed.">        if (exp &lt; 0) {</span>
<span class="nc" id="L1044">            throw new ArithmeticException(&quot;Negative exponent&quot;);</span>
        }
<span class="pc bpc" id="L1046" title="1 of 2 branches missed.">        if (exp == 0) {</span>
<span class="nc" id="L1047">            return ONE;</span>
<span class="pc bpc" id="L1048" title="3 of 6 branches missed.">        } else if (exp == 1 || equals(ONE) || equals(ZERO)) {</span>
<span class="nc" id="L1049">            return this;</span>
        }

        // if even take out 2^x factor which we can
        // calculate by shifting.
<span class="pc bpc" id="L1054" title="1 of 2 branches missed.">        if (!testBit(0)) {</span>
<span class="nc" id="L1055">            int x = 1;</span>
<span class="nc bnc" id="L1056" title="All 2 branches missed.">            while (!testBit(x)) {</span>
<span class="nc" id="L1057">                x++;</span>
            }
<span class="nc" id="L1059">            return getPowerOfTwo(x * exp).multiply(this.shiftRight(x).pow(exp));</span>
        }
<span class="fc" id="L1061">        return TMultiplication.pow(this, exp);</span>
    }

    /**
     * Returns a {@code BigInteger} array which contains {@code this / divisor}
     * at index 0 and {@code this % divisor} at index 1.
     *
     * @param divisor value by which {@code this} is divided.
     * @return {@code [this / divisor, this % divisor]}.
     * @throws NullPointerException if {@code divisor == null}.
     * @throws ArithmeticException  if {@code divisor == 0}.
     * @see #divide
     * @see #remainder
     */
    public TBigInteger[] divideAndRemainder(TBigInteger divisor) {
<span class="fc" id="L1076">        int divisorSign = divisor.sign;</span>
<span class="pc bpc" id="L1077" title="1 of 2 branches missed.">        if (divisorSign == 0) {</span>
<span class="nc" id="L1078">            throw new ArithmeticException(&quot;BigInteger divide by zero&quot;);</span>
        }
<span class="fc" id="L1080">        int divisorLen = divisor.numberLength;</span>
<span class="fc" id="L1081">        int[] divisorDigits = divisor.digits;</span>
<span class="pc bpc" id="L1082" title="1 of 2 branches missed.">        if (divisorLen == 1) {</span>
<span class="fc" id="L1083">            return TDivision.divideAndRemainderByInteger(this, divisorDigits[0], divisorSign);</span>
        }
        // res[0] is a quotient and res[1] is a remainder:
<span class="nc" id="L1086">        int[] thisDigits = digits;</span>
<span class="nc" id="L1087">        int thisLen = numberLength;</span>
<span class="nc bnc" id="L1088" title="All 4 branches missed.">        int cmp = (thisLen != divisorLen) ? ((thisLen &gt; divisorLen) ? 1 : -1) : TElementary.compareArrays(thisDigits,</span>
                divisorDigits, thisLen);
<span class="nc bnc" id="L1090" title="All 2 branches missed.">        if (cmp &lt; 0) {</span>
<span class="nc" id="L1091">            return new TBigInteger[]{ZERO, this};</span>
        }
<span class="nc" id="L1093">        int thisSign = sign;</span>
<span class="nc" id="L1094">        int quotientLength = thisLen - divisorLen + 1;</span>
<span class="nc" id="L1095">        int remainderLength = divisorLen;</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">        int quotientSign = ((thisSign == divisorSign) ? 1 : -1);</span>
<span class="nc" id="L1097">        int[] quotientDigits = new int[quotientLength];</span>
<span class="nc" id="L1098">        int[] remainderDigits = TDivision.divide(quotientDigits, quotientLength, thisDigits, thisLen, divisorDigits,</span>
                divisorLen);
<span class="nc" id="L1100">        TBigInteger result0 = new TBigInteger(quotientSign, quotientLength, quotientDigits);</span>
<span class="nc" id="L1101">        TBigInteger result1 = new TBigInteger(thisSign, remainderLength, remainderDigits);</span>
<span class="nc" id="L1102">        result0.cutOffLeadingZeroes();</span>
<span class="nc" id="L1103">        result1.cutOffLeadingZeroes();</span>
<span class="nc" id="L1104">        return new TBigInteger[]{result0, result1};</span>
    }

    /**
     * Returns a new {@code BigInteger} whose value is {@code this / divisor}.
     *
     * @param divisor value by which {@code this} is divided.
     * @return {@code this / divisor}.
     * @throws NullPointerException if {@code divisor == null}.
     * @throws ArithmeticException  if {@code divisor == 0}.
     */
    public TBigInteger divide(TBigInteger divisor) {
<span class="pc bpc" id="L1116" title="1 of 2 branches missed.">        if (divisor.sign == 0) {</span>
<span class="nc" id="L1117">            throw new ArithmeticException(&quot;BigInteger divide by zero&quot;);</span>
        }
<span class="fc" id="L1119">        int divisorSign = divisor.sign;</span>
<span class="pc bpc" id="L1120" title="1 of 2 branches missed.">        if (divisor.isOne()) {</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">            return ((divisor.sign &gt; 0) ? this : this.negate());</span>
        }
<span class="fc" id="L1123">        int thisSign = sign;</span>
<span class="fc" id="L1124">        int thisLen = numberLength;</span>
<span class="fc" id="L1125">        int divisorLen = divisor.numberLength;</span>
<span class="pc bpc" id="L1126" title="1 of 2 branches missed.">        if (thisLen + divisorLen == 2) {</span>
<span class="fc" id="L1127">            long val = (digits[0] &amp; 0xFFFFFFFFL) / (divisor.digits[0] &amp; 0xFFFFFFFFL);</span>
<span class="pc bpc" id="L1128" title="1 of 2 branches missed.">            if (thisSign != divisorSign) {</span>
<span class="nc" id="L1129">                val = -val;</span>
            }
<span class="fc" id="L1131">            return valueOf(val);</span>
        }
<span class="nc bnc" id="L1133" title="All 4 branches missed.">        int cmp = ((thisLen != divisorLen) ? ((thisLen &gt; divisorLen) ? 1 : -1) : TElementary.compareArrays(digits,</span>
                divisor.digits, thisLen));
<span class="nc bnc" id="L1135" title="All 2 branches missed.">        if (cmp == EQUALS) {</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">            return ((thisSign == divisorSign) ? ONE : MINUS_ONE);</span>
        }
<span class="nc bnc" id="L1138" title="All 2 branches missed.">        if (cmp == LESS) {</span>
<span class="nc" id="L1139">            return ZERO;</span>
        }
<span class="nc" id="L1141">        int resLength = thisLen - divisorLen + 1;</span>
<span class="nc" id="L1142">        int[] resDigits = new int[resLength];</span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">        int resSign = ((thisSign == divisorSign) ? 1 : -1);</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">        if (divisorLen == 1) {</span>
<span class="nc" id="L1145">            TDivision.divideArrayByInt(resDigits, digits, thisLen, divisor.digits[0]);</span>
        } else {
<span class="nc" id="L1147">            TDivision.divide(resDigits, resLength, digits, thisLen, divisor.digits, divisorLen);</span>
        }
<span class="nc" id="L1149">        TBigInteger result = new TBigInteger(resSign, resLength, resDigits);</span>
<span class="nc" id="L1150">        result.cutOffLeadingZeroes();</span>
<span class="nc" id="L1151">        return result;</span>
    }

    /**
     * Returns a new {@code BigInteger} whose value is {@code this % divisor}.
     * Regarding signs this methods has the same behavior as the % operator on
     * int's, i.e. the sign of the remainder is the same as the sign of this.
     *
     * @param divisor value by which {@code this} is divided.
     * @return {@code this % divisor}.
     * @throws NullPointerException if {@code divisor == null}.
     * @throws ArithmeticException  if {@code divisor == 0}.
     */
    public TBigInteger remainder(TBigInteger divisor) {
<span class="pc bpc" id="L1165" title="1 of 2 branches missed.">        if (divisor.sign == 0) {</span>
<span class="nc" id="L1166">            throw new ArithmeticException(&quot;BigInteger divide by zero&quot;);</span>
        }
<span class="fc" id="L1168">        int thisLen = numberLength;</span>
<span class="fc" id="L1169">        int divisorLen = divisor.numberLength;</span>
<span class="pc bpc" id="L1170" title="2 of 6 branches missed.">        if (((thisLen != divisorLen) ? ((thisLen &gt; divisorLen) ? 1 : -1) : TElementary.compareArrays(digits,</span>
                divisor.digits, thisLen)) == LESS) {
<span class="nc" id="L1172">            return this;</span>
        }
<span class="fc" id="L1174">        int resLength = divisorLen;</span>
<span class="fc" id="L1175">        int[] resDigits = new int[resLength];</span>
<span class="pc bpc" id="L1176" title="1 of 2 branches missed.">        if (resLength == 1) {</span>
<span class="fc" id="L1177">            resDigits[0] = TDivision.remainderArrayByInt(digits, thisLen, divisor.digits[0]);</span>
        } else {
<span class="nc" id="L1179">            int qLen = thisLen - divisorLen + 1;</span>
<span class="nc" id="L1180">            resDigits = TDivision.divide(null, qLen, digits, thisLen, divisor.digits, divisorLen);</span>
        }
<span class="fc" id="L1182">        TBigInteger result = new TBigInteger(sign, resLength, resDigits);</span>
<span class="fc" id="L1183">        result.cutOffLeadingZeroes();</span>
<span class="fc" id="L1184">        return result;</span>
    }

    /**
     * Returns a new {@code BigInteger} whose value is {@code 1/this mod m}. The
     * modulus {@code m} must be positive. The result is guaranteed to be in the
     * interval {@code [0, m)} (0 inclusive, m exclusive). If {@code this} is
     * not relatively prime to m, then an exception is thrown.
     *
     * @param m the modulus.
     * @return {@code 1/this mod m}.
     * @throws NullPointerException if {@code m == null}
     * @throws ArithmeticException  if {@code m &lt; 0 or} if {@code this} is not relatively prime
     *                              to {@code m}
     */
    public TBigInteger modInverse(TBigInteger m) {
<span class="nc bnc" id="L1200" title="All 2 branches missed.">        if (m.sign &lt;= 0) {</span>
<span class="nc" id="L1201">            throw new ArithmeticException(&quot;BigInteger: modulus not positive&quot;);</span>
        }
        // If both are even, no inverse exists
<span class="nc bnc" id="L1204" title="All 4 branches missed.">        if (!(testBit(0) || m.testBit(0))) {</span>
<span class="nc" id="L1205">            throw new ArithmeticException(&quot;BigInteger not invertible.&quot;);</span>
        }
<span class="nc bnc" id="L1207" title="All 2 branches missed.">        if (m.isOne()) {</span>
<span class="nc" id="L1208">            return ZERO;</span>
        }

        // From now on: (m &gt; 1)
<span class="nc" id="L1212">        TBigInteger res = TDivision.modInverseMontgomery(abs().mod(m), m);</span>
<span class="nc bnc" id="L1213" title="All 2 branches missed.">        if (res.sign == 0) {</span>
<span class="nc" id="L1214">            throw new ArithmeticException(&quot;BigInteger not invertible.&quot;);</span>
        }

<span class="nc bnc" id="L1217" title="All 2 branches missed.">        res = ((sign &lt; 0) ? m.subtract(res) : res);</span>
<span class="nc" id="L1218">        return res;</span>

    }

    /**
     * Returns a new {@code BigInteger} whose value is {@code this^exponent mod
     * m}. The modulus {@code m} must be positive. The result is guaranteed to
     * be in the interval {@code [0, m)} (0 inclusive, m exclusive). If the
     * exponent is negative, then {@code this.modInverse(m)^(-exponent) mod m)}
     * is computed. The inverse of this only exists if {@code this} is
     * relatively prime to m, otherwise an exception is thrown.
     *
     * @param exponent the exponent.
     * @param m        the modulus.
     * @return {@code this^exponent mod val}.
     * @throws NullPointerException if {@code m == null} or {@code exponent == null}.
     * @throws ArithmeticException  if {@code m &lt; 0} or if {@code exponent&lt;0} and this is not
     *                              relatively prime to {@code m}.
     */
    public TBigInteger modPow(TBigInteger exponent, TBigInteger m) {
<span class="pc bpc" id="L1238" title="1 of 2 branches missed.">        if (m.sign &lt;= 0) {</span>
<span class="nc" id="L1239">            throw new ArithmeticException(&quot;BigInteger: modulus not positive&quot;);</span>
        }
<span class="fc" id="L1241">        TBigInteger base = this;</span>

<span class="pc bpc" id="L1243" title="3 of 6 branches missed.">        if (m.isOne() | (exponent.sign &gt; 0 &amp; base.sign == 0)) {</span>
<span class="nc" id="L1244">            return TBigInteger.ZERO;</span>
        }
<span class="pc bpc" id="L1246" title="1 of 2 branches missed.">        if (exponent.sign == 0) {</span>
<span class="nc" id="L1247">            return TBigInteger.ONE.mod(m);</span>
        }
<span class="pc bpc" id="L1249" title="1 of 2 branches missed.">        if (exponent.sign &lt; 0) {</span>
<span class="nc" id="L1250">            base = modInverse(m);</span>
<span class="nc" id="L1251">            exponent = exponent.negate();</span>
        }
        // From now on: (m &gt; 0) and (exponent &gt;= 0)
<span class="pc bpc" id="L1254" title="1 of 2 branches missed.">        TBigInteger res = (m.testBit(0)) ? TDivision.oddModPow(base.abs(), exponent, m) : TDivision.evenModPow(</span>
<span class="nc" id="L1255">                base.abs(), exponent, m);</span>
<span class="pc bpc" id="L1256" title="3 of 4 branches missed.">        if ((base.sign &lt; 0) &amp;&amp; exponent.testBit(0)) {</span>
            // -b^e mod m == ((-1 mod m) * (b^e mod m)) mod m
<span class="nc" id="L1258">            res = m.subtract(TBigInteger.ONE).multiply(res).mod(m);</span>
        }
        // else exponent is even, so base^exp is positive
<span class="fc" id="L1261">        return res;</span>
    }

    /**
     * Returns a new {@code BigInteger} whose value is {@code this mod m}. The
     * modulus {@code m} must be positive. The result is guaranteed to be in the
     * interval {@code [0, m)} (0 inclusive, m exclusive). The behavior of this
     * function is not equivalent to the behavior of the % operator defined for
     * the built-in {@code int}'s.
     *
     * @param m the modulus.
     * @return {@code this mod m}.
     * @throws NullPointerException if {@code m == null}.
     * @throws ArithmeticException  if {@code m &lt; 0}.
     */
    public TBigInteger mod(TBigInteger m) {
<span class="pc bpc" id="L1277" title="1 of 2 branches missed.">        if (m.sign &lt;= 0) {</span>
<span class="nc" id="L1278">            throw new ArithmeticException(&quot;BigInteger: modulus not positive&quot;);</span>
        }
<span class="fc" id="L1280">        TBigInteger rem = remainder(m);</span>
<span class="pc bpc" id="L1281" title="1 of 2 branches missed.">        return rem.sign &lt; 0 ? rem.add(m) : rem;</span>
    }

    /**
     * Tests whether this {@code BigInteger} is probably prime. If {@code true}
     * is returned, then this is prime with a probability beyond
     * (1-1/2^certainty). If {@code false} is returned, then this is definitely
     * composite. If the argument {@code certainty} &lt;= 0, then this method
     * returns true.
     *
     * @param certainty tolerated primality uncertainty.
     * @return {@code true}, if {@code this} is probably prime, {@code false}
     * otherwise.
     */
    public boolean isProbablePrime(int certainty) {
<span class="fc" id="L1296">        return TPrimality.isProbablePrime(abs(), certainty);</span>
    }

    /* Private Methods */

    /**
     * Returns the smallest integer x &gt; {@code this} which is probably prime as
     * a {@code BigInteger} instance. The probability that the returned
     * {@code BigInteger} is prime is beyond (1-1/2^80).
     *
     * @return smallest integer &gt; {@code this} which is robably prime.
     * @throws ArithmeticException if {@code this &lt; 0}.
     */
    public TBigInteger nextProbablePrime() {
<span class="nc bnc" id="L1310" title="All 2 branches missed.">        if (sign &lt; 0) {</span>
<span class="nc" id="L1311">            throw new ArithmeticException(&quot;start &lt; 0: &quot; + this);</span>
        }
<span class="nc" id="L1313">        return TPrimality.nextProbablePrime(this);</span>
    }

    /**
     * Decreases {@code numberLength} if there are zero high elements.
     */
    final void cutOffLeadingZeroes() {
<span class="pc bpc" id="L1320" title="1 of 4 branches missed.">        while ((numberLength &gt; 0) &amp;&amp; (digits[--numberLength] == 0)) {</span>
            // Empty
        }
<span class="pc bpc" id="L1323" title="1 of 2 branches missed.">        if (digits[numberLength++] == 0) {</span>
<span class="nc" id="L1324">            sign = 0;</span>
        }
<span class="fc" id="L1326">    }</span>

    /**
     * Tests if {@code this.abs()} is equals to {@code ONE}
     */
    boolean isOne() {
<span class="pc bpc" id="L1332" title="1 of 4 branches missed.">        return ((numberLength == 1) &amp;&amp; (digits[0] == 1));</span>
    }

    /**
     * Puts a big-endian byte array into a little-endian int array.
     */
    private void putBytesPositiveToIntegers(byte[] byteValues) {
<span class="fc" id="L1339">        int bytesLen = byteValues.length;</span>
<span class="fc" id="L1340">        int highBytes = bytesLen &amp; 3;</span>
<span class="pc bpc" id="L1341" title="1 of 2 branches missed.">        numberLength = (bytesLen &gt;&gt; 2) + ((highBytes == 0) ? 0 : 1);</span>
<span class="fc" id="L1342">        digits = new int[numberLength];</span>
<span class="fc" id="L1343">        int i = 0;</span>
        // Put bytes to the int array starting from the end of the byte array
<span class="fc bfc" id="L1345" title="All 2 branches covered.">        while (bytesLen &gt; highBytes) {</span>
<span class="fc" id="L1346">            digits[i++] = (byteValues[--bytesLen] &amp; 0xFF) | (byteValues[--bytesLen] &amp; 0xFF) &lt;&lt; 8 |</span>
                    (byteValues[--bytesLen] &amp; 0xFF) &lt;&lt; 16 | (byteValues[--bytesLen] &amp; 0xFF) &lt;&lt; 24;
        }
        // Put the first bytes in the highest element of the int array
<span class="pc bpc" id="L1350" title="1 of 2 branches missed.">        for (int j = 0; j &lt; bytesLen; j++) {</span>
<span class="nc" id="L1351">            digits[i] = (digits[i] &lt;&lt; 8) | (byteValues[j] &amp; 0xFF);</span>
        }
<span class="fc" id="L1353">    }</span>

    /**
     * Puts a big-endian byte array into a little-endian applying two
     * complement.
     */
    private void putBytesNegativeToIntegers(byte[] byteValues) {
<span class="nc" id="L1360">        int bytesLen = byteValues.length;</span>
<span class="nc" id="L1361">        int highBytes = bytesLen &amp; 3;</span>
<span class="nc bnc" id="L1362" title="All 2 branches missed.">        numberLength = (bytesLen &gt;&gt; 2) + ((highBytes == 0) ? 0 : 1);</span>
<span class="nc" id="L1363">        digits = new int[numberLength];</span>
<span class="nc" id="L1364">        int i = 0;</span>
        // Setting the sign
<span class="nc" id="L1366">        digits[numberLength - 1] = -1;</span>
        // Put bytes to the int array starting from the end of the byte array
<span class="nc bnc" id="L1368" title="All 2 branches missed.">        while (bytesLen &gt; highBytes) {</span>
<span class="nc" id="L1369">            digits[i] = (byteValues[--bytesLen] &amp; 0xFF) | (byteValues[--bytesLen] &amp; 0xFF) &lt;&lt; 8 |</span>
                    (byteValues[--bytesLen] &amp; 0xFF) &lt;&lt; 16 | (byteValues[--bytesLen] &amp; 0xFF) &lt;&lt; 24;
<span class="nc bnc" id="L1371" title="All 2 branches missed.">            if (digits[i] != 0) {</span>
<span class="nc" id="L1372">                digits[i] = -digits[i];</span>
<span class="nc" id="L1373">                firstNonzeroDigit = i;</span>
<span class="nc" id="L1374">                i++;</span>
<span class="nc bnc" id="L1375" title="All 2 branches missed.">                while (bytesLen &gt; highBytes) {</span>
<span class="nc" id="L1376">                    digits[i] = (byteValues[--bytesLen] &amp; 0xFF) | (byteValues[--bytesLen] &amp; 0xFF) &lt;&lt; 8 |</span>
                            (byteValues[--bytesLen] &amp; 0xFF) &lt;&lt; 16 | (byteValues[--bytesLen] &amp; 0xFF) &lt;&lt; 24;
<span class="nc" id="L1378">                    digits[i] = ~digits[i];</span>
<span class="nc" id="L1379">                    i++;</span>
                }
                break;
            }
<span class="nc" id="L1383">            i++;</span>
        }
<span class="nc bnc" id="L1385" title="All 2 branches missed.">        if (highBytes != 0) {</span>
            // Put the first bytes in the highest element of the int array
<span class="nc bnc" id="L1387" title="All 2 branches missed.">            if (firstNonzeroDigit != -2) {</span>
<span class="nc bnc" id="L1388" title="All 2 branches missed.">                for (int j = 0; j &lt; bytesLen; j++) {</span>
<span class="nc" id="L1389">                    digits[i] = (digits[i] &lt;&lt; 8) | (byteValues[j] &amp; 0xFF);</span>
                }
<span class="nc" id="L1391">                digits[i] = ~digits[i];</span>
            } else {
<span class="nc bnc" id="L1393" title="All 2 branches missed.">                for (int j = 0; j &lt; bytesLen; j++) {</span>
<span class="nc" id="L1394">                    digits[i] = (digits[i] &lt;&lt; 8) | (byteValues[j] &amp; 0xFF);</span>
                }
<span class="nc" id="L1396">                digits[i] = -digits[i];</span>
            }
        }
<span class="nc" id="L1399">    }</span>

    int getFirstNonzeroDigit() {
<span class="fc bfc" id="L1402" title="All 2 branches covered.">        if (firstNonzeroDigit == -2) {</span>
            int i;
<span class="pc bpc" id="L1404" title="1 of 2 branches missed.">            if (this.sign == 0) {</span>
<span class="nc" id="L1405">                i = -1;</span>
            } else {
<span class="pc bpc" id="L1407" title="1 of 2 branches missed.">                for (i = 0; digits[i] == 0; i++) {</span>
                    // Empty
                }
            }
<span class="fc" id="L1411">            firstNonzeroDigit = i;</span>
        }
<span class="fc" id="L1413">        return firstNonzeroDigit;</span>
    }

    /*
     * Returns a copy of the current instance to achieve immutability
     */
    TBigInteger copy() {
<span class="nc" id="L1420">        int[] copyDigits = new int[numberLength];</span>
<span class="nc" id="L1421">        System.arraycopy(digits, 0, copyDigits, 0, numberLength);</span>
<span class="nc" id="L1422">        return new TBigInteger(sign, numberLength, copyDigits);</span>
    }

    void unCache() {
<span class="nc" id="L1426">        firstNonzeroDigit = -2;</span>
<span class="nc" id="L1427">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>