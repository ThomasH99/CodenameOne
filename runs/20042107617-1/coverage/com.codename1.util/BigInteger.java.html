<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BigInteger.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codenameone-core-unittests</a> &gt; <a href="index.source.html" class="el_package">com.codename1.util</a> &gt; <span class="el_source">BigInteger.java</span></div><h1>BigInteger.java</h1><pre class="source lang-java linenums">/*
 *  This code originates from the bouncy castle library and didn't have a copyright header
 */

package com.codename1.util;

import java.util.Random;

/**
 * A simplified version of big integer from the bouncy castle implementation
 */
public class BigInteger {

<span class="fc" id="L14">    public static final BigInteger ZERO = new BigInteger(0, new int[0]);</span>
<span class="fc" id="L15">    public static final BigInteger ONE = valueOf(1);</span>
    private static final int BITS_PER_BYTE = 8;
    private static final int BYTES_PER_INT = 4;
<span class="fc" id="L18">    private static final byte[] rndMask = {(byte) 255, 127, 63, 31, 15, 7, 3, 1};</span>
<span class="fc" id="L19">    private final static byte[] bitCounts = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1,</span>
            2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4,
            4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3,
            4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5,
            3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2,
            3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3,
            3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6,
            7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6,
            5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5,
            6, 6, 7, 6, 7, 7, 8};
    TBigInteger peer;

<span class="nc" id="L31">    private BigInteger() {</span>
<span class="nc" id="L32">        peer = new TBigInteger(0, new int[0]);</span>
<span class="nc" id="L33">    }</span>


<span class="fc" id="L36">    private BigInteger(int signum, int[] mag) {</span>
<span class="fc" id="L37">        peer = new TBigInteger(signum, mag);</span>
<span class="fc" id="L38">    }</span>

    public BigInteger(String sval) throws NumberFormatException {
<span class="fc" id="L41">        this(sval, 10);</span>
<span class="fc" id="L42">    }</span>

<span class="fc" id="L44">    public BigInteger(String sval, int rdx) throws NumberFormatException {</span>
<span class="fc" id="L45">        peer = new TBigInteger(sval, rdx);</span>
<span class="fc" id="L46">    }</span>

<span class="fc" id="L48">    public BigInteger(byte[] bval) throws NumberFormatException {</span>
<span class="fc" id="L49">        peer = new TBigInteger(bval);</span>
<span class="fc" id="L50">    }</span>
<span class="fc" id="L51">    BigInteger(TBigInteger peer) {</span>
<span class="fc" id="L52">        this.peer = peer;</span>
<span class="fc" id="L53">    }</span>


<span class="nc" id="L56">    public BigInteger(int sign, byte[] mag) throws NumberFormatException {</span>
<span class="nc" id="L57">        peer = new TBigInteger(sign, mag);</span>
<span class="nc" id="L58">    }</span>

<span class="nc" id="L60">    public BigInteger(int numBits, Random rnd) throws IllegalArgumentException {</span>
<span class="nc" id="L61">        peer = new TBigInteger(numBits, rnd);</span>

<span class="nc" id="L63">    }</span>

<span class="nc" id="L65">    public BigInteger(int bitLength, int certainty, Random rnd) throws ArithmeticException {</span>
<span class="nc" id="L66">        peer = new TBigInteger(bitLength, certainty, rnd);</span>
<span class="nc" id="L67">    }</span>

    //
    // bitLen(val) is the number of bits in val.
    //
    static int bitLen(int w) {
        // Binary search - decision tree (5 tests, rarely 6)
<span class="nc bnc" id="L74" title="All 64 branches missed.">        return (w &lt; 1 &lt;&lt; 15 ? (w &lt; 1 &lt;&lt; 7</span>
                ? (w &lt; 1 &lt;&lt; 3 ? (w &lt; 1 &lt;&lt; 1
                ? (w &lt; 1 &lt;&lt; 0 ? (w &lt; 0 ? 32 : 0) : 1)
                : (w &lt; 1 &lt;&lt; 2 ? 2 : 3)) : (w &lt; 1 &lt;&lt; 5
                ? (w &lt; 1 &lt;&lt; 4 ? 4 : 5)
                : (w &lt; 1 &lt;&lt; 6 ? 6 : 7)))
                : (w &lt; 1 &lt;&lt; 11
                ? (w &lt; 1 &lt;&lt; 9 ? (w &lt; 1 &lt;&lt; 8 ? 8 : 9) : (w &lt; 1 &lt;&lt; 10 ? 10 : 11))
                : (w &lt; 1 &lt;&lt; 13 ? (w &lt; 1 &lt;&lt; 12 ? 12 : 13) : (w &lt; 1 &lt;&lt; 14 ? 14 : 15)))) : (w &lt; 1 &lt;&lt; 23 ? (w &lt; 1 &lt;&lt; 19
                ? (w &lt; 1 &lt;&lt; 17 ? (w &lt; 1 &lt;&lt; 16 ? 16 : 17) : (w &lt; 1 &lt;&lt; 18 ? 18 : 19))
                : (w &lt; 1 &lt;&lt; 21 ? (w &lt; 1 &lt;&lt; 20 ? 20 : 21) : (w &lt; 1 &lt;&lt; 22 ? 22 : 23))) : (w &lt; 1 &lt;&lt; 27
                ? (w &lt; 1 &lt;&lt; 25 ? (w &lt; 1 &lt;&lt; 24 ? 24 : 25) : (w &lt; 1 &lt;&lt; 26 ? 26 : 27))
                : (w &lt; 1 &lt;&lt; 29 ? (w &lt; 1 &lt;&lt; 28 ? 28 : 29) : (w &lt; 1 &lt;&lt; 30 ? 30 : 31)))));
    }

    public static BigInteger probablePrime(
            int bitLength,
            Random random) {
<span class="fc" id="L92">        return new BigInteger(TBigInteger.probablePrime(bitLength, random));</span>
    }

    public static BigInteger valueOf(long val) {
<span class="fc" id="L96">        return new BigInteger(TBigInteger.valueOf(val));</span>
    }

    public BigInteger abs() {
<span class="nc bnc" id="L100" title="All 2 branches missed.">        return (peer.sign &gt;= 0) ? this : this.negate();</span>
    }

    public BigInteger add(BigInteger val) throws ArithmeticException {
<span class="fc" id="L104">        return new BigInteger(peer.add(val.peer));</span>
    }

    public BigInteger and(
            BigInteger value) {
<span class="fc" id="L109">        return new BigInteger(peer.and(value.peer));</span>
    }

    public BigInteger andNot(
            BigInteger value) {
<span class="nc" id="L114">        return and(value.not());</span>
    }

    public int bitCount() {
<span class="nc" id="L118">        return peer.bitCount();</span>
    }

    public int bitLength() {
<span class="nc" id="L122">        return peer.bitLength();</span>
    }

    public int compareTo(Object o) {
<span class="nc bnc" id="L126" title="All 2 branches missed.">        if (o instanceof BigInteger) {</span>
<span class="nc" id="L127">            return compareTo((BigInteger) o);</span>
        }
<span class="nc" id="L129">        throw new IllegalArgumentException(&quot;BigInteger can only be compared to other BigIntegers&quot;);</span>
    }

    public int compareTo(BigInteger val) {
<span class="fc" id="L133">        return peer.compareTo(val.peer);</span>
    }

    public BigInteger divide(BigInteger val) throws ArithmeticException {
<span class="nc" id="L137">        return new BigInteger(peer.divide(val.peer));</span>
    }

    public BigInteger[] divideAndRemainder(BigInteger val) throws ArithmeticException {
<span class="fc" id="L141">        TBigInteger[] presults = peer.divideAndRemainder(val.peer);</span>
<span class="fc" id="L142">        BigInteger[] out = new BigInteger[presults.length];</span>
<span class="fc" id="L143">        int plen = presults.length;</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">        for (int i = 0; i &lt; plen; i++) {</span>
<span class="fc" id="L145">            out[i] = new BigInteger(presults[i]);</span>
        }
<span class="fc" id="L147">        return out;</span>
    }

    public boolean equals(Object val) {
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">        if (val == this)</span>
<span class="nc" id="L152">            return true;</span>

<span class="pc bpc" id="L154" title="1 of 2 branches missed.">        if (!(val instanceof BigInteger))</span>
<span class="nc" id="L155">            return false;</span>
<span class="fc" id="L156">        BigInteger biggie = (BigInteger) val;</span>
<span class="fc" id="L157">        return peer.equals(biggie.peer);</span>
    }

    public BigInteger gcd(BigInteger val) {
<span class="fc" id="L161">        return new BigInteger(peer.gcd(val.peer));</span>
    }

    public int hashCode() {
<span class="nc" id="L165">        return peer.hashCode();</span>
    }

    public int intValue() {
<span class="fc" id="L169">        return peer.intValue();</span>
    }

    public byte byteValue() {
<span class="nc" id="L173">        return (byte) intValue();</span>
    }

    /**
     * return whether or not a BigInteger is probably prime with a
     * probability of 1 - (1/2)**certainty.
     * &lt;p&gt;
     * From Knuth Vol 2, pg 395.
     */
    public boolean isProbablePrime(int certainty) {
<span class="fc" id="L183">        return peer.isProbablePrime(certainty);</span>
    }

    public long longValue() {
<span class="fc" id="L187">        return peer.longValue();</span>
    }

    public BigInteger max(BigInteger val) {
<span class="nc bnc" id="L191" title="All 2 branches missed.">        return (compareTo(val) &gt; 0) ? this : val;</span>
    }

    public BigInteger min(BigInteger val) {
<span class="nc bnc" id="L195" title="All 2 branches missed.">        return (compareTo(val) &lt; 0) ? this : val;</span>
    }

    public BigInteger mod(BigInteger m) throws ArithmeticException {
<span class="fc" id="L199">        return new BigInteger(peer.mod(m.peer));</span>
    }

    public BigInteger modInverse(BigInteger m) throws ArithmeticException {
<span class="nc" id="L203">        return new BigInteger(peer.modInverse(m.peer));</span>
    }

    public BigInteger modPow(BigInteger exponent, BigInteger m) throws ArithmeticException {
<span class="nc" id="L207">        return new BigInteger(peer.modPow(exponent.peer, m.peer));</span>
    }

    public BigInteger multiply(BigInteger val) {
<span class="fc" id="L211">        return new BigInteger(peer.multiply(val.peer));</span>
    }

    public BigInteger negate() {
<span class="fc" id="L215">        return new BigInteger(peer.negate());</span>
    }

    public BigInteger not() {
<span class="fc" id="L219">        return add(ONE).negate();</span>
    }

    public BigInteger pow(int exp) throws ArithmeticException {
<span class="fc" id="L223">        return new BigInteger(peer.pow(exp));</span>
    }

    public BigInteger remainder(BigInteger n) throws ArithmeticException {
<span class="fc" id="L227">        return new BigInteger(peer.remainder(n.peer));</span>
    }

    public BigInteger shiftLeft(int n) {
<span class="fc" id="L231">        return new BigInteger(peer.shiftLeft(n));</span>
    }

    public BigInteger shiftRight(int n) {
<span class="fc" id="L235">        return new BigInteger(peer.shiftRight(n));</span>
    }

    public int signum() {
<span class="nc" id="L239">        return peer.signum();</span>
    }

    public BigInteger subtract(BigInteger val) {
<span class="fc" id="L243">        return new BigInteger(peer.subtract(val.peer));</span>
    }

    public byte[] toByteArray() {
<span class="fc" id="L247">        return peer.toByteArray();</span>
    }

    public BigInteger xor(BigInteger val) {
<span class="fc" id="L251">        return new BigInteger(peer.xor(val.peer));</span>
    }

    public BigInteger or(
            BigInteger value) {
<span class="fc" id="L256">        return new BigInteger(peer.or(value.peer));</span>
    }

    public BigInteger setBit(int n)
            throws ArithmeticException {
<span class="fc" id="L261">        return new BigInteger(peer.setBit(n));</span>
    }

    public BigInteger clearBit(int n)
            throws ArithmeticException {
<span class="fc" id="L266">        return new BigInteger(peer.clearBit(n));</span>
    }

    public BigInteger flipBit(int n)
            throws ArithmeticException {
<span class="fc" id="L271">        return new BigInteger(peer.flipBit(n));</span>
    }

    public String toString() {
<span class="fc" id="L275">        return peer.toString();</span>
    }

    public String toString(int rdx) {
<span class="nc" id="L279">        return peer.toString(rdx);</span>

    }

    public int getLowestSetBit() {
<span class="nc" id="L284">        return peer.getLowestSetBit();</span>
    }

    public boolean testBit(int n)
            throws ArithmeticException {
<span class="fc" id="L289">        return peer.testBit(n);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>