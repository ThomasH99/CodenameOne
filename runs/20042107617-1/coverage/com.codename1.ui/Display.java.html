<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Display.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codenameone-core-unittests</a> &gt; <a href="index.source.html" class="el_package">com.codename1.ui</a> &gt; <span class="el_source">Display.java</span></div><h1>Display.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores
 * CA 94065 USA or visit www.oracle.com if you need additional information or
 * have any questions.
 */
package com.codename1.ui;

import com.codename1.annotations.Async;
import com.codename1.capture.VideoCaptureConstraints;
import com.codename1.codescan.CodeScanner;
import com.codename1.contacts.Contact;
import com.codename1.contacts.ContactsManager;
import com.codename1.db.Database;
import com.codename1.impl.CodenameOneImplementation;
import com.codename1.impl.CodenameOneThread;
import com.codename1.impl.ImplementationFactory;
import com.codename1.impl.VirtualKeyboardInterface;
import com.codename1.io.Log;
import com.codename1.io.Preferences;
import com.codename1.io.Util;
import com.codename1.l10n.L10NManager;
import com.codename1.location.LocationManager;
import com.codename1.media.Media;
import com.codename1.media.MediaManager;
import com.codename1.media.MediaRecorderBuilder;
import com.codename1.media.RemoteControlListener;
import com.codename1.messaging.Message;
import com.codename1.notifications.LocalNotification;
import com.codename1.payment.Purchase;
import com.codename1.plugin.PluginSupport;
import com.codename1.plugin.event.IsGalleryTypeSupportedEvent;
import com.codename1.plugin.event.OpenGalleryEvent;
import com.codename1.system.CrashReport;
import com.codename1.ui.animations.Animation;
import com.codename1.ui.animations.CommonTransitions;
import com.codename1.ui.animations.Transition;
import com.codename1.ui.events.ActionEvent;
import com.codename1.ui.events.ActionListener;
import com.codename1.ui.events.MessageEvent;
import com.codename1.ui.events.WindowEvent;
import com.codename1.ui.geom.Dimension;
import com.codename1.ui.geom.Rectangle;
import com.codename1.ui.plaf.Style;
import com.codename1.ui.plaf.UIManager;
import com.codename1.ui.util.EventDispatcher;
import com.codename1.ui.util.ImageIO;
import com.codename1.util.AsyncResource;
import com.codename1.util.RunnableWithResultSync;
import com.codename1.util.SuccessCallback;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;

/**
 * Central class for the API that manages rendering/events and is used to place top
 * level components ({@link Form}) on the &quot;display&quot;.
 * &lt;p&gt;This class handles the main thread for the toolkit referenced here on as the EDT
 * (Event Dispatch Thread) similar to the Swing EDT. This thread encapsulates the platform
 * specific event delivery and painting semantics and enables threading features such as
 * animations etc...
 * &lt;p&gt;The EDT should not be blocked since paint operations and events would also be blocked
 * in much the same way as they would be in other platforms. In order to serialize calls back
 * into the EDT use the methods {@link Display#callSerially} &amp;amp; {@link Display#callSeriallyAndWait}.
 * &lt;p&gt;Notice that all Codename One calls occur on the EDT (events, painting, animations etc...), Codename One
 * should normally be manipulated on the EDT as well (hence the {@link Display#callSerially} &amp;amp;
 * {@link Display#callSeriallyAndWait} methods). Theoretically it should be possible to manipulate
 * some Codename One features from other threads but this can't be guaranteed to work for all use cases.
 *
 * @author Chen Fishbein, Shai Almog
 */
public final class Display extends CN1Constants {
    /**
     * A common sound type that can be used with playBuiltinSound
     */
    public static final String SOUND_TYPE_ALARM = &quot;alarm&quot;;
    /**
     * A common sound type that can be used with playBuiltinSound
     */
    public static final String SOUND_TYPE_CONFIRMATION = &quot;confirmation&quot;;
    /**
     * A common sound type that can be used with playBuiltinSound
     */
    public static final String SOUND_TYPE_ERROR = &quot;error&quot;;
    /**
     * A common sound type that can be used with playBuiltinSound
     */
    public static final String SOUND_TYPE_INFO = &quot;info&quot;;
    /**
     * A common sound type that can be used with playBuiltinSound
     */
    public static final String SOUND_TYPE_WARNING = &quot;warning&quot;;
    /**
     * A common sound type that can be used with playBuiltinSound
     */
    public static final String SOUND_TYPE_BUTTON_PRESS = &quot;press&quot;;
    /**
     * Unknown keyboard type is the default indicating the software should try
     * to detect the keyboard type if necessary
     */
    public static final int KEYBOARD_TYPE_UNKNOWN = 0;
    /**
     * Numeric keypad keyboard type
     */
    public static final int KEYBOARD_TYPE_NUMERIC = 1;
    /**
     * Full QWERTY keypad keyboard type, even if a numeric keyboard also exists
     */
    public static final int KEYBOARD_TYPE_QWERTY = 2;
    /**
     * Touch device without a physical keyboard that should popup a keyboad
     */
    public static final int KEYBOARD_TYPE_VIRTUAL = 3;
    /**
     * Half QWERTY which needs software assistance for completion
     */
    public static final int KEYBOARD_TYPE_HALF_QWERTY = 4;
    /**
     * Game action for fire
     */
    public static final int GAME_FIRE = 8;
    /**
     * Game action for left key
     */
    public static final int GAME_LEFT = 2;
    /**
     * Game action for right key
     */
    public static final int GAME_RIGHT = 5;
    /**
     * Game action for UP key
     */
    public static final int GAME_UP = 1;
    /**
     * Game action for down key
     */
    public static final int GAME_DOWN = 6;
    /**
     * Special case game key used for media playback events
     */
    public static final int MEDIA_KEY_SKIP_FORWARD = 20;
    /**
     * Special case game key used for media playback events
     */
    public static final int MEDIA_KEY_SKIP_BACK = 21;
    /**
     * Special case game key used for media playback events
     */
    public static final int MEDIA_KEY_PLAY = 22;
    /**
     * Special case game key used for media playback events
     */
    public static final int MEDIA_KEY_STOP = 23;
    /**
     * Special case game key used for media playback events
     */
    public static final int MEDIA_KEY_PLAY_STOP = 24;
    /**
     * Special case game key used for media playback events
     */
    public static final int MEDIA_KEY_PLAY_PAUSE = 25;
    /**
     * Special case game key used for media playback events
     */
    public static final int MEDIA_KEY_FAST_FORWARD = 26;
    /**
     * Special case game key used for media playback events
     */
    public static final int MEDIA_KEY_FAST_BACKWARD = 27;
    /**
     * An attribute that encapsulates '#' int value.
     */
    public static final int KEY_POUND = '#';
    /**
     * Ignore all calls to show occurring during edit, they are discarded immediately
     */
    public static final int SHOW_DURING_EDIT_IGNORE = 1;
    /**
     * If show is called while editing text in the native text box an exception is thrown
     */
    public static final int SHOW_DURING_EDIT_EXCEPTION = 2;
    /**
     * Allow show to occur during edit and discard all user input at this moment
     */
    public static final int SHOW_DURING_EDIT_ALLOW_DISCARD = 3;
    /**
     * Allow show to occur during edit and save all user input at this moment
     */
    public static final int SHOW_DURING_EDIT_ALLOW_SAVE = 4;
    /**
     * Show will update the current form to which the OK button of the text box
     * will return
     */
    public static final int SHOW_DURING_EDIT_SET_AS_NEXT = 5;
    /**
     * Indicates that the Codename One implementation should decide internally the command
     * behavior most appropriate for this platform.
     */
    public static final int COMMAND_BEHAVIOR_DEFAULT = 1;
    /**
     * Indicates the classic Codename One command behavior where the commands are placed in
     * a list within a dialog. This is the most customizable approach for none touch devices.
     */
    public static final int COMMAND_BEHAVIOR_SOFTKEY = 2;
    /**
     * Indicates the touch menu dialog rendered by Codename One where commands are placed
     * into a scrollable dialog
     */
    public static final int COMMAND_BEHAVIOR_TOUCH_MENU = 3;
    /**
     * Indicates that commands should be added to an always visible bar at the
     * bottom of the form.
     */
    public static final int COMMAND_BEHAVIOR_BUTTON_BAR = 4;
    /**
     * Identical to the bar behavior, places the back command within the title bar
     * of the form/dialg
     */
    public static final int COMMAND_BEHAVIOR_BUTTON_BAR_TITLE_BACK = 5;
    /**
     * Places all commands on the right side of the title bar with a uniform size
     * grid layout
     */
    public static final int COMMAND_BEHAVIOR_BUTTON_BAR_TITLE_RIGHT = 6;
    /**
     * Commands are placed in the same was as they are in the ice cream sandwich Android
     * OS update where the back button has a theme icon the application icon appears next
     * to the
     */
    public static final int COMMAND_BEHAVIOR_ICS = 7;
    /**
     * Commands are placed in a side menu similar to Facebook/Google+ apps
     */
    public static final int COMMAND_BEHAVIOR_SIDE_NAVIGATION = 8;
    /**
     * Indicates that commands should try to add themselves to the native menus
     */
    public static final int COMMAND_BEHAVIOR_NATIVE = 10;
    /**
     * Client property key used on the first shown {@link Form} to indicate the desired initial
     * window size as a percentage of the available desktop. The value should be a {@link com.codename1.ui.geom.Dimension}
     * whose width and height represent percentages.
     */
    public static final String WINDOW_SIZE_HINT_PERCENT = &quot;cn1.windowSizePercent&quot;;
<span class="fc" id="L271">    static final Display INSTANCE = new Display();</span>
<span class="fc" id="L272">    static final Object lock = new Object();</span>
    private static final int POINTER_PRESSED = 1;
    private static final int POINTER_RELEASED = 2;
    private static final int POINTER_DRAGGED = 3;
    private static final int POINTER_HOVER = 8;
    private static final int POINTER_HOVER_RELEASED = 11;
    private static final int POINTER_HOVER_PRESSED = 12;
    private static final int KEY_PRESSED = 4;
    private static final int KEY_RELEASED = 5;
    private static final int KEY_LONG_PRESSED = 6;
    private static final int SIZE_CHANGED = 7;
    private static final int HIDE_NOTIFY = 9;
    private static final int SHOW_NOTIFY = 10;
    private static final int POINTER_PRESSED_MULTI = 21;
    private static final int POINTER_RELEASED_MULTI = 22;
    private static final int POINTER_DRAGGED_MULTI = 23;
    private static final int MAX_ASYNC_EXCEPTION_DEPTH = 10;
<span class="fc" id="L289">    private static final int[] xArray1 = new int[1];</span>
<span class="fc" id="L290">    private static final int[] yArray1 = new int[1];</span>
<span class="fc" id="L291">    static int transitionDelay = -1;</span>
    static CodenameOneImplementation impl;
<span class="fc" id="L293">    private static String selectedVirtualKeyboard = null;</span>
<span class="fc" id="L294">    private static final Map&lt;String, VirtualKeyboardInterface&gt; virtualKeyboards = new HashMap&lt;String, VirtualKeyboardInterface&gt;();</span>
<span class="fc" id="L295">    private final LinkedList&lt;Runnable&gt; runningSerialCallsQueue = new LinkedList&lt;Runnable&gt;();</span>
    boolean codenameOneExited;
    long time;
    private CrashReport crashReporter;
    private EventDispatcher errorHandler;
    private boolean inNativeUI;
    private Runnable bookmark;
    private EventDispatcher messageListeners;
    private EventDispatcher windowListeners;
    /**
     * Tracks whether the initial window size hint has already been consumed for the first shown form.
     */
    private boolean initialWindowSizeApplied;
    private boolean disableInvokeAndBlock;
    /**
     * Enable Async stack traces.  This is disabled by default, but will cause
     * stack traces of callSerially() calls to be stored, and logged if the
     * Runnable throws an exception.
     */
    private boolean enableAsyncStackTraces;
    /**
     * A pure touch device has no focus showing when the user is using the touch
     * interface. Selection only shows when the user actually touches the screen
     * or suddenly switches to using a keypad/trackball. This sort of interface
     * is common in Android devices
     */
    private boolean pureTouch;
    private Graphics codenameOneGraphics;
    /**
     * Indicates whether this is a touch device
     */
    private boolean touchScreen;
    private HashMap&lt;String, String&gt; localProperties;
    /**
     * Indicates whether the edt should sleep between each loop
     */
<span class="fc" id="L331">    private boolean noSleep = false;</span>
    /**
     * Normally Codename One folds the VKB when switching forms this field allows us
     * to block that behavior.
     */
<span class="fc" id="L336">    private boolean autoFoldVKBOnFormSwitch = true;</span>
    /**
     * Indicates the maximum drawing speed of no more than 10 frames per second
     * by default (this can be increased or decreased) the advantage of limiting
     * framerate is to allow the CPU to perform other tasks besides drawing.
     * Notice that when no change is occurring on the screen no frame is drawn and
     * so a high/low FPS will have no effect then.
     */
<span class="fc" id="L344">    private int framerateLock = 15;</span>
<span class="fc" id="L345">    private boolean codenameOneRunning = false;</span>
    /**
     * Contains the call serially pending elements
     */
<span class="fc" id="L349">    private final ArrayList&lt;Runnable&gt; pendingSerialCalls = new ArrayList&lt;Runnable&gt;();</span>
    /**
     * Contains the call serially idle elements
     */
<span class="fc" id="L353">    private final ArrayList&lt;Runnable&gt; pendingIdleSerialCalls = new ArrayList&lt;Runnable&gt;();</span>
    /**
     * This is the instance of the EDT used internally to indicate whether
     * we are executing on the EDT or some arbitrary thread
     */
    private Thread edt;
    /**
     * Contains animations that must be played in full by the EDT before anything further
     * may be processed. This is useful for transitions/intro's etc... that animate without
     * user interaction.
     */
    private ArrayList&lt;Animation&gt; animationQueue;
    /**
     * Indicates whether the 3rd softbutton should be supported on this device
     */
<span class="fc" id="L368">    private boolean thirdSoftButton = false;</span>
    private int showDuringEdit;
    /**
     * Events to broadcast on the EDT, we are using a handcoded stack for maximum
     * performance and minimal synchronization. We are using the switching algorithm
     * where we only synchronize on the very minimal point of switching between the stacks
     * and adding to the active stack.
     */
<span class="fc" id="L376">    private int[] inputEventStack = new int[1000];</span>
    private int inputEventStackPointer;
<span class="fc" id="L378">    private int[] inputEventStackTmp = new int[1000];</span>
    private int inputEventStackPointerTmp;
    private boolean longPointerCharged;
    private boolean pointerPressedAndNotReleasedOrDragged;
    private boolean recursivePointerReleaseA;
    private boolean recursivePointerReleaseB;
    private int pointerX, pointerY;
    private boolean keyRepeatCharged;
    private boolean longPressCharged;
    private long longKeyPressTime;
<span class="fc" id="L388">    private int longPressInterval = 500;</span>
    private long nextKeyRepeatEvent;
    private int keyRepeatValue;
<span class="fc" id="L391">    private final int keyRepeatInitialIntervalTime = 800;</span>
<span class="fc" id="L392">    private final int keyRepeatNextIntervalTime = 10;</span>
    private boolean lastInteractionWasKeypad;
    private boolean dragOccured;
    private boolean processingSerialCalls;
    private int PATHLENGTH;
    private float[] dragPathX;
    private float[] dragPathY;
    private long[] dragPathTime;
<span class="fc" id="L400">    private int dragPathOffset = 0;</span>
<span class="fc" id="L401">    private int dragPathLength = 0;</span>
    private Boolean darkMode;
    private PluginSupport pluginSupport;
    /**
     * Internally track display initialization time as a fixed point to allow tagging of pointer
     * events with an integer timestamp (System.currentTimeMillis() - displayInitTime)
     * and not a long value.
     */
<span class="fc" id="L409">    private long displayInitTime = 0;</span>
    /**
     * Allows a Codename One application to minimize without forcing it to the front whenever
     * a new dialog is poped up
     */
    private boolean allowMinimizing;
    private boolean dropEvents;
    private ArrayList&lt;Runnable&gt; backgroundTasks;
    private Thread backgroundThread;
    private boolean multiKeyMode;
    private ActionListener virtualKeyboardListener;
    private EventDispatcher virtualKeyboardListeners;
<span class="fc" id="L421">    private int lastSizeChangeEventWH = -1;</span>
    private DebugRunnable currentEdtContext;
    private int previousKeyPressed;
    private int lastKeyPressed;
    private int lastDragOffset;
<span class="fc" id="L426">    private final Rectangle tmpRect = new Rectangle();</span>
    private Form eventForm;

    /**
     * Private constructor to prevent instanciation
     */
<span class="fc" id="L432">    private Display() {</span>
<span class="fc" id="L433">    }</span>

    /**
     * This is the INTERNAL Display initialization method, it will be removed in future versions of the API.
     * This method must be called before any Form is shown
     *
     * @param m platform specific object used by the implementation
     * @deprecated this method is invoked internally do not invoke it!
     */
    public static void init(Object m) {
<span class="fc bfc" id="L443" title="All 2 branches covered.">        if (!INSTANCE.codenameOneRunning) {</span>
<span class="fc" id="L444">            INSTANCE.codenameOneRunning = true;</span>
<span class="fc" id="L445">            INSTANCE.initialWindowSizeApplied = false;</span>
<span class="fc" id="L446">            INSTANCE.pluginSupport = new PluginSupport();</span>
<span class="fc" id="L447">            INSTANCE.displayInitTime = System.currentTimeMillis();</span>

            //restore menu state from previous run if exists
<span class="fc" id="L450">            int commandBehaviour = COMMAND_BEHAVIOR_DEFAULT;</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">            if (impl != null) {</span>
<span class="fc" id="L452">                commandBehaviour = impl.getCommandBehavior();</span>
            }
<span class="fc" id="L454">            impl = (CodenameOneImplementation) ImplementationFactory.getInstance().createImplementation();</span>

<span class="fc" id="L456">            impl.setDisplayLock(lock);</span>
<span class="fc" id="L457">            impl.initImpl(m);</span>
<span class="fc" id="L458">            INSTANCE.codenameOneGraphics = new Graphics(impl.getNativeGraphics());</span>
<span class="fc" id="L459">            INSTANCE.codenameOneGraphics.paintPeersBehind = impl.paintNativePeersBehind();</span>
<span class="fc" id="L460">            impl.setCodenameOneGraphics(INSTANCE.codenameOneGraphics);</span>

            // only enable but never disable the third softbutton
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">            if (impl.isThirdSoftButton()) {</span>
<span class="nc" id="L464">                INSTANCE.thirdSoftButton = true;</span>
            }
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">            if (impl.getSoftkeyCount() &gt; 0) {</span>
<span class="fc" id="L467">                MenuBar.leftSK = impl.getSoftkeyCode(0)[0];</span>
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">                if (impl.getSoftkeyCount() &gt; 1) {</span>
<span class="fc" id="L469">                    MenuBar.rightSK = impl.getSoftkeyCode(1)[0];</span>
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">                    if (impl.getSoftkeyCode(1).length &gt; 1) {</span>
<span class="nc" id="L471">                        MenuBar.rightSK2 = impl.getSoftkeyCode(1)[1];</span>
                    }
                }
            }
<span class="fc" id="L475">            MenuBar.backSK = impl.getBackKeyCode();</span>
<span class="fc" id="L476">            MenuBar.backspaceSK = impl.getBackspaceKeyCode();</span>
<span class="fc" id="L477">            MenuBar.clearSK = impl.getClearKeyCode();</span>

<span class="fc" id="L479">            INSTANCE.PATHLENGTH = impl.getDragPathLength();</span>
<span class="fc" id="L480">            INSTANCE.dragPathX = new float[INSTANCE.PATHLENGTH];</span>
<span class="fc" id="L481">            INSTANCE.dragPathY = new float[INSTANCE.PATHLENGTH];</span>
<span class="fc" id="L482">            INSTANCE.dragPathTime = new long[INSTANCE.PATHLENGTH];</span>
<span class="fc" id="L483">            com.codename1.util.StringUtil.setImplementation(impl);</span>
<span class="fc" id="L484">            com.codename1.io.Util.setImplementation(impl);</span>

            // this can happen on some cases where an application was restarted etc...
            // generally its probably a bug but we can let it slide...
<span class="fc bfc" id="L488" title="All 2 branches covered.">            if (INSTANCE.edt == null) {</span>
<span class="fc" id="L489">                INSTANCE.touchScreen = impl.isTouchDevice();</span>
                // initialize the Codename One EDT which from now on will take all responsibility
                // for the event delivery.
<span class="fc" id="L492">                INSTANCE.edt = new CodenameOneThread(new RunnableWrapper(null, 3), &quot;EDT&quot;);</span>
<span class="fc" id="L493">                impl.setThreadPriority(INSTANCE.edt, impl.getEDTThreadPriority());</span>
<span class="fc" id="L494">                INSTANCE.edt.start();</span>
            }
<span class="fc" id="L496">            impl.postInit();</span>
<span class="fc" id="L497">            INSTANCE.setCommandBehavior(commandBehaviour);</span>
<span class="fc" id="L498">        } else {</span>
<span class="fc" id="L499">            impl.confirmControlView();</span>
        }
<span class="fc" id="L501">    }</span>

    /**
     * Closes down the EDT and Codename One, under normal conditions this method is completely unnecessary
     * since exiting the application will shut down Codename One. However, if the application is minimized
     * and the user wishes to free all resources without exiting the application then this method can be used.
     * Once this method is used Codename One will no longer work and Display.init(Object) should be invoked
     * again for any further Codename One call!
     * Notice that minimize (being a Codename One method) MUST be invoked before invoking this method!
     */
    public static void deinitialize() {

<span class="fc" id="L513">        INSTANCE.codenameOneRunning = false;</span>
<span class="fc" id="L514">        synchronized (lock) {</span>
<span class="fc" id="L515">            lock.notifyAll();</span>
<span class="fc" id="L516">        }</span>
<span class="fc" id="L517">    }</span>

    /**
     * This method returns true if the Display is initialized.
     *
     * @return true if the EDT is running
     */
    public static boolean isInitialized() {
<span class="pc bpc" id="L525" title="2 of 6 branches missed.">        return INSTANCE.codenameOneRunning &amp;&amp; (impl != null &amp;&amp; impl.isInitialized());</span>
    }

    /**
     * Return the Display instance
     *
     * @return the Display instance
     */
    public static Display getInstance() {
<span class="fc" id="L534">        return INSTANCE;</span>
    }

    /**
     * Sets a bookmark that can restore the app to a particular state.  This takes a
     * {@link Runnable} that will be run when {@link #restoreToBookmark()} () } is called.
     *
     * &lt;p&gt;The primary purpose of this feature is live code refresh.&lt;/p&gt;
     *
     * @param bookmark A {@link Runnable} that can be run to restore the app to a particular point.
     * @since 8.0
     */
    public void setBookmark(Runnable bookmark) {
<span class="fc" id="L547">        this.bookmark = bookmark;</span>
<span class="fc" id="L548">    }</span>

    /**
     * Runs the last bookmark that was set using {@link #setBookmark(java.lang.Runnable) }
     *
     * @since 8.0
     */
    public void restoreToBookmark() {
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">        if (this.bookmark != null) {</span>
<span class="fc" id="L557">            this.bookmark.run();</span>
        }
<span class="fc" id="L559">    }</span>

    /**
     * Gets reference to plugin support object.
     *
     * @return The plugin support object.
     * @since 8.0
     */
    public PluginSupport getPluginSupport() {
<span class="fc" id="L568">        return pluginSupport;</span>
    }

    /**
     * This method allows us to manipulate the drag started detection logic.
     * If the pointer was dragged for more than this percentage of the display size it
     * is safe to assume that a drag is in progress.
     *
     * @return motion percentage
     */
    public int getDragStartPercentage() {
<span class="fc" id="L579">        return getImplementation().getDragStartPercentage();</span>
    }

    /**
     * This method allows us to manipulate the drag started detection logic.
     * If the pointer was dragged for more than this percentage of the display size it
     * is safe to assume that a drag is in progress.
     *
     * @param dragStartPercentage percentage of the screen required to initiate drag
     */
    public void setDragStartPercentage(int dragStartPercentage) {
<span class="fc" id="L590">        getImplementation().setDragStartPercentage(dragStartPercentage);</span>
<span class="fc" id="L591">    }</span>

    CodenameOneImplementation getImplementation() {
<span class="fc" id="L594">        return impl;</span>
    }

    /**
     * Indicates the maximum frames the API will try to draw every second
     * by default this is set to 10. The advantage of limiting
     * framerate is to allow the CPU to perform other tasks besides drawing.
     * Notice that when no change is occurring on the screen no frame is drawn and
     * so a high/low FPS will have no effect then.
     * 10FPS would be very reasonable for a business application.
     *
     * @param rate the frame rate
     */
    public void setFramerate(int rate) {
<span class="nc" id="L608">        framerateLock = 1000 / rate;</span>
<span class="nc" id="L609">    }</span>

    /**
     * Vibrates the device for the given length of time, notice that this might ignore the time value completely
     * on some OS's where this level of control isn't supported e.g. iOS see: https://github.com/codenameone/CodenameOne/issues/1904
     *
     * @param duration length of time to vibrate (might be ignored)
     */
    public void vibrate(int duration) {
<span class="nc" id="L618">        impl.vibrate(duration);</span>
<span class="nc" id="L619">    }</span>

    /**
     * Flash the backlight of the device for the given length of time
     *
     * @param duration length of time to flash the backlight
     * @deprecated this refers to functionality of devices that are no longer sold, not to the devices &quot;flash&quot;
     */
    public void flashBacklight(int duration) {
<span class="nc" id="L628">        impl.flashBacklight(duration);</span>
<span class="nc" id="L629">    }</span>

    /**
     * Manually announces text to native accessibility services, optionally associating the
     * announcement with a specific component. Most assistive technologies will announce a
     * component automatically when it gains focus; this method is intended for situations
     * where an announcement should occur independently of focus changes.
     *
     * @param cmp  the component related to this announcement or {@code null} for the root view
     * @param text the message to announce
     */
    public void announceForAccessibility(Component cmp, String text) {
<span class="fc" id="L641">        impl.announceForAccessibility(cmp, text);</span>
<span class="fc" id="L642">    }</span>

    /**
     * Convenience overload to announce text without specifying a component.
     *
     * @param text the message to announce
     */
    public void announceForAccessibility(String text) {
<span class="nc" id="L650">        announceForAccessibility(null, text);</span>
<span class="nc" id="L651">    }</span>

    /**
     * Returns the status of the show during edit flag
     *
     * @return one of the following: SHOW_DURING_EDIT_IGNORE,
     * SHOW_DURING_EDIT_EXCEPTION, SHOW_DURING_EDIT_ALLOW_DISCARD,
     * SHOW_DURING_EDIT_ALLOW_SAVE, SHOW_DURING_EDIT_SET_AS_NEXT
     * @deprecated this method isn't applicable in modern devices
     */
    public int getShowDuringEditBehavior() {
<span class="nc" id="L662">        return showDuringEdit;</span>
    }

    /**
     * Invoking the show() method of a form/dialog while the user is editing
     * text in the native text box can have several behaviors: SHOW_DURING_EDIT_IGNORE,
     * SHOW_DURING_EDIT_EXCEPTION, SHOW_DURING_EDIT_ALLOW_DISCARD,
     * SHOW_DURING_EDIT_ALLOW_SAVE, SHOW_DURING_EDIT_SET_AS_NEXT
     *
     * @param showDuringEdit one of the following: SHOW_DURING_EDIT_IGNORE,
     *                       SHOW_DURING_EDIT_EXCEPTION, SHOW_DURING_EDIT_ALLOW_DISCARD,
     *                       SHOW_DURING_EDIT_ALLOW_SAVE, SHOW_DURING_EDIT_SET_AS_NEXT
     * @deprecated this method isn't applicable in modern devices
     */
    public void setShowDuringEditBehavior(int showDuringEdit) {
<span class="nc" id="L677">        this.showDuringEdit = showDuringEdit;</span>
<span class="nc" id="L678">    }</span>

    /**
     * Indicates the maximum frames the API will try to draw every second
     *
     * @return the frame rate
     */
    public int getFrameRate() {
<span class="fc" id="L686">        return 1000 / framerateLock;</span>
    }

    /**
     * Returns true if we are currently in the event dispatch thread.
     * This is useful for generic code that can be used both with the
     * EDT and outside of it.
     *
     * @return true if we are currently in the event dispatch thread;
     * otherwise false
     */
    public boolean isEdt() {
<span class="fc bfc" id="L698" title="All 2 branches covered.">        return edt == Thread.currentThread();</span>
    }

    /**
     * Plays sound for the dialog
     */
    void playDialogSound(final int type) {
<span class="nc" id="L705">        impl.playDialogSound(type);</span>
<span class="nc" id="L706">    }</span>

    /**
     * Stops the remote control service.  This should be implemented in the platform
     * to handle unbinding the {@link com.codename1.media.RemoteControlListener} with the platform's remote control.
     * &lt;p&gt;This is executed when a new listener is registered using {@link com.codename1.media.MediaManager#setRemoteControlListener(com.codename1.media.RemoteControlListener) }&lt;/p&gt;
     *
     * @since 7.0
     */
    public void stopRemoteControl() {
<span class="fc" id="L716">        impl.stopRemoteControl();</span>
<span class="fc" id="L717">    }</span>

    /**
     * Starts the remote control service.  This should be implemented
     * in the platform to handle binding the {@link RemoteControlListener} with
     * the platform's remote control.
     *
     * &lt;p&gt;This is executed when the user registers a new listener using {@link MediaManager#setRemoteControlListener(com.codename1.media.RemoteControlListener) }&lt;/p&gt;
     *
     * @since 7.0
     */
    public void startRemoteControl() {
<span class="fc" id="L729">        impl.startRemoteControl();</span>
<span class="fc" id="L730">    }</span>

    /**
     * Returns true if the platform is in dark mode, null is returned for
     * unknown status
     *
     * @return true in case of dark mode
     */
    public Boolean isDarkMode() {
<span class="nc bnc" id="L739" title="All 2 branches missed.">        if (darkMode != null) {</span>
<span class="nc" id="L740">            return darkMode;</span>
        }
<span class="nc" id="L742">        return impl.isDarkMode();</span>
    }

    /**
     * Override the default dark mode setting
     *
     * @param darkMode can be set to null to reset to platform default
     */
    public void setDarkMode(Boolean darkMode) {
<span class="nc" id="L751">        this.darkMode = darkMode;</span>
<span class="nc" id="L752">    }</span>

    /**
     * Checks if async stack traces are enabled.  If enabled, the stack trace
     * at the point of {@link #callSerially(java.lang.Runnable) } calls will
     * be recorded, and logged in the case that there is an uncaught exception.
     * &lt;p&gt;Currently this is only supported in the JavaSE/Simulator port.&lt;/p&gt;
     *
     * @return Whether async stack traces are enabled.
     * @see #setEnableAsyncStackTraces(boolean)
     * @since 7.0
     */
    public boolean isEnableAsyncStackTraces() {
<span class="fc" id="L765">        return enableAsyncStackTraces;</span>
    }

    /**
     * Enables or disables async stack traces.  If enabled, the stack trace
     * at the point of {@link #callSerially(java.lang.Runnable) } calls will
     * be recorded, and logged in the case that there is an uncaught exception.
     *
     * &lt;p&gt;Currently this is only supported in the JavaSE/Simulator port.&lt;/p&gt;
     *
     * @param enableAsyncStackTraces True to enable async stack traces.
     * @see #isEnableAsyncStackTraces()
     * @since 7.0
     */
    public void setEnableAsyncStackTraces(boolean enableAsyncStackTraces) {
<span class="nc" id="L780">        this.enableAsyncStackTraces = enableAsyncStackTraces;</span>
<span class="nc" id="L781">    }</span>

    /**
     * Causes the runnable to be invoked on the event dispatch thread. This method
     * returns immediately and will not wait for the serial call to occur
     *
     * @param r runnable (NOT A THREAD!) that will be invoked on the EDT serial to
     *          the paint and key handling events
     */
    public void callSerially(Runnable r) {
        // otherwise this will fail in an odd locaiton. Better it fails here...
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">        if (r == null) {</span>
<span class="nc" id="L793">            throw new NullPointerException();</span>
        }
<span class="fc bfc" id="L795" title="All 2 branches covered.">        if (codenameOneRunning) {</span>
<span class="fc" id="L796">            synchronized (lock) {</span>
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">                scheduleSerialCall(isEnableAsyncStackTraces() ? new DebugRunnable(r) : r);</span>
<span class="fc" id="L798">                lock.notifyAll();</span>
<span class="fc" id="L799">            }</span>
        } else {
<span class="fc" id="L801">            r.run();</span>
        }
<span class="fc" id="L803">    }</span>

    // We factor out the scheduling of a serial call so that we can
    // use the Schedule annotation for IntelliJ async debugging https://www.jetbrains.com/help/idea/debug-asynchronous-code.html
    private void scheduleSerialCall(@Async.Schedule Runnable r) {
<span class="fc" id="L808">        pendingSerialCalls.add(r);</span>
<span class="fc" id="L809">    }</span>

    /**
     * Causes the runnable to be invoked on the event dispatch thread when the event
     * dispatch thread is idle. This method returns immediately and will not wait for the serial call
     * to occur. Notice this method is identical to call serially but will perform the runnable only when
     * the EDT is idle
     *
     * @param r runnable (NOT A THREAD!) that will be invoked on the EDT serial to
     *          the paint and key handling events
     */
    public void callSeriallyOnIdle(Runnable r) {
<span class="pc bpc" id="L821" title="1 of 2 branches missed.">        if (codenameOneRunning) {</span>
<span class="fc" id="L822">            synchronized (lock) {</span>
<span class="fc" id="L823">                pendingIdleSerialCalls.add(r);</span>
<span class="fc" id="L824">                lock.notifyAll();</span>
<span class="fc" id="L825">            }</span>
        } else {
<span class="nc" id="L827">            r.run();</span>
        }
<span class="fc" id="L829">    }</span>

    public String getLineSeparator() {
<span class="fc" id="L832">        return impl.getLineSeparator();</span>
    }

    /**
     * Allows executing a background task in a separate low priority thread. Tasks are serialized
     * so they don't overload the CPU.
     *
     * @param r the task to perform in the background
     */
    public void scheduleBackgroundTask(@Async.Schedule Runnable r) {
<span class="fc" id="L842">        synchronized (lock) {</span>
<span class="fc bfc" id="L843" title="All 2 branches covered.">            if (backgroundTasks == null) {</span>
<span class="fc" id="L844">                backgroundTasks = new ArrayList&lt;Runnable&gt;();</span>
            }
<span class="fc" id="L846">            backgroundTasks.add(r);</span>
<span class="pc bpc" id="L847" title="1 of 2 branches missed.">            if (backgroundThread == null) {</span>
<span class="fc" id="L848">                backgroundThread = new CodenameOneThread(new Runnable() {</span>
                    public void run() {
                        // using while true to avoid double lock optimization with synchronized block
                        while (true) {
<span class="fc" id="L852">                            Runnable nextTask = null;</span>
<span class="fc" id="L853">                            synchronized (lock) {</span>
<span class="fc bfc" id="L854" title="All 2 branches covered.">                                if (backgroundTasks.size() &gt; 0) {</span>
<span class="fc" id="L855">                                    nextTask = backgroundTasks.get(0);</span>
                                } else {
<span class="fc" id="L857">                                    backgroundThread = null;</span>
<span class="fc" id="L858">                                    return;</span>
                                }
<span class="fc" id="L860">                                backgroundTasks.remove(0);</span>
<span class="fc" id="L861">                            }</span>
                            try {
<span class="fc" id="L863">                                executeBackgroundTaskRunnable(nextTask);</span>
<span class="nc" id="L864">                            } catch (Throwable e) {</span>
<span class="nc" id="L865">                                Log.e(e);</span>
<span class="fc" id="L866">                            }</span>
<span class="fc" id="L867">                            Util.sleep(10);</span>
<span class="fc" id="L868">                        }</span>
                    }
                }, &quot;Task Thread&quot;);
<span class="fc" id="L871">                backgroundThread.setPriority(Thread.MIN_PRIORITY + 1);</span>
<span class="fc" id="L872">                backgroundThread.start();</span>
            }
<span class="fc" id="L874">        }</span>
<span class="fc" id="L875">    }</span>

    private void executeBackgroundTaskRunnable(@Async.Execute Runnable r) {
<span class="fc" id="L878">        r.run();</span>
<span class="fc" id="L879">    }</span>

    /**
     * Identical to callSerially with the added benefit of waiting for the Runnable method to complete.
     *
     * @param r runnable (NOT A THREAD!) that will be invoked on the EDT serial to
     *          the paint and key handling events
     * @throws IllegalStateException if this method is invoked on the event dispatch thread (e.g. during
     *                               paint or event handling).
     */
    public void callSeriallyAndWait(Runnable r) {
<span class="fc bfc" id="L890" title="All 2 branches covered.">        if (isEdt()) {</span>
<span class="fc" id="L891">            throw new RuntimeException(&quot;This method MUST NOT be invoked on the EDT&quot;);</span>
        }
<span class="fc" id="L893">        RunnableWrapper c = new RunnableWrapper(r, 0);</span>
<span class="fc" id="L894">        callSerially(c);</span>
<span class="fc" id="L895">        flushEdt();</span>
<span class="fc" id="L896">        synchronized (lock) {</span>
<span class="fc bfc" id="L897" title="All 2 branches covered.">            while (!c.isDone()) {</span>
                try {
                    // poll doneness to prevent potential race conditions
<span class="fc" id="L900">                    lock.wait(50);</span>
<span class="nc" id="L901">                } catch (InterruptedException err) {</span>
<span class="pc" id="L902">                }</span>
            }
<span class="fc" id="L904">        }</span>
<span class="fc" id="L905">    }</span>

    /**
     * Checks if this platform uses input modes.  No current platforms return true for this.  It is a holdover from J2ME.
     *
     * @return True if the platform supports input modes.  Only true for J2ME and RIM.
     */
    public boolean platformUsesInputMode() {
<span class="fc" id="L913">        return impl.platformUsesInputMode();</span>
    }

    /**
     * Identical to callSerially with the added benefit of waiting for the Runnable method to complete.
     *
     * @param r       runnable (NOT A THREAD!) that will be invoked on the EDT serial to
     *                the paint and key handling events
     * @param timeout timeout duration, on timeout the method just returns
     * @throws IllegalStateException if this method is invoked on the event dispatch thread (e.g. during
     *                               paint or event handling).
     */
    public void callSeriallyAndWait(Runnable r, int timeout) {
<span class="nc" id="L926">        RunnableWrapper c = new RunnableWrapper(r, 0);</span>
<span class="nc" id="L927">        callSerially(c);</span>
<span class="nc" id="L928">        synchronized (lock) {</span>
<span class="nc" id="L929">            long t = System.currentTimeMillis();</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">            while (!c.isDone()) {</span>
                try {
                    // poll doneness to prevent potential race conditions
<span class="nc" id="L933">                    lock.wait(20);</span>
<span class="nc" id="L934">                } catch (InterruptedException err) {</span>
<span class="nc" id="L935">                }</span>
<span class="nc bnc" id="L936" title="All 2 branches missed.">                if (System.currentTimeMillis() - t &gt;= timeout) {</span>
<span class="nc" id="L937">                    return;</span>
                }
            }
<span class="nc" id="L940">        }</span>
<span class="nc" id="L941">    }</span>

    /**
     * Allows us to &quot;flush&quot; the edt to allow any pending transitions and input to go
     * by before continuing with our other tasks.
     */
    void flushEdt() {
<span class="fc bfc" id="L948" title="All 2 branches covered.">        if (!isEdt()) {</span>
<span class="fc" id="L949">            return;</span>
        }
<span class="fc bfc" id="L951" title="All 2 branches covered.">        while (!shouldEDTSleepNoFormAnimation()) {</span>
<span class="fc" id="L952">            edtLoopImpl();</span>
        }
<span class="pc bpc" id="L954" title="1 of 4 branches missed.">        while (animationQueue != null &amp;&amp; animationQueue.size() &gt; 0) {</span>
<span class="nc" id="L955">            edtLoopImpl();</span>
        }
<span class="fc" id="L957">    }</span>

    /**
     * Restores the menu in the given form
     */
    private void restoreMenu(Form f) {
<span class="pc bpc" id="L963" title="1 of 2 branches missed.">        if (f != null) {</span>
<span class="fc" id="L964">            f.restoreMenu();</span>
        }
<span class="fc" id="L966">    }</span>

    /**
     * Returns true if the system is currently in the process of transitioning between
     * forms
     *
     * @return true if in the middle of form transition
     */
    public boolean isInTransition() {
<span class="nc bnc" id="L975" title="All 4 branches missed.">        if (animationQueue != null &amp;&amp; animationQueue.size() &gt; 0) {</span>
<span class="nc" id="L976">            Animation ani = animationQueue.get(0);</span>
<span class="nc" id="L977">            return ani instanceof Transition;</span>
        }
<span class="nc" id="L979">        return false;</span>
    }

    private void paintTransitionAnimation() {
<span class="fc" id="L983">        Animation ani = animationQueue.get(0);</span>
<span class="pc bpc" id="L984" title="1 of 2 branches missed.">        if (!ani.animate()) {</span>
<span class="fc" id="L985">            animationQueue.remove(0);</span>
<span class="pc bpc" id="L986" title="1 of 2 branches missed.">            if (ani instanceof Transition) {</span>
<span class="fc" id="L987">                Form source = (Form) ((Transition) ani).getSource();</span>
<span class="fc" id="L988">                restoreMenu(source);</span>

<span class="fc bfc" id="L990" title="All 2 branches covered.">                if (animationQueue.size() &gt; 0) {</span>
<span class="fc" id="L991">                    ani = animationQueue.get(0);</span>
<span class="pc bpc" id="L992" title="1 of 2 branches missed.">                    if (ani instanceof Transition) {</span>
<span class="fc" id="L993">                        ((Transition) ani).initTransition();</span>
                    }
                } else {
<span class="fc" id="L996">                    Form f = (Form) ((Transition) ani).getDestination();</span>
<span class="fc" id="L997">                    restoreMenu(f);</span>
<span class="pc bpc" id="L998" title="4 of 6 branches missed.">                    if (source == null || source == impl.getCurrentForm() || source == getCurrent()) {</span>
<span class="fc" id="L999">                        setCurrentForm(f);</span>
                    }
<span class="fc" id="L1001">                    ((Transition) ani).cleanup();</span>
                }
<span class="fc" id="L1003">                return;</span>
            }
        }
<span class="nc" id="L1006">        ani.paint(codenameOneGraphics);</span>

<span class="nc" id="L1008">        impl.flushGraphics();</span>

<span class="nc bnc" id="L1010" title="All 2 branches missed.">        if (transitionDelay &gt; 0) {</span>
            // yield for a fraction, some devices don't &quot;properly&quot; implement
            // flush and so require the painting thread to get CPU too.
            try {
<span class="nc" id="L1014">                synchronized (lock) {</span>
<span class="nc" id="L1015">                    long end = System.currentTimeMillis() + transitionDelay;</span>
                    while (true) {
<span class="nc" id="L1017">                        long remaining = end - System.currentTimeMillis();</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">                        if (remaining &lt;= 0) {</span>
<span class="nc" id="L1019">                            break;</span>
                        }
<span class="nc" id="L1021">                        lock.wait(remaining);</span>
<span class="nc" id="L1022">                        break;</span>
                    }
<span class="nc" id="L1024">                }</span>
<span class="nc" id="L1025">            } catch (InterruptedException ex) {</span>
<span class="nc" id="L1026">                ex.printStackTrace();</span>
<span class="nc" id="L1027">            }</span>
        }
<span class="nc" id="L1029">    }</span>

    /**
     * This method represents the event thread for the UI library on which
     * all events are carried out. It differs from the MIDP event thread to
     * prevent blocking of actual input and drawing operations. This also
     * enables functionality such as &quot;true&quot; modal dialogs etc...
     */
    void mainEDTLoop() {
<span class="fc" id="L1038">        impl.initEDT();</span>
<span class="fc" id="L1039">        UIManager.getInstance();</span>
        try {
            // when there is no current form the EDT is useful only
            // for features such as call serially
<span class="fc bfc" id="L1043" title="All 2 branches covered.">            while (impl.getCurrentForm() == null) { // PMD Fix: AvoidBranchingStatementAsLastInLoop</span>
<span class="fc" id="L1044">                synchronized (lock) {</span>
<span class="pc bpc" id="L1045" title="1 of 4 branches missed.">                    while (shouldEDTSleep() &amp;&amp; pendingIdleSerialCalls.isEmpty()) {</span>
                        try {
<span class="fc" id="L1047">                            lock.wait();</span>
<span class="nc" id="L1048">                        } catch (InterruptedException ie) {</span>
<span class="nc" id="L1049">                            Thread.currentThread().interrupt();</span>
<span class="nc" id="L1050">                            break;</span>
<span class="fc" id="L1051">                        }</span>
                    }
<span class="pc bpc" id="L1053" title="3 of 4 branches missed.">                    if (shouldEDTSleep() &amp;&amp; !pendingIdleSerialCalls.isEmpty()) {</span>
<span class="nc" id="L1054">                        Runnable r = pendingIdleSerialCalls.remove(0);</span>
<span class="nc" id="L1055">                        callSerially(r);</span>
                    }

                    // paint transition or intro animations and don't do anything else if such
                    // animations are in progress...
<span class="pc bpc" id="L1060" title="1 of 4 branches missed.">                    if (animationQueue != null &amp;&amp; animationQueue.size() &gt; 0) {</span>
<span class="nc" id="L1061">                        paintTransitionAnimation();</span>
<span class="nc" id="L1062">                        continue;</span>
                    }
<span class="fc" id="L1064">                }</span>
<span class="fc" id="L1065">                processSerialCalls();</span>
            }
<span class="nc" id="L1067">        } catch (Throwable err) {</span>
<span class="nc" id="L1068">            Log.e(err);</span>
<span class="nc bnc" id="L1069" title="All 2 branches missed.">            if (crashReporter != null) {</span>
<span class="nc" id="L1070">                crashReporter.exception(err);</span>
            }
<span class="nc bnc" id="L1072" title="All 2 branches missed.">            if (!impl.handleEDTException(err)) {</span>
<span class="nc bnc" id="L1073" title="All 2 branches missed.">                if (errorHandler != null) {</span>
<span class="nc" id="L1074">                    errorHandler.fireActionEvent(new ActionEvent(err, ActionEvent.Type.Exception));</span>
                } else {
<span class="nc" id="L1076">                    Dialog.show(&quot;Error&quot;, &quot;An internal application error occurred: &quot; + err, &quot;OK&quot;, null);</span>
                }
            }
<span class="fc" id="L1079">        }</span>

<span class="fc bfc" id="L1081" title="All 2 branches covered.">        while (codenameOneRunning) { // PMD Fix: AvoidBranchingStatementAsLastInLoop</span>
            try {
                // wait indefinetly Lock surrounds the should method to prevent serial calls from
                // getting &quot;lost&quot;
<span class="fc" id="L1085">                synchronized (lock) {</span>
<span class="fc bfc" id="L1086" title="All 2 branches covered.">                    if (shouldEDTSleep()) {</span>
<span class="fc bfc" id="L1087" title="All 2 branches covered.">                        if (!pendingIdleSerialCalls.isEmpty()) {</span>
<span class="fc" id="L1088">                            Runnable r = pendingIdleSerialCalls.remove(0);</span>
<span class="fc" id="L1089">                            callSerially(r);</span>
<span class="fc" id="L1090">                        } else {</span>
<span class="fc" id="L1091">                            impl.edtIdle(true);</span>
<span class="pc bpc" id="L1092" title="1 of 4 branches missed.">                            while (shouldEDTSleep() &amp;&amp; pendingIdleSerialCalls.isEmpty()) {</span>
                                try {
<span class="fc" id="L1094">                                    lock.wait();</span>
<span class="nc" id="L1095">                                } catch (InterruptedException ie) {</span>
<span class="nc" id="L1096">                                    Thread.currentThread().interrupt();</span>
<span class="nc" id="L1097">                                    break;</span>
<span class="fc" id="L1098">                                }</span>
                            }
<span class="fc" id="L1100">                            impl.edtIdle(false);</span>
<span class="pc bpc" id="L1101" title="1 of 2 branches missed.">                            if (!pendingIdleSerialCalls.isEmpty()) {</span>
<span class="nc" id="L1102">                                Runnable r = pendingIdleSerialCalls.remove(0);</span>
<span class="nc" id="L1103">                                callSerially(r);</span>
                            }
                        }
                    }
<span class="fc" id="L1107">                }</span>


<span class="fc" id="L1110">                edtLoopImpl();</span>
<span class="nc" id="L1111">            } catch (Throwable err) {</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">                if (!codenameOneRunning) {</span>
<span class="nc" id="L1113">                    return;</span>
                }
<span class="nc" id="L1115">                Log.e(err);</span>
<span class="nc bnc" id="L1116" title="All 2 branches missed.">                if (crashReporter != null) {</span>
<span class="nc" id="L1117">                    CodenameOneThread.handleException(err);</span>
                }
<span class="nc bnc" id="L1119" title="All 2 branches missed.">                if (!impl.handleEDTException(err)) {</span>
<span class="nc bnc" id="L1120" title="All 2 branches missed.">                    if (errorHandler != null) {</span>
<span class="nc" id="L1121">                        errorHandler.fireActionEvent(new ActionEvent(err, ActionEvent.Type.Exception));</span>
                    } else {
<span class="nc" id="L1123">                        Dialog.show(&quot;Error&quot;, &quot;An internal application error occurred: &quot; + err, &quot;OK&quot;, null);</span>
                    }
                }
<span class="pc" id="L1126">            }</span>
        }
<span class="fc" id="L1128">        impl.deinitialize();</span>
        //INSTANCE.impl = null;
        //INSTANCE.codenameOneGraphics = null;
<span class="fc" id="L1131">        INSTANCE.edt = null;</span>
<span class="fc" id="L1132">    }</span>

    /**
     * Returns the stack trace from the exception on the given
     * thread. This API isn't supported on all platforms and may
     * return a blank string when unavailable.
     *
     * @param parentThread the thread in which the exception was thrown
     * @param t the exception
     * @return a stack trace string that might be blank
     */
    public String getStackTrace(Thread parentThread, Throwable t) {
<span class="nc" id="L1144">        System.out.println(&quot;CN1SS:ERR:Invoking getStackTrace in Display&quot;);</span>
<span class="nc" id="L1145">        return impl.getStackTrace(parentThread, t);</span>
    }

    /**
     * Implementation of the event dispatch loop content
     */
    void edtLoopImpl() {
        try {
            // transitions shouldn't be bound by framerate
<span class="fc bfc" id="L1154" title="All 4 branches covered.">            if (animationQueue == null || animationQueue.size() == 0) {</span>
                // prevents us from waking up the EDT too much and
                // thus exhausting the systems resources. The + 1
                // prevents us from ever waiting 0 milliseconds which
                // is the same as waiting with no time limit
<span class="pc bpc" id="L1159" title="1 of 2 branches missed.">                if (!noSleep) {</span>
<span class="fc" id="L1160">                    synchronized (lock) {</span>
<span class="fc" id="L1161">                        impl.edtIdle(true);</span>
<span class="fc" id="L1162">                        long waitTime = Math.max(1, framerateLock - (time));</span>
<span class="fc" id="L1163">                        long end = System.currentTimeMillis() + waitTime;</span>
                        while (true) {
<span class="fc" id="L1165">                            long remaining = end - System.currentTimeMillis();</span>
<span class="pc bpc" id="L1166" title="1 of 2 branches missed.">                            if (remaining &lt;= 0) {</span>
<span class="nc" id="L1167">                                break;</span>
                            }
                            try {
<span class="fc" id="L1170">                                lock.wait(remaining);</span>
<span class="fc" id="L1171">                                break;</span>
<span class="nc" id="L1172">                            } catch (InterruptedException ie) {</span>
<span class="nc" id="L1173">                                Thread.currentThread().interrupt();</span>
<span class="nc" id="L1174">                                break;</span>
                            }
                        }
<span class="fc" id="L1177">                        impl.edtIdle(false);</span>
<span class="fc" id="L1178">                    }</span>
                }
            } else {
                // paint transition or intro animations and don't do anything else if such
                // animations are in progress...
<span class="fc" id="L1183">                paintTransitionAnimation();</span>
<span class="fc" id="L1184">                return;</span>
            }
<span class="nc" id="L1186">        } catch (Exception ignor) {</span>
<span class="nc" id="L1187">            Log.e(ignor);</span>
<span class="fc" id="L1188">        }</span>
<span class="fc" id="L1189">        long currentTime = System.currentTimeMillis();</span>

        // minimal amount of sync, just flipping the stack pointers
<span class="fc" id="L1192">        synchronized (lock) {</span>
<span class="fc" id="L1193">            inputEventStackPointerTmp = inputEventStackPointer;</span>
<span class="fc" id="L1194">            inputEventStackPointer = 0;</span>
<span class="fc" id="L1195">            lastDragOffset = -1;</span>
<span class="fc" id="L1196">            int[] qt = inputEventStackTmp;</span>
<span class="fc" id="L1197">            inputEventStackTmp = inputEventStack;</span>

            // We have a special flag here for a case where the input event stack might still be processing this can
            // happen if an event callback calls something like invokeAndBlock while processing and might reach
            // this code again
<span class="pc bpc" id="L1202" title="1 of 2 branches missed.">            if (qt[qt.length - 1] == Integer.MAX_VALUE) {</span>
<span class="nc" id="L1203">                inputEventStack = new int[qt.length];</span>
            } else {
<span class="fc" id="L1205">                inputEventStack = qt;</span>
<span class="fc" id="L1206">                qt[qt.length - 1] = 0;</span>
            }
<span class="fc" id="L1208">        }</span>

        // we copy the variables to the stack since the array might be replaced while we are working if the EDT
        // is nested into an &quot;invokeAndBlock&quot;
<span class="fc" id="L1212">        int actualTmpPointer = inputEventStackPointerTmp;</span>
<span class="fc" id="L1213">        inputEventStackPointerTmp = 0;</span>
<span class="fc" id="L1214">        int[] actualStack = inputEventStackTmp;</span>
<span class="fc" id="L1215">        int offset = 0;</span>
<span class="fc" id="L1216">        actualStack[actualStack.length - 1] = Integer.MAX_VALUE;</span>
<span class="fc bfc" id="L1217" title="All 2 branches covered.">        while (offset &lt; actualTmpPointer) {</span>
<span class="fc" id="L1218">            offset = handleEvent(offset, actualStack);</span>
        }

<span class="fc" id="L1221">        actualStack[actualStack.length - 1] = 0;</span>

<span class="pc bpc" id="L1223" title="1 of 2 branches missed.">        if (!impl.isInitialized()) {</span>
<span class="nc" id="L1224">            return;</span>
        }
<span class="fc" id="L1226">        codenameOneGraphics.setGraphics(impl.getNativeGraphics());</span>
<span class="fc" id="L1227">        Form current = impl.getCurrentForm();</span>
<span class="fc bfc" id="L1228" title="All 2 branches covered.">        if (current != null) {</span>
            // Revalidate components that registered to be revalidated
            // before the next paint cycle.
<span class="fc" id="L1231">            current.flushRevalidateQueue();</span>
        }
<span class="fc" id="L1233">        impl.paintDirty();</span>

        // draw the animations

<span class="fc bfc" id="L1237" title="All 2 branches covered.">        if (current != null) {</span>
<span class="fc" id="L1238">            current.repaintAnimations();</span>
            // check key repeat events
<span class="fc" id="L1240">            long t = System.currentTimeMillis();</span>
<span class="pc bpc" id="L1241" title="3 of 4 branches missed.">            if (keyRepeatCharged &amp;&amp; nextKeyRepeatEvent &lt;= t) {</span>
<span class="nc" id="L1242">                current.keyRepeated(keyRepeatValue);</span>
<span class="nc" id="L1243">                nextKeyRepeatEvent = t + keyRepeatNextIntervalTime;</span>
            }
<span class="pc bpc" id="L1245" title="3 of 4 branches missed.">            if (longPressCharged &amp;&amp; longPressInterval &lt;= t - longKeyPressTime) {</span>
<span class="nc" id="L1246">                longPressCharged = false;</span>
<span class="nc" id="L1247">                current.longKeyPress(keyRepeatValue);</span>
            }
<span class="pc bpc" id="L1249" title="3 of 4 branches missed.">            if (longPointerCharged &amp;&amp; longPressInterval &lt;= t - longKeyPressTime) {</span>
<span class="nc" id="L1250">                longPointerCharged = false;</span>
<span class="nc" id="L1251">                current.longPointerPress(pointerX, pointerY);</span>
            }
        }
<span class="fc" id="L1254">        processSerialCalls();</span>

<span class="fc" id="L1256">        time = System.currentTimeMillis() - currentTime;</span>
<span class="fc" id="L1257">    }</span>

    boolean hasNoSerialCallsPending() {
<span class="fc bfc" id="L1260" title="All 2 branches covered.">        return pendingSerialCalls.size() == 0;</span>
    }

    /**
     * Called by the underlying implementation to indicate that editing in the native
     * system has completed and changes should propagate into Codename One
     *
     * @param c    edited component
     * @param text new text for the component
     */
    public void onEditingComplete(final Component c, final String text) {
<span class="pc bpc" id="L1271" title="3 of 4 branches missed.">        if (!isEdt() &amp;&amp; codenameOneRunning) {</span>
<span class="nc" id="L1272">            Display.getInstance().callSerially(new Runnable() {</span>
                public void run() {
<span class="nc" id="L1274">                    onEditingComplete(c, text);</span>
<span class="nc" id="L1275">                }</span>
            });
<span class="nc" id="L1277">            return;</span>
        }
<span class="fc" id="L1279">        c.onEditComplete(text);</span>
<span class="fc" id="L1280">        c.fireActionEvent();</span>
<span class="fc" id="L1281">    }</span>

    /**
     * Used by the EDT to process all the calls submitted via call serially
     */
    void processSerialCalls() {
<span class="fc" id="L1287">        processingSerialCalls = true;</span>
<span class="fc" id="L1288">        int size = pendingSerialCalls.size();</span>
<span class="fc bfc" id="L1289" title="All 2 branches covered.">        if (size &gt; 0) {</span>
            //Runnable[] array = null;
<span class="fc" id="L1291">            synchronized (lock) {</span>
<span class="fc" id="L1292">                size = pendingSerialCalls.size();</span>
                //array = new Runnable[size];

                // copy all elements to an array and remove them otherwise invokeAndBlock from
                // within a callSerially() can cause an infinite loop...
                //pendingSerialCalls.toArray(array);
<span class="fc" id="L1298">                runningSerialCallsQueue.addAll(pendingSerialCalls);</span>

<span class="pc bpc" id="L1300" title="1 of 2 branches missed.">                if (size == pendingSerialCalls.size()) {</span>
                    // this is faster
<span class="fc" id="L1302">                    pendingSerialCalls.clear();</span>
                } else {
                    // this can occur if an element was added during the loop
<span class="nc bnc" id="L1305" title="All 2 branches missed.">                    for (int iter = 0; iter &lt; size; iter++) {</span>
<span class="nc" id="L1306">                        pendingSerialCalls.remove(0);</span>
                    }
                }
<span class="fc" id="L1309">            }</span>
<span class="fc bfc" id="L1310" title="All 2 branches covered.">            while (!runningSerialCallsQueue.isEmpty()) {</span>
<span class="fc" id="L1311">                executeSerialCall(runningSerialCallsQueue.remove(0));</span>
            }

            // after finishing an event cycle there might be serial calls waiting
            // to return.
<span class="fc" id="L1316">            synchronized (lock) {</span>
<span class="fc" id="L1317">                lock.notify();</span>
<span class="fc" id="L1318">            }</span>
        }
<span class="fc" id="L1320">        processingSerialCalls = false;</span>
<span class="fc" id="L1321">    }</span>

    // Executes a Runnable from a pending serial call. We wrap it in its
    // own function so we can use the Async.Execute annotation for debugging.
    // https://www.jetbrains.com/help/idea/debug-asynchronous-code.html
    private void executeSerialCall(@Async.Execute Runnable r) {
<span class="fc" id="L1327">        r.run();</span>
<span class="fc" id="L1328">    }</span>

    boolean isProcessingSerialCalls() {
<span class="nc" id="L1331">        return processingSerialCalls;</span>
    }

    void notifyDisplay() {
<span class="fc" id="L1335">        synchronized (lock) {</span>
<span class="fc" id="L1336">            lock.notify();</span>
<span class="fc" id="L1337">        }</span>
<span class="fc" id="L1338">    }</span>

    /**
     * Invokes a Runnable with blocking disabled.  If any attempt is made to block
     * (i.e. call {@link #invokeAndBlock(java.lang.Runnable) } from inside this Runnable,
     * it will result in a {@link BlockingDisallowedException} being thrown.
     *
     * @param r Runnable to be run immediately.
     * @throws BlockingDisallowedException If {@link #invokeAndBlock(java.lang.Runnable) } is attempted
     *                                     anywhere in the Runnable.
     * @since 7.0
     */
    public void invokeWithoutBlocking(Runnable r) {
<span class="nc bnc" id="L1351" title="All 4 branches missed.">        if (disableInvokeAndBlock || !isEdt()) {</span>
<span class="nc" id="L1352">            r.run();</span>
        } else {
<span class="nc" id="L1354">            disableInvokeAndBlock = true;</span>
            try {
<span class="nc" id="L1356">                r.run();</span>
            } finally {
<span class="nc" id="L1358">                disableInvokeAndBlock = false;</span>
            }
        }
<span class="nc" id="L1361">    }</span>

    /**
     * Invokes a RunnableWithResultSync with blocking disabled.  If any attempt is made to block
     * (i.e. call {@link #invokeAndBlock(java.lang.Runnable) } from inside this Runnable,
     * it will result in a {@link BlockingDisallowedException} being thrown.
     *
     * @param r RunnableWithResultSync to be run immediately.
     * @throws BlockingDisallowedException If {@link #invokeAndBlock(java.lang.Runnable) } is attempted
     *                                     anywhere in the Runnable.
     * @since 7.0
     */
    public &lt;T&gt; T invokeWithoutBlockingWithResultSync(RunnableWithResultSync&lt;T&gt; r) {
<span class="pc bpc" id="L1374" title="2 of 4 branches missed.">        if (disableInvokeAndBlock || !isEdt()) {</span>
<span class="nc" id="L1375">            return r.run();</span>
        } else {
<span class="fc" id="L1377">            disableInvokeAndBlock = true;</span>
            try {
<span class="fc" id="L1379">                return r.run();</span>
            } finally {
<span class="fc" id="L1381">                disableInvokeAndBlock = false;</span>
            }
        }
    }

    /**
     * Invokes runnable and blocks the current thread, if the current thread is the
     * EDT it will still be blocked in a way that doesn't break event dispatch .
     * &lt;b&gt;Important:&lt;/b&gt; calling this method spawns a new thread that shouldn't access the UI!&lt;br /&gt;
     * See &lt;a href=&quot;https://www.codenameone.com/manual/edt.html#_invoke_and_block&quot;&gt;
     * this section&lt;/a&gt; in the developer guide for further information.
     *
     * @param r          runnable (NOT A THREAD!) that will be invoked synchronously by this method
     * @param dropEvents indicates if the display should drop all events
     *                   while this runnable is running
     * @throws BlockingDisallowedException if this method is called while blocking is disabled (i.e. we are running
     *                                     inside a call to {@link #invokeWithoutBlocking(java.lang.Runnable) } on the EDT).
     */
    public void invokeAndBlock(Runnable r, boolean dropEvents) {
<span class="fc" id="L1400">        this.dropEvents = dropEvents;</span>
        try {
<span class="pc bpc" id="L1402" title="1 of 2 branches missed.">            if (isEdt()) {</span>
<span class="pc bpc" id="L1403" title="1 of 2 branches missed.">                if (disableInvokeAndBlock) {</span>
<span class="nc" id="L1404">                    throw new BlockingDisallowedException();</span>
                }
                // this class allows a runtime exception to propogate correctly out of the
                // internal thread
<span class="fc" id="L1408">                RunnableWrapper w = new RunnableWrapper(r, 1);</span>
<span class="fc" id="L1409">                RunnableWrapper.pushToThreadPool(w);</span>

<span class="fc" id="L1411">                synchronized (lock) {</span>
                    // prevent an invoke and block loop from breaking the ongoing event processing
<span class="pc bpc" id="L1413" title="1 of 2 branches missed.">                    if (inputEventStackPointerTmp &gt; 0) {</span>
<span class="nc" id="L1414">                        inputEventStackPointerTmp = inputEventStackPointer;</span>
                    }
                    try {
                        // yield the CPU for a very short time to let the invoke thread
                        // get started
<span class="fc" id="L1419">                        lock.wait(2);</span>
<span class="nc" id="L1420">                    } catch (InterruptedException ex) {</span>
<span class="nc" id="L1421">                        ex.printStackTrace();</span>
<span class="fc" id="L1422">                    }</span>

<span class="fc bfc" id="L1424" title="All 2 branches covered.">                    while (!runningSerialCallsQueue.isEmpty()) {</span>
<span class="fc" id="L1425">                        pendingSerialCalls.add(0, runningSerialCallsQueue.removeLast());</span>
                    }
<span class="fc" id="L1427">                }</span>


                // loop over the EDT until the thread completes then return
<span class="pc bpc" id="L1431" title="1 of 4 branches missed.">                while (!w.isDone() &amp;&amp; codenameOneRunning) {</span>
<span class="fc" id="L1432">                    edtLoopImpl();</span>
<span class="fc" id="L1433">                    synchronized (lock) {</span>
<span class="fc bfc" id="L1434" title="All 2 branches covered.">                        if (shouldEDTSleep()) {</span>
<span class="fc" id="L1435">                            impl.edtIdle(true);</span>
                            try {
<span class="fc" id="L1437">                                lock.wait(10);</span>
<span class="nc" id="L1438">                            } catch (InterruptedException ex) {</span>
<span class="fc" id="L1439">                            }</span>
<span class="fc" id="L1440">                            impl.edtIdle(false);</span>
                        }
<span class="fc" id="L1442">                    }</span>
                }
                // if the thread thew an exception we need to throw it onwards
<span class="pc bpc" id="L1445" title="1 of 2 branches missed.">                if (w.getErr() != null) {</span>
<span class="nc" id="L1446">                    throw w.getErr();</span>
                }
<span class="fc" id="L1448">            } else {</span>
<span class="nc" id="L1449">                r.run();</span>
            }
<span class="nc" id="L1451">        } catch (RuntimeException re) {</span>
<span class="nc bnc" id="L1452" title="All 2 branches missed.">            if (!(re instanceof BlockingDisallowedException)) {</span>
<span class="nc" id="L1453">                Log.e(re);</span>
            }
<span class="nc" id="L1455">            throw re;</span>
        } finally {
<span class="fc" id="L1457">            this.dropEvents = false;</span>
        }
<span class="fc" id="L1459">    }</span>

    /**
     * Invokes runnable and blocks the current thread, if the current thread is the
     * EDT it will still be blocked in a way that doesn't break event dispatch .
     * &lt;b&gt;Important:&lt;/b&gt; calling this method spawns a new thread that shouldn't access the UI!&lt;br /&gt;
     * See &lt;a href=&quot;https://www.codenameone.com/manual/edt.html#_invoke_and_block&quot;&gt;
     * this section&lt;/a&gt; in the developer guide for further information.
     *
     * @param r runnable (NOT A THREAD!) that will be invoked synchroniously by this method
     */
    public void invokeAndBlock(Runnable r) {
<span class="fc" id="L1471">        invokeAndBlock(r, false);</span>
<span class="fc" id="L1472">    }</span>

    /**
     * The name of this method is misleading due to it's legacy. It will return true on the desktop too where
     * the mouse sends pointer events.
     *
     * @return true if this device supports touch/pointer events
     */
    public boolean isTouchScreenDevice() {
<span class="fc" id="L1481">        return touchScreen;</span>
    }

    /**
     * Indicates if this is a touch screen device that will return pen events,
     * defaults to true if the device has pen events but can be overriden by
     * the developer.
     *
     * @param touchScreen false if this is not a touch screen device
     */
    public void setTouchScreenDevice(boolean touchScreen) {
<span class="fc" id="L1492">        this.touchScreen = touchScreen;</span>
<span class="fc" id="L1493">    }</span>

    /**
     * Calling this method with noSleep=true will cause the edt to run without sleeping.
     *
     * @param noSleep causes the edt to stop the sleeping periods between 2 cycles
     */
    public void setNoSleep(boolean noSleep) {
<span class="nc" id="L1501">        this.noSleep = noSleep;</span>
<span class="nc" id="L1502">    }</span>

    /**
     * Displays the given Form on the screen.
     *
     * @param newForm the Form to Display
     */
    void setCurrent(final Form newForm, boolean reverse) {
<span class="pc bpc" id="L1510" title="1 of 2 branches missed.">        if (edt == null) {</span>
<span class="nc" id="L1511">            throw new IllegalStateException(&quot;Initialize must be invoked before setCurrent!&quot;);</span>
        }
<span class="fc" id="L1513">        Form current = impl.getCurrentForm();</span>


<span class="pc bpc" id="L1516" title="1 of 4 branches missed.">        if (autoFoldVKBOnFormSwitch &amp;&amp; !(newForm instanceof Dialog)) {</span>
<span class="fc" id="L1517">            setShowVirtualKeyboard(false);</span>
        }

<span class="fc bfc" id="L1520" title="All 2 branches covered.">        if (current == newForm) {</span>
<span class="fc" id="L1521">            current.revalidate();</span>
<span class="fc" id="L1522">            current.repaint();</span>
<span class="fc" id="L1523">            current.onShowCompletedImpl();</span>
<span class="fc" id="L1524">            return;</span>
        }

<span class="pc bpc" id="L1527" title="1 of 2 branches missed.">        if (impl.isEditingText()) {</span>
<span class="nc bnc" id="L1528" title="All 6 branches missed.">            switch (showDuringEdit) {</span>
                case SHOW_DURING_EDIT_ALLOW_DISCARD:
<span class="nc" id="L1530">                    break;</span>
                case SHOW_DURING_EDIT_ALLOW_SAVE:
<span class="nc" id="L1532">                    impl.saveTextEditingState();</span>
<span class="nc" id="L1533">                    break;</span>
                case SHOW_DURING_EDIT_EXCEPTION:
<span class="nc" id="L1535">                    throw new IllegalStateException(&quot;Show during edit&quot;);</span>
                case SHOW_DURING_EDIT_IGNORE:
<span class="nc" id="L1537">                    return;</span>
                case SHOW_DURING_EDIT_SET_AS_NEXT:
<span class="nc" id="L1539">                    impl.setCurrentForm(newForm);</span>
<span class="nc" id="L1540">                    return;</span>
            }
        }

<span class="fc bfc" id="L1544" title="All 2 branches covered.">        if (!isEdt()) {</span>
<span class="fc" id="L1545">            callSerially(new RunnableWrapper(newForm, null, reverse));</span>
<span class="fc" id="L1546">            return;</span>
        }

<span class="fc bfc" id="L1549" title="All 2 branches covered.">        if (current != null) {</span>
<span class="fc bfc" id="L1550" title="All 2 branches covered.">            if (current.isInitialized()) {</span>
<span class="fc" id="L1551">                current.deinitializeImpl();</span>
            } else {
<span class="fc" id="L1553">                Form fg = getCurrentUpcoming();</span>
<span class="pc bpc" id="L1554" title="1 of 2 branches missed.">                if (fg != current) {</span>
<span class="pc bpc" id="L1555" title="1 of 2 branches missed.">                    if (fg.isInitialized()) {</span>
<span class="fc" id="L1556">                        fg.deinitializeImpl();</span>
                    }
                }
            }
        }
<span class="fc bfc" id="L1561" title="All 2 branches covered.">        if (!newForm.isInitialized()) {</span>
<span class="fc" id="L1562">            newForm.initComponentImpl();</span>
        }

<span class="pc bpc" id="L1565" title="2 of 4 branches missed.">        if (newForm.getWidth() != getDisplayWidth() || newForm.getHeight() != getDisplayHeight()) {</span>
<span class="nc" id="L1566">            newForm.setSize(new Dimension(getDisplayWidth(), getDisplayHeight()));</span>
<span class="nc" id="L1567">            newForm.setShouldCalcPreferredSize(true);</span>
<span class="nc" id="L1568">            newForm.layoutContainer();</span>
<span class="nc" id="L1569">            newForm.revalidate();</span>
        } else {
            // if shouldLayout is true
<span class="fc" id="L1572">            newForm.layoutContainer();</span>
<span class="fc" id="L1573">            newForm.revalidate();</span>

        }

<span class="fc" id="L1577">        boolean transitionExists = false;</span>
<span class="fc bfc" id="L1578" title="All 4 branches covered.">        if (animationQueue != null &amp;&amp; animationQueue.size() &gt; 0) {</span>
<span class="fc" id="L1579">            Object o = animationQueue.get(animationQueue.size() - 1);</span>
<span class="pc bpc" id="L1580" title="1 of 2 branches missed.">            if (o instanceof Transition) {</span>
<span class="fc" id="L1581">                current = (Form) ((Transition) o).getDestination();</span>
<span class="fc" id="L1582">                impl.setCurrentForm(current);</span>
            }
        }

<span class="fc bfc" id="L1586" title="All 2 branches covered.">        if (current != null) {</span>
            // make sure the fold menu occurs as expected then set the current
            // to the correct parent!
<span class="pc bpc" id="L1589" title="1 of 4 branches missed.">            if (current instanceof Dialog &amp;&amp; current.isMenu()) {</span>
<span class="nc" id="L1590">                Transition t = current.getTransitionOutAnimator();</span>
<span class="nc bnc" id="L1591" title="All 2 branches missed.">                if (t != null) {</span>
                    // go back to the parent form first
<span class="nc bnc" id="L1593" title="All 2 branches missed.">                    if (current.getPreviousForm() != null) {</span>
<span class="nc" id="L1594">                        initTransition(t.copy(false), current, current.getPreviousForm());</span>
                    }
                }
<span class="nc" id="L1597">                current = current.getPreviousForm();</span>
<span class="nc" id="L1598">                impl.setCurrentForm(current);</span>
            }

            // prevent the transition from occurring from a form into itself
<span class="fc bfc" id="L1602" title="All 2 branches covered.">            if (newForm != current) {</span>
<span class="pc bpc" id="L1603" title="1 of 6 branches missed.">                if ((current != null &amp;&amp; current.getTransitionOutAnimator() != null) || newForm.getTransitionInAnimator() != null) {</span>
<span class="fc bfc" id="L1604" title="All 2 branches covered.">                    if (animationQueue == null) {</span>
<span class="fc" id="L1605">                        animationQueue = new ArrayList&lt;Animation&gt;();</span>
                    }
                    // prevent form transitions from breaking our dialog based
                    // transitions which are a bit sensitive
<span class="pc bpc" id="L1609" title="1 of 4 branches missed.">                    if (current != null &amp;&amp; (!(newForm instanceof Dialog))) {</span>
<span class="fc" id="L1610">                        Transition t = current.getTransitionOutAnimator();</span>
<span class="pc bpc" id="L1611" title="2 of 4 branches missed.">                        if (current != null &amp;&amp; t != null) {</span>
<span class="fc" id="L1612">                            transitionExists = initTransition(t.copy(reverse), current, newForm);</span>
                        }
                    }
<span class="pc bpc" id="L1615" title="1 of 4 branches missed.">                    if (current != null &amp;&amp; !(current instanceof Dialog)) {</span>
<span class="fc" id="L1616">                        Transition t = newForm.getTransitionInAnimator();</span>
<span class="pc bpc" id="L1617" title="1 of 2 branches missed.">                        if (t != null) {</span>
<span class="fc" id="L1618">                            transitionExists = initTransition(t.copy(reverse), current, newForm);</span>
                        }
                    }
                }
            }
        }
<span class="fc" id="L1624">        synchronized (lock) {</span>
<span class="fc" id="L1625">            lock.notify();</span>
<span class="fc" id="L1626">        }</span>

<span class="fc bfc" id="L1628" title="All 2 branches covered.">        if (!transitionExists) {</span>
<span class="fc bfc" id="L1629" title="All 4 branches covered.">            if (animationQueue == null || animationQueue.size() == 0) {</span>
<span class="fc" id="L1630">                setCurrentForm(newForm);</span>
            } else {
                // we need to add an empty transition to &quot;serialize&quot; this
                // screen change...
<span class="fc" id="L1634">                Transition t = CommonTransitions.createEmpty();</span>
<span class="fc" id="L1635">                initTransition(t, current, newForm);</span>
            }
        }
<span class="fc" id="L1638">    }</span>

    /**
     * Initialize the transition and add it to the queue
     */
    private boolean initTransition(Transition transition, Form source, Form dest) {
        try {
<span class="fc" id="L1645">            dest.setVisible(true);</span>
<span class="fc" id="L1646">            transition.init(source, dest);</span>
<span class="pc bpc" id="L1647" title="1 of 2 branches missed.">            if (source != null) {</span>
<span class="fc" id="L1648">                source.setLightweightMode(true);</span>
            }
<span class="pc bpc" id="L1650" title="1 of 2 branches missed.">            if (dest != null) {</span>
<span class="fc" id="L1651">                dest.setLightweightMode(true);</span>
            }

            // if a native transition implementation exists then substitute it into place
<span class="fc" id="L1655">            transition = impl.getNativeTransition(transition);</span>
<span class="fc" id="L1656">            animationQueue.add(transition);</span>

<span class="fc bfc" id="L1658" title="All 2 branches covered.">            if (animationQueue.size() == 1) {</span>
<span class="fc" id="L1659">                transition.initTransition();</span>
            }
<span class="nc" id="L1661">        } catch (Throwable e) {</span>
<span class="nc" id="L1662">            Log.e(e);</span>
<span class="nc" id="L1663">            transition.cleanup();</span>
<span class="nc" id="L1664">            animationQueue.remove(transition);</span>
<span class="nc" id="L1665">            return false;</span>
<span class="fc" id="L1666">        }</span>
<span class="fc" id="L1667">        return true;</span>
    }

    void setCurrentForm(Form newForm) {
<span class="fc" id="L1671">        boolean forceShow = false;</span>
<span class="fc" id="L1672">        Form current = impl.getCurrentForm();</span>
<span class="fc bfc" id="L1673" title="All 2 branches covered.">        if (current != null) {</span>
<span class="fc" id="L1674">            current.setVisible(false);</span>
        } else {
<span class="fc" id="L1676">            forceShow = true;</span>
        }
<span class="fc bfc" id="L1678" title="All 2 branches covered.">        if (!initialWindowSizeApplied) {</span>
<span class="fc" id="L1679">            initialWindowSizeApplied = applyInitialWindowSize(newForm);</span>
        }
<span class="fc" id="L1681">        keyRepeatCharged = false;</span>
<span class="fc" id="L1682">        longPressCharged = false;</span>
<span class="fc" id="L1683">        longPointerCharged = false;</span>
<span class="fc" id="L1684">        current = newForm;</span>
<span class="fc" id="L1685">        impl.setCurrentForm(current);</span>
<span class="fc" id="L1686">        current.setVisible(true);</span>
<span class="pc bpc" id="L1687" title="3 of 6 branches missed.">        if (forceShow || !allowMinimizing || inNativeUI) {</span>
<span class="fc" id="L1688">            impl.confirmControlView();</span>
        }
<span class="fc" id="L1690">        int w = current.getWidth();</span>
<span class="fc" id="L1691">        int h = current.getHeight();</span>
<span class="pc bpc" id="L1692" title="2 of 6 branches missed.">        if (isEdt() &amp;&amp; (w != impl.getDisplayWidth() || h != impl.getDisplayHeight())) {</span>
<span class="fc" id="L1693">            current.sizeChangedInternal(impl.getDisplayWidth(), impl.getDisplayHeight());</span>
        } else {
<span class="fc" id="L1695">            repaint(current);</span>
        }
<span class="fc" id="L1697">        lastKeyPressed = 0;</span>
<span class="fc" id="L1698">        previousKeyPressed = 0;</span>
<span class="fc" id="L1699">        newForm.onShowCompletedImpl();</span>
<span class="fc" id="L1700">    }</span>

    private boolean applyInitialWindowSize(Form form) {
<span class="pc bpc" id="L1703" title="1 of 2 branches missed.">        if (form == null) {</span>
<span class="nc" id="L1704">            return false;</span>
        }
<span class="fc" id="L1706">        Object hint = form.getClientProperty(WINDOW_SIZE_HINT_PERCENT);</span>
<span class="fc bfc" id="L1707" title="All 2 branches covered.">        if (!(hint instanceof Dimension)) {</span>
<span class="fc" id="L1708">            return false;</span>
        }
<span class="fc" id="L1710">        impl.setInitialWindowSizeHintPercent((Dimension) hint);</span>
<span class="fc" id="L1711">        return true;</span>
    }

    /**
     * Indicates whether a delay should exist between calls to flush graphics during
     * transition. In some devices flushGraphics is asynchronious causing it to be
     * very slow with our background thread. The solution is to add a short wait allowing
     * the implementation time to paint the screen. This value is set automatically by default
     * but can be overriden for some devices.
     *
     * @param transitionD -1 for no delay otherwise delay in milliseconds
     */
    public void setTransitionYield(int transitionD) {
<span class="nc" id="L1724">        transitionDelay = transitionD;</span>
<span class="nc" id="L1725">    }</span>

    /**
     * Fires the native in place text editing logic, normally you wouldn't invoke this API directly and instead
     * use an API like {@link com.codename1.ui.TextArea#startEditingAsync()}, {@link com.codename1.ui.TextArea#startEditing()}
     * or {@link com.codename1.ui.Form#setEditOnShow(com.codename1.ui.TextArea)}.
     *
     * @param cmp        the {@link TextArea} component
     * @param maxSize    the maximum size from the text area
     * @param constraint the constraints of the text area
     * @param text       the string to edit
     */
    public void editString(Component cmp, int maxSize, int constraint, String text) {
<span class="fc" id="L1738">        editString(cmp, maxSize, constraint, text, 0);</span>
<span class="fc" id="L1739">    }</span>

    /**
     * Fires the native in place text editing logic, normally you wouldn't invoke this API directly and instead
     * use an API like {@link com.codename1.ui.TextArea#startEditingAsync()}, {@link com.codename1.ui.TextArea#startEditing()}
     * or {@link com.codename1.ui.Form#setEditOnShow(com.codename1.ui.TextArea)}.
     *
     * @param cmp               the {@link TextArea} component
     * @param maxSize           the maximum size from the text area
     * @param constraint        the constraints of the text area
     * @param text              the string to edit
     * @param initiatingKeycode the keycode used to initiate the edit.
     */
    public void editString(Component cmp, int maxSize, int constraint, String text, int initiatingKeycode) {
<span class="pc bpc" id="L1753" title="1 of 2 branches missed.">        if (isTextEditing(cmp)) {</span>
<span class="nc" id="L1754">            return;</span>
        }
<span class="fc" id="L1756">        cmp.requestFocus();</span>
<span class="pc bpc" id="L1757" title="1 of 2 branches missed.">        if (cmp instanceof TextArea) {</span>
<span class="fc" id="L1758">            ((TextArea) cmp).setSuppressActionEvent(false);</span>
        }
<span class="fc" id="L1760">        Form f = cmp.getComponentForm();</span>

        // this can happen in the spinner in the simulator where the key press should in theory start native
        // edit
<span class="fc bfc" id="L1764" title="All 2 branches covered.">        if (f == null) {</span>
<span class="fc" id="L1765">            return;</span>
        }
<span class="fc" id="L1767">        Component.setDisableSmoothScrolling(true);</span>
<span class="fc" id="L1768">        f.scrollComponentToVisible(cmp);</span>
<span class="fc" id="L1769">        Component.setDisableSmoothScrolling(false);</span>
<span class="fc" id="L1770">        keyRepeatCharged = false;</span>
<span class="fc" id="L1771">        longPressCharged = false;</span>
<span class="fc" id="L1772">        lastKeyPressed = 0;</span>
<span class="fc" id="L1773">        previousKeyPressed = 0;</span>
<span class="fc" id="L1774">        impl.editStringImpl(cmp, maxSize, constraint, text, initiatingKeycode);</span>
<span class="fc" id="L1775">    }</span>

    /**
     * Allows us to stop editString on the given text component
     *
     * @param cmp the text field/text area component
     */
    public void stopEditing(Component cmp) {
<span class="fc bfc" id="L1783" title="All 2 branches covered.">        if (isTextEditing(cmp)) {</span>
<span class="fc" id="L1784">            impl.stopTextEditing();</span>
        }
<span class="fc" id="L1786">    }</span>

    /**
     * Allows us to stop editString on the given text component or Form.
     * If {@literal cmp} is a {@link Form}, it will stop editing in any active
     * component on the form, and close the keyboard if it is opened.
     *
     * @param cmp      the text field/text area component
     * @param onFinish invoked when editing stopped
     */
    public void stopEditing(Component cmp, Runnable onFinish) {
<span class="pc bpc" id="L1797" title="1 of 2 branches missed.">        if (isTextEditing(cmp)) {</span>
<span class="nc" id="L1798">            impl.stopTextEditing(onFinish);</span>
        } else {
<span class="pc bpc" id="L1800" title="1 of 2 branches missed.">            if (onFinish != null) {</span>
<span class="fc" id="L1801">                onFinish.run();</span>
            }
        }
<span class="fc" id="L1804">    }</span>

    boolean isTextEditing(Component c) {
<span class="pc bpc" id="L1807" title="1 of 4 branches missed.">        if (c instanceof Form &amp;&amp; c == getCurrent()) {</span>
<span class="fc" id="L1808">            return impl.isEditingText();</span>
        }

<span class="fc" id="L1811">        return impl.isEditingText(c);</span>
    }

    boolean isNativeEditorVisible(Component c) {
<span class="fc" id="L1815">        return impl.isNativeEditorVisible(c);</span>
    }

    /**
     * Minimizes the current application if minimization is supported by the platform (may fail).
     * Returns false if minimization failed.
     *
     * @return false if minimization failed true if it succeeded or seems to be successful
     */
    public boolean minimizeApplication() {
<span class="nc" id="L1825">        return getImplementation().minimizeApplication();</span>
    }

    /**
     * Indicates whether an application is minimized
     *
     * @return true if the application is minimized
     */
    public boolean isMinimized() {
<span class="fc" id="L1834">        return getImplementation().isMinimized();</span>
    }

    /**
     * Restore the minimized application if minimization is supported by the platform
     */
    public void restoreMinimizedApplication() {
<span class="nc" id="L1841">        getImplementation().restoreMinimizedApplication();</span>
<span class="nc" id="L1842">    }</span>

    private void addSingleArgumentEvent(int type, int code) {
<span class="fc" id="L1845">        synchronized (lock) {</span>
<span class="pc bpc" id="L1846" title="1 of 2 branches missed.">            if (this.dropEvents) {</span>
<span class="nc" id="L1847">                return;</span>
            }
<span class="fc" id="L1849">            inputEventStack[inputEventStackPointer] = type;</span>
<span class="fc" id="L1850">            inputEventStackPointer++;</span>
<span class="fc" id="L1851">            inputEventStack[inputEventStackPointer] = code;</span>
<span class="fc" id="L1852">            inputEventStackPointer++;</span>
<span class="fc" id="L1853">            lock.notify();</span>
<span class="fc" id="L1854">        }</span>
<span class="fc" id="L1855">    }</span>

    /**
     * Checks if the control key is currently down.  Only relevant for desktop ports.
     *
     * @return
     */
    public boolean isControlKeyDown() {
<span class="nc" id="L1863">        return impl.isControlKeyDown();</span>
    }

    /**
     * Checks if the meta key is currently down.  Only relevant for desktop ports.
     *
     * @return
     */
    public boolean isMetaKeyDown() {
<span class="nc" id="L1872">        return impl.isMetaKeyDown();</span>
    }

    /**
     * Checks if the alt key is currently down.  Only relevant for desktop ports.
     *
     * @return
     */
    public boolean isAltKeyDown() {
<span class="nc" id="L1881">        return impl.isAltKeyDown();</span>
    }

    /**
     * Checks if the altgraph key is currently down.  Only relevant for desktop ports.
     *
     * @return
     */
    public boolean isAltGraphKeyDown() {
<span class="nc" id="L1890">        return impl.isAltGraphKeyDown();</span>
    }

    /**
     * Checks if the last mouse press was a right click.
     *
     * @return True if the last mouse press was a right click.
     * @since 7.0
     */
    public boolean isRightMouseButtonDown() {
<span class="nc" id="L1900">        return impl.isRightMouseButtonDown();</span>
    }

    /**
     * Checks if shift key is currently down.  Only relevant for desktop ports.
     *
     * @return
     */
    public boolean isShiftKeyDown() {
<span class="nc" id="L1909">        return impl.isShiftKeyDown();</span>
    }

    /**
     * Pushes a key press event with the given keycode into Codename One
     *
     * @param keyCode keycode of the key event
     */
    public void keyPressed(final int keyCode) {
<span class="pc bpc" id="L1918" title="1 of 2 branches missed.">        if (impl.getCurrentForm() == null) {</span>
<span class="nc" id="L1919">            return;</span>
        }
<span class="fc" id="L1921">        addSingleArgumentEvent(KEY_PRESSED, keyCode);</span>

<span class="pc bpc" id="L1923" title="3 of 8 branches missed.">        lastInteractionWasKeypad = lastInteractionWasKeypad || (keyCode != MenuBar.leftSK &amp;&amp; keyCode != MenuBar.clearSK &amp;&amp; keyCode != MenuBar.backSK);</span>

        // this solves a Sony Ericsson bug where on slider open/close someone &quot;brilliant&quot; chose
        // to send a keyPress with a -43/-44 keycode... Without ever sending a key release!
<span class="pc bpc" id="L1927" title="5 of 6 branches missed.">        keyRepeatCharged = (keyCode &gt;= 0 || getGameAction(keyCode) &gt; 0) || keyCode == impl.getClearKeyCode();</span>
<span class="fc" id="L1928">        longPressCharged = keyRepeatCharged;</span>
<span class="fc" id="L1929">        longKeyPressTime = System.currentTimeMillis();</span>
<span class="fc" id="L1930">        keyRepeatValue = keyCode;</span>
<span class="fc" id="L1931">        nextKeyRepeatEvent = System.currentTimeMillis() + keyRepeatInitialIntervalTime;</span>
<span class="fc" id="L1932">        previousKeyPressed = lastKeyPressed;</span>
<span class="fc" id="L1933">        lastKeyPressed = keyCode;</span>
<span class="fc" id="L1934">    }</span>

    /**
     * Pushes a key release event with the given keycode into Codename One
     *
     * @param keyCode keycode of the key event
     */
    public void keyReleased(final int keyCode) {
<span class="fc" id="L1942">        keyRepeatCharged = false;</span>
<span class="fc" id="L1943">        longPressCharged = false;</span>
<span class="pc bpc" id="L1944" title="1 of 2 branches missed.">        if (impl.getCurrentForm() == null) {</span>
<span class="nc" id="L1945">            return;</span>
        }
<span class="pc bpc" id="L1947" title="1 of 2 branches missed.">        if (!multiKeyMode) {</span>
            // this can happen when traversing from the native form to the current form
            // caused by a keypress
            // We need the previous key press for Codename One issue 108 which can occur when typing into
            // text field rapidly and pressing two buttons at once. Originally I had a patch
            // here specifically to the native edit but that patch doesn't work properly for
            // all native phone bugs (e.g. incoming phone call rejected and the key release is
            // sent to the java application).
<span class="pc bpc" id="L1955" title="1 of 2 branches missed.">            if (keyCode != lastKeyPressed) {</span>
<span class="nc bnc" id="L1956" title="All 2 branches missed.">                if (keyCode != previousKeyPressed) {</span>
<span class="nc" id="L1957">                    return;</span>
                } else {
<span class="nc" id="L1959">                    previousKeyPressed = 0;</span>
                }
            } else {
<span class="fc" id="L1962">                lastKeyPressed = 0;</span>
            }
        }
<span class="fc" id="L1965">        addSingleArgumentEvent(KEY_RELEASED, keyCode);</span>
<span class="fc" id="L1966">    }</span>

    void keyRepeatedInternal(final int keyCode) {
<span class="nc" id="L1969">    }</span>

    private void addPointerEvent(int type, int x, int y) {
<span class="nc" id="L1972">        synchronized (lock) {</span>
<span class="nc bnc" id="L1973" title="All 2 branches missed.">            if (this.dropEvents) {</span>
<span class="nc" id="L1974">                return;</span>
            }
<span class="nc" id="L1976">            inputEventStack[inputEventStackPointer] = type;</span>
<span class="nc" id="L1977">            inputEventStackPointer++;</span>
<span class="nc" id="L1978">            inputEventStack[inputEventStackPointer] = x;</span>
<span class="nc" id="L1979">            inputEventStackPointer++;</span>
<span class="nc" id="L1980">            inputEventStack[inputEventStackPointer] = y;</span>
<span class="nc" id="L1981">            inputEventStackPointer++;</span>
<span class="nc" id="L1982">            lock.notify();</span>
<span class="nc" id="L1983">        }</span>
<span class="nc" id="L1984">    }</span>

    private void addPointerEvent(int type, int[] x, int[] y) {
<span class="nc" id="L1987">        synchronized (lock) {</span>
<span class="nc bnc" id="L1988" title="All 2 branches missed.">            if (this.dropEvents) {</span>
<span class="nc" id="L1989">                return;</span>
            }
<span class="nc" id="L1991">            inputEventStack[inputEventStackPointer] = type;</span>
<span class="nc" id="L1992">            inputEventStackPointer++;</span>
<span class="nc" id="L1993">            inputEventStack[inputEventStackPointer] = x.length;</span>
<span class="nc" id="L1994">            inputEventStackPointer++;</span>
<span class="nc bnc" id="L1995" title="All 2 branches missed.">            for (int iter = 0; iter &lt; x.length; iter++) {</span>
<span class="nc" id="L1996">                inputEventStack[inputEventStackPointer] = x[iter];</span>
<span class="nc" id="L1997">                inputEventStackPointer++;</span>
            }
<span class="nc" id="L1999">            inputEventStack[inputEventStackPointer] = y.length;</span>
<span class="nc" id="L2000">            inputEventStackPointer++;</span>
<span class="nc bnc" id="L2001" title="All 2 branches missed.">            for (int iter = 0; iter &lt; y.length; iter++) {</span>
<span class="nc" id="L2002">                inputEventStack[inputEventStackPointer] = y[iter];</span>
<span class="nc" id="L2003">                inputEventStackPointer++;</span>
            }
<span class="nc" id="L2005">            lock.notify();</span>
<span class="nc" id="L2006">        }</span>
<span class="nc" id="L2007">    }</span>

    private void addPointerDragEventWithTimestamp(int x, int y) {
<span class="nc" id="L2010">        synchronized (lock) {</span>
<span class="nc bnc" id="L2011" title="All 2 branches missed.">            if (this.dropEvents) {</span>
<span class="nc" id="L2012">                return;</span>
            }
            try {
<span class="nc bnc" id="L2015" title="All 2 branches missed.">                if (lastDragOffset &gt; -1) {</span>
<span class="nc" id="L2016">                    inputEventStack[lastDragOffset] = x;</span>
<span class="nc" id="L2017">                    inputEventStack[lastDragOffset + 1] = y;</span>
<span class="nc" id="L2018">                    inputEventStack[lastDragOffset + 2] = (int) (System.currentTimeMillis() - displayInitTime);</span>
                } else {
<span class="nc" id="L2020">                    inputEventStack[inputEventStackPointer] = POINTER_DRAGGED;</span>
<span class="nc" id="L2021">                    inputEventStackPointer++;</span>
<span class="nc" id="L2022">                    lastDragOffset = inputEventStackPointer;</span>
<span class="nc" id="L2023">                    inputEventStack[inputEventStackPointer] = x;</span>
<span class="nc" id="L2024">                    inputEventStackPointer++;</span>
<span class="nc" id="L2025">                    inputEventStack[inputEventStackPointer] = y;</span>
<span class="nc" id="L2026">                    inputEventStackPointer++;</span>
<span class="nc" id="L2027">                    inputEventStack[inputEventStackPointer] = (int) (System.currentTimeMillis() - displayInitTime);</span>
<span class="nc" id="L2028">                    inputEventStackPointer++;</span>
                }
<span class="nc" id="L2030">            } catch (ArrayIndexOutOfBoundsException err) {</span>
<span class="nc" id="L2031">                Log.p(&quot;EDT performance is very slow triggering this exception!&quot;);</span>
<span class="nc" id="L2032">                Log.e(err);</span>
<span class="nc" id="L2033">            }</span>
<span class="nc" id="L2034">            lock.notify();</span>
<span class="nc" id="L2035">        }</span>
<span class="nc" id="L2036">    }</span>

    private void addPointerEventWithTimestamp(int type, int x, int y) {
<span class="nc" id="L2039">        synchronized (lock) {</span>
<span class="nc bnc" id="L2040" title="All 2 branches missed.">            if (this.dropEvents) {</span>
<span class="nc" id="L2041">                return;</span>
            }
            try {
<span class="nc" id="L2044">                inputEventStack[inputEventStackPointer] = type;</span>
<span class="nc" id="L2045">                inputEventStackPointer++;</span>
<span class="nc" id="L2046">                inputEventStack[inputEventStackPointer] = x;</span>
<span class="nc" id="L2047">                inputEventStackPointer++;</span>
<span class="nc" id="L2048">                inputEventStack[inputEventStackPointer] = y;</span>
<span class="nc" id="L2049">                inputEventStackPointer++;</span>
<span class="nc" id="L2050">                inputEventStack[inputEventStackPointer] = (int) (System.currentTimeMillis() - displayInitTime);</span>
<span class="nc" id="L2051">                inputEventStackPointer++;</span>
<span class="nc" id="L2052">            } catch (ArrayIndexOutOfBoundsException err) {</span>
<span class="nc" id="L2053">                Log.p(&quot;EDT performance is very slow triggering this exception!&quot;);</span>
<span class="nc" id="L2054">                Log.e(err);</span>
<span class="nc" id="L2055">            }</span>
<span class="nc" id="L2056">            lock.notify();</span>
<span class="nc" id="L2057">        }</span>
<span class="nc" id="L2058">    }</span>

    /**
     * Pushes a pointer drag event with the given coordinates into Codename One
     *
     * @param x the x position of the pointer
     * @param y the y position of the pointer
     */
    public void pointerDragged(final int[] x, final int[] y) {
<span class="nc bnc" id="L2067" title="All 2 branches missed.">        if (impl.getCurrentForm() == null) {</span>
<span class="nc" id="L2068">            return;</span>
        }
<span class="nc" id="L2070">        longPointerCharged = false;</span>
<span class="nc bnc" id="L2071" title="All 2 branches missed.">        if (x.length == 1) {</span>
<span class="nc" id="L2072">            addPointerDragEventWithTimestamp(x[0], y[0]);</span>
        } else {
<span class="nc" id="L2074">            addPointerEvent(POINTER_DRAGGED_MULTI, x, y);</span>
        }
<span class="nc" id="L2076">    }</span>

    /**
     * Pushes a pointer hover event with the given coordinates into Codename One
     *
     * @param x the x position of the pointer
     * @param y the y position of the pointer
     */
    public void pointerHover(final int[] x, final int[] y) {
<span class="nc bnc" id="L2085" title="All 2 branches missed.">        if (impl.getCurrentForm() == null) {</span>
<span class="nc" id="L2086">            return;</span>
        }
<span class="nc bnc" id="L2088" title="All 2 branches missed.">        if (x.length == 1) {</span>
<span class="nc" id="L2089">            addPointerEventWithTimestamp(POINTER_HOVER, x[0], y[0]);</span>
        } else {
<span class="nc" id="L2091">            addPointerEvent(POINTER_HOVER, x, y);</span>
        }
<span class="nc" id="L2093">    }</span>

    /**
     * Pushes a pointer hover release event with the given coordinates into Codename One
     *
     * @param x the x position of the pointer
     * @param y the y position of the pointer
     */
    public void pointerHoverPressed(final int[] x, final int[] y) {
<span class="nc bnc" id="L2102" title="All 2 branches missed.">        if (impl.getCurrentForm() == null) {</span>
<span class="nc" id="L2103">            return;</span>
        }
<span class="nc" id="L2105">        addPointerEvent(POINTER_HOVER_PRESSED, x[0], y[0]);</span>
<span class="nc" id="L2106">    }</span>

    /**
     * Pushes a pointer hover release event with the given coordinates into Codename One
     *
     * @param x the x position of the pointer
     * @param y the y position of the pointer
     */
    public void pointerHoverReleased(final int[] x, final int[] y) {
<span class="nc bnc" id="L2115" title="All 2 branches missed.">        if (impl.getCurrentForm() == null) {</span>
<span class="nc" id="L2116">            return;</span>
        }
<span class="nc" id="L2118">        addPointerEvent(POINTER_HOVER_RELEASED, x[0], y[0]);</span>
<span class="nc" id="L2119">    }</span>

    /**
     * Pushes a pointer press event with the given coordinates into Codename One
     *
     * @param x the x position of the pointer
     * @param y the y position of the pointer
     */
    public void pointerPressed(final int[] x, final int[] y) {
<span class="nc bnc" id="L2128" title="All 2 branches missed.">        if (impl.getCurrentForm() == null) {</span>
<span class="nc" id="L2129">            return;</span>
        }

<span class="nc" id="L2132">        lastInteractionWasKeypad = false;</span>
<span class="nc" id="L2133">        longPointerCharged = true;</span>
<span class="nc" id="L2134">        longKeyPressTime = System.currentTimeMillis();</span>
<span class="nc" id="L2135">        pointerX = x[0];</span>
<span class="nc" id="L2136">        pointerY = y[0];</span>
<span class="nc bnc" id="L2137" title="All 2 branches missed.">        if (x.length == 1) {</span>
<span class="nc" id="L2138">            addPointerEvent(POINTER_PRESSED, x[0], y[0]);</span>
        } else {
<span class="nc" id="L2140">            addPointerEvent(POINTER_PRESSED_MULTI, x, y);</span>
        }
<span class="nc" id="L2142">    }</span>

    /**
     * Pushes a pointer release event with the given coordinates into Codename One
     *
     * @param x the x position of the pointer
     * @param y the y position of the pointer
     */
    public void pointerReleased(final int[] x, final int[] y) {
<span class="nc" id="L2151">        longPointerCharged = false;</span>
<span class="nc bnc" id="L2152" title="All 2 branches missed.">        if (impl.getCurrentForm() == null) {</span>
<span class="nc" id="L2153">            return;</span>
        }
<span class="nc bnc" id="L2155" title="All 2 branches missed.">        if (x.length == 1) {</span>
<span class="nc" id="L2156">            addPointerEvent(POINTER_RELEASED, x[0], y[0]);</span>
        } else {
<span class="nc" id="L2158">            addPointerEvent(POINTER_RELEASED_MULTI, x, y);</span>
        }
<span class="nc" id="L2160">    }</span>

    private void addSizeChangeEvent(int type, int w, int h) {
<span class="fc" id="L2163">        synchronized (lock) {</span>
<span class="fc" id="L2164">            inputEventStack[inputEventStackPointer] = type;</span>
<span class="fc" id="L2165">            inputEventStackPointer++;</span>
<span class="fc" id="L2166">            inputEventStack[inputEventStackPointer] = w;</span>
<span class="fc" id="L2167">            inputEventStackPointer++;</span>
<span class="fc" id="L2168">            inputEventStack[inputEventStackPointer] = h;</span>
<span class="fc" id="L2169">            inputEventStackPointer++;</span>
<span class="fc" id="L2170">            lock.notify();</span>
<span class="fc" id="L2171">        }</span>
<span class="fc" id="L2172">    }</span>

    /**
     * Notifies Codename One of display size changes, this method is invoked by the implementation
     * class and is for internal use
     *
     * @param w the width of the drawing surface
     * @param h the height of the drawing surface
     */
    public void sizeChanged(int w, int h) {
<span class="fc" id="L2182">        Form current = impl.getCurrentForm();</span>
<span class="pc bpc" id="L2183" title="1 of 2 branches missed.">        if (current == null) {</span>
<span class="nc" id="L2184">            return;</span>
        }
<span class="pc bpc" id="L2186" title="3 of 4 branches missed.">        if (w == current.getWidth() &amp;&amp; h == current.getHeight()) {</span>
            // a workaround for a race condition on pixel 2 where size change events can happen really quickly
<span class="nc bnc" id="L2188" title="All 4 branches missed.">            if (lastSizeChangeEventWH == -1 || lastSizeChangeEventWH == w + h) {</span>
<span class="nc" id="L2189">                return;</span>
            }
        }

<span class="fc" id="L2193">        lastSizeChangeEventWH = w + h;</span>
<span class="fc" id="L2194">        addSizeChangeEvent(SIZE_CHANGED, w, h);</span>
<span class="fc" id="L2195">    }</span>

    private void addNotifyEvent(int type) {
<span class="nc" id="L2198">        synchronized (lock) {</span>
<span class="nc" id="L2199">            inputEventStack[inputEventStackPointer] = type;</span>
<span class="nc" id="L2200">            inputEventStackPointer++;</span>
<span class="nc" id="L2201">            lock.notify();</span>
<span class="nc" id="L2202">        }</span>
<span class="nc" id="L2203">    }</span>

    /**
     * Broadcasts hide notify into Codename One, this method is invoked by the Codename One implementation
     * to notify Codename One of hideNotify events
     */
    public void hideNotify() {
<span class="nc" id="L2210">        keyRepeatCharged = false;</span>
<span class="nc" id="L2211">        longPressCharged = false;</span>
<span class="nc" id="L2212">        longPointerCharged = false;</span>
<span class="nc" id="L2213">        pointerPressedAndNotReleasedOrDragged = false;</span>
<span class="nc" id="L2214">        addNotifyEvent(HIDE_NOTIFY);</span>
<span class="nc" id="L2215">    }</span>

    /**
     * Broadcasts show notify into Codename One, this method is invoked by the Codename One implementation
     * to notify Codename One of showNotify events
     */
    public void showNotify() {
<span class="nc" id="L2222">        addNotifyEvent(SHOW_NOTIFY);</span>
<span class="nc" id="L2223">    }</span>

    /**
     * Used by the flush functionality which doesn't care much about component
     * animations
     */
    boolean shouldEDTSleepNoFormAnimation() {
        boolean b;
<span class="fc" id="L2231">        synchronized (lock) {</span>
<span class="pc bpc" id="L2232" title="1 of 2 branches missed.">            b = inputEventStackPointer == 0 &amp;&amp;</span>
<span class="pc bpc" id="L2233" title="3 of 6 branches missed.">                    hasNoSerialCallsPending() &amp;&amp;</span>
                    (!keyRepeatCharged || !longPressCharged);
<span class="fc" id="L2235">        }</span>
<span class="fc" id="L2236">        return b;</span>
    }

    private void updateDragSpeedStatus(int x, int y, int timestamp) {
        //save dragging input to calculate the dragging speed later
<span class="nc" id="L2241">        dragPathX[dragPathOffset] = x;</span>
<span class="nc" id="L2242">        dragPathY[dragPathOffset] = y;</span>
<span class="nc" id="L2243">        dragPathTime[dragPathOffset] = displayInitTime + (long) timestamp;</span>
<span class="nc bnc" id="L2244" title="All 2 branches missed.">        if (dragPathLength &lt; PATHLENGTH) {</span>
<span class="nc" id="L2245">            dragPathLength++;</span>
        }
<span class="nc" id="L2247">        dragPathOffset++;</span>
<span class="nc bnc" id="L2248" title="All 2 branches missed.">        if (dragPathOffset &gt;= PATHLENGTH) {</span>
<span class="nc" id="L2249">            dragPathOffset = 0;</span>
        }
<span class="nc" id="L2251">    }</span>

    boolean isRecursivePointerRelease() {
<span class="nc" id="L2254">        return recursivePointerReleaseB;</span>
    }

    private int[] readArrayStackArgument(int offset) {
<span class="nc" id="L2258">        int[] a = new int[inputEventStackTmp[offset]];</span>
<span class="nc" id="L2259">        offset++;</span>
<span class="nc" id="L2260">        int alen = a.length;</span>
<span class="nc" id="L2261">        System.arraycopy(inputEventStackTmp, offset + 0, a, 0, alen);</span>
<span class="nc" id="L2262">        return a;</span>
    }

    /**
     * Invoked on the EDT to propagate the event
     */
    private int handleEvent(int offset, int[] inputEventStackTmp) {
<span class="fc" id="L2269">        Form f = getCurrentUpcomingForm(true);</span>

        // might happen when returning from a deinitialized version of Codename One
<span class="pc bpc" id="L2272" title="1 of 2 branches missed.">        if (f == null) {</span>
<span class="nc" id="L2273">            return offset;</span>
        }

        // no need to synchronize since we are reading only and modifying the stack frame offset
<span class="fc" id="L2277">        int type = inputEventStackTmp[offset];</span>
<span class="fc" id="L2278">        offset++;</span>

<span class="pc bpc" id="L2280" title="12 of 15 branches missed.">        switch (type) {</span>
            case KEY_PRESSED:
<span class="fc" id="L2282">                f.keyPressed(inputEventStackTmp[offset]);</span>
<span class="fc" id="L2283">                offset++;</span>
<span class="fc" id="L2284">                eventForm = f;</span>
<span class="fc" id="L2285">                break;</span>
            case KEY_RELEASED:
                // pointer release can cycle into invoke and block which will cause this method
                // to recurse if a pointer will be released while we are in an invoke and block state
                // this is the case in http://code.google.com/p/codenameone/issues/detail?id=265
<span class="fc" id="L2290">                Form xf = eventForm;</span>
<span class="fc" id="L2291">                eventForm = null;</span>

                //make sure the released event is sent to the same Form who got a
                //pressed event
<span class="pc bpc" id="L2295" title="3 of 4 branches missed.">                if (xf == f || multiKeyMode) {</span>
<span class="fc" id="L2296">                    f.keyReleased(inputEventStackTmp[offset]);</span>
<span class="fc" id="L2297">                    offset++;</span>
                }
                break;
            case POINTER_PRESSED:
<span class="nc bnc" id="L2301" title="All 2 branches missed.">                if (recursivePointerReleaseA) {</span>
<span class="nc" id="L2302">                    recursivePointerReleaseB = true;</span>
                }
<span class="nc" id="L2304">                dragOccured = false;</span>
<span class="nc" id="L2305">                dragPathLength = 0;</span>
<span class="nc" id="L2306">                pointerPressedAndNotReleasedOrDragged = true;</span>
<span class="nc" id="L2307">                xArray1[0] = inputEventStackTmp[offset];</span>
<span class="nc" id="L2308">                offset++;</span>
<span class="nc" id="L2309">                yArray1[0] = inputEventStackTmp[offset];</span>
<span class="nc" id="L2310">                offset++;</span>
<span class="nc" id="L2311">                f.pointerPressed(xArray1, yArray1);</span>
<span class="nc" id="L2312">                eventForm = f;</span>
<span class="nc" id="L2313">                break;</span>
            case POINTER_PRESSED_MULTI: {
<span class="nc bnc" id="L2315" title="All 2 branches missed.">                if (recursivePointerReleaseA) {</span>
<span class="nc" id="L2316">                    recursivePointerReleaseB = true;</span>
                }
<span class="nc" id="L2318">                dragOccured = false;</span>
<span class="nc" id="L2319">                dragPathLength = 0;</span>
<span class="nc" id="L2320">                pointerPressedAndNotReleasedOrDragged = true;</span>
<span class="nc" id="L2321">                int[] array1 = readArrayStackArgument(offset);</span>
<span class="nc" id="L2322">                offset += array1.length + 1;</span>
<span class="nc" id="L2323">                int[] array2 = readArrayStackArgument(offset);</span>
<span class="nc" id="L2324">                offset += array2.length + 1;</span>
<span class="nc" id="L2325">                f.pointerPressed(array1, array2);</span>
<span class="nc" id="L2326">                eventForm = f;</span>
<span class="nc" id="L2327">                break;</span>
            }
            case POINTER_RELEASED:
<span class="nc" id="L2330">                recursivePointerReleaseA = true;</span>
<span class="nc" id="L2331">                pointerPressedAndNotReleasedOrDragged = false;</span>

                // pointer release can cycle into invoke and block which will cause this method
                // to recurse if a pointer will be released while we are in an invoke and block state
                // this is the case in http://code.google.com/p/codenameone/issues/detail?id=265
<span class="nc" id="L2336">                Form x = eventForm;</span>
<span class="nc" id="L2337">                eventForm = null;</span>

                // make sure the released event is sent to the same Form that got a
                // pressed event
<span class="nc bnc" id="L2341" title="All 4 branches missed.">                if (x == f || f.shouldSendPointerReleaseToOtherForm()) {</span>
<span class="nc" id="L2342">                    xArray1[0] = inputEventStackTmp[offset];</span>
<span class="nc" id="L2343">                    offset++;</span>
<span class="nc" id="L2344">                    yArray1[0] = inputEventStackTmp[offset];</span>
<span class="nc" id="L2345">                    offset++;</span>
<span class="nc" id="L2346">                    f.pointerReleased(xArray1, yArray1);</span>
                }
<span class="nc" id="L2348">                recursivePointerReleaseA = false;</span>
<span class="nc" id="L2349">                recursivePointerReleaseB = false;</span>
<span class="nc" id="L2350">                break;</span>
            case POINTER_RELEASED_MULTI:
<span class="nc" id="L2352">                recursivePointerReleaseA = true;</span>
<span class="nc" id="L2353">                pointerPressedAndNotReleasedOrDragged = false;</span>

                // pointer release can cycle into invoke and block which will cause this method
                // to recurse if a pointer will be released while we are in an invoke and block state
                // this is the case in http://code.google.com/p/codenameone/issues/detail?id=265
<span class="nc" id="L2358">                Form xy = eventForm;</span>
<span class="nc" id="L2359">                eventForm = null;</span>

                // make sure the released event is sent to the same Form that got a
                // pressed event
<span class="nc bnc" id="L2363" title="All 6 branches missed.">                if (xy == f || (f != null &amp;&amp; f.shouldSendPointerReleaseToOtherForm())) {</span>
<span class="nc" id="L2364">                    int[] array1 = readArrayStackArgument(offset);</span>
<span class="nc" id="L2365">                    offset += array1.length + 1;</span>
<span class="nc" id="L2366">                    int[] array2 = readArrayStackArgument(offset);</span>
<span class="nc" id="L2367">                    offset += array2.length + 1;</span>
<span class="nc" id="L2368">                    f.pointerReleased(array1, array1);</span>
                }
<span class="nc" id="L2370">                recursivePointerReleaseA = false;</span>
<span class="nc" id="L2371">                recursivePointerReleaseB = false;</span>
<span class="nc" id="L2372">                break;</span>
            case POINTER_DRAGGED: {
<span class="nc" id="L2374">                dragOccured = true;</span>
<span class="nc" id="L2375">                int arg1 = inputEventStackTmp[offset];</span>
<span class="nc" id="L2376">                offset++;</span>
<span class="nc" id="L2377">                int arg2 = inputEventStackTmp[offset];</span>
<span class="nc" id="L2378">                offset++;</span>
<span class="nc" id="L2379">                int timestamp = inputEventStackTmp[offset];</span>
<span class="nc" id="L2380">                offset++;</span>
<span class="nc" id="L2381">                updateDragSpeedStatus(arg1, arg2, timestamp);</span>
<span class="nc" id="L2382">                pointerPressedAndNotReleasedOrDragged = false;</span>
<span class="nc" id="L2383">                xArray1[0] = arg1;</span>
<span class="nc" id="L2384">                yArray1[0] = arg2;</span>
<span class="nc" id="L2385">                f.pointerDragged(xArray1, yArray1);</span>
<span class="nc" id="L2386">                break;</span>
            }
            case POINTER_DRAGGED_MULTI: {
<span class="nc" id="L2389">                dragOccured = true;</span>
<span class="nc" id="L2390">                pointerPressedAndNotReleasedOrDragged = false;</span>
<span class="nc" id="L2391">                int[] array1 = readArrayStackArgument(offset);</span>
<span class="nc" id="L2392">                offset += array1.length + 1;</span>
<span class="nc" id="L2393">                int[] array2 = readArrayStackArgument(offset);</span>
<span class="nc" id="L2394">                offset += array2.length + 1;</span>
<span class="nc" id="L2395">                f.pointerDragged(array1, array2);</span>
<span class="nc" id="L2396">                break;</span>
            }
            case POINTER_HOVER: {
<span class="nc" id="L2399">                int arg1 = inputEventStackTmp[offset];</span>
<span class="nc" id="L2400">                offset++;</span>
<span class="nc" id="L2401">                int arg2 = inputEventStackTmp[offset];</span>
<span class="nc" id="L2402">                offset++;</span>
<span class="nc" id="L2403">                int timestamp = inputEventStackTmp[offset];</span>
<span class="nc" id="L2404">                offset++;</span>
<span class="nc" id="L2405">                updateDragSpeedStatus(arg1, arg2, timestamp);</span>
<span class="nc" id="L2406">                xArray1[0] = arg1;</span>
<span class="nc" id="L2407">                yArray1[0] = arg2;</span>
<span class="nc" id="L2408">                f.pointerHover(xArray1, yArray1);</span>
<span class="nc" id="L2409">                break;</span>
            }
            case POINTER_HOVER_RELEASED: {
<span class="nc" id="L2412">                int arg1 = inputEventStackTmp[offset];</span>
<span class="nc" id="L2413">                offset++;</span>
<span class="nc" id="L2414">                int arg2 = inputEventStackTmp[offset];</span>
<span class="nc" id="L2415">                offset++;</span>
<span class="nc" id="L2416">                xArray1[0] = arg1;</span>
<span class="nc" id="L2417">                yArray1[0] = arg2;</span>
<span class="nc" id="L2418">                f.pointerHoverReleased(xArray1, yArray1);</span>
<span class="nc" id="L2419">                break;</span>
            }
            case POINTER_HOVER_PRESSED: {
<span class="nc" id="L2422">                int arg1 = inputEventStackTmp[offset];</span>
<span class="nc" id="L2423">                offset++;</span>
<span class="nc" id="L2424">                int arg2 = inputEventStackTmp[offset];</span>
<span class="nc" id="L2425">                offset++;</span>
<span class="nc" id="L2426">                xArray1[0] = arg1;</span>
<span class="nc" id="L2427">                yArray1[0] = arg2;</span>
<span class="nc" id="L2428">                f.pointerHoverPressed(xArray1, yArray1);</span>
<span class="nc" id="L2429">                break;</span>
            }
            case SIZE_CHANGED:
<span class="fc" id="L2432">                int w = inputEventStackTmp[offset];</span>
<span class="fc" id="L2433">                offset++;</span>
<span class="fc" id="L2434">                int h = inputEventStackTmp[offset];</span>
<span class="fc" id="L2435">                offset++;</span>
<span class="fc" id="L2436">                f.sizeChangedInternal(w, h);</span>
<span class="fc" id="L2437">                break;</span>
            case HIDE_NOTIFY:
<span class="nc" id="L2439">                f.hideNotify();</span>
<span class="nc" id="L2440">                break;</span>
            case SHOW_NOTIFY:
<span class="nc" id="L2442">                f.showNotify();</span>
                break;
        }
<span class="fc" id="L2445">        return offset;</span>
    }

    /**
     * This method should be invoked by components that broadcast events on the pointerReleased callback.
     * This method will indicate if a drag occured since the pointer press event, notice that this method will not
     * behave as expected for multi-touch events.
     *
     * @return true if a drag has occured since the last pointer pressed
     */
    public boolean hasDragOccured() {
<span class="fc" id="L2456">        return dragOccured;</span>
    }

    private int[] pointerEvent(int off, int[] event) {
<span class="nc" id="L2460">        int[] peX = new int[(event.length - 1) / 2];</span>
<span class="nc" id="L2461">        int offset = 0;</span>
<span class="nc bnc" id="L2462" title="All 2 branches missed.">        for (int iter = off; iter &lt; (event.length - 1); iter += 2) {</span>
<span class="nc" id="L2463">            peX[offset] = event[iter];</span>
<span class="nc" id="L2464">            offset++;</span>
        }
<span class="nc" id="L2466">        return peX;</span>
    }

    /**
     * Returns true for a case where the EDT has nothing at all to do
     */
    boolean shouldEDTSleep() {
<span class="fc" id="L2473">        Form current = impl.getCurrentForm();</span>
<span class="fc bfc" id="L2474" title="All 6 branches covered.">        return ((current == null || (!current.hasAnimations())) &amp;&amp;</span>
<span class="fc bfc" id="L2475" title="All 4 branches covered.">                (animationQueue == null || animationQueue.size() == 0) &amp;&amp;</span>
                inputEventStackPointer == 0 &amp;&amp;
<span class="fc bfc" id="L2477" title="All 2 branches covered.">                (!impl.hasPendingPaints()) &amp;&amp;</span>
<span class="pc bpc" id="L2478" title="2 of 6 branches missed.">                hasNoSerialCallsPending() &amp;&amp; !keyRepeatCharged</span>
<span class="pc bpc" id="L2479" title="3 of 4 branches missed.">                &amp;&amp; !longPointerCharged) || (isMinimized() &amp;&amp; hasNoSerialCallsPending());</span>
    }

    Form getCurrentInternal() {
<span class="nc" id="L2483">        return impl.getCurrentForm();</span>
    }

    /**
     * Same as getCurrent with the added exception of looking into the future
     * transitions and returning the last current in the transition (the upcoming
     * value for current)
     *
     * @return the form currently displayed on the screen or null if no form is
     * currently displayed
     */
    Form getCurrentUpcoming() {
<span class="fc" id="L2495">        return getCurrentUpcomingForm(false);</span>
    }

    private Form getCurrentUpcomingForm(boolean includeMenus) {
<span class="fc" id="L2499">        Form upcoming = null;</span>

        // we are in the middle of a transition so we should extract the next form
<span class="fc bfc" id="L2502" title="All 2 branches covered.">        if (animationQueue != null) {</span>
<span class="fc" id="L2503">            int size = animationQueue.size();</span>
<span class="fc bfc" id="L2504" title="All 2 branches covered.">            for (int iter = 0; iter &lt; size; iter++) {</span>
<span class="fc" id="L2505">                Animation o = animationQueue.get(iter);</span>
<span class="pc bpc" id="L2506" title="1 of 2 branches missed.">                if (o instanceof Transition) {</span>
<span class="fc" id="L2507">                    upcoming = (Form) ((Transition) o).getDestination();</span>
                }
            }
        }
<span class="fc bfc" id="L2511" title="All 2 branches covered.">        if (upcoming == null) {</span>
<span class="pc bpc" id="L2512" title="1 of 2 branches missed.">            if (includeMenus) {</span>
<span class="fc" id="L2513">                Form f = impl.getCurrentForm();</span>
<span class="pc bpc" id="L2514" title="1 of 2 branches missed.">                if (f instanceof Dialog) {</span>
<span class="nc bnc" id="L2515" title="All 2 branches missed.">                    if (f.isDisposed()) {</span>
<span class="nc" id="L2516">                        return getCurrent();</span>
                    }
                }
<span class="fc" id="L2519">                return f;</span>
            } else {
<span class="nc" id="L2521">                return getCurrent();</span>
            }
        }
<span class="fc" id="L2524">        return upcoming;</span>
    }

    /**
     * Return the form currently displayed on the screen or null if no form is
     * currently displayed.
     *
     * @return the form currently displayed on the screen or null if no form is
     * currently displayed
     */
    public Form getCurrent() {
<span class="fc" id="L2535">        Form current = impl.getCurrentForm();</span>
<span class="fc bfc" id="L2536" title="All 4 branches covered.">        if (current != null &amp;&amp; current instanceof Dialog) {</span>
<span class="pc bpc" id="L2537" title="1 of 4 branches missed.">            if (current.isMenu() || current.isDisposed()) {</span>
<span class="fc" id="L2538">                Form p = current.getPreviousForm();</span>
<span class="pc bpc" id="L2539" title="1 of 2 branches missed.">                if (p != null) {</span>
<span class="fc" id="L2540">                    return p;</span>
                }

                // we are in the middle of a transition so we should extract the next form
<span class="nc bnc" id="L2544" title="All 2 branches missed.">                if (animationQueue != null) {</span>
<span class="nc" id="L2545">                    int size = animationQueue.size();</span>
<span class="nc bnc" id="L2546" title="All 2 branches missed.">                    for (int iter = 0; iter &lt; size; iter++) {</span>
<span class="nc" id="L2547">                        Animation o = animationQueue.get(iter);</span>
<span class="nc bnc" id="L2548" title="All 2 branches missed.">                        if (o instanceof Transition) {</span>
<span class="nc" id="L2549">                            return (Form) ((Transition) o).getDestination();</span>
                        }
                    }
                }
            }
        }
<span class="fc" id="L2555">        return current;</span>
    }

    /**
     * Return the number of alpha levels supported by the implementation.
     *
     * @return the number of alpha levels supported by the implementation
     * @deprecated this method isn't implemented in most modern devices
     */
    public int numAlphaLevels() {
<span class="nc" id="L2565">        return impl.numAlphaLevels();</span>
    }

    /**
     * Returns the number of colors applicable on the device, note that the API
     * does not support gray scale devices.
     *
     * @return the number of colors applicable on the device
     * @deprecated this method isn't implemented in most modern devices
     */
    public int numColors() {
<span class="fc" id="L2576">        return impl.numColors();</span>
    }

    /**
     * Return the width of the display
     *
     * @return the width of the display
     */
    public int getDisplayWidth() {
<span class="fc" id="L2585">        return impl.getDisplayWidth();</span>
    }

    /**
     * Return the height of the display
     *
     * @return the height of the display
     */
    public int getDisplayHeight() {
<span class="fc" id="L2594">        return impl.getDisplayHeight();</span>
    }

    /**
     * Returns the size of the desktop hosting the application window when running on a desktop platform.
     *
     * @return the desktop size or the current display size if not supported
     */
    public Dimension getDesktopSize() {
<span class="fc" id="L2603">        Dimension desktopSize = impl.getDesktopSize();</span>
<span class="pc bpc" id="L2604" title="1 of 2 branches missed.">        if (desktopSize != null) {</span>
<span class="fc" id="L2605">            return desktopSize;</span>
        }
<span class="nc" id="L2607">        return new Dimension(getDisplayWidth(), getDisplayHeight());</span>
    }

    /**
     * Returns the current window bounds when running on a desktop platform.
     *
     * @return the bounds of the application window
     */
    public Rectangle getWindowBounds() {
<span class="nc" id="L2616">        Rectangle bounds = impl.getWindowBounds();</span>
<span class="nc bnc" id="L2617" title="All 2 branches missed.">        if (bounds == null) {</span>
<span class="nc" id="L2618">            return new Rectangle(0, 0, getDisplayWidth(), getDisplayHeight());</span>
        }
<span class="nc" id="L2620">        return bounds;</span>
    }

    /**
     * Requests a resize of the application window when supported by the platform.
     *
     * @param width  the desired window width
     * @param height the desired window height
     */
    public void setWindowSize(int width, int height) {
<span class="nc" id="L2630">        impl.setWindowSize(width, height);</span>
<span class="nc" id="L2631">    }</span>

    /**
     * Returns the initial desktop window size hint provided by the first shown form, when available.
     *
     * @return the stored hint or {@code null}
     */
    public Dimension getInitialWindowSizeHintPercent() {
<span class="fc" id="L2639">        return impl.getInitialWindowSizeHintPercent();</span>
    }

    /**
     * Sets the initial desktop window size hint (percent of the desktop) that should be used when the
     * first form is shown. This is primarily useful for desktop environments where the Codename One
     * application is hosted in a window rather than full-screen.
     *
     * @param hint a {@link Dimension} whose width/height represent percentages of the desktop to use for
     *             the initial window size, or {@code null} to clear a previously stored hint
     */
    public void setInitialWindowSizeHintPercent(Dimension hint) {
<span class="nc" id="L2651">        impl.setInitialWindowSizeHintPercent(hint);</span>
<span class="nc" id="L2652">    }</span>

    /**
     * Causes the given component to repaint, used internally by Form
     *
     * @param cmp the given component to repaint
     */
    void repaint(final Animation cmp) {
<span class="fc" id="L2660">        impl.repaint(cmp);</span>
<span class="fc" id="L2661">    }</span>

    /**
     * Converts the dips count to pixels, dips are roughly 1mm in length. This is a very rough estimate and not
     * to be relied upon
     *
     * @param dipCount   the dips that we will convert to pixels
     * @param horizontal indicates pixels in the horizontal plane
     * @return value in pixels
     */
    public int convertToPixels(int dipCount, boolean horizontal) {
<span class="fc" id="L2672">        return impl.convertToPixels(dipCount, horizontal);</span>
    }

    /**
     * Converts from specified unit to pixels.
     *
     * @param value    The value to convert, expressed in unitType.
     * @param unitType The unit type.  One of {@link Style#UNIT_TYPE_DIPS}, {@link Style#UNIT_TYPE_PIXELS},
     *                 {@link Style#UNIT_TYPE_REM}, {@link Style#UNIT_TYPE_SCREEN_PERCENTAGE}, {@link Style#UNIT_TYPE_VH},
     *                 {@link Style#UNIT_TYPE_VW}, {@link Style#UNIT_TYPE_VMIN}, {@link Style#UNIT_TYPE_VMAX}
     * @return The value converted to pixels.
     * @since 8.0
     */
    public int convertToPixels(float value, byte unitType) {
<span class="fc" id="L2686">        return convertToPixels(value, unitType, true);</span>
    }

    /**
     * Converts from specified unit to pixels.
     *
     * @param value      The value to convert, expressed in unitType.
     * @param unitType   The unit type.  One of {@link Style#UNIT_TYPE_DIPS}, {@link Style#UNIT_TYPE_PIXELS},
     *                   {@link Style#UNIT_TYPE_REM}, {@link Style#UNIT_TYPE_SCREEN_PERCENTAGE}, {@link Style#UNIT_TYPE_VH},
     *                   {@link Style#UNIT_TYPE_VW}, {@link Style#UNIT_TYPE_VMIN}, {@link Style#UNIT_TYPE_VMAX}
     * @param horizontal Whether screen percentage units should be based on horitonzal or vertical percentage.
     * @return The value converted to pixels.
     * @since 8.0
     */
    public int convertToPixels(float value, byte unitType, boolean horizontal) {
<span class="fc bfc" id="L2701" title="All 8 branches covered.">        switch (unitType) {</span>
            case Style.UNIT_TYPE_REM:
<span class="fc" id="L2703">                return Math.round(value * Font.getDefaultFont().getHeight());</span>
            case Style.UNIT_TYPE_VH:
<span class="fc" id="L2705">                return Math.round(value / 100f * CN.getDisplayHeight());</span>
            case Style.UNIT_TYPE_VW:
<span class="fc" id="L2707">                return Math.round(value / 100f * CN.getDisplayWidth());</span>
            case Style.UNIT_TYPE_VMIN:
<span class="fc" id="L2709">                return Math.round(value / 100f * Math.min(CN.getDisplayWidth(), CN.getDisplayHeight()));</span>
            case Style.UNIT_TYPE_VMAX:
<span class="fc" id="L2711">                return Math.round(value / 100f * Math.max(CN.getDisplayWidth(), CN.getDisplayHeight()));</span>
            case Style.UNIT_TYPE_DIPS:
<span class="fc" id="L2713">                return Display.getInstance().convertToPixels(value);</span>
            case Style.UNIT_TYPE_SCREEN_PERCENTAGE:
<span class="fc bfc" id="L2715" title="All 2 branches covered.">                if (!horizontal) {</span>
<span class="fc" id="L2716">                    float h = Display.getInstance().getDisplayHeight();</span>
<span class="fc" id="L2717">                    h = h / 100.0f * value;</span>
<span class="fc" id="L2718">                    return (int) h;</span>
                } else {
<span class="fc" id="L2720">                    float w = Display.getInstance().getDisplayWidth();</span>
<span class="fc" id="L2721">                    w = w / 100.0f * value;</span>
<span class="fc" id="L2722">                    return (int) w;</span>
                }
            default:
<span class="fc" id="L2725">                return (int) value;</span>
        }

    }

    /**
     * Converts the dips count to pixels, dips are roughly 1mm in length. This is a very rough estimate and not
     * to be relied upon. This version of the method assumes square pixels which is pretty much the norm.
     *
     * @param dipCount the dips that we will convert to pixels
     * @return value in pixels
     */
    public int convertToPixels(float dipCount) {
<span class="fc" id="L2738">        return Math.round(impl.convertToPixels((int) (dipCount * 1000), true) / 1000.0f);</span>
    }

    /**
     * Checks to see if the platform supports a native image cache.
     *
     * @return True on platforms that support a native image cache.  Currently only Javascript.
     */
    boolean supportsNativeImageCache() {
<span class="nc" id="L2747">        return impl.supportsNativeImageCache();</span>
    }

    /**
     * Returns the game action code matching the given key combination
     *
     * @param keyCode key code received from the event
     * @return game action matching this keycode
     */
    public int getGameAction(int keyCode) {
<span class="fc" id="L2757">        return impl.getGameAction(keyCode);</span>
    }

    /**
     * Returns the keycode matching the given game action constant (the opposite of getGameAction).
     * On some devices getKeyCode returns numeric keypad values for game actions,
     * this breaks the code since we filter these values (to prevent navigation on '2').
     * We pick unused negative values for game keys and assign them to game keys for
     * getKeyCode so they will work with getGameAction.
     *
     * @param gameAction game action constant from this class
     * @return keycode matching this constant
     * @deprecated this method doesn't work properly across device and is mocked up here
     * mostly for the case of unit testing. Do not use it for anything other than that! Do
     * not rely on getKeyCode(GAME_*) == keyCodeFromKeyEvent, this will never actually happen!
     */
    public int getKeyCode(int gameAction) {
<span class="fc" id="L2774">        return impl.getKeyCode(gameAction);</span>
    }

    /**
     * Indicates whether the 3rd softbutton should be supported on this device
     *
     * @return true if a third softbutton should be used
     */
    public boolean isThirdSoftButton() {
<span class="fc" id="L2783">        return thirdSoftButton;</span>
    }

    /**
     * Indicates whether the 3rd softbutton should be supported on this device
     *
     * @param thirdSoftButton true if a third softbutton should be used
     */
    public void setThirdSoftButton(boolean thirdSoftButton) {
<span class="nc" id="L2792">        this.thirdSoftButton = thirdSoftButton;</span>
<span class="nc" id="L2793">    }</span>

    /**
     * Displays the virtual keyboard on devices that support manually poping up
     * the vitual keyboard
     *
     * @param show toggles the virtual keyboards visibility
     * @deprecated this method was only relevant for feature phones.
     * You should use {@link com.codename1.ui.TextArea#startEditingAsync()} or {@link com.codename1.ui.TextArea#stopEditing()}
     * to control text field editing/VKB visibility
     */
    public void setShowVirtualKeyboard(boolean show) {
<span class="pc bpc" id="L2805" title="1 of 2 branches missed.">        if (isTouchScreenDevice()) {</span>
<span class="fc" id="L2806">            VirtualKeyboardInterface vkb = getDefaultVirtualKeyboard();</span>
<span class="pc bpc" id="L2807" title="1 of 2 branches missed.">            if (vkb != null) {</span>
<span class="nc" id="L2808">                vkb.showKeyboard(show);</span>
            }
        }
<span class="fc" id="L2811">    }</span>

    /**
     * Indicates if the virtual keyboard is currently showing or not
     *
     * @return true if the virtual keyboard is showing
     * @deprecated this method was only relevant for feature phones.
     * You should use {@link com.codename1.ui.TextArea#isEditing()} instead.
     */
    public boolean isVirtualKeyboardShowing() {
<span class="pc bpc" id="L2821" title="1 of 2 branches missed.">        if (!isTouchScreenDevice()) {</span>
<span class="nc" id="L2822">            return false;</span>
        }
<span class="pc bpc" id="L2824" title="3 of 4 branches missed.">        return getDefaultVirtualKeyboard() != null &amp;&amp; getDefaultVirtualKeyboard().isVirtualKeyboardShowing();</span>
    }

    /**
     * Returns all platform supported virtual keyboards names
     *
     * @return all platform supported virtual keyboards names
     * @deprecated this method is only used in feature phones and has no modern equivalent
     */
    public String[] getSupportedVirtualKeyboard() {
<span class="nc" id="L2834">        String[] retVal = new String[virtualKeyboards.size()];</span>
<span class="nc" id="L2835">        int index = 0;</span>
<span class="nc bnc" id="L2836" title="All 2 branches missed.">        for (String k : virtualKeyboards.keySet()) {</span>
<span class="nc" id="L2837">            retVal[index++] = k;</span>
<span class="nc" id="L2838">        }</span>
<span class="nc" id="L2839">        return retVal;</span>
    }

    /**
     * Register a virtual keyboard
     *
     * @param vkb
     * @deprecated this method is only used in feature phones and has no modern equivalent
     */
    public void registerVirtualKeyboard(VirtualKeyboardInterface vkb) {
<span class="nc" id="L2849">        virtualKeyboards.put(vkb.getVirtualKeyboardName(), vkb);</span>
<span class="nc" id="L2850">    }</span>

    /**
     * Get the default virtual keyboard or null if the VirtualKeyboard is disabled
     *
     * @return the default vkb
     * @deprecated this method is only used in feature phones and has no modern equivalent
     */
    public VirtualKeyboardInterface getDefaultVirtualKeyboard() {
<span class="pc bpc" id="L2859" title="1 of 2 branches missed.">        if (selectedVirtualKeyboard == null) {</span>
<span class="fc" id="L2860">            return null;</span>
        }
<span class="nc" id="L2862">        return virtualKeyboards.get(selectedVirtualKeyboard);</span>
    }

    /**
     * Sets the default virtual keyboard to be used by the platform
     *
     * @param vkb a VirtualKeyboard to be used or null to disable the
     *            VirtualKeyboard
     * @deprecated this method is only used in feature phones and has no modern equivalent
     */
    public void setDefaultVirtualKeyboard(VirtualKeyboardInterface vkb) {
<span class="nc bnc" id="L2873" title="All 2 branches missed.">        if (vkb != null) {</span>
<span class="nc" id="L2874">            selectedVirtualKeyboard = vkb.getVirtualKeyboardName();</span>
<span class="nc bnc" id="L2875" title="All 2 branches missed.">            if (!virtualKeyboards.containsKey(selectedVirtualKeyboard)) {</span>
<span class="nc" id="L2876">                registerVirtualKeyboard(vkb);</span>
            }
        } else {
<span class="nc" id="L2879">            selectedVirtualKeyboard = null;</span>
        }
<span class="nc" id="L2881">    }</span>

    /**
     * Gets the VirtualKeyboardListener Objects of exists.
     *
     * @return a Listener Object or null if not exists
     * @deprecated Use {@link #removeVirtualKeyboardListener(com.codename1.ui.events.ActionListener) }
     */
    public ActionListener getVirtualKeyboardListener() {
<span class="nc" id="L2890">        return virtualKeyboardListener;</span>
    }

    /**
     * Sets a listener for VirtualKeyboard hide/show events.
     * The Listener will get an event once the keyboard is opened/closed with
     * a Boolean value that represents the state of the keyboard true for open
     * and false for closed getSource() on the ActionEvent will return the
     * Boolean value.
     *
     * @param l the listener
     * @deprecated Use {@link #addVirtualKeyboardListener(com.codename1.ui.events.ActionListener) }
     */
    public void setVirtualKeyboardListener(ActionListener l) {
<span class="nc bnc" id="L2904" title="All 2 branches missed.">        if (virtualKeyboardListener != null) {</span>
<span class="nc" id="L2905">            removeVirtualKeyboardListener(l);</span>
        }
<span class="nc" id="L2907">        virtualKeyboardListener = l;</span>
<span class="nc" id="L2908">        addVirtualKeyboardListener(l);</span>
<span class="nc" id="L2909">    }</span>

    /**
     * Adds a listener for VirtualKeyboard hide/show events.  ActionEvents will return a Boolean
     * value for {@link ActionEvent#getSource() }, with {@literal Boolean.TRUE} on show, and {@literal Boolean.FALSE}
     * on hide.
     * &lt;p&gt;Note: Keyboard events may not be 100% reliable as they use heuristics on most platforms to guess when the keyboard
     * is shown or hidden.&lt;/p&gt;
     *
     * @param l The listener.
     * @see #removeVirtualKeyboardListener(com.codename1.ui.events.ActionListener)
     * @since 6.0
     */
    public synchronized void addVirtualKeyboardListener(ActionListener l) {
<span class="nc bnc" id="L2923" title="All 2 branches missed.">        if (virtualKeyboardListeners == null) {</span>
<span class="nc" id="L2924">            virtualKeyboardListeners = new EventDispatcher();</span>
        }
<span class="nc" id="L2926">        virtualKeyboardListeners.addListener(l);</span>
<span class="nc" id="L2927">    }</span>

    /**
     * Removes a listener for VirtualKeyboard hide/show events.  ActionEvents will return a Boolean
     * value for {@link ActionEvent#getSource() }, with {@literal Boolean.TRUE} on show, and {@literal Boolean.FALSE}
     * on hide.
     * &lt;p&gt;Note: Keyboard events may not be 100% reliable as they use heuristics on most platforms to guess when the keyboard
     * is shown or hidden.&lt;/p&gt;
     *
     * @param l The listener.
     * @see #addVirtualKeyboardListener(com.codename1.ui.events.ActionListener)
     * @since 6.0
     */
    public synchronized void removeVirtualKeyboardListener(ActionListener l) {
<span class="nc bnc" id="L2941" title="All 2 branches missed.">        if (virtualKeyboardListeners != null) {</span>
<span class="nc" id="L2942">            virtualKeyboardListeners.removeListener(l);</span>
        }
<span class="nc" id="L2944">    }</span>

    /**
     * Fires a virtual keyboard show event.
     *
     * @param show
     * @since 6.0
     */
    public void fireVirtualKeyboardEvent(boolean show) {
<span class="nc bnc" id="L2953" title="All 2 branches missed.">        if (virtualKeyboardListeners != null) {</span>
<span class="nc" id="L2954">            virtualKeyboardListeners.fireActionEvent(new ActionEvent(show));</span>
        }
<span class="nc" id="L2956">    }</span>

    /**
     * Gets the invisible area under the Virtual Keyboard.
     *
     * @return Height of the VKB that overlaps the screen.
     * @since 6.0
     */
    public int getInvisibleAreaUnderVKB() {
<span class="nc" id="L2965">        return impl.getInvisibleAreaUnderVKB();</span>
    }

    /**
     * Returns the type of the input device one of:
     * KEYBOARD_TYPE_UNKNOWN, KEYBOARD_TYPE_NUMERIC, KEYBOARD_TYPE_QWERTY,
     * KEYBOARD_TYPE_VIRTUAL, KEYBOARD_TYPE_HALF_QWERTY
     *
     * @return KEYBOARD_TYPE_UNKNOWN
     */
    public int getKeyboardType() {
<span class="fc" id="L2976">        return impl.getKeyboardType();</span>
    }

    /**
     * Indicates whether the device supports native in place editing in which case
     * lightweight input logic shouldn't be used for input.
     *
     * @return false by default
     */
    public boolean isNativeInputSupported() {
<span class="fc" id="L2986">        return impl.isNativeInputSupported();</span>
    }

    /**
     * Indicates whether the device supports multi-touch events, this is only
     * relevant when touch events are supported
     *
     * @return false by default
     */
    public boolean isMultiTouch() {
<span class="nc" id="L2996">        return impl.isMultiTouch();</span>
    }

    /**
     * Indicates whether the device has a double layer screen thus allowing two
     * stages to touch events: click and hover. This is true for devices such
     * as the storm but can also be true for a PC with a mouse pointer floating
     * on top.
     * &lt;p&gt;A click touch screen will also send pointer hover events to the underlying
     * software and will only send the standard pointer events on click.
     *
     * @return false by default
     */
    public boolean isClickTouchScreen() {
<span class="nc" id="L3010">        return impl.isClickTouchScreen();</span>
    }

    /**
     * This method returns the dragging speed based on the latest dragged
     * events
     *
     * @param yAxis indicates what axis speed is required
     * @return the dragging speed
     */
    public float getDragSpeed(boolean yAxis) {
        float speed;
<span class="fc bfc" id="L3022" title="All 2 branches covered.">        if (yAxis) {</span>
<span class="fc" id="L3023">            speed = impl.getDragSpeed(dragPathY, dragPathTime, dragPathOffset, dragPathLength);</span>
        } else {
<span class="fc" id="L3025">            speed = impl.getDragSpeed(dragPathX, dragPathTime, dragPathOffset, dragPathLength);</span>
        }
<span class="fc" id="L3027">        return speed;</span>
    }

    /**
     * Indicates whether Codename One should consider the bidi RTL algorithm
     * when drawing text or navigating with the text field cursor.
     *
     * @return true if the bidi algorithm should be considered
     */
    public boolean isBidiAlgorithm() {
<span class="nc" id="L3037">        return impl.isBidiAlgorithm();</span>
    }

    /**
     * Indicates whether Codename One should consider the bidi RTL algorithm
     * when drawing text or navigating with the text field cursor.
     *
     * @param activate set to true to activate the bidi algorithm, false to
     *                 disable it
     */
    public void setBidiAlgorithm(boolean activate) {
<span class="fc" id="L3048">        impl.setBidiAlgorithm(activate);</span>
<span class="fc" id="L3049">    }</span>

    /**
     * Converts the given string from logical bidi layout to visual bidi layout so
     * it can be rendered properly on the screen. This method is only necessary
     * for devices/platforms that don't have &quot;built in&quot; bidi support such as
     * Sony Ericsson devices.
     * See &lt;a href=&quot;http://www.w3.org/International/articles/inline-bidi-markup/#visual&quot;&gt;this&lt;/a&gt;
     * for more on visual vs. logical ordering.
     *
     * @param s a &quot;logical&quot; string with RTL characters
     * @return a &quot;visual&quot; renderable string
     */
    public String convertBidiLogicalToVisual(String s) {
<span class="nc" id="L3063">        return impl.convertBidiLogicalToVisual(s);</span>
    }

    /**
     * Returns the index of the given char within the source string, the actual
     * index isn't necessarily the same when bidi is involved
     * See &lt;a href=&quot;http://www.w3.org/International/articles/inline-bidi-markup/#visual&quot;&gt;this&lt;/a&gt;
     * for more on visual vs. logical ordering.
     *
     * @param source the string in which we are looking for the position
     * @param index  the &quot;logical&quot; location of the cursor
     * @return the &quot;visual&quot; location of the cursor
     */
    public int getCharLocation(String source, int index) {
<span class="nc" id="L3077">        return impl.getCharLocation(source, index);</span>
    }

    /**
     * Returns true if the given character is an RTL character
     *
     * @param c character to test
     * @return true if the charcter is an RTL character
     */
    public boolean isRTL(char c) {
<span class="nc" id="L3087">        return impl.isRTL(c);</span>
    }

    /**
     * This method is essentially equivalent to cls.getResourceAsStream(String)
     * however some platforms might define unique ways in which to load resources
     * within the implementation.
     *
     * @param cls      class to load the resource from
     * @param resource relative/absolute URL based on the Java convention
     * @return input stream for the resource or null if not found
     */
    public InputStream getResourceAsStream(Class cls, String resource) {
<span class="fc" id="L3100">        return impl.getResourceAsStream(cls, resource);</span>
    }

    /**
     * An error handler will receive an action event with the source exception from the EDT
     * once an error handler is installed the default Codename One error dialog will no longer appear
     *
     * @param e listener receiving the errors
     */
    public void addEdtErrorHandler(ActionListener e) {
<span class="nc bnc" id="L3110" title="All 2 branches missed.">        if (errorHandler == null) {</span>
<span class="nc" id="L3111">            errorHandler = new EventDispatcher();</span>
        }
<span class="nc" id="L3113">        errorHandler.addListener(e);</span>
<span class="nc" id="L3114">    }</span>

    /**
     * An error handler will receive an action event with the source exception from the EDT
     * once an error handler is installed the default Codename One error dialog will no longer appear
     *
     * @param e listener receiving the errors
     */
    public void removeEdtErrorHandler(ActionListener e) {
<span class="nc bnc" id="L3123" title="All 2 branches missed.">        if (errorHandler != null) {</span>
<span class="nc" id="L3124">            errorHandler.removeListener(e);</span>
<span class="nc" id="L3125">            Collection v = errorHandler.getListenerCollection();</span>
<span class="nc bnc" id="L3126" title="All 4 branches missed.">            if (v == null || v.size() == 0) {</span>
<span class="nc" id="L3127">                errorHandler = null;</span>
            }
        }
<span class="nc" id="L3130">    }</span>

    /**
     * Allows a Codename One application to minimize without forcing it to the front whenever
     * a new dialog is poped up
     *
     * @return allowMinimizing value
     */
    public boolean isAllowMinimizing() {
<span class="nc" id="L3139">        return allowMinimizing;</span>
    }

    /**
     * Allows a Codename One application to minimize without forcing it to the front whenever
     * a new dialog is poped up
     *
     * @param allowMinimizing value
     */
    public void setAllowMinimizing(boolean allowMinimizing) {
<span class="nc" id="L3149">        this.allowMinimizing = allowMinimizing;</span>
<span class="nc" id="L3150">    }</span>

    /**
     * This is an internal state flag relevant only for pureTouch mode (otherwise it
     * will always be true). A pureTouch mode is stopped if a user switches to using
     * the trackball/navigation pad and this flag essentially toggles between those two modes.
     *
     * @return the shouldRenderSelection
     */
    public boolean shouldRenderSelection() {
<span class="pc bpc" id="L3160" title="5 of 6 branches missed.">        return !pureTouch || pointerPressedAndNotReleasedOrDragged || lastInteractionWasKeypad;</span>
    }

    /**
     * This is an internal state flag relevant only for pureTouch mode (otherwise it
     * will always be true). A pureTouch mode is stopped if a user switches to using
     * the trackball/navigation pad and this flag essentially toggles between those two modes.
     *
     * @param c the component to test against, this prevents a touch outside of the component that triggers a repaint from painting the component selection
     * @return the shouldRenderSelection
     */
    public boolean shouldRenderSelection(Component c) {
<span class="fc bfc" id="L3172" title="All 2 branches covered.">        if (c.isCellRenderer()) {</span>
<span class="fc" id="L3173">            return shouldRenderSelection();</span>
        }
<span class="pc bpc" id="L3175" title="9 of 10 branches missed.">        return !pureTouch || lastInteractionWasKeypad || (pointerPressedAndNotReleasedOrDragged &amp;&amp; c.contains(pointerX, pointerY)) || c.shouldRenderComponentSelection();</span>
    }

    /**
     * A pure touch device has no focus showing when the user is using the touch
     * interface. Selection only shows when the user actually touches the screen
     * or suddenly switches to using a keypad/trackball. This sort of interface
     * is common in Android devices
     *
     * @return the pureTouch flag
     */
    public boolean isPureTouch() {
<span class="fc" id="L3187">        return pureTouch;</span>
    }

    /**
     * A pure touch device has no focus showing when the user is using the touch
     * interface. Selection only shows when the user actually touches the screen
     * or suddenly switches to using a keypad/trackball. This sort of interface
     * is common in Android devices
     *
     * @param pureTouch the value for pureTouch
     */
    public void setPureTouch(boolean pureTouch) {
<span class="fc" id="L3199">        this.pureTouch = pureTouch;</span>
<span class="fc" id="L3200">    }</span>

    /**
     * Indicates whether Codename One commands should be mapped to the native menus
     *
     * @return the nativeCommands status
     * @deprecated use getCommandBehavior() == Display.COMMAND_BEHAVIOR_NATIVE
     */
    public boolean isNativeCommands() {
<span class="pc bpc" id="L3209" title="1 of 2 branches missed.">        return getCommandBehavior() == COMMAND_BEHAVIOR_NATIVE;</span>
    }

    /**
     * Indicates whether Codename One commands should be mapped to the native menus
     *
     * @param nativeCommands the flag to set
     * @deprecated use setCommandBehavior(Display.COMMAND_BEHAVIOR_NATIVE)
     */
    public void setNativeCommands(boolean nativeCommands) {
<span class="nc" id="L3219">        setCommandBehavior(COMMAND_BEHAVIOR_NATIVE);</span>
<span class="nc" id="L3220">    }</span>

    /**
     * Exits the application...
     */
    public void exitApplication() {
<span class="nc" id="L3226">        codenameOneExited = true;</span>
<span class="nc" id="L3227">        impl.exit();</span>
<span class="nc" id="L3228">    }</span>

    /**
     * Checks if this platform supports full-screen mode.  If full-screen mode is supported, you can use
     * the {@link #requestFullScreen() }, {@link #exitFullScreen() }, and {@link #isInFullScreenMode() } methods
     * to enter and exit full-screen - and query the current state.
     *
     * &lt;p&gt;Currently only desktop and Javascript builds support full-screen mode; And Javascript
     * only supports this on certain browsers.  See the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API&quot;&gt;MDN Fullscreen API docs&lt;/a&gt;
     * for a list of browsers that support full-screen.&lt;/p&gt;
     *
     * &lt;p&gt;When running in the simulator, full-screen is only supported for the desktop skin.&lt;/p&gt;
     *
     * @return {@literal true} if Full-screen mode is supported on this platform.
     * @see #requestFullScreen()
     * @see #exitFullScreen()
     * @see #isInFullScreenMode()
     * @since 6.0
     */
    public boolean isFullScreenSupported() {
<span class="nc" id="L3248">        return impl.isFullScreenSupported();</span>
    }

    /**
     * Try to enter full-screen mode if the platform supports it.
     *
     * &lt;p&gt;Currently only desktop and Javascript builds support full-screen mode; And Javascript
     * only supports this on certain browsers.  See the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API&quot;&gt;MDN Fullscreen API docs&lt;/a&gt;
     * for a list of browsers that support full-screen.&lt;/p&gt;
     *
     * &lt;p&gt;When running in the simulator, full-screen is only supported for the desktop skin.&lt;/p&gt;
     *
     * @return {@literal true} on success.  This will also return {@literal true} if the app is already running in full-screen mode.  It will return {@literal false}
     * if the app fails to enter full-screen mode.
     * @see #exitFullScreen()
     * @see #isInFullScreenMode()
     * @see #isFullScreenSupported()
     * @since 6.0
     */
    public boolean requestFullScreen() {
<span class="fc" id="L3268">        return impl.requestFullScreen();</span>
    }

    /**
     * Try to exit full-screen mode if the platform supports it.
     *
     * &lt;p&gt;Currently only desktop and Javascript builds support full-screen mode; And Javascript
     * only supports this on certain browsers.  See the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API&quot;&gt;MDN Fullscreen API docs&lt;/a&gt;
     * for a list of browsers that support full-screen.&lt;/p&gt;
     *
     * &lt;p&gt;When running in the simulator, full-screen is only supported for the desktop skin.&lt;/p&gt;
     *
     * @return {@literal true} on success.  This will also return {@literal true} if the app is already NOT in full-screen mode.  It will return {@literal false}
     * if the app fails to exit full-screen mode.
     * @see #requestFullScreen()
     * @see #isInFullScreenMode()
     * @see #isFullScreenSupported()
     * @since 6.0
     */
    public boolean exitFullScreen() {
<span class="nc" id="L3288">        return impl.exitFullScreen();</span>
    }

    /**
     * Checks if the app is currently running in full-screen mode.
     *
     * @return {@literal true} if the app is currently in full-screen mode.
     * @see #requestFullScreen()
     * @see #exitFullScreen()
     * @see #isFullScreenSupported()
     * @since 6.0
     */
    public boolean isInFullScreenMode() {
<span class="fc" id="L3301">        return impl.isInFullScreenMode();</span>
    }

    /**
     * Shows a native Form/Canvas or some other heavyweight native screen
     *
     * @param nativeFullScreenPeer the native screen peer
     */
    public void showNativeScreen(Object nativeFullScreenPeer) {
<span class="nc" id="L3310">        inNativeUI = true;</span>
<span class="nc" id="L3311">        impl.showNativeScreen(nativeFullScreenPeer);</span>
<span class="nc" id="L3312">    }</span>

    /**
     * Normally Codename One folds the VKB when switching forms this field allows us
     * to block that behavior.
     *
     * @return the autoFoldVKBOnFormSwitch
     */
    public boolean isAutoFoldVKBOnFormSwitch() {
<span class="nc" id="L3321">        return autoFoldVKBOnFormSwitch;</span>
    }

    /**
     * Normally Codename One folds the VKB when switching forms this field allows us
     * to block that behavior.
     *
     * @param autoFoldVKBOnFormSwitch the autoFoldVKBOnFormSwitch to set
     */
    public void setAutoFoldVKBOnFormSwitch(boolean autoFoldVKBOnFormSwitch) {
<span class="nc" id="L3331">        this.autoFoldVKBOnFormSwitch = autoFoldVKBOnFormSwitch;</span>
<span class="nc" id="L3332">    }</span>

    /**
     * Indicates the way commands should be added to a form as one of the ocmmand constants defined
     * in this class
     *
     * @return the commandBehavior
     * @deprecated we recommend migrating to the {@link Toolbar} API. When using the toolbar the command
     * behavior can't be manipulated
     */
    public int getCommandBehavior() {
<span class="fc" id="L3343">        return impl.getCommandBehavior();</span>
    }

    /**
     * Indicates the way commands should be added to a form as one of the ocmmand constants defined
     * in this class
     *
     * @param commandBehavior the commandBehavior to set
     * @deprecated we recommend migrating to the {@link Toolbar} API. When using the toolbar the command
     * behavior can't be manipulated
     */
    public void setCommandBehavior(int commandBehavior) {
<span class="fc bfc" id="L3355" title="All 2 branches covered.">        if (commandBehavior == Display.COMMAND_BEHAVIOR_SIDE_NAVIGATION) {</span>
<span class="fc" id="L3356">            String message = &quot;WARNING: Display.setCommandBehavior() is deprecated, Using it may result in unexpected behaviour. In particular, using COMMAND_BEHAVIOR_SIDE_NAVIGATION in conjunction with Toolbar.setOnTopSideMenu(true) may result in runtime errors.&quot;;</span>
<span class="fc" id="L3357">            Log.p(message, Log.WARNING);</span>
        }
<span class="fc" id="L3359">        impl.setCommandBehavior(commandBehavior);</span>
<span class="fc" id="L3360">    }</span>

    /**
     * Posts a message to the native platform.  Different platforms may handle messages posted this
     * way differently.
     * &lt;p&gt;The Javascript port will dispatch the message on the {@literal window} object
     * as a custom DOM event named 'cn1outbox', with the event data containing a 'detail' key with the
     * message, and a 'code' key with the code.&lt;/p&gt;
     *
     * @param message The message.
     * @since 7.0
     */
    public void postMessage(MessageEvent message) {
<span class="nc" id="L3373">        impl.postMessage(message);</span>
<span class="nc" id="L3374">    }</span>

    /**
     * Adds a listener to receive messages from the native platform.  This is one mechanism for the native
     * platform to communicate with the Codename one app.
     *
     * &lt;p&gt;In the JavaScript port, listeners will be notified when DOM events named 'cn1inbox' are received on the
     * window object.  The event data 'detail' key will be the source of the message, and the 'code' key will be the
     * source of the code.
     *
     * @param l The listener.
     * @since 7.0
     */
    public void addMessageListener(ActionListener&lt;MessageEvent&gt; l) {
<span class="fc bfc" id="L3388" title="All 2 branches covered.">        if (messageListeners == null) {</span>
<span class="fc" id="L3389">            messageListeners = new EventDispatcher();</span>
        }
<span class="fc" id="L3391">        messageListeners.addListener(l);</span>
<span class="fc" id="L3392">    }</span>

    /**
     * Removes a listener from receiving messages from the native platform.
     *
     * @param l The listener.
     * @since 7.0
     */
    public void removeMessageListener(ActionListener&lt;MessageEvent&gt; l) {
<span class="pc bpc" id="L3401" title="1 of 2 branches missed.">        if (messageListeners != null) {</span>
<span class="fc" id="L3402">            messageListeners.removeListener(l);</span>
        }
<span class="fc" id="L3404">    }</span>

    /**
     * Dispatches a message to all of the registered listeners.
     *
     * @param evt
     * @see #addMessageListener(com.codename1.ui.events.ActionListener)
     * @see #removeMessageListener(com.codename1.ui.events.ActionListener)
     * @since 7.0
     */
    public void dispatchMessage(MessageEvent evt) {
<span class="pc bpc" id="L3415" title="2 of 4 branches missed.">        if (messageListeners != null &amp;&amp; messageListeners.hasListeners()) {</span>
<span class="fc" id="L3416">            messageListeners.fireActionEvent(evt);</span>
        }
<span class="fc" id="L3418">    }</span>

    /**
     * Adds a listener to receive notifications about native window changes such as resize or movement.
     *
     * @param l the listener to add
     */
    public synchronized void addWindowListener(ActionListener&lt;WindowEvent&gt; l) {
<span class="pc bpc" id="L3426" title="1 of 2 branches missed.">        if (windowListeners == null) {</span>
<span class="fc" id="L3427">            windowListeners = new EventDispatcher();</span>
        }
<span class="fc" id="L3429">        windowListeners.addListener(l);</span>
<span class="fc" id="L3430">    }</span>

    /**
     * Removes a previously registered window listener.
     *
     * @param l the listener to remove
     */
    public synchronized void removeWindowListener(ActionListener&lt;WindowEvent&gt; l) {
<span class="pc bpc" id="L3438" title="1 of 2 branches missed.">        if (windowListeners != null) {</span>
<span class="fc" id="L3439">            windowListeners.removeListener(l);</span>
        }
<span class="fc" id="L3441">    }</span>

    /**
     * Dispatches a window change event to registered listeners. This method is intended to be invoked by
     * platform implementations.
     *
     * @param evt the window event to dispatch
     */
    public void fireWindowEvent(WindowEvent evt) {
<span class="pc bpc" id="L3450" title="3 of 6 branches missed.">        if (evt == null || windowListeners == null || !windowListeners.hasListeners()) {</span>
<span class="nc" id="L3451">            return;</span>
        }
<span class="pc bpc" id="L3453" title="1 of 2 branches missed.">        if (isEdt()) {</span>
<span class="fc" id="L3454">            windowListeners.fireActionEvent(evt);</span>
        } else {
<span class="nc" id="L3456">            final WindowEvent windowEvent = evt;</span>
<span class="nc" id="L3457">            callSerially(new Runnable() {</span>
                @Override
                public void run() {
<span class="nc bnc" id="L3460" title="All 4 branches missed.">                    if (windowListeners != null &amp;&amp; windowListeners.hasListeners()) {</span>
<span class="nc" id="L3461">                        windowListeners.fireActionEvent(windowEvent);</span>
                    }
<span class="nc" id="L3463">                }</span>
            });
        }
<span class="fc" id="L3466">    }</span>

    /**
     * Returns the property from the underlying platform deployment or the default
     * value if no deployment values are supported. This is equivalent to the
     * getAppProperty from the jad file.
     * &lt;p&gt;The implementation should be responsible for the following keys to return
     * reasonable valid values for the application:
     * &lt;ol&gt;
     * &lt;li&gt;AppName
     * &lt;li&gt;User-Agent
     * &lt;li&gt;AppVersion
     * &lt;li&gt;Platform - Similar to microedition.platform
     * &lt;li&gt;OS - returns what is the underlying platform e.g. - iOS, Android, RIM, SE...
     * &lt;li&gt;OSVer - OS version when available as a user readable string (not necessarily a number e.g: 3.2.1).
     *
     * &lt;/ol&gt;
     *
     * @param key          the key of the property
     * @param defaultValue a default return value
     * @return the value of the property
     */
    public String getProperty(String key, String defaultValue) {
<span class="fc bfc" id="L3489" title="All 2 branches covered.">        if (&quot;AppArg&quot;.equals(key)) {</span>
<span class="fc" id="L3490">            String out = impl.getAppArg();</span>
<span class="pc bpc" id="L3491" title="1 of 2 branches missed.">            return out == null ? defaultValue : out;</span>
        }
<span class="pc bpc" id="L3493" title="1 of 2 branches missed.">        if (&quot;Component.revalidateOnStyleChange&quot;.equals(key)) {</span>
<span class="nc bnc" id="L3494" title="All 2 branches missed.">            return Component.revalidateOnStyleChange ? &quot;true&quot; : &quot;false&quot;;</span>
        }
<span class="fc bfc" id="L3496" title="All 2 branches covered.">        if (localProperties != null) {</span>
<span class="fc" id="L3497">            String v = localProperties.get(key);</span>
<span class="fc bfc" id="L3498" title="All 2 branches covered.">            if (v != null) {</span>
<span class="fc" id="L3499">                return v;</span>
            }
        }
<span class="fc" id="L3502">        return impl.getProperty(key, defaultValue);</span>
    }

    /**
     * Sets a local property to the application, this method has no effect on the
     * implementation code and only allows the user to override the logic of getProperty
     * for internal application purposes.
     *
     * @param key   key the key of the property
     * @param value the value of the property
     */
    public void setProperty(String key, String value) {
<span class="fc bfc" id="L3514" title="All 2 branches covered.">        if (&quot;AppArg&quot;.equals(key)) {</span>
<span class="fc" id="L3515">            impl.setAppArg(value);</span>
<span class="fc" id="L3516">            return;</span>
        }
<span class="fc bfc" id="L3518" title="All 2 branches covered.">        if (&quot;blockOverdraw&quot;.equals(key)) {</span>
<span class="fc" id="L3519">            Container.blockOverdraw = true;</span>
<span class="fc" id="L3520">            return;</span>
        }
<span class="fc bfc" id="L3522" title="All 2 branches covered.">        if (&quot;blockCopyPaste&quot;.equals(key)) {</span>
<span class="fc" id="L3523">            impl.blockCopyPaste(&quot;true&quot;.equals(value));</span>
        }
<span class="fc bfc" id="L3525" title="All 2 branches covered.">        if (&quot;Component.revalidateOnStyleChange&quot;.equals(key)) {</span>
<span class="fc" id="L3526">            Component.revalidateOnStyleChange = &quot;true&quot;.equalsIgnoreCase(value);</span>
        }
<span class="fc bfc" id="L3528" title="All 2 branches covered.">        if (key.startsWith(&quot;platformHint.&quot;)) {</span>
<span class="fc" id="L3529">            impl.setPlatformHint(key, value);</span>
<span class="fc" id="L3530">            return;</span>
        }
<span class="fc bfc" id="L3532" title="All 2 branches covered.">        if (localProperties == null) {</span>
<span class="fc" id="L3533">            localProperties = new HashMap&lt;String, String&gt;();</span>
        }
<span class="fc bfc" id="L3535" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L3536">            localProperties.remove(key);</span>
        } else {
<span class="fc" id="L3538">            localProperties.put(key, value);</span>
        }
<span class="fc" id="L3540">    }</span>

    /**
     * &lt;p&gt;Returns true if executing this URL should work, returns false if it will not
     * and null if this is unknown.&lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/codenameone/7aefb64909e75e10c396.js&quot;&gt;&lt;/script&gt;
     *
     * @param url the url that would be executed
     * @return true if executing this URL should work, returns false if it will not
     * and null if this is unknown
     */
    public Boolean canExecute(String url) {
<span class="nc" id="L3552">        return impl.canExecute(url);</span>
    }

    /**
     * &lt;p&gt;Executes the given URL on the native platform&lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/codenameone/7aefb64909e75e10c396.js&quot;&gt;&lt;/script&gt;
     *
     * @param url the url to execute
     */
    public void execute(String url) {
<span class="nc" id="L3562">        impl.execute(url);</span>
<span class="nc" id="L3563">    }</span>

    /**
     * Executes the given URL on the native platform, this method is useful if
     * the platform has the ability to send an event to the app when the execution
     * has ended, currently this works only for Android platform to invoke other
     * intents.
     *
     * @param url      the url to execute
     * @param response a callback from the platform when this execution returned
     *                 to the application
     */
    public void execute(String url, ActionListener response) {
<span class="nc" id="L3576">        impl.execute(url, response);</span>
<span class="nc" id="L3577">    }</span>

    /**
     * Returns one of the density variables appropriate for this device, notice that
     * density doesn't always correspond to resolution and an implementation might
     * decide to change the density based on DPI constraints.
     *
     * @return one of the DENSITY constants of Display
     */
    public int getDeviceDensity() {
<span class="fc" id="L3587">        return impl.getDeviceDensity();</span>
    }

    /**
     * Returns the device density as a string.
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt;DENSITY_VERY_LOW : &quot;very-low&quot;&lt;/li&gt;
     * &lt;li&gt;DENSITY_LOW : &quot;low&quot;&lt;/li&gt;
     * &lt;li&gt;DENSITY_MEDIUM : &quot;medium&quot;&lt;/li&gt;
     * &lt;li&gt;DENSITY_HIGH : &quot;high&quot;&lt;/li&gt;
     * &lt;li&gt;DENSITY_VERY_HIGH : &quot;very-high&quot;&lt;/li&gt;
     * &lt;li&gt;DENSITY_HD : &quot;hd&quot;&lt;/li&gt;
     * &lt;li&gt;DENSITY_560 : &quot;560&quot;&lt;/li&gt;
     * &lt;li&gt;DENSITY_2HD : &quot;2hd&quot;&lt;/li&gt;
     * &lt;li&gt;DENSITY_4K : &quot;4k&quot;;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return Device density as a string.
     * @see #getDeviceDensity()
     * @since 7.0
     */
    public String getDensityStr() {
<span class="nc bnc" id="L3611" title="All 10 branches missed.">        switch (getDeviceDensity()) {</span>
            case DENSITY_VERY_LOW:
<span class="nc" id="L3613">                return &quot;very-low&quot;;</span>
            case DENSITY_LOW:
<span class="nc" id="L3615">                return &quot;low&quot;;</span>
            case DENSITY_MEDIUM:
<span class="nc" id="L3617">                return &quot;medium&quot;;</span>
            case DENSITY_HIGH:
<span class="nc" id="L3619">                return &quot;high&quot;;</span>
            case DENSITY_VERY_HIGH:
<span class="nc" id="L3621">                return &quot;very-high&quot;;</span>
            case DENSITY_HD:
<span class="nc" id="L3623">                return &quot;hd&quot;;</span>
            case DENSITY_560:
<span class="nc" id="L3625">                return &quot;560&quot;;</span>
            case DENSITY_2HD:
<span class="nc" id="L3627">                return &quot;2hd&quot;;</span>
            case DENSITY_4K:
<span class="nc" id="L3629">                return &quot;4k&quot;;</span>
            default:
<span class="nc" id="L3631">                throw new IllegalStateException(&quot;Unknown density &quot; + getDeviceDensity());</span>
        }
    }

    /**
     * Plays a builtin device sound matching the given identifier, implementations
     * and themes can offer additional identifiers to the ones that are already built
     * in.
     *
     * @param soundIdentifier the sound identifier which can match one of the
     *                        common constants in this class or be a user/implementation defined sound
     * @deprecated this isn't supported on most platforms
     */
    public void playBuiltinSound(String soundIdentifier) {
<span class="fc" id="L3645">        impl.playBuiltinSound(soundIdentifier);</span>
<span class="fc" id="L3646">    }</span>

    /**
     * Gets the display safe area as a rectangle.
     *
     * @param rect Out parameter that will store the display safe area.
     * @return The display safe area.
     * @see Form#getSafeArea()
     * @since 7.0
     */
    public Rectangle getDisplaySafeArea(Rectangle rect) {
<span class="fc" id="L3657">        return impl.getDisplaySafeArea(rect);</span>
    }

    /**
     * Installs a replacement sound as the builtin sound responsible for the given
     * sound identifier (this will override the system sound if such a sound exists).
     *
     * @param soundIdentifier the sound string passed to playBuiltinSound
     * @param data            an input stream containing platform specific audio file, its usually safe
     *                        to assume that wav/mp3 would be supported.
     * @throws IOException if the stream throws an exception
     */
    public void installBuiltinSound(String soundIdentifier, InputStream data) throws IOException {
<span class="nc" id="L3670">        impl.installBuiltinSound(soundIdentifier, data);</span>
<span class="nc" id="L3671">    }</span>

    /**
     * Indicates whether a user installed or system sound is available
     *
     * @param soundIdentifier the sound string passed to playBuiltinSound
     * @return true if a sound of this given type is avilable
     * @deprecated this isn't supported on most platforms
     */
    public boolean isBuiltinSoundAvailable(String soundIdentifier) {
<span class="nc" id="L3681">        return impl.isBuiltinSoundAvailable(soundIdentifier);</span>
    }

    /**
     * Allows muting/unmuting the builtin sounds easily
     *
     * @return true if the sound is *not* muted
     */
    public boolean isBuiltinSoundsEnabled() {
<span class="fc" id="L3690">        return impl.isBuiltinSoundsEnabled();</span>
    }

    /**
     * Allows muting/unmuting the builtin sounds easily
     *
     * @param enabled indicates whether the sound is muted
     */
    public void setBuiltinSoundsEnabled(boolean enabled) {
<span class="nc" id="L3699">        impl.setBuiltinSoundsEnabled(enabled);</span>
<span class="nc" id="L3700">    }</span>

    /**
     * Creates a sound in the given URI which is partially platform specific.
     * Notice that an audio is &quot;auto destroyed&quot; on completion and cannot be played
     * twice!
     *
     * @param uri          the platform specific location for the sound
     * @param onCompletion invoked when the audio file finishes playing, may be null
     * @return a handle that can be used to control the playback of the audio
     * @throws java.io.IOException if the URI access fails
     */
    public Media createMedia(String uri, boolean isVideo, Runnable onCompletion) throws IOException {
<span class="fc" id="L3713">        return impl.createMedia(uri, isVideo, onCompletion);</span>
    }

    /**
     * Creates media asynchronously.
     *
     * @param uri          the platform specific location for the sound
     * @param onCompletion invoked when the audio file finishes playing, may be null
     * @return a handle that can be used to control the playback of the audio
     * @since 7.0
     */
    public AsyncResource&lt;Media&gt; createMediaAsync(String uri, boolean video, Runnable onCompletion) {
<span class="fc" id="L3725">        return impl.createMediaAsync(uri, video, onCompletion);</span>
    }

    /**
     * Adds a callback to a Media element that will be called when the media finishes playing.
     *
     * @param media        The media to add the callback to.
     * @param onCompletion The callback that will run on the EDT when the playback completes.
     * @see #removeCompletionHandler(com.codename1.media.Media, java.lang.Runnable)
     */
    public void addCompletionHandler(Media media, Runnable onCompletion) {
<span class="fc" id="L3736">        impl.addCompletionHandler(media, onCompletion);</span>
<span class="fc" id="L3737">    }</span>

    /**
     * Removes onComplete callback from Media element.
     *
     * @param media        The media element.
     * @param onCompletion The callback.
     * @see #addCompletionHandler(com.codename1.media.Media, java.lang.Runnable)
     */
    public void removeCompletionHandler(Media media, Runnable onCompletion) {
<span class="fc" id="L3747">        impl.removeCompletionHandler(media, onCompletion);</span>
<span class="fc" id="L3748">    }</span>

    /**
     * Create the sound in the given stream
     * Notice that an audio is &quot;auto destroyed&quot; on completion and cannot be played
     * twice!
     *
     * @param stream       the stream containing the media data
     * @param mimeType     the type of the data in the stream
     * @param onCompletion invoked when the audio file finishes playing, may be null
     * @return a handle that can be used to control the playback of the audio
     * @throws java.io.IOException if the URI access fails
     */
    public Media createMedia(InputStream stream, String mimeType, Runnable onCompletion) throws IOException {
<span class="fc" id="L3762">        return impl.createMedia(stream, mimeType, onCompletion);</span>
    }

    public AsyncResource&lt;Media&gt; createMediaAsync(InputStream stream, String mimeType, Runnable onCompletion) {
<span class="fc" id="L3766">        return impl.createMediaAsync(stream, mimeType, onCompletion);</span>

    }

    /**
     * Creates a soft/weak reference to an object that allows it to be collected
     * yet caches it. This method is in the porting layer since CLDC only includes
     * weak references while some platforms include nothing at all and some include
     * the superior soft references.
     *
     * @param o object to cache
     * @return a caching object or null  if caching isn't supported
     */
    public Object createSoftWeakRef(Object o) {
<span class="fc" id="L3780">        return impl.createSoftWeakRef(o);</span>
    }

    /**
     * Extracts the hard reference from the soft/weak reference given
     *
     * @param o the reference returned by createSoftWeakRef
     * @return the original object submitted or null
     */
    public Object extractHardRef(Object o) {
<span class="fc" id="L3790">        return impl.extractHardRef(o);</span>
    }

    /**
     * Indicates if the implemenetation has a native underlying theme
     *
     * @return true if the implementation has a native theme available
     */
    public boolean hasNativeTheme() {
<span class="nc" id="L3799">        return impl.hasNativeTheme();</span>
    }

    /**
     * Installs the native theme, this is only applicable if hasNativeTheme() returned true. Notice that this method
     * might replace the DefaultLookAndFeel instance and the default transitions.
     */
    public void installNativeTheme() {
<span class="nc" id="L3807">        impl.installNativeTheme();</span>
<span class="nc" id="L3808">    }</span>

    /**
     * Performs a clipboard copy operation, if the native clipboard is supported by the implementation it would be used
     *
     * @param obj object to copy, while this can be any arbitrary object it is recommended that only Strings or Codename One
     *            image objects be used to copy
     */
    public void copyToClipboard(Object obj) {
<span class="nc" id="L3817">        impl.copyToClipboard(obj);</span>
<span class="nc" id="L3818">    }</span>

    /**
     * Returns the current content of the clipboard
     *
     * @return can be any object or null see copyToClipboard
     */
    public Object getPasteDataFromClipboard() {
<span class="nc" id="L3826">        return impl.getPasteDataFromClipboard();</span>
    }

    /**
     * Returns true if the device is currently in portrait mode
     *
     * @return true if the device is in portrait mode
     */
    public boolean isPortrait() {
<span class="fc" id="L3835">        return impl.isPortrait();</span>
    }

    /**
     * Returns true if the device allows forcing the orientation via code, feature phones do not allow this
     * although some include a jad property allowing for this feature
     *
     * &lt;p&gt;Since version 6.0, orientation lock is supported in Javascript builds in some browsers.  For a full
     * list of browsers the support locking orientation, see the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Screen/lockOrientation&quot;&gt;MDN Lock Orientation docs&lt;/a&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; In Javascript builds, orientation lock is only supported if the app is running in full-screen mode.  If the app is not
     * currently in full-screen mode, then {@link #canForceOrientation() } will return {@literal false} and {@link #lockOrientation(boolean) } will do nothing.&lt;/p&gt;
     *
     * @return true if lockOrientation  would work
     * @see #lockOrientation(boolean)
     * @see #unlockOrientation()
     */
    public boolean canForceOrientation() {
<span class="nc" id="L3853">        return impl.canForceOrientation();</span>
    }

    /**
     * On devices that return true for canForceOrientation() this method can lock the device orientation
     * either to portrait or landscape mode
     *
     * &lt;p&gt;Since version 6.0, orientation lock is supported in Javascript builds in some browsers.  For a full
     * list of browsers the support locking orientation, see the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Screen/lockOrientation&quot;&gt;MDN Lock Orientation docs&lt;/a&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; In Javascript builds, orientation lock is only supported if the app is running in full-screen mode.  If the app is not
     * currently in full-screen mode, then {@link #canForceOrientation() } will return {@literal false} and {@link #lockOrientation(boolean) } will do nothing.&lt;/p&gt;
     *
     * @param portrait true to lock to portrait mode, false to lock to landscape mode
     * @see #unlockOrientation()
     * @see #canForceOrientation()
     */
    public void lockOrientation(boolean portrait) {
<span class="nc" id="L3871">        impl.lockOrientation(portrait);</span>
<span class="nc" id="L3872">    }</span>

    /**
     * This is the reverse method for lock orientation allowing orientation lock to be disabled
     *
     * &lt;p&gt;Since version 6.0, orientation lock is supported in Javascript builds in some browsers.  For a full
     * list of browsers the support locking orientation, see the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Screen/lockOrientation&quot;&gt;MDN Lock Orientation docs&lt;/a&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; In Javascript builds, orientation lock is only supported if the app is running in full-screen mode.  If the app is not
     * currently in full-screen mode, then {@link #canForceOrientation() } will return {@literal false} and {@link #lockOrientation(boolean) } will do nothing.&lt;/p&gt;
     *
     * @see #lockOrientation(boolean)
     * @see #canForceOrientation()
     */
    public void unlockOrientation() {
<span class="nc" id="L3887">        impl.unlockOrientation();</span>
<span class="nc" id="L3888">    }</span>

    /**
     * Indicates whether the device is a tablet, notice that this is often a guess
     *
     * @return true if the device is assumed to be a tablet
     */
    public boolean isTablet() {
<span class="fc" id="L3896">        return impl.isTablet();</span>
    }

    /**
     * Returns true if this is a desktop application
     *
     * @return true if this is a desktop application
     */
    public boolean isDesktop() {
<span class="nc" id="L3905">        return impl.isDesktop();</span>
    }

    /**
     * Returns true if the device has dialing capabilities
     *
     * @return false if it cannot dial
     */
    public boolean canDial() {
<span class="nc" id="L3914">        return impl.canDial();</span>
    }

    /**
     * On most platforms it is quite fast to draw on a mutable image and then render that
     * image, however some platforms have much slower mutable images in comparison to just
     * drawing on the screen. These platforms should return false here and Codename One will try
     * to use less mutable image related optimizations in transitions and other operations.
     *
     * @return true if mutable images are fast on this platform
     */
    public boolean areMutableImagesFast() {
<span class="fc" id="L3926">        return impl.areMutableImagesFast();</span>
    }

    /**
     * This method returns the platform Location Manager used for geofencing. This allows tracking the
     * user location in the background. Usage:
     *
     * &lt;script src=&quot;https://gist.github.com/codenameone/b0fa5280bde905a8f0cd.js&quot;&gt;&lt;/script&gt;
     * &lt;noscript&gt;&lt;pre&gt;{@code public class GeofenceListenerImpl implements GeofenceListener {
     * public void onExit(String id) {
     * System.out.println(&quot;Exited &quot;+id);
     * }
     *
     * public void onEntered(String id) {
     * System.out.println(&quot;Entered &quot;+id);
     * }
     * }
     * Form hi = new Form(&quot;Hi World&quot;);
     * hi.addComponent(new Label(&quot;Hi World&quot;));
     *
     * Location loc = new Location();
     * loc.setLatitude(51.5033630);
     * loc.setLongitude(-0.1276250);
     *
     * Geofence gf = new Geofence(&quot;test&quot;, loc, 100, 100000);
     *
     * LocationManager.getLocationManager().addGeoFencing(GeofenceListenerImpl.class, gf);
     *
     * hi.show();}&lt;/pre&gt;&lt;/noscript&gt;
     *
     * @return LocationManager Object
     */
    public LocationManager getLocationManager() {
<span class="fc" id="L3959">        return impl.getLocationManager();</span>
    }

    /**
     * This method tries to invoke the device native camera to capture images.
     * The method returns immediately and the response will be sent asynchronously
     * to the given ActionListener Object
     * The image is saved as a jpeg to a file on the device.
     * &lt;p&gt;
     * use this in the actionPerformed to retrieve the file path
     * String path = (String) evt.getSource();
     * &lt;p&gt;
     * if evt returns null the image capture was cancelled by the user.
     *
     * @param response a callback Object to retrieve the file path
     * @throws RuntimeException if this feature failed or unsupported on the platform
     */
    public void capturePhoto(ActionListener response) {
<span class="fc" id="L3977">        impl.capturePhoto(response);</span>
<span class="fc" id="L3978">    }</span>

    /**
     * This method tries to invoke the device native hardware to capture audio.
     * The method returns immediately and the response will be sent asynchronously
     * to the given ActionListener Object
     * The audio is saved to a file on the device.
     * &lt;p&gt;
     * use this in the actionPerformed to retrieve the file path
     * String path = (String) evt.getSource();
     *
     * @param response a callback Object to retrieve the file path
     * @throws RuntimeException if this feature failed or unsupported on the platform
     */
    public void captureAudio(ActionListener response) {
<span class="fc" id="L3993">        impl.captureAudio(response);</span>
<span class="fc" id="L3994">    }</span>

    /**
     * This method tries to invoke the device native hardware to capture audio.
     * The method returns immediately and the response will be sent asynchronously
     * to the given ActionListener Object
     * The audio is saved to a file on the device.
     * &lt;p&gt;
     * use this in the actionPerformed to retrieve the file path
     * String path = (String) evt.getSource();
     *
     * @param recordingOptions Audio recording options.
     * @param response         a callback Object to retrieve the file path
     * @throws RuntimeException if this feature failed or unsupported on the platform
     * @since 7.0
     */
    public void captureAudio(MediaRecorderBuilder recordingOptions, ActionListener response) {
<span class="fc" id="L4011">        impl.captureAudio(recordingOptions, response);</span>
<span class="fc" id="L4012">    }</span>

    /**
     * This method tries to invoke the device native camera to capture video.
     * The method returns immediately and the response will be sent asynchronously
     * to the given ActionListener Object
     * The video is saved to a file on the device.
     * &lt;p&gt;
     * use this in the actionPerformed to retrieve the file path
     * String path = (String) evt.getSource();
     *
     * @param response a callback Object to retrieve the file path
     * @throws RuntimeException if this feature failed or unsupported on the platform
     */
    public void captureVideo(ActionListener response) {
<span class="fc" id="L4027">        impl.captureVideo(response);</span>
<span class="fc" id="L4028">    }</span>

    /**
     * Same as {@link #captureVideo(com.codename1.ui.events.ActionListener) }, except that it
     * attempts to impose constraints on the capture.  Constraints include width, height,
     * and max length.  Not all platforms support capture constraints.  Use the {@link VideoCaptureConstraints#isSupported()}
     * to see if a constraint is supported.  If constraints are not supported at all, then this method
     * will fall back to calling {@link #captureVideo(com.codename1.ui.events.ActionListener) }.
     *
     * @param constraints Capture constraints to use.
     * @param response    a callback Object to retrieve the file path
     * @see com.codename1.capture.Capture#captureVideo(com.codename1.capture.VideoCaptureConstraints, com.codename1.ui.events.ActionListener)
     * @since 7.0
     */
    public void captureVideo(VideoCaptureConstraints constraints, ActionListener response) {
<span class="fc" id="L4043">        impl.captureVideo(constraints, response);</span>
<span class="fc" id="L4044">    }</span>

    /**
     * Opens the device image gallery
     * The method returns immediately and the response will be sent asynchronously
     * to the given ActionListener Object
     * &lt;p&gt;
     * use this in the actionPerformed to retrieve the file path
     * String path = (String) evt.getSource();
     *
     * @param response a callback Object to retrieve the file path
     * @throws RuntimeException if this feature failed or unsupported on the platform
     * @deprecated see openGallery instead
     */
    public void openImageGallery(ActionListener response) {
<span class="fc bfc" id="L4059" title="All 2 branches covered.">        if (pluginSupport.firePluginEvent(new OpenGalleryEvent(response, Display.GALLERY_IMAGE)).isConsumed()) {</span>
<span class="fc" id="L4060">            return;</span>
        }
<span class="fc" id="L4062">        impl.openImageGallery(response);</span>
<span class="fc" id="L4063">    }</span>

    /**
     * &lt;p&gt;Opens the device gallery to pick an image or a video.&lt;br&gt;
     * The method returns immediately and the response is sent asynchronously
     * to the given ActionListener Object as the source value of the event (as a String)&lt;/p&gt;
     *
     * &lt;p&gt;E.g. within the callback action performed call you can use this code: {@code String path = (String) evt.getSource();}.&lt;br&gt;
     * A more detailed sample of picking a video file can be seen here:
     * &lt;/p&gt;
     *
     * &lt;script src=&quot;https://gist.github.com/codenameone/fb73f5d47443052f8956.js&quot;&gt;&lt;/script&gt;
     * &lt;img src=&quot;https://www.codenameone.com/img/developer-guide/components-mediaplayer.png&quot; alt=&quot;Media player sample&quot; /&gt;
     *
     * &lt;p&gt;Version 5.0 and higher support multi-selection (i.e. the types {@link #GALLERY_IMAGE_MULTI}, {@link #GALLERY_VIDEO_MULTI}, and {@link #GALLERY_ALL_MULTI}).  When using one of the multiselection
     * types, the {@literal source} of the ActionEvent will be a {@code String[]}, containing the paths of the selected elements, or {@literal null} if the user cancelled the dialog.&lt;/p&gt;
     *
     * &lt;h4&gt;Platform support&lt;/h4&gt;
     * &lt;p&gt;Currently (version 5.0 and higher), all platforms support the types {@link #GALLERY_IMAGE}, {@link #GALLERY_VIDEO}, {@link #GALLERY_ALL}, {@link #GALLERY_IMAGE_MULTI}, {@link #GALLERY_VIDEO_MULTI}, {@link #GALLERY_ALL_MULTI}.  On iOS,
     * multi-selection requires a deployment target of iOS 8.0 or higher, so it is disabled by default.   You can enable multi-selection on iOS, by adding the {@literal ios.enableGalleryMultiselect=true} build hint.  This
     * build hint will be added automatically for you if you run your app in the simulator, and it calls {@literal openGallery()} with one of the multiselect gallery types.&lt;/p&gt;
     *
     * @param response a callback Object to retrieve the file path For multiselection types ({@link #GALLERY_IMAGE_MULTI}, {@link #GALLERY_VIDEO_MULTI}, and {@link #GALLERY_ALL_MULTI}), the {@literal source}
     *                 of the ActionEvent sent this callback will be a {@literal String[]}.  For other types, it will be a {@literal String}.  If the dialog was cancelled, it will be {@literal null}.
     * @param type     one of the following {@link #GALLERY_IMAGE}, {@link #GALLERY_VIDEO}, {@link #GALLERY_ALL}, {@link #GALLERY_IMAGE_MULTI}, {@link #GALLERY_VIDEO_MULTI}, {@link #GALLERY_ALL_MULTI}.
     * @throws RuntimeException if this feature failed or unsupported on the platform.  Use {@link #isGalleryTypeSupported(int) } to check if the type is supported before calling this method.
     * @see #isGalleryTypeSupported(int) To see if a type is supported on the current platform.
     */
    public void openGallery(ActionListener response, int type) {
<span class="fc bfc" id="L4092" title="All 2 branches covered.">        if (pluginSupport.firePluginEvent(new OpenGalleryEvent(response, type)).isConsumed()) {</span>
<span class="fc" id="L4093">            return;</span>
        }

<span class="fc" id="L4096">        impl.openGallery(response, type);</span>
<span class="fc" id="L4097">    }</span>

    /**
     * Checks to see if the given gallery type is supported on the current platform.
     *
     * @param type one of the following {@link #GALLERY_IMAGE}, {@link #GALLERY_VIDEO}, {@link #GALLERY_ALL}, {@link #GALLERY_IMAGE_MULTI}, {@link #GALLERY_VIDEO_MULTI}, {@link #GALLERY_ALL_MULTI}.
     * @return True if the type is supported
     * @see #openGallery(com.codename1.ui.events.ActionListener, int)
     */
    public boolean isGalleryTypeSupported(int type) {
<span class="fc" id="L4107">        IsGalleryTypeSupportedEvent evt = new IsGalleryTypeSupportedEvent(type);</span>
<span class="fc bfc" id="L4108" title="All 2 branches covered.">        if (pluginSupport.firePluginEvent(evt).isConsumed()) {</span>
<span class="fc" id="L4109">            return evt.getPluginEventResponse();</span>
        }
<span class="fc" id="L4111">        return impl.isGalleryTypeSupported(type);</span>
    }

    /**
     * Returns a 2-3 letter code representing the platform name for the platform override
     *
     * @return the name of the platform e.g. ios, rim, win, and, me, HTML5
     */
    public String getPlatformName() {
<span class="fc" id="L4120">        return impl.getPlatformName();</span>
    }

    /**
     * Returns the suffixes for ovr files that should be used when loading a layered resource file on this platform
     *
     * @return a string array with the proper order of resource override layers
     */
    public String[] getPlatformOverrides() {
<span class="nc" id="L4129">        return impl.getPlatformOverrides();</span>
    }

    /**
     * &lt;p&gt;Send an email using the platform mail client.&lt;br&gt;
     * The code below demonstrates sending a simple message with attachments using the devices
     * native email client:
     * &lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/codenameone/3db47a2ff8b35cae6410.js&quot;&gt;&lt;/script&gt;
     *
     * @param recipients array of e-mail addresses
     * @param subject    e-mail subject
     * @param msg        the Message to send
     */
    public void sendMessage(String[] recipients, String subject, Message msg) {
<span class="fc" id="L4144">        impl.sendMessage(recipients, subject, msg);</span>
<span class="fc" id="L4145">    }</span>

    /**
     * Opens the device Dialer application with the given phone number
     *
     * @param phoneNumber
     */
    public void dial(String phoneNumber) {
<span class="nc" id="L4153">        impl.dial(phoneNumber);</span>
<span class="nc" id="L4154">    }</span>

    /**
     * &lt;p&gt;Indicates the level of SMS support in the platform as one of:
     * {@link #SMS_NOT_SUPPORTED} (for desktop, tablet etc.),
     * {@link #SMS_SEAMLESS} (no UI interaction), {@link #SMS_INTERACTIVE} (with compose UI),
     * {@link #SMS_BOTH}.&lt;br&gt;
     * The sample below demonstrates the use case for this property:
     * &lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/codenameone/da23d33b1a9e105efffd.js&quot;&gt;&lt;/script&gt;
     *
     * @return one of the SMS_* values
     */
    public int getSMSSupport() {
<span class="nc" id="L4168">        return impl.getSMSSupport();</span>
    }

    /**
     * Sends a SMS message to the given phone number
     *
     * @param phoneNumber to send the sms
     * @param message     the content of the sms
     */
    public void sendSMS(String phoneNumber, String message) throws IOException {
<span class="nc" id="L4178">        impl.sendSMS(phoneNumber, message, false);</span>
<span class="nc" id="L4179">    }</span>

    /**
     * &lt;p&gt;Sends a SMS message to the given phone number, the code below demonstrates the logic
     * of detecting platform behavior for sending SMS.&lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/codenameone/da23d33b1a9e105efffd.js&quot;&gt;&lt;/script&gt;
     *
     * @param phoneNumber to send the sms
     * @param message     the content of the sms
     * @param interactive indicates the SMS should show a UI or should not show a UI if applicable see getSMSSupport
     * @see #getSMSSupport()
     */
    public void sendSMS(String phoneNumber, String message, boolean interactive) throws IOException {
<span class="nc" id="L4192">        impl.sendSMS(phoneNumber, message, interactive);</span>
<span class="nc" id="L4193">    }</span>

    /**
     * Place a notification on the device status bar (if device has this
     * functionality).
     * Clicking the notification might re-start the Application.
     *
     * @param tickerText   the ticker text of the Notification
     * @param contentTitle the title of the Notification
     * @param contentBody  the content of the Notification
     * @param vibrate      enable/disable notification alert
     * @param flashLights  enable/disable notification flashing
     * @deprecated there is a new version of this method with a slightly improved
     * signature
     */
    public void notifyStatusBar(String tickerText, String contentTitle,
                                String contentBody, boolean vibrate, boolean flashLights) {
<span class="nc" id="L4210">        notifyStatusBar(tickerText, contentTitle, contentBody, vibrate, flashLights, null);</span>
<span class="nc" id="L4211">    }</span>

    /**
     * Indicates whether the notify status bar method will present a notification to the user
     *
     * @return true if the notify status bar method will present a notification to the user
     */
    public boolean isNotificationSupported() {
<span class="nc" id="L4219">        return impl.isNotificationSupported();</span>
    }

    /**
     * Place a notification on the device status bar (if device has this
     * functionality).
     * Clicking the notification might re-start the Application.
     *
     * @param tickerText   the ticker text of the Notification
     * @param contentTitle the title of the Notification
     * @param contentBody  the content of the Notification
     * @param vibrate      enable/disable notification alert
     * @param flashLights  enable/disable notification flashing
     * @param args         additional arguments to the notification
     * @return a platform native object that allows modifying notification state
     * @deprecated use scheduleLocalNotification instead
     */
    public Object notifyStatusBar(String tickerText, String contentTitle,
                                  String contentBody, boolean vibrate, boolean flashLights, Hashtable args) {
<span class="nc" id="L4238">        return impl.notifyStatusBar(tickerText, contentTitle, contentBody, vibrate, flashLights, args);</span>
    }

    /**
     * Removes the notification previously posted with the notify status bar method
     *
     * @param o the object returned from the notifyStatusBar method
     */
    public void dismissNotification(Object o) {
<span class="nc" id="L4247">        impl.dismissNotification(o);</span>
<span class="nc" id="L4248">    }</span>

    /**
     * Returns true if the underlying OS supports numeric badges on icons. Notice this is only available on iOS
     * and only when push notification is enabled
     *
     * @return true if the underlying OS supports numeric badges
     */
    public boolean isBadgingSupported() {
<span class="nc" id="L4257">        return impl.isBadgingSupported();</span>
    }

    /**
     * Sets the number that appears on the application icon in iOS
     *
     * @param number number to show on the icon
     */
    public void setBadgeNumber(int number) {
<span class="nc" id="L4266">        impl.setBadgeNumber(number);</span>
<span class="nc" id="L4267">    }</span>

    /**
     * Returns true if the underlying OS supports opening the native navigation
     * application
     *
     * @return true if the underlying OS supports launch of native navigation app
     */
    public boolean isOpenNativeNavigationAppSupported() {
<span class="nc" id="L4276">        return impl.isOpenNativeNavigationAppSupported();</span>
    }

    /**
     * Opens the native navigation app in the given coordinate.
     *
     * @param latitude
     * @param longitude
     */
    public void openNativeNavigationApp(double latitude, double longitude) {
<span class="nc" id="L4286">        impl.openNativeNavigationApp(latitude, longitude);</span>
<span class="nc" id="L4287">    }</span>

    /**
     * Opens the native navigation app with the given search location
     *
     * @param location the location to search for in the native navigation map
     */
    public void openNativeNavigationApp(String location) {
<span class="nc" id="L4295">        impl.openNativeNavigationApp(location);</span>
<span class="nc" id="L4296">    }</span>

    /**
     * Gets all contacts from the address book of the device
     *
     * @param withNumbers if true returns only contacts that has a number
     * @return array of contacts unique ids
     */
    public String[] getAllContacts(boolean withNumbers) {
<span class="fc" id="L4305">        return impl.getAllContacts(withNumbers);</span>
    }

    /**
     * &lt;p&gt;Notice: this method might be very slow and should be invoked on a separate thread!
     * It might have platform specific optimizations over getAllContacts followed by looping
     * over individual contacts but that isn't guaranteed. See isGetAllContactsFast for
     * information.&lt;br&gt;
     * The sample below demonstrates listing all the contacts within the device with their photos&lt;/p&gt;
     *
     * &lt;script src=&quot;https://gist.github.com/codenameone/15f39e1eef77f6059aff.js&quot;&gt;&lt;/script&gt;
     * &lt;img src=&quot;https://www.codenameone.com/img/developer-guide/contacts-with-photos.png&quot; alt=&quot;Contacts with the default photos on the simulator, on device these will use actual user photos when available&quot; /&gt;
     *
     * @param withNumbers      if true returns only contacts that has a number
     * @param includesFullName if true try to fetch the full name of the Contact(not just display name)
     * @param includesPicture  if true try to fetch the Contact Picture if exists
     * @param includesNumbers  if true try to fetch all Contact numbers
     * @param includesEmail    if true try to fetch all Contact Emails
     * @param includeAddress   if true try to fetch all Contact Addresses
     * @return array of the contacts
     */
    public Contact[] getAllContacts(boolean withNumbers, boolean includesFullName, boolean includesPicture, boolean includesNumbers, boolean includesEmail, boolean includeAddress) {
<span class="fc" id="L4327">        return impl.getAllContacts(withNumbers, includesFullName, includesPicture, includesNumbers, includesEmail, includeAddress);</span>
    }

    /**
     * Indicates if the getAllContacts is platform optimized, notice that the method
     * might still take seconds or more to run so you should still use a separate thread!
     *
     * @return true if getAllContacts will perform faster that just getting each contact
     */
    public boolean isGetAllContactsFast() {
<span class="fc" id="L4337">        return impl.isGetAllContactsFast();</span>
    }

    /**
     * Gets IDs of all contacts that are linked to a given contact.  Some platforms, like iOS, allow for multiple distinct contact records to be &quot;linked&quot; to indicate that they refer to the same person.
     *
     * @param c The contact whose &quot;linked&quot; contacts are to be retrieved.
     * @return IDs of linked contacts.
     */
    public String[] getLinkedContactIds(Contact c) {
<span class="nc" id="L4347">        return impl.getLinkedContactIds(c);</span>
    }

    /**
     * Get a Contact according to it's contact id.
     *
     * @param id unique id of the Contact
     * @return a Contact Object
     */
    public Contact getContactById(String id) {
<span class="fc" id="L4357">        return impl.getContactById(id);</span>
    }

    /**
     * Gets all of the contacts that are linked to this contact.  Some platforms, like iOS, allow for multiple distinct contact records to be &quot;linked&quot; to indicate that they refer to the same person.
     * @param c The contact whose &quot;linked&quot; contacts are to be retrieved.
     * @return Array of Contacts.  Should never be null, but may be a zero-sized array.
     * @see ContactsManager#getLinkedContacts(com.codename1.contacts.Contact)
     */
    //public Contact[] getLinkedContacts(Contact c) {
    //    return impl.getLinkedContacts(c);
    //}

    /**
     * &lt;p&gt;This method returns a Contact by the contact id and fills it's data
     * according to the given flags.&lt;br&gt;
     * The sample below demonstrates listing all the contacts within the device with their photos&lt;/p&gt;
     *
     * &lt;script src=&quot;https://gist.github.com/codenameone/15f39e1eef77f6059aff.js&quot;&gt;&lt;/script&gt;
     * &lt;img src=&quot;https://www.codenameone.com/img/developer-guide/contacts-with-photos.png&quot; alt=&quot;Contacts with the default photos on the simulator, on device these will use actual user photos when available&quot; /&gt;
     *
     * @param id               of the Contact
     * @param includesFullName if true try to fetch the full name of the Contact(not just display name)
     * @param includesPicture  if true try to fetch the Contact Picture if exists
     * @param includesNumbers  if true try to fetch all Contact numbers
     * @param includesEmail    if true try to fetch all Contact Emails
     * @param includeAddress   if true try to fetch all Contact Addresses
     * @return a Contact Object
     */
    public Contact getContactById(String id, boolean includesFullName,
                                  boolean includesPicture, boolean includesNumbers, boolean includesEmail,
                                  boolean includeAddress) {
<span class="fc" id="L4389">        return impl.getContactById(id, includesFullName, includesPicture,</span>
                includesNumbers, includesEmail, includeAddress);
    }

    /**
     * Some platforms allow the user to block contacts access on a per application basis this method
     * returns true if the user denied permission to access contacts. This can allow you to customize the error
     * message presented to the user.
     *
     * @return true if contacts access is allowed or globally available, false otherwise
     */
    public boolean isContactsPermissionGranted() {
<span class="nc" id="L4401">        return impl.isContactsPermissionGranted();</span>
    }

    /**
     * Create a contact to the device contacts book
     *
     * @param firstName   the Contact firstName
     * @param familyName  the Contact familyName
     * @param officePhone the Contact work phone or null
     * @param homePhone   the Contact home phone or null
     * @param cellPhone   the Contact mobile phone or null
     * @param email       the Contact email or null
     * @return the contact id if creation succeeded or null  if failed
     */
    public String createContact(String firstName, String familyName, String officePhone, String homePhone, String cellPhone, String email) {
<span class="fc" id="L4416">        return impl.createContact(firstName, familyName, officePhone, homePhone, cellPhone, email);</span>
    }

    /**
     * removed a contact from the device contacts book
     *
     * @param id the contact id to remove
     * @return true if deletion succeeded false otherwise
     */
    public boolean deleteContact(String id) {
<span class="fc" id="L4426">        return impl.deleteContact(id);</span>
    }

    /**
     * Indicates if the native video player includes its own play/pause etc. controls so the movie player
     * component doesn't need to include them
     *
     * @return true if the movie player component doesn't need to include such controls
     */
    public boolean isNativeVideoPlayerControlsIncluded() {
<span class="nc" id="L4436">        return impl.isNativeVideoPlayerControlsIncluded();</span>
    }

    /**
     * Indicates if the underlying platform supports sharing capabilities
     *
     * @return true if the underlying platform handles share.
     */
    public boolean isNativeShareSupported() {
<span class="nc" id="L4445">        return impl.isNativeShareSupported();</span>
    }

    /**
     * Share the required information using the platform sharing services.
     * a Sharing service can be: mail, sms, facebook, twitter,...
     * This method is implemented if isNativeShareSupported() returned true for
     * a specific platform.
     *
     * &lt;p&gt;Since 6.0, there is native sharing support in the Javascript port using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share&quot;&gt;navigator.share&lt;/a&gt;
     * API.  Currently (2019) this is only supported on Chrome for Android, and will only work if the app is accessed over https:.&lt;/p&gt;
     *
     * @param toShare String to share.
     * @deprecated use the method share that accepts an image and mime type
     */
    public void share(String toShare) {
<span class="nc" id="L4461">        share(toShare, null, null);</span>
<span class="nc" id="L4462">    }</span>

    /**
     * Share the required information using the platform sharing services.
     * a Sharing service can be: mail, sms, facebook, twitter,...
     * This method is implemented if isNativeShareSupported() returned true for
     * a specific platform.
     *
     * &lt;p&gt;Since 6.0, there is native sharing support in the Javascript port using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share&quot;&gt;navigator.share&lt;/a&gt;
     * API.  Currently (2019) this is only supported on Chrome for Android, and will only work if the app is accessed over https:.&lt;/p&gt;
     *
     * @param text     String to share.
     * @param image    file path to the image or null
     * @param mimeType type of the image or null if no image to share
     */
    public void share(String text, String image, String mimeType) {
<span class="nc" id="L4478">        share(text, image, mimeType, null);</span>

<span class="nc" id="L4480">    }</span>

    /**
     * Share the required information using the platform sharing services.
     * a Sharing service can be: mail, sms, facebook, twitter,...
     * This method is implemented if isNativeShareSupported() returned true for
     * a specific platform.
     *
     * &lt;p&gt;Since 6.0, there is native sharing support in the Javascript port using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share&quot;&gt;navigator.share&lt;/a&gt;
     * API.  Currently (2019) this is only supported on Chrome for Android, and will only work if the app is accessed over https:.&lt;/p&gt;
     *
     * &lt;p&gt;Since 8.0, you can share files using using the file path in the text parameter.  The file must exist in file system storage, and
     * you must define the appropriate mimeType in the mimeType parameter.  E.g. {@code share(&quot;file:/.../myfile.pdf&quot;, null, &quot;application.pdf&quot;) }&lt;/p&gt;
     *
     * @param textOrPath String to share, or path to file to share.
     * @param image      file path to the image or null
     * @param mimeType   type of the image or file.  null if just sharing text
     * @param sourceRect The source rectangle of the button that originated the share request.  This is used on
     *                   some platforms to provide a hint as to where the share dialog overlay should pop up.  Particularly,
     *                   on the iPad with iOS 8 and higher.
     */
    public void share(String textOrPath, String image, String mimeType, Rectangle sourceRect) {
<span class="nc" id="L4502">        impl.share(textOrPath, image, mimeType, sourceRect);</span>
<span class="nc" id="L4503">    }</span>

    /**
     * &lt;p&gt;The localization manager allows adapting values for display in different locales thru parsing and formatting
     * capabilities (similar to JavaSE's DateFormat/NumberFormat). It also includes language/locale/currency
     * related API's similar to Locale/currency API's from JavaSE.&lt;br&gt;
     * The sample code below just lists the various capabilities of the API:&lt;/p&gt;
     *
     * &lt;script src=&quot;https://gist.github.com/codenameone/6d93edd5e6b69e7c088a.js&quot;&gt;&lt;/script&gt;
     * &lt;img src=&quot;https://www.codenameone.com/img/developer-guide/l10n-manager.png&quot; alt=&quot;Localization formatting/parsing and information&quot; /&gt;
     *
     * @return an instance of the localization manager
     */
    public L10NManager getLocalizationManager() {
<span class="fc" id="L4517">        return impl.getLocalizationManager();</span>
    }

    /**
     * User register to receive push notification
     *
     * @param id         the id for the user
     * @param noFallback some devices don't support an efficient push API and will resort to polling
     *                   to provide push like functionality. If this flag is set to true no polling will occur and
     *                   the error PushCallback.REGISTRATION_ERROR_SERVICE_NOT_AVAILABLE will be sent to the push interface.
     * @deprecated use {@link #registerPush()} the Android push id should be set with the build hint {@code gcm.sender_id} which will work for Chrome JavaScript builds too
     */
    public void registerPush(String id, boolean noFallback) {
<span class="nc" id="L4530">        Hashtable h = new Hashtable();</span>
<span class="nc" id="L4531">        h.put(&quot;googlePlay&quot;, id);</span>
<span class="nc" id="L4532">        registerPush(h, noFallback);</span>
<span class="nc" id="L4533">    }</span>

    /**
     * Register to receive push notification, invoke this method once (ever) to receive push
     * notifications.
     *
     * @param metaData   meta data for push, this is relevant on some platforms such as google where
     *                   a push id is necessary,
     * @param noFallback some devices don't support an efficient push API and will resort to polling
     *                   to provide push like functionality. If this flag is set to true no polling will occur and
     *                   the error PushCallback.REGISTRATION_ERROR_SERVICE_NOT_AVAILABLE will be sent to the push interface.
     * @deprecated use {@link #registerPush()} the Android push id should be set with the build hint {@code gcm.sender_id} which will work for Chrome JavaScript builds too
     */
    public void registerPush(Hashtable metaData, boolean noFallback) {
<span class="nc bnc" id="L4547" title="All 2 branches missed.">        if (Preferences.get(&quot;push_id&quot;, (long) -1) == -1) {</span>
<span class="nc" id="L4548">            impl.registerPush(metaData, noFallback);</span>
        }
<span class="nc" id="L4550">    }</span>

    /**
     * Register to receive push notification, invoke this method once (ever) to receive push
     * notifications.
     */
    public void registerPush() {
<span class="nc" id="L4557">        impl.registerPush(new Hashtable(), false);</span>
<span class="nc" id="L4558">    }</span>

    /**
     * Stop receiving push notifications to this client application
     */
    public void deregisterPush() {
<span class="nc" id="L4564">        impl.deregisterPush();</span>
<span class="nc" id="L4565">    }</span>

    /**
     * Creates a Media recorder Object which will record from the device mic to
     * a file in the given path.
     * The output format will be amr-nb if supported by the platform.
     *
     * @param path a file path to where to store the recording, if the file does
     *             not exists it will be created.
     * @deprecated
     */
    public Media createMediaRecorder(String path) throws IOException {
<span class="nc" id="L4577">        return createMediaRecorder(path, getAvailableRecordingMimeTypes()[0]);</span>
    }

    /**
     * @param builder A MediaRecorderBuilder
     * @return a MediaRecorder
     * @throws IOException
     * @see MediaRecorderBuilder#build()
     * @since 7.0
     * @deprecated use MediaRecorderBuilder#build()
     */
    public Media createMediaRecorder(MediaRecorderBuilder builder) throws IOException {
<span class="fc" id="L4589">        return impl.createMediaRecorder(builder);</span>
    }

    /**
     * Creates a Media recorder Object which will record from the device mic to
     * a file in the given path.
     *
     * @param path     a file path to where to store the recording, if the file does
     *                 not exists it will be created.
     * @param mimeType the output mime type that is supported see
     *                 getAvailableRecordingMimeTypes()
     */
    public Media createMediaRecorder(String path, String mimeType) throws IOException {
<span class="fc" id="L4602">        return impl.createMediaRecorder(path, mimeType);</span>
    }

    /**
     * Returns the image IO instance that allows scaling image files.
     *
     * @return the image IO instance or null if image IO isn't supported for the given platform
     */
    public ImageIO getImageIO() {
<span class="fc" id="L4611">        return impl.getImageIO();</span>
    }

    /**
     * Gets the recording mime type for the returned Media from the
     * createMediaRecorder method
     *
     * @return the recording mime type
     * @deprecated see getAvailableRecordingMimeTypes() instead
     */
    public String getMediaRecorderingMimeType() {
<span class="nc" id="L4622">        return impl.getAvailableRecordingMimeTypes()[0];</span>
    }

    /**
     * Opens a database or create one if not exists.  On platforms where {@link #isDatabaseCustomPathSupported() }
     * this method can optionally accept a file path.
     *
     * @param databaseName the name of the database
     * @return Database Object or null if not supported on the platform
     * @throws IOException if database cannot be created
     */
    public Database openOrCreate(String databaseName) throws IOException {
<span class="fc" id="L4634">        return impl.openOrCreateDB(databaseName);</span>
    }

    public boolean isDatabaseCustomPathSupported() {
<span class="fc" id="L4638">        return impl.isDatabaseCustomPathSupported();</span>
    }

    /**
     * Deletes database
     *
     * @param databaseName the name of the database
     * @throws IOException if database cannot be deleted
     */
    public void delete(String databaseName) throws IOException {
<span class="fc" id="L4648">        impl.deleteDB(databaseName);</span>
<span class="fc" id="L4649">    }</span>

    /**
     * Indicates weather a database exists
     *
     * @param databaseName the name of the database
     * @return true if database exists
     */
    public boolean exists(String databaseName) {
<span class="fc" id="L4658">        return impl.existsDB(databaseName);</span>
    }

    /**
     * Returns the file path of the Database if support for database exists
     * on the platform.
     *
     * @param databaseName the name of the database with out / or path
     *                     elements e.g. {@code mydatabase.db}
     * @return the file path of the database or null if database isn't supported
     */
    public String getDatabasePath(String databaseName) {
<span class="fc" id="L4670">        return impl.getDatabasePath(databaseName);</span>
    }

    /**
     * Sets the frequency for polling the server in case of polling based push notification
     *
     * @param freq the frequency in milliseconds
     */
    public void setPollingFrequency(int freq) {
<span class="nc" id="L4679">        impl.setPollingFrequency(freq);</span>
<span class="nc" id="L4680">    }</span>

    /**
     * Start a Codename One thread that supports crash protection and similar Codename One features.
     *
     * @param r    runnable to run, &lt;b&gt;NOTICE&lt;/b&gt; the thread MUST be explicitly started!
     * @param name the name for the thread
     * @return a thread instance which must be explicitly started!
     */
    public Thread createThread(Runnable r, String name) {
<span class="nc" id="L4690">        return new CodenameOneThread(r, name);</span>
    }

    /**
     * Start a Codename One thread that supports crash protection and similar Codename One features.
     *
     * @param r    runnable to run, &lt;b&gt;NOTICE&lt;/b&gt; the thread MUST be explicitly started!
     * @param name the name for the thread
     * @return a thread instance which must be explicitly started!
     * @deprecated confusing name use {@link #createThread(java.lang.Runnable, java.lang.String)} instead
     */
    public Thread startThread(Runnable r, String name) {
<span class="fc" id="L4702">        return new CodenameOneThread(r, name);</span>
    }

    /**
     * Indicates if the title of the Form is native title(in android ICS devices
     * if the command behavior is native the ActionBar is used to display the title
     * and the menu)
     *
     * @return true if platform would like to show the Form title
     */
    public boolean isNativeTitle() {
<span class="fc" id="L4713">        return impl.isNativeTitle();</span>
    }

    /**
     * if the title is native(e.g the android action bar), notify the native title
     * that is needs to be refreshed
     */
    public void refreshNativeTitle() {
<span class="nc" id="L4721">        impl.refreshNativeTitle();</span>
<span class="nc" id="L4722">    }</span>

    /**
     * The crash reporter gets invoked when an uncaught exception is intercepted
     *
     * @return the crashReporter
     */
    public CrashReport getCrashReporter() {
<span class="fc" id="L4730">        return crashReporter;</span>
    }

    /**
     * The crash reporter gets invoked when an uncaught exception is intercepted
     *
     * @param crashReporter the crashReporter to set
     */
    public void setCrashReporter(CrashReport crashReporter) {
<span class="fc" id="L4739">        this.crashReporter = crashReporter;</span>
<span class="fc" id="L4740">    }</span>

    /**
     * Returns the UDID for devices that support it
     *
     * @return the UDID or null
     */
    public String getUdid() {
<span class="nc" id="L4748">        return impl.getUdid();</span>
    }

    /**
     * Returns the MSISDN for devices that expose it
     *
     * @return the msisdn or null
     */
    public String getMsisdn() {
<span class="nc" id="L4757">        return impl.getMsisdn();</span>
    }

    /**
     * Returns the native OS purchase implementation if applicable, if unavailable this
     * method will try to fallback to a custom purchase implementation and failing that
     * will return null
     *
     * @return instance of the purchase class or null
     */
    public Purchase getInAppPurchase() {
<span class="fc" id="L4768">        return impl.getInAppPurchase();</span>
    }

    /**
     * @deprecated use the version that accepts no arguments, the physical goods purchase is always
     * manual payment if applicable
     */
    public Purchase getInAppPurchase(boolean d) {
<span class="nc" id="L4776">        return getInAppPurchase();</span>
    }

    /**
     * Returns the native implementation of the code scanner or null
     *
     * @return code scanner instance
     * @deprecated Use the cn1-codescanner cn1lib.
     */
    public CodeScanner getCodeScanner() {
<span class="nc bnc" id="L4786" title="All 2 branches missed.">        if (!hasCamera()) {</span>
<span class="nc" id="L4787">            return null;</span>
        }
<span class="nc" id="L4789">        return impl.getCodeScanner();</span>
    }

    /**
     * Gets the available recording MimeTypes
     */
    public String[] getAvailableRecordingMimeTypes() {
<span class="fc" id="L4796">        return impl.getAvailableRecordingMimeTypes();</span>
    }

    /**
     * Checks if the device supports disabling the screen display from dimming, allowing
     * the developer to keep the screen display on.
     */
    public boolean isScreenSaverDisableSupported() {
<span class="nc" id="L4804">        return impl.isScreenLockSupported();</span>
    }

    /**
     * Checks is the scroll-wheel mouse is currently scrolling.  The scroll-wheel simulates pointer presses and drags
     * so there are cases when you are processing pointer events when you may want to know if it was driggered by
     * a scroll wheel.
     *
     * @return True if the scroll-wheel is responsible for current pointer events.
     * @since 8.0
     */
    public boolean isScrollWheeling() {
<span class="nc" id="L4816">        return impl.isScrollWheeling();</span>
    }

    /**
     * If isScreenSaverDisableSupported() returns true calling this method will
     * lock the screen display on
     *
     * @param e when set to true the screen saver will work as usual and when set to false the screen
     *          will not turn off automatically
     */
    public void setScreenSaverEnabled(boolean e) {
<span class="nc bnc" id="L4827" title="All 2 branches missed.">        if (e) {</span>
<span class="nc" id="L4828">            impl.unlockScreen();</span>
        } else {
<span class="nc" id="L4830">            impl.lockScreen();</span>
        }
<span class="nc" id="L4832">    }</span>

    /**
     * Returns true if the device has camera false otherwise.
     */
    public boolean hasCamera() {
<span class="nc" id="L4838">        return impl.hasCamera();</span>
    }

    /**
     * Indicates whether the native picker dialog is supported for the given type
     * which can include one of PICKER_TYPE_DATE_AND_TIME, PICKER_TYPE_TIME, PICKER_TYPE_DATE
     *
     * @param pickerType the picker type constant
     * @return true if the native platform supports this picker type
     */
    public boolean isNativePickerTypeSupported(int pickerType) {
<span class="fc" id="L4849">        return impl.isNativePickerTypeSupported(pickerType);</span>
    }

    /**
     * Shows a native modal dialog allowing us to perform the picking for the given type
     * which can include one of PICKER_TYPE_DATE_AND_TIME, PICKER_TYPE_TIME, PICKER_TYPE_DATE
     *
     * @param type         the picker type constant
     * @param source       the source component (optional) the native dialog will be placed in relation to this
     *                     component if applicable
     * @param currentValue the currently selected value
     * @param data         additional meta data specific to the picker type when applicable
     * @return the value from the picker or null if the operation was canceled.
     */
    public Object showNativePicker(int type, Component source, Object currentValue, Object data) {
<span class="nc" id="L4864">        return impl.showNativePicker(type, source, currentValue, data);</span>
    }

    /**
     * When set to true Codename One allows multiple hardware keys to be pressed at once,
     * this isn't on by default since it can trigger some complexities with UI navigation to/from
     * native code
     *
     * @return the multiKeyMode
     */
    public boolean isMultiKeyMode() {
<span class="nc" id="L4875">        return multiKeyMode;</span>
    }

    /**
     * When set to true Codename One allows multiple hardware keys to be pressed at once,
     * this isn't on by default since it can trigger some complexities with UI navigation to/from
     * native code
     *
     * @param multiKeyMode the multiKeyMode to set
     */
    public void setMultiKeyMode(boolean multiKeyMode) {
<span class="nc" id="L4886">        this.multiKeyMode = multiKeyMode;</span>
<span class="nc" id="L4887">    }</span>

    /**
     * Long pointer press is invoked after the given interval, this allows making long press events shorter/longer
     *
     * @return time in milliseconds
     */
    public int getLongPointerPressInterval() {
<span class="nc" id="L4895">        return longPressInterval;</span>
    }

    /**
     * Long pointer press is invoked after the given interval, this allows making long press events shorter/longer
     *
     * @param v time in milliseconds
     */
    public void setLongPointerPressInterval(int v) {
<span class="nc" id="L4904">        longPressInterval = v;</span>
<span class="nc" id="L4905">    }</span>

    /**
     * &lt;p&gt;Schedules a local notification that will occur after the given time elapsed.&lt;br&gt;
     * The sample below combines this with the geofence API to show a local notification
     * when entering a radius with the app in the background:&lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/shannah/a5592313da97e085822120af16518874.js&quot;&gt;&lt;/script&gt;
     *
     * @param n         The notification to schedule.
     * @param firstTime time in milliseconds when to schedule the notification
     * @param repeat    repeat one of the following: REPEAT_NONE, REPEAT_FIFTEEN_MINUTES,
     *                  REPEAT_HALF_HOUR, REPEAT_HOUR, REPEAT_DAY, REPEAT_WEEK
     */
    public void scheduleLocalNotification(LocalNotification n, long firstTime, int repeat) {
<span class="pc bpc" id="L4919" title="2 of 4 branches missed.">        if (n.getId() == null || n.getId().length() == 0) {</span>
<span class="nc" id="L4920">            throw new IllegalArgumentException(&quot;Notification ID must be set&quot;);</span>
        }
<span class="pc bpc" id="L4922" title="1 of 2 branches missed.">        if (firstTime &lt; System.currentTimeMillis()) {</span>
<span class="nc" id="L4923">            throw new IllegalArgumentException(&quot;Cannot schedule a notification to a past time&quot;);</span>
        }
<span class="pc bpc" id="L4925" title="2 of 6 branches missed.">        if (n.getAlertSound() != null &amp;&amp; n.getAlertSound().length() &gt; 0 &amp;&amp; !n.getAlertSound().startsWith(&quot;/notification_sound&quot;)) {</span>
<span class="nc" id="L4926">            throw new IllegalArgumentException(&quot;Alert sound file name must start with the 'notification_sound' prefix&quot;);</span>
        }
<span class="fc" id="L4928">        impl.scheduleLocalNotification(n, firstTime, repeat);</span>
<span class="fc" id="L4929">    }</span>

    /**
     * Cancels a local notification by ID.
     *
     * @param notificationId
     * @see com.codename1.notifications.LocalNotification
     */
    public void cancelLocalNotification(String notificationId) {
<span class="fc" id="L4938">        impl.cancelLocalNotification(notificationId);</span>
<span class="fc" id="L4939">    }</span>

    /**
     * Sets the preferred time interval between background fetches.  This is only a
     * preferred interval and is not guaranteed.  Some platforms, like iOS, maintain sovereign
     * control over when and if background fetches will be allowed. This number is used
     * only as a guideline.
     *
     * &lt;p&gt;&lt;strong&gt;This method must be called in order to activate background fetch.&lt;/strong&gt;&gt;&lt;/p&gt;
     * &lt;p&gt;Note: If the platform doesn't support background fetch (i.e. {@link #isBackgroundFetchSupported() } returns {@code false},
     * then this method does nothing.&lt;/p&gt;
     *
     * @param seconds The time interval in seconds.
     * @see #isBackgroundFetchSupported()
     * @see #getPreferredBackgroundFetchInterval(int) ()
     * @see com.codename1.background.BackgroundFetch
     */
    public void setPreferredBackgroundFetchInterval(int seconds) {
<span class="nc" id="L4957">        impl.setPreferredBackgroundFetchInterval(seconds);</span>
<span class="nc" id="L4958">    }</span>

    /**
     * Gets the preferred time (in seconds) between background fetches.
     *
     * @return The time interval in seconds.
     * @see #isBackgroundFetchSupported()
     * @see #setPreferredBackgroundFetchInterval(int)
     * @see com.codename1.background.BackgroundFetch
     */
    public int getPreferredBackgroundFetchInterval(int seconds) {
<span class="nc" id="L4969">        return impl.getPreferredBackgroundFetchInterval();</span>
    }

    /**
     * Checks to see if the current platform supports background fetch.
     *
     * @return True if the current platform supports background fetch.
     * @see #setPreferredBackgroundFetchInterval(int)
     * @see #getPreferredBackgroundFetchInterval(int) ()
     * @see com.codename1.background.BackgroundFetch
     */
    public boolean isBackgroundFetchSupported() {
<span class="nc" id="L4981">        return impl.isBackgroundFetchSupported();</span>
    }

    /**
     * Allows detecting development mode so debugging code and special cases can be used to simplify flow
     *
     * @return true if we are running in the simulator, false otherwise
     */
    public boolean isSimulator() {
<span class="fc" id="L4990">        return impl.isSimulator();</span>
    }

    /**
     * Creates an audio media that can be played in the background.
     *
     * @param uri the uri of the media can start with jar://, file://, http://
     *            (can also use rtsp:// if supported on the platform)
     * @return Media a Media Object that can be used to control the playback
     * of the media or null if background playing is not supported on the platform
     * @throws IOException if creation of media from the given URI has failed
     */
    public Media createBackgroundMedia(String uri) throws IOException {
<span class="fc" id="L5003">        return impl.createBackgroundMedia(uri);</span>
    }

    /**
     * Creates an audio media that can be played in the background.  This call is
     * asynchronous, so that it will return perhaps before the media object is ready.
     *
     * @param uri the uri of the media can start with jar://, file://, http://
     *            (can also use rtsp:// if supported on the platform)
     * @return Media a Media Object that can be used to control the playback
     * of the media or null if background playing is not supported on the platform
     */
    public AsyncResource&lt;Media&gt; createBackgroundMediaAsync(String uri) {
<span class="fc" id="L5016">        return impl.createBackgroundMediaAsync(uri);</span>
    }

    /**
     * Create a blur image from the given image.
     * The algorithm is gaussian blur - https://en.wikipedia.org/wiki/Gaussian_blur
     *
     * @param image  the image to blur
     * @param radius the radius to be used in the algorithm
     */
    public Image gaussianBlurImage(Image image, float radius) {
<span class="fc" id="L5027">        return impl.gaussianBlurImage(image, radius);</span>
    }

    /**
     * Returns true if gaussian blur is supported on this platform
     *
     * @return true if gaussian blur is supported.
     */
    public boolean isGaussianBlurSupported() {
<span class="fc" id="L5036">        return impl.isGaussianBlurSupported();</span>
    }

    /**
     * Refreshes the native list of contacts on devices that require this see {@link com.codename1.contacts.ContactsManager#refresh()}
     */
    public void refreshContacts() {
<span class="fc" id="L5043">        impl.refreshContacts();</span>
<span class="fc" id="L5044">    }</span>

    /**
     * Returns true if this device is jailbroken or rooted, false if not or unknown. Notice that this method isn't
     * accurate and can't detect all jailbreak/rooting cases
     *
     * @return true if this device is jailbroken or rooted, false if not or unknown.
     */
    public boolean isJailbrokenDevice() {
<span class="nc" id="L5053">        return impl.isJailbrokenDevice();</span>
    }

    /**
     * Returns the build hints for the simulator, this will only work in the debug environment and it's
     * designed to allow extensions/API's to verify user settings/build hints exist
     *
     * @return map of the build hints that isn't modified without the codename1.arg. prefix
     */
    public Map&lt;String, String&gt; getProjectBuildHints() {
<span class="nc" id="L5063">        return impl.getProjectBuildHints();</span>
    }

    /**
     * Sets a build hint into the settings while overwriting any previous value. This will only work in the
     * debug environment and it's designed to allow extensions/API's to verify user settings/build hints exist.
     * Important: this will throw an exception outside of the simulator!
     *
     * @param key   the build hint without the codename1.arg. prefix
     * @param value the value for the hint
     */
    public void setProjectBuildHint(String key, String value) {
<span class="nc" id="L5075">        impl.setProjectBuildHint(key, value);</span>
<span class="nc" id="L5076">    }</span>

    /**
     * Checks to see if you can prompt the user to install the app on their homescreen.
     * This is only relevant for the Javascript port with PWAs.  This is not a &quot;static&quot; property, as it
     * only returns true if the app is in a state that allows you to prompt the user.  E.g. if you have
     * previously prompted the user and they have declined, then this will return false.
     *
     * &lt;p&gt;Best practice is to use {@link #onCanInstallOnHomescreen(java.lang.Runnable) } to be notified
     * when you are allowed to prompt the user for installation.  Then call {@link #promptInstallOnHomescreen() }
     * inside that method - or sometime after.&lt;/p&gt;
     *
     * &lt;h3&gt;Example&lt;/h3&gt;
     * &lt;pre&gt;{@code
     * onCanInstallOnHomescreen(()-&gt;{
     *      if (canInstallOnHomescreen()) {
     *           if (promptInstallOnHomescreen()) {
     *               // User accepted installation
     *           } else {
     *               // user rejected installation
     *           }
     *      }
     * });
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * https://developers.google.com/web/fundamentals/app-install-banners/
     *
     * @return True if you are able to prompt the user to install the app on their homescreen.
     * @see #promptInstallOnHomescreen()
     * @see #onCanInstallOnHomescreen(java.lang.Runnable)
     */
    public boolean canInstallOnHomescreen() {
<span class="nc" id="L5108">        return impl.canInstallOnHomescreen();</span>
    }

    /**
     * Prompts the user to install this app on their homescreen.  This is only relevant in the
     * javascript port.
     *
     * @return The result of the user prompt.  {@literal true} if the user accepts the installation,
     * {@literal false} if they reject it.
     * @see #canInstallOnHomescreen()
     * @see #onCanInstallOnHomescreen(java.lang.Runnable)
     */
    public boolean promptInstallOnHomescreen() {
<span class="nc" id="L5121">        return impl.promptInstallOnHomescreen();</span>
    }

    /**
     * A callback fired when you are allowed to prompt the user to install the app on their homescreen.
     * Only relevant in the javascript port.
     *
     * @param r Runnable that will be run when/if you are permitted to prompt the user to install
     *          the app on their homescreen.
     */
    public void onCanInstallOnHomescreen(Runnable r) {
<span class="nc" id="L5132">        impl.onCanInstallOnHomescreen(r);</span>
<span class="nc" id="L5133">    }</span>

    /**
     * Captures a screenshot of the screen.
     *
     * @return An image of the screen, or null if it failed.
     * @since 7.0
     * @deprecated use screenshot(SuccessCallback) instead
     */
    public Image captureScreen() {
<span class="nc" id="L5143">        return impl.captureScreen();</span>
    }

    /**
     * Captures a screenshot in the native layer which should include peer
     * components as well.
     *
     * @param callback will be invoked on the EDT with a screenshot
     * @since 7.0.211
     */
    public void screenshot(SuccessCallback&lt;Image&gt; callback) {
<span class="nc" id="L5154">        impl.screenshot(callback);</span>
<span class="nc" id="L5155">    }</span>

                           /**
     * Convenience method to schedule a task to run on the EDT after {@literal timeout}ms.
     *
     * @param timeout The timeout in milliseconds.
     * @param r       The task to run.
     * @return The Timer object that can be used to cancel the task.
     * @see #setInterval(int, java.lang.Runnable)
     * @since 7.0
     */
    public Timer setTimeout(int timeout, @Async.Schedule final Runnable r) {

<span class="nc" id="L5168">        Timer t = new Timer();</span>
<span class="nc" id="L5169">        t.schedule(new TimerTask() {</span>
            public void run() {
<span class="nc" id="L5171">                executeTimeoutRunnable(r);</span>
<span class="nc" id="L5172">            }</span>
        }, timeout);
<span class="nc" id="L5174">        return t;</span>
    }

    private void executeTimeoutRunnable(@Async.Execute Runnable r) {
<span class="nc" id="L5178">        CN.callSerially(r);</span>
<span class="nc" id="L5179">    }</span>

    /**
     * Convenience method to schedule a task to run on the EDT after {@literal period}ms
     * repeating every {@literal period}ms.
     *
     * @param period The delay and repeat in milliseconds.
     * @param r      The runnable to run on the EDT.
     * @return The timer object which can be used to cancel the task.
     * @see #setTimeout(int, java.lang.Runnable)
     * @since 7.0
     */
    public Timer setInterval(int period, @Async.Schedule final Runnable r) {
<span class="nc" id="L5192">        Timer t = new Timer();</span>
<span class="nc" id="L5193">        t.schedule(new TimerTask() {</span>
            public void run() {
<span class="nc" id="L5195">                executeTimeoutRunnable(r);</span>
<span class="nc" id="L5196">            }</span>
        }, period, period);


<span class="nc" id="L5200">        return t;</span>
    }

    /**
     * Gets a reference to an application-wide shared Javascript context that can be used for running
     * Javascript commands.  When running in the Javascript port, this Javascript context will be the
     * same context in which the application itself is running, so it gives you the ability to interact
     * with the browser and DOM directly using the familiar {@link BrowserComponent} API.
     *
     * &lt;p&gt;When running on other platforms, this shared context will be an off-screen browser component.&lt;/p&gt;
     *
     * &lt;p&gt;Sample code allowing user to execute arbitrary Javascript code inside the shared context:&lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/shannah/60040d9b3cc520b28bc1fef5e31afd31.js&quot;&gt;&lt;/script&gt;
     *
     * @return A shared BrowserComponent
     * @since 7.0
     */
    public BrowserComponent getSharedJavascriptContext() {
<span class="nc" id="L5218">        return impl.getSharedJavscriptContext();</span>
    }

<span class="nc" id="L5221">    private class EdtException extends RuntimeException {</span>
        private Throwable cause;
        private EdtException parent;

        public synchronized Throwable getCause() {
<span class="nc" id="L5226">            return cause;</span>
        }

        public void setCause(Throwable t) {
<span class="nc" id="L5230">            this.cause = t;</span>
<span class="nc" id="L5231">        }</span>

        private void throwRoot(Throwable cause) {
<span class="nc" id="L5234">            HashSet&lt;Throwable&gt; circuitCheck = new HashSet&lt;Throwable&gt;();</span>
<span class="nc" id="L5235">            circuitCheck.add(cause);</span>
<span class="nc" id="L5236">            EdtException root = this;</span>
<span class="nc bnc" id="L5237" title="All 2 branches missed.">            if (root != cause) {</span>
<span class="nc" id="L5238">                root.setCause(cause);</span>
<span class="nc" id="L5239">                circuitCheck.add(root);</span>
            } else {
<span class="nc" id="L5241">                root = (EdtException) cause;</span>
            }
<span class="nc bnc" id="L5243" title="All 2 branches missed.">            while (root.parent != null) {</span>
<span class="nc bnc" id="L5244" title="All 2 branches missed.">                if (circuitCheck.contains(root.parent)) {</span>
<span class="nc" id="L5245">                    break;</span>
                }
<span class="nc" id="L5247">                root.parent.setCause(root);</span>
<span class="nc" id="L5248">                circuitCheck.add(root.parent);</span>
<span class="nc" id="L5249">                root = root.parent;</span>
            }
<span class="nc" id="L5251">            throw root;</span>
        }

    }

    /**
     * A wrapper around Runnable that records the stack trace so that
     * if an exception occurs, it is easier to track it back to the original
     * source.
     */
    private class DebugRunnable implements Runnable {
        private final Runnable internal;
        private final EdtException exceptionWrapper;
        private DebugRunnable parentContext;
        private int depth;
        private int totalDepth;

<span class="nc" id="L5268">        DebugRunnable(Runnable internal) {</span>
<span class="nc" id="L5269">            this.internal = internal;</span>
<span class="nc" id="L5270">            this.parentContext = currentEdtContext;</span>
<span class="nc bnc" id="L5271" title="All 2 branches missed.">            if (parentContext != null) {</span>
<span class="nc" id="L5272">                depth = parentContext.depth + 1;</span>
<span class="nc" id="L5273">                totalDepth = parentContext.totalDepth + 1;</span>
            }

<span class="nc bnc" id="L5276" title="All 2 branches missed.">            if (isEnableAsyncStackTraces()) {</span>
<span class="nc" id="L5277">                exceptionWrapper = new EdtException();</span>

<span class="nc bnc" id="L5279" title="All 2 branches missed.">                if (parentContext != null) {</span>
<span class="nc bnc" id="L5280" title="All 2 branches missed.">                    if (depth &lt; MAX_ASYNC_EXCEPTION_DEPTH) {</span>
<span class="nc" id="L5281">                        exceptionWrapper.parent = parentContext.exceptionWrapper;</span>
<span class="nc" id="L5282">                        parentContext = null;</span>
                    } else {
<span class="nc" id="L5284">                        depth = 0;</span>
                    }
                }
            } else {
<span class="nc" id="L5288">                exceptionWrapper = null;</span>
<span class="nc" id="L5289">                parentContext = null;</span>
            }
<span class="nc" id="L5291">        }</span>


        public void run() {
<span class="nc bnc" id="L5295" title="All 2 branches missed.">            if (exceptionWrapper != null) {</span>
                try {
<span class="nc" id="L5297">                    currentEdtContext = this;</span>
<span class="nc" id="L5298">                    internal.run();</span>
<span class="nc" id="L5299">                } catch (RuntimeException t) {</span>
<span class="nc" id="L5300">                    exceptionWrapper.throwRoot(t);</span>
<span class="nc" id="L5301">                }</span>
            } else {
<span class="nc" id="L5303">                internal.run();</span>
            }
<span class="nc" id="L5305">        }</span>

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>