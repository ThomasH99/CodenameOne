<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>URLImage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codenameone-core-unittests</a> &gt; <a href="index.source.html" class="el_package">com.codename1.ui</a> &gt; <span class="el_source">URLImage.java</span></div><h1>URLImage.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, Codename One and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Codename One designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Codename One through http://www.codenameone.com/ if you
 * need additional information or have any questions.
 */

package com.codename1.ui;

import com.codename1.compat.java.util.Objects;
import com.codename1.io.FileSystemStorage;
import com.codename1.io.Log;
import com.codename1.io.Storage;
import com.codename1.io.Util;
import com.codename1.ui.events.ActionEvent;
import com.codename1.ui.events.ActionListener;
import com.codename1.ui.util.Resources;
import com.codename1.util.EasyThread;
import com.codename1.util.FailureCallback;
import com.codename1.util.StringUtil;
import com.codename1.util.SuccessCallback;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.Map;

/**
 * &lt;p&gt;{@code URLImage} allows us to create an image from a URL. If the image was downloaded
 * already it is fetched from cache; if not it is downloaded optionally scaled/adapted
 * and placed in cache.&lt;/p&gt;
 * &lt;p&gt;By default an image is fetched lazily as it is asked for by the GUI unless
 * the fetch() method is invoked in which case the IO code is executed immediately.&lt;/p&gt;
 *
 * &lt;p&gt;
 * This sample code show a {@code URLImage} that is fetched to the title area background and scaled/cropped
 * to fit device specific dimensions.
 * &lt;/p&gt;
 * &lt;script src=&quot;https://gist.github.com/codenameone/085e3a8fa1c36829d812.js&quot;&gt;&lt;/script&gt;
 *
 * &lt;p&gt;
 * This sample code shows the usage of the nestoria API to fill out an infinitely scrolling list in it
 * we use {@code URLImage} to fetch the icon.
 * &lt;/p&gt;
 * &lt;script src=&quot;https://gist.github.com/codenameone/af27af111ba766627363.js&quot;&gt;&lt;/script&gt;
 *
 * &lt;img src=&quot;https://www.codenameone.com/img/developer-guide/components-infinitescrolladapter.png&quot; alt=&quot;Sample usage of infinite scroll adapter&quot; /&gt;&lt;br&gt;&lt;br&gt;
 *
 * &lt;p&gt;
 * You can use adapters with masks using syntax similar to this to create a round image mask for a {@code URLImage}:
 * &lt;/p&gt;
 * &lt;script src=&quot;https://gist.github.com/codenameone/2515be7528ef3e402ec0.js&quot;&gt;&lt;/script&gt;
 *
 * @author Shai Almog
 */
public class URLImage extends EncodedImage {

    /**
     * Flag used by {@link #createCachedImage(java.lang.String, java.lang.String, com.codename1.ui.Image, int) }.
     * Equivalent to {@link #RESIZE_FAIL}
     */
    public static final int FLAG_RESIZE_FAIL = 3;
    /**
     * Will fail if the downloaded image has a different size from the placeholder image
     */
<span class="fc" id="L83">    public static final ImageAdapter RESIZE_FAIL = new ImageAdapter() {</span>
        public EncodedImage adaptImage(EncodedImage downloadedImage, EncodedImage placeholderImage) {
<span class="nc bnc" id="L85" title="All 4 branches missed.">            if (downloadedImage.getWidth() != placeholderImage.getWidth() || downloadedImage.getHeight() != placeholderImage.getHeight()) {</span>
<span class="nc" id="L86">                throw new RuntimeException(&quot;Invalid image size&quot;);</span>
            }
<span class="nc" id="L88">            return downloadedImage;</span>
        }

        public boolean isAsyncAdapter() {
<span class="nc" id="L92">            return false;</span>
        }
    };
    /**
     * Flag used by {@link #createCachedImage(java.lang.String, java.lang.String, com.codename1.ui.Image, int) }
     * Equivalent to {@link #RESIZE_SCALE}.
     */
    public static final int FLAG_RESIZE_SCALE = 1;
    /**
     * Scales the image to match the size of the new image exactly
     */
<span class="fc" id="L103">    public static final ImageAdapter RESIZE_SCALE = new ImageAdapter() {</span>
        public EncodedImage adaptImage(EncodedImage downloadedImage, EncodedImage placeholderImage) {
<span class="nc bnc" id="L105" title="All 4 branches missed.">            if (downloadedImage.getWidth() != placeholderImage.getWidth() || downloadedImage.getHeight() != placeholderImage.getHeight()) {</span>
<span class="nc" id="L106">                return downloadedImage.scaledEncoded(placeholderImage.getWidth(), placeholderImage.getHeight());</span>
            }
<span class="nc" id="L108">            return downloadedImage;</span>
        }

        public boolean isAsyncAdapter() {
<span class="nc" id="L112">            return false;</span>
        }
    };
    /**
     * Flag used by {@link #createCachedImage(java.lang.String, java.lang.String, com.codename1.ui.Image, int) }.
     * Equivalent to {@link #RESIZE_SCALE_TO_FILL}.
     */
    public static final int FLAG_RESIZE_SCALE_TO_FILL = 2;
    /**
     * Scales the image to match to fill the area while preserving aspect ratio
     */
<span class="fc" id="L123">    public static final ImageAdapter RESIZE_SCALE_TO_FILL = new ScaleToFill();</span>
<span class="fc" id="L124">    private static final Map&lt;String, URLImage&gt; pendingToStorage = new HashMap&lt;String, URLImage&gt;();</span>
<span class="fc" id="L125">    private static final Map&lt;String, URLImage&gt; pendingToFile = new HashMap&lt;String, URLImage&gt;();</span>
    private static final String IMAGE_SUFFIX = &quot;ImageURLTMP&quot;;
<span class="fc" id="L127">    private static final EasyThread imageLoader = EasyThread.start(&quot;ImageLoader&quot;);</span>
    /**
     * The exception handler is used for callbacks in case of an error
     */
    private static ErrorCallback exceptionHandler;
    private final EncodedImage placeholder;
    private final String url;
    private final ImageAdapter adapter;
    private final String storageFile;
    private final String fileSystemFile;
    private boolean fetching;
    private byte[] imageData;
    private boolean repaintImage;
    private boolean locked;
    private URLImage(EncodedImage placeholder, String url, ImageAdapter adapter, String storageFile, String fileSystemFile) {
<span class="fc" id="L142">        super(placeholder.getWidth(), placeholder.getHeight());</span>
<span class="fc" id="L143">        this.placeholder = placeholder;</span>
<span class="fc" id="L144">        this.url = url;</span>
<span class="fc" id="L145">        this.adapter = adapter;</span>
<span class="fc" id="L146">        this.storageFile = storageFile;</span>
<span class="fc" id="L147">        this.fileSystemFile = fileSystemFile;</span>
<span class="fc" id="L148">    }</span>

    /**
     * The exception handler is used for callbacks in case of an error
     *
     * @return the exceptionHandler
     */
    public static ErrorCallback getExceptionHandler() {
<span class="fc" id="L156">        return exceptionHandler;</span>
    }

    /**
     * The exception handler is used for callbacks in case of an error
     *
     * @param aExceptionHandler the exceptionHandler to set
     */
    public static void setExceptionHandler(
            ErrorCallback aExceptionHandler) {
<span class="fc" id="L166">        exceptionHandler = aExceptionHandler;</span>
<span class="fc" id="L167">    }</span>

    /**
     * &lt;p&gt;Creates an adapter that uses an image as a Mask, this is roughly the same as SCALE_TO_FILL with the
     * exception that a mask will be applied later on. This adapter requires that the resulting image be in the size
     * of the imageMask!&lt;br&gt;
     * See the sample usage code below that implements a circular image masked downloader:&lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/codenameone/2515be7528ef3e402ec0.js&quot;&gt;&lt;/script&gt;
     *
     * @param imageMask the mask image see the createMask() method of image for details of what a mask is, it
     *                  will be used as the reference size for the image and resulting images must be of the same size!
     * @return the adapter
     */
    public static ImageAdapter createMaskAdapter(Image imageMask) {
<span class="nc" id="L181">        final Object mask = imageMask.createMask();</span>
<span class="nc" id="L182">        return new ScaleToFill() {</span>
            @Override
            Image postProcess(Image i) {
<span class="nc" id="L185">                return i.applyMask(mask);</span>
            }
        };
    }

    public static ImageAdapter createMaskAdapter(final Object mask) {
<span class="nc" id="L191">        return new ScaleToFill() {</span>
            @Override
            Image postProcess(Image i) {
<span class="nc" id="L194">                return i.applyMask(mask);</span>
            }
        };
    }

    /**
     * Creates an image the will be downloaded on the fly as necessary with RESIZE_SCALE_TO_FILL as
     * the default behavior
     *
     * @param placeholder the image placeholder is shown as the image is loading/downloading
     *                    and serves as the guideline to the size of the downloaded image.
     * @param storageFile the file in storage to which the image will be stored
     * @param url         the url from which the image is fetched
     * @return a URLImage that will initialy just delegate to the placeholder
     */
    public static URLImage createToStorage(EncodedImage placeholder, String storageFile, String url) {
<span class="fc" id="L210">        return createToStorage(placeholder, storageFile, url, RESIZE_SCALE_TO_FILL);</span>
    }

    /**
     * Creates an image the will be downloaded on the fly as necessary
     *
     * @param placeholder the image placeholder is shown as the image is loading/downloading
     *                    and serves as the guideline to the size of the downloaded image.
     * @param storageFile the file in storage to which the image will be stored
     * @param url         the url from which the image is fetched
     * @param adapter     the adapter used to adapt the image into place, it should scale the image
     *                    if necessary
     * @return a URLImage that will initialy just delegate to the placeholder
     */
    public static URLImage createToStorage(EncodedImage placeholder, String storageFile, String url, ImageAdapter adapter) {
        // intern is used to trigger an NPE in case of a null URL or storage file
<span class="fc" id="L226">        URLImage out = pendingToStorage.get(storageFile);</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">        if (out != null) {</span>
<span class="fc" id="L228">            return out;</span>
        }
<span class="fc" id="L230">        out = new URLImage(placeholder, url.intern(), adapter, storageFile.intern(), null);</span>
<span class="fc" id="L231">        pendingToStorage.put(storageFile, out);</span>
<span class="fc" id="L232">        return out;</span>
    }

    /**
     * Creates an image the will be downloaded on the fly as necessary
     *
     * @param placeholder the image placeholder is shown as the image is loading/downloading
     *                    and serves as the guideline to the size of the downloaded image.
     * @param file        the file in the file system to which the image will be stored
     * @param url         the url from which the image is fetched
     * @param adapter     the adapter used to adapt the image into place, it should scale the image
     *                    if necessary
     * @return a URLImage that will initialy just delegate to the placeholder
     */
    public static URLImage createToFileSystem(EncodedImage placeholder, String file, String url, ImageAdapter adapter) {
        // intern is used to trigger an NPE in case of a null URL or storage file
<span class="nc" id="L248">        URLImage out = pendingToFile.get(file);</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">        if (out != null) {</span>
<span class="nc" id="L250">            return out;</span>
        }
<span class="nc" id="L252">        out = new URLImage(placeholder, url.intern(), adapter, null, file.intern());</span>
<span class="nc" id="L253">        pendingToFile.put(file, out);</span>
<span class="nc" id="L254">        return out;</span>
    }

    /**
     * Creates an image that will be downloaded on the fly as necessary.  On platforms that support a native
     * image cache (e.g. Javascript), the image will be loaded directly from the native cache (i.e. it defers to the
     * platform to handle all caching considerations.  On platforms that don't have a native image cache but
     * do have a caches directory {@link FileSystemStorage#hasCachesDir()}, this will call {@link #createToFileSystem(com.codename1.ui.EncodedImage, java.lang.String, java.lang.String, com.codename1.ui.URLImage.ImageAdapter) }
     * with a file location in the caches directory.  In all other cases, this will call {@link #createToStorage(com.codename1.ui.EncodedImage, java.lang.String, java.lang.String) }.
     *
     * @param imageName   The name of the image.
     * @param url         the URL from which the image is fetched
     * @param placeholder the image placeholder is shown as the image is loading/downloading
     *                    and serves as the guideline to the size of the downloaded image.
     * @param resizeRule  One of {@link #FLAG_RESIZE_FAIL}, {@link #FLAG_RESIZE_SCALE}, or {@link #FLAG_RESIZE_SCALE_TO_FILL}.
     * @return a Image that will initially just delegate to the placeholder
     */
    public static Image createCachedImage(String imageName, String url, Image placeholder, int resizeRule) {
<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (Display.getInstance().supportsNativeImageCache()) {</span>
<span class="nc" id="L273">            CachedImage im = new CachedImage(placeholder, url, resizeRule);</span>
<span class="nc" id="L274">            im.setImageName(imageName);</span>
<span class="nc" id="L275">            return im;</span>
        } else {
<span class="nc" id="L277">            ImageAdapter adapter = null;</span>
<span class="nc bnc" id="L278" title="All 4 branches missed.">            switch (resizeRule) {</span>
                case FLAG_RESIZE_FAIL:
<span class="nc" id="L280">                    adapter = RESIZE_FAIL;</span>
<span class="nc" id="L281">                    break;</span>
                case FLAG_RESIZE_SCALE:
<span class="nc" id="L283">                    adapter = RESIZE_SCALE;</span>
<span class="nc" id="L284">                    break;</span>
                case FLAG_RESIZE_SCALE_TO_FILL:
<span class="nc" id="L286">                    adapter = RESIZE_SCALE_TO_FILL;</span>
<span class="nc" id="L287">                    break;</span>
                default:
<span class="nc" id="L289">                    adapter = RESIZE_SCALE_TO_FILL;</span>
                    break;
            }
<span class="nc" id="L292">            FileSystemStorage fs = FileSystemStorage.getInstance();</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">            if (fs.hasCachesDir()) {</span>
<span class="nc" id="L294">                String name = &quot;cn1_image_cache[&quot; + url + &quot;]&quot;;</span>
<span class="nc" id="L295">                name = StringUtil.replaceAll(name, &quot;/&quot;, &quot;_&quot;);</span>
<span class="nc" id="L296">                name = StringUtil.replaceAll(name, &quot;\\&quot;, &quot;_&quot;);</span>
<span class="nc" id="L297">                name = StringUtil.replaceAll(name, &quot;%&quot;, &quot;_&quot;);</span>
<span class="nc" id="L298">                name = StringUtil.replaceAll(name, &quot;?&quot;, &quot;_&quot;);</span>
<span class="nc" id="L299">                name = StringUtil.replaceAll(name, &quot;*&quot;, &quot;_&quot;);</span>
<span class="nc" id="L300">                name = StringUtil.replaceAll(name, &quot;:&quot;, &quot;_&quot;);</span>
<span class="nc" id="L301">                name = StringUtil.replaceAll(name, &quot;=&quot;, &quot;_&quot;);</span>

<span class="nc" id="L303">                String filePath = fs.getCachesDir() + fs.getFileSystemSeparator() + name;</span>
                //System.out.println(&quot;Creating to file system &quot;+filePath);
<span class="nc" id="L305">                URLImage im = createToFileSystem(</span>
<span class="nc" id="L306">                        EncodedImage.createFromImage(placeholder, false),</span>
                        filePath,
                        url,
                        adapter
                );
<span class="nc" id="L311">                im.setImageName(imageName);</span>
<span class="nc" id="L312">                return im;</span>
            } else {
                //System.out.println(&quot;Creating to storage &quot;);
<span class="nc" id="L315">                URLImage im = createToStorage(EncodedImage.createFromImage(placeholder, false),</span>
<span class="nc" id="L316">                        &quot;cn1_image_cache[&quot; + url + &quot;@&quot; + placeholder.getWidth() + &quot;x&quot; + placeholder.getHeight(),</span>
                        url,
                        adapter
                );
<span class="nc" id="L320">                im.setImageName(imageName);</span>
<span class="nc" id="L321">                return im;</span>
            }
        }
    }

    private void runAndWait(Runnable r) {
<span class="nc bnc" id="L327" title="All 2 branches missed.">        if (platformSupportsImageLoadingOffEdt()) {</span>
<span class="nc" id="L328">            String oldShowEDTWarnings = CN.getProperty(&quot;platformHint.showEDTWarnings&quot;, &quot;false&quot;);</span>
<span class="nc" id="L329">            CN.setProperty(&quot;platformHint.showEDTWarnings&quot;, &quot;false&quot;);</span>
            try {
<span class="nc" id="L331">                r.run();</span>
            } finally {
<span class="nc" id="L333">                CN.setProperty(&quot;platformHint.showEDTWarnings&quot;, oldShowEDTWarnings);</span>
            }
<span class="nc" id="L335">        } else {</span>
<span class="nc" id="L336">            CN.callSeriallyAndWait(r);</span>
        }
<span class="nc" id="L338">    }</span>

    private boolean platformSupportsImageLoadingOffEdt() {
<span class="nc bnc" id="L341" title="All 4 branches missed.">        return CN.isSimulator() || !CN.getPlatformName().equals(&quot;ios&quot;);</span>
    }

    private void loadImageFromStorageURLToStorage(final String targetKey) {
<span class="nc" id="L345">        imageLoader.run(new Runnable() {</span>
            public void run() {
                try {
<span class="nc bnc" id="L348" title="All 2 branches missed.">                    if (!Objects.equals(url, targetKey)) {</span>
<span class="nc" id="L349">                        InputStream input = Storage.getInstance().createInputStream(url);</span>
<span class="nc" id="L350">                        OutputStream output = Storage.getInstance().createOutputStream(targetKey);</span>
<span class="nc" id="L351">                        Util.copy(input, output);</span>
                    }
<span class="nc" id="L353">                    runAndWait(new Runnable() {</span>
                        public void run() {
                            try {
<span class="nc" id="L356">                                Image value = Image.createImage(Storage.getInstance().createInputStream(targetKey));</span>
<span class="nc" id="L357">                                DownloadCompleted onComplete = new DownloadCompleted();</span>
<span class="nc" id="L358">                                onComplete.setSourceImage(value);</span>
<span class="nc" id="L359">                                onComplete.actionPerformed(new ActionEvent(value));</span>
<span class="nc" id="L360">                            } catch (Exception ex) {</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">                                if (exceptionHandler != null) {</span>
<span class="nc" id="L362">                                    exceptionHandler.onError(URLImage.this, ex);</span>
                                } else {
<span class="nc" id="L364">                                    Log.e(new RuntimeException(ex.toString()));</span>
                                }
<span class="nc" id="L366">                            }</span>
<span class="nc" id="L367">                        }</span>
                    });
<span class="nc" id="L369">                } catch (Exception t) {</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">                    if (exceptionHandler != null) {</span>
<span class="nc" id="L371">                        exceptionHandler.onError(URLImage.this, t);</span>
                    } else {
<span class="nc" id="L373">                        Log.e(new RuntimeException(t.toString()));</span>
                    }
<span class="nc" id="L375">                }</span>
<span class="nc" id="L376">            }</span>
        });
<span class="nc" id="L378">    }</span>

    private void loadImageFromLocalUrl(final String targetKey, final boolean useFileSystemStorage) {
<span class="nc" id="L381">        imageLoader.run(new Runnable() {</span>
            public void run() {
                try {
                    InputStream input;
<span class="nc bnc" id="L385" title="All 2 branches missed.">                    if (url.startsWith(&quot;file:/&quot;)) {</span>
<span class="nc" id="L386">                        input = FileSystemStorage.getInstance().openInputStream(url);</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">                    } else if (url.startsWith(&quot;jar:/&quot;)) {</span>
<span class="nc" id="L388">                        input = CN.getResourceAsStream(url.substring(url.lastIndexOf(&quot;/&quot;)));</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">                    } else if (url.startsWith(&quot;image:&quot;)) {</span>
<span class="nc" id="L390">                        input = null;</span>
                    } else {
<span class="nc" id="L392">                        input = Storage.getInstance().createInputStream(url);</span>
                    }
<span class="nc bnc" id="L394" title="All 2 branches missed.">                    if (input != null) {</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">                        OutputStream output = useFileSystemStorage ? FileSystemStorage.getInstance().openOutputStream(targetKey) : Storage.getInstance().createOutputStream(targetKey);</span>
<span class="nc" id="L396">                        Util.copy(input, output);</span>
                    }
<span class="nc" id="L398">                    runAndWait(new Runnable() {</span>
                        public void run() {
                            try {
<span class="nc bnc" id="L401" title="All 4 branches missed.">                                Image value = url.startsWith(&quot;image:&quot;) ? Resources.getGlobalResources().getImage(url) :</span>
<span class="nc" id="L402">                                        Image.createImage(useFileSystemStorage ? FileSystemStorage.getInstance().openInputStream(targetKey) : Storage.getInstance().createInputStream(targetKey));</span>
<span class="nc" id="L403">                                DownloadCompleted onComplete = new DownloadCompleted();</span>
<span class="nc" id="L404">                                onComplete.setSourceImage(value);</span>
<span class="nc" id="L405">                                onComplete.actionPerformed(new ActionEvent(value));</span>
<span class="nc" id="L406">                            } catch (Exception ex) {</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">                                if (exceptionHandler != null) {</span>
<span class="nc" id="L408">                                    exceptionHandler.onError(URLImage.this, ex);</span>
                                } else {
<span class="nc" id="L410">                                    Log.e(new RuntimeException(ex.toString()));</span>
                                }
<span class="nc" id="L412">                            }</span>
<span class="nc" id="L413">                        }</span>
                    });
<span class="nc" id="L415">                } catch (Exception t) {</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">                    if (exceptionHandler != null) {</span>
<span class="nc" id="L417">                        exceptionHandler.onError(URLImage.this, t);</span>
                    } else {
<span class="nc" id="L419">                        Log.e(new RuntimeException(t.toString()));</span>
                    }
<span class="nc" id="L421">                }</span>
<span class="nc" id="L422">            }</span>
        });
<span class="nc" id="L424">    }</span>

    /**
     * Images are normally fetched from storage or network only as needed,
     * however if the download must start before the image is drawn this method
     * can be invoked. Notice that &quot;immediately&quot; doesn't mean synchronously, it just
     * means that the image will be added to the queue right away but probably won't be
     * available by the time the method completes.
     */
    public void fetch() {
<span class="pc bpc" id="L434" title="2 of 4 branches missed.">        if (fetching || imageData != null) {</span>
<span class="nc" id="L435">            return;</span>
        }
<span class="fc" id="L437">        fetching = true;</span>
        try {
<span class="fc" id="L439">            locked = super.isLocked();</span>
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">            if (storageFile != null) {</span>
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">                if (Storage.getInstance().exists(storageFile)) {</span>
<span class="fc" id="L442">                    super.unlock();</span>
<span class="fc" id="L443">                    imageData = new byte[Storage.getInstance().entrySize(storageFile)];</span>
<span class="fc" id="L444">                    InputStream is = Storage.getInstance().createInputStream(storageFile);</span>
<span class="fc" id="L445">                    Util.readFully(is, imageData);</span>
<span class="fc" id="L446">                    resetCache();</span>
<span class="fc" id="L447">                    fetching = false;</span>
<span class="fc" id="L448">                    repaintImage = true;</span>
<span class="fc" id="L449">                    fireChangedEvent();</span>
<span class="fc" id="L450">                    return;</span>
                }
<span class="nc bnc" id="L452" title="All 2 branches missed.">                if (adapter != null) {</span>
<span class="nc bnc" id="L453" title="All 4 branches missed.">                    if (url.startsWith(&quot;http://&quot;) || url.startsWith(&quot;https://&quot;)) {</span>
<span class="nc" id="L454">                        Util.downloadImageToStorage(url, storageFile + IMAGE_SUFFIX,</span>
<span class="nc" id="L455">                                new SuccessCallback&lt;Image&gt;() {</span>
                                    public void onSucess(final Image value) {
<span class="nc" id="L457">                                        imageLoader.run(new Runnable() {</span>
                                            public void run() {
<span class="nc" id="L459">                                                runAndWait(new Runnable() {</span>
                                                    public void run() {
<span class="nc" id="L461">                                                        DownloadCompleted onComplete = new DownloadCompleted();</span>
<span class="nc" id="L462">                                                        onComplete.setSourceImage(value);</span>
<span class="nc" id="L463">                                                        onComplete.actionPerformed(new ActionEvent(value));</span>
<span class="nc" id="L464">                                                    }</span>
                                                });
<span class="nc" id="L466">                                            }</span>
                                        });


<span class="nc" id="L470">                                    }</span>

                                });
                    } else {
                        // from file
<span class="nc" id="L475">                        loadImageFromLocalUrl(storageFile + IMAGE_SUFFIX, false);</span>
                    }
                } else {
<span class="nc bnc" id="L478" title="All 4 branches missed.">                    if (url.startsWith(&quot;http://&quot;) || url.startsWith(&quot;https://&quot;)) {</span>
                        // Load image from http
<span class="nc" id="L480">                        Util.downloadImageToStorage(url, storageFile,</span>
<span class="nc" id="L481">                                new SuccessCallback&lt;Image&gt;() {</span>
                                    public void onSucess(final Image value) {
<span class="nc" id="L483">                                        imageLoader.run(new Runnable() {</span>
                                            public void run() {
<span class="nc" id="L485">                                                runAndWait(new Runnable() {</span>
                                                    public void run() {
<span class="nc" id="L487">                                                        DownloadCompleted onComplete = new DownloadCompleted();</span>
<span class="nc" id="L488">                                                        onComplete.setSourceImage(value);</span>
<span class="nc" id="L489">                                                        onComplete.actionPerformed(new ActionEvent(value));</span>
<span class="nc" id="L490">                                                    }</span>
                                                });
<span class="nc" id="L492">                                            }</span>
                                        });


<span class="nc" id="L496">                                    }</span>
                                });
                    } else {
                        //load image from file system
<span class="nc" id="L500">                        loadImageFromLocalUrl(storageFile, false);</span>
                    }
                }
            } else {
<span class="nc bnc" id="L504" title="All 2 branches missed.">                if (FileSystemStorage.getInstance().exists(fileSystemFile)) {</span>
<span class="nc" id="L505">                    super.unlock();</span>
<span class="nc" id="L506">                    imageData = new byte[(int) FileSystemStorage.getInstance().getLength(fileSystemFile)];</span>
<span class="nc" id="L507">                    InputStream is = FileSystemStorage.getInstance().openInputStream(fileSystemFile);</span>
<span class="nc" id="L508">                    Util.readFully(is, imageData);</span>
<span class="nc" id="L509">                    resetCache();</span>
<span class="nc" id="L510">                    fetching = false;</span>
<span class="nc" id="L511">                    repaintImage = true;</span>
<span class="nc" id="L512">                    fireChangedEvent();</span>
<span class="nc" id="L513">                    return;</span>
                }
<span class="nc bnc" id="L515" title="All 2 branches missed.">                if (adapter != null) {</span>
<span class="nc bnc" id="L516" title="All 4 branches missed.">                    if (url.startsWith(&quot;http://&quot;) || url.startsWith(&quot;https://&quot;)) {</span>
                        // Load image over http
<span class="nc" id="L518">                        Util.downloadImageToFileSystem(url, fileSystemFile + IMAGE_SUFFIX,</span>
<span class="nc" id="L519">                                new SuccessCallback&lt;Image&gt;() {</span>

                                    public void onSucess(final Image value) {
<span class="nc" id="L522">                                        imageLoader.run(new Runnable() {</span>
                                            public void run() {
<span class="nc" id="L524">                                                runAndWait(new Runnable() {</span>
                                                    public void run() {
<span class="nc" id="L526">                                                        DownloadCompleted onComplete = new DownloadCompleted();</span>
<span class="nc" id="L527">                                                        onComplete.setSourceImage(value);</span>
<span class="nc" id="L528">                                                        onComplete.actionPerformed(new ActionEvent(value));</span>
<span class="nc" id="L529">                                                    }</span>
                                                });
<span class="nc" id="L531">                                            }</span>
                                        });


<span class="nc" id="L535">                                    }</span>

                                });
                    } else {
                        // load image from file system
<span class="nc" id="L540">                        loadImageFromLocalUrl(fileSystemFile + IMAGE_SUFFIX, true);</span>
                    }
                } else {
<span class="nc bnc" id="L543" title="All 4 branches missed.">                    if (url.startsWith(&quot;http://&quot;) || url.startsWith(&quot;https://&quot;)) {</span>
<span class="nc" id="L544">                        Util.downloadImageToFileSystem(url, fileSystemFile,</span>
<span class="nc" id="L545">                                new SuccessCallback&lt;Image&gt;() {</span>

                                    public void onSucess(final Image value) {
<span class="nc" id="L548">                                        imageLoader.run(new Runnable() {</span>
                                            public void run() {
<span class="nc" id="L550">                                                runAndWait(new Runnable() {</span>
                                                    public void run() {
<span class="nc" id="L552">                                                        DownloadCompleted onComplete = new DownloadCompleted();</span>
<span class="nc" id="L553">                                                        onComplete.setSourceImage(value);</span>
<span class="nc" id="L554">                                                        onComplete.actionPerformed(new ActionEvent(value));</span>
<span class="nc" id="L555">                                                    }</span>
                                                });
<span class="nc" id="L557">                                            }</span>
                                        });


<span class="nc" id="L561">                                    }</span>

                                });
                    } else {
<span class="nc" id="L565">                        loadImageFromLocalUrl(fileSystemFile, true);</span>
                    }
                }
            }
<span class="nc" id="L569">        } catch (IOException ioErr) {</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">            if (exceptionHandler != null) {</span>
<span class="nc" id="L571">                exceptionHandler.onError(URLImage.this, ioErr);</span>
            } else {
<span class="nc" id="L573">                throw new RuntimeException(ioErr.toString());</span>
            }
<span class="nc" id="L575">        }</span>
<span class="nc" id="L576">    }</span>

    /**
     * {@inheritDoc}
     */
    protected Image getInternal() {
<span class="nc bnc" id="L582" title="All 2 branches missed.">        if (imageData == null) {</span>
<span class="nc" id="L583">            fetch();</span>
<span class="nc" id="L584">            return placeholder;</span>
        }
<span class="nc" id="L586">        return super.getInternal();</span>
    }

    @Override
    public boolean requiresDrawImage() {
        // IT is important to override this for URLImage because the default implementation will
        // trigger that the URL image downloads its image, which is disastrous for performance
        // if you have a lot of URL images.
        // Ideally, the image doesn't get downloaded until it is needed for painting.
<span class="nc" id="L595">        return false;</span>
    }

    /**
     * {@inheritDoc}
     */
    public byte[] getImageData() {
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">        if (imageData != null) {</span>
<span class="fc" id="L603">            return imageData;</span>
        }
<span class="nc" id="L605">        return placeholder.getImageData();</span>
    }

    /**
     * {@inheritDoc}
     */
    public boolean animate() {
<span class="nc bnc" id="L612" title="All 2 branches missed.">        if (repaintImage) {</span>
<span class="nc" id="L613">            repaintImage = false;</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">            if (locked) {</span>
<span class="nc" id="L615">                super.lock();</span>
<span class="nc" id="L616">                locked = false;</span>
            }
<span class="nc" id="L618">            return true;</span>
        }
<span class="nc" id="L620">        return false;</span>
    }

    /**
     * Block this method from external callers as it might break the functionality
     */
    @Override
    public void lock() {
<span class="nc" id="L628">    }</span>

    /**
     * Block this method from external callers as it might break the functionality
     */
    @Override
    public void unlock() {
<span class="nc" id="L635">    }</span>

    /**
     * {@inheritDoc}
     */
    public boolean isAnimation() {
<span class="nc bnc" id="L641" title="All 4 branches missed.">        return repaintImage || imageData == null;</span>
    }

    /**
     * Invoked in a case of an error
     */
    public interface ErrorCallback {
        void onError(URLImage source, Exception err);
    }

    /**
     * Allows applying resize logic to downloaded images you can use constant
     * resize behaviors defined in this class. This class allows masking and various
     * other effects to be applied to downloaded images.
     * &lt;p&gt;Notice: adapters happen before the image is saved so they will only happen once
     * and the image will be saved as &quot;adapted&quot; which can be great for performance but
     * is also permanent. E.g. If you mask an image it will remain masked.
     */
    public interface ImageAdapter {
        /**
         * Allows the downloaded image to be adapted e.g if it isn't the same size of the placeholder image.
         *
         * @param downloadedImage  the downloaded image
         * @param placeholderImage the placeholder image
         * @return the adapted image or the same image
         */
        EncodedImage adaptImage(EncodedImage downloadedImage, EncodedImage placeholderImage);

        /**
         * Return true if the adapter should work on a separate thread to avoid blocking the EDT
         * this is especially important for image masks and heavy image manipulation
         *
         * @return true to run off the EDT
         */
        boolean isAsyncAdapter();
    }

<span class="fc" id="L678">    static class ScaleToFill implements ImageAdapter {</span>
        public EncodedImage adaptImage(EncodedImage downloadedImage, EncodedImage placeholderImage) {
<span class="nc bnc" id="L680" title="All 4 branches missed.">            if (downloadedImage.getWidth() != placeholderImage.getWidth() || downloadedImage.getHeight() != placeholderImage.getHeight()) {</span>
<span class="nc" id="L681">                Image tmp = downloadedImage.getInternal().scaledLargerRatio(placeholderImage.getWidth(), placeholderImage.getHeight());</span>
<span class="nc" id="L682">                Image i = Image.createImage(placeholderImage.getWidth(), placeholderImage.getHeight(), 0);</span>
<span class="nc" id="L683">                Graphics g = i.getGraphics();</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">                if (tmp.getWidth() &gt; placeholderImage.getWidth()) {</span>
<span class="nc" id="L685">                    int diff = tmp.getWidth() - placeholderImage.getWidth();</span>
<span class="nc" id="L686">                    int x = diff / 2;</span>
<span class="nc" id="L687">                    g.drawImage(tmp, -x, 0);</span>
<span class="nc" id="L688">                    tmp = i;</span>
<span class="nc" id="L689">                } else {</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">                    if (tmp.getHeight() &gt; placeholderImage.getHeight()) {</span>
<span class="nc" id="L691">                        int diff = tmp.getHeight() - placeholderImage.getHeight();</span>
<span class="nc" id="L692">                        int y = diff / 2;</span>
<span class="nc" id="L693">                        g.drawImage(tmp, 0, -y);</span>
<span class="nc" id="L694">                        tmp = i;</span>
                    }
                }
<span class="nc" id="L697">                tmp = postProcess(tmp);</span>
                //return EncodedImage.createFromImage(tmp, tmp.isOpaque());
<span class="nc" id="L699">                return EncodedImage.createFromImage(tmp, false);</span>
            }
<span class="nc" id="L701">            return downloadedImage;</span>
        }

        Image postProcess(Image i) {
<span class="nc" id="L705">            return i;</span>
        }

        public boolean isAsyncAdapter() {
<span class="nc" id="L709">            return false;</span>
        }
    }

    /**
     * CachedImage used by {@link #createCachedImage(java.lang.String, java.lang.String, com.codename1.ui.Image, int) }
     */
    private static class CachedImage extends Image {
        boolean fetching;
        int resizeRule;
        Object image;
        Image placeholderImage;
        String url;
        boolean repaintImage;

        public CachedImage(Image placeholder, String url, int resize) {
<span class="nc" id="L725">            super(placeholder.getImage());</span>
<span class="nc" id="L726">            this.url = url;</span>
<span class="nc" id="L727">            this.resizeRule = resize;</span>
<span class="nc" id="L728">            this.placeholderImage = placeholder;</span>
<span class="nc" id="L729">            Util.downloadImageToCache(url, new SuccessCallback&lt;Image&gt;() {</span>
                public void onSucess(Image downloadedImage) {
<span class="nc" id="L731">                    fetching = false;</span>
<span class="nc bnc" id="L732" title="All 4 branches missed.">                    switch (resizeRule) {</span>
                        case FLAG_RESIZE_FAIL: {
<span class="nc bnc" id="L734" title="All 4 branches missed.">                            if (downloadedImage.getWidth() != placeholderImage.getWidth() || downloadedImage.getHeight() != placeholderImage.getHeight()) {</span>
<span class="nc" id="L735">                                throw new RuntimeException(&quot;Invalid image size&quot;);</span>
                            }
                            break;
                        }
                        case FLAG_RESIZE_SCALE: {
<span class="nc" id="L740">                            downloadedImage = downloadedImage.scaled(placeholderImage.getWidth(), placeholderImage.getHeight());</span>
<span class="nc" id="L741">                            break;</span>
                        }
                        case FLAG_RESIZE_SCALE_TO_FILL: {
<span class="nc bnc" id="L744" title="All 4 branches missed.">                            if (downloadedImage.getWidth() != placeholderImage.getWidth() || downloadedImage.getHeight() != placeholderImage.getHeight()) {</span>
<span class="nc" id="L745">                                Image tmp = downloadedImage.scaledLargerRatio(placeholderImage.getWidth(), placeholderImage.getHeight());</span>
<span class="nc" id="L746">                                Image i = Image.createImage(placeholderImage.getWidth(), placeholderImage.getHeight(), 0);</span>
<span class="nc" id="L747">                                Graphics g = i.getGraphics();</span>
<span class="nc" id="L748">                                g.setAntiAliased(true);</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">                                if (tmp.getWidth() &gt; placeholderImage.getWidth()) {</span>
<span class="nc" id="L750">                                    int diff = tmp.getWidth() - placeholderImage.getWidth();</span>
<span class="nc" id="L751">                                    int x = diff / 2;</span>
<span class="nc" id="L752">                                    g.drawImage(tmp, -x, 0);</span>
<span class="nc" id="L753">                                    tmp = i;</span>
<span class="nc" id="L754">                                } else {</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">                                    if (tmp.getHeight() &gt; placeholderImage.getHeight()) {</span>
<span class="nc" id="L756">                                        int diff = tmp.getHeight() - placeholderImage.getHeight();</span>
<span class="nc" id="L757">                                        int y = diff / 2;</span>
<span class="nc" id="L758">                                        g.drawImage(tmp, 0, -y);</span>
<span class="nc" id="L759">                                        tmp = i;</span>
                                    }
                                }

<span class="nc" id="L763">                                downloadedImage = tmp;</span>
                            }
                            break;
                        }
                    }

<span class="nc" id="L769">                    image = downloadedImage.getImage();</span>
<span class="nc" id="L770">                    repaintImage = true;</span>
<span class="nc" id="L771">                    fireChangedEvent();</span>
<span class="nc" id="L772">                }</span>

<span class="nc" id="L774">            }, new FailureCallback&lt;Image&gt;() {</span>
                public void onError(Object sender, Throwable err, int errorCode, String errorMessage) {
<span class="nc" id="L776">                    throw new RuntimeException(&quot;Failed to download image &quot; + CachedImage.this.url + &quot; from cache&quot;);</span>
                }
            });
<span class="nc" id="L779">        }</span>

        @Override
        public boolean animate() {
<span class="nc bnc" id="L783" title="All 2 branches missed.">            if (repaintImage) {</span>
<span class="nc" id="L784">                repaintImage = false;</span>
<span class="nc" id="L785">                return true;</span>
            }
<span class="nc" id="L787">            return false;</span>
        }

        @Override
        public boolean isAnimation() {
<span class="nc bnc" id="L792" title="All 4 branches missed.">            return repaintImage || image == null;</span>
        }

        @Override
        public Object getImage() {
<span class="nc bnc" id="L797" title="All 2 branches missed.">            if (image != null) {</span>
<span class="nc" id="L798">                return image;</span>
            }
<span class="nc" id="L800">            return super.getImage();</span>
        }
    }

<span class="nc" id="L804">    class DownloadCompleted implements ActionListener, Runnable {</span>
        private EncodedImage adapt;
        private EncodedImage adaptedIns;
        private Image sourceImage;

        public void run() {
<span class="nc" id="L810">            adaptedIns = adapter.adaptImage(adapt, placeholder);</span>
<span class="nc" id="L811">        }</span>

        public void actionPerformed(ActionEvent evt) {
<span class="nc bnc" id="L814" title="All 2 branches missed.">            if (adapter != null) {</span>
                try {
                    EncodedImage img;
<span class="nc bnc" id="L817" title="All 2 branches missed.">                    if (sourceImage == null) {</span>
                        byte[] d;
                        InputStream is;
<span class="nc bnc" id="L820" title="All 2 branches missed.">                        if (storageFile != null) {</span>
<span class="nc" id="L821">                            d = new byte[Storage.getInstance().entrySize(storageFile + IMAGE_SUFFIX)];</span>
<span class="nc" id="L822">                            is = Storage.getInstance().createInputStream(storageFile + IMAGE_SUFFIX);</span>
                        } else {
<span class="nc" id="L824">                            d = new byte[(int) FileSystemStorage.getInstance().getLength(fileSystemFile + IMAGE_SUFFIX)];</span>
<span class="nc" id="L825">                            is = FileSystemStorage.getInstance().openInputStream(fileSystemFile + IMAGE_SUFFIX);</span>
                        }
<span class="nc" id="L827">                        Util.readFully(is, d);</span>
<span class="nc" id="L828">                        img = EncodedImage.create(d);</span>
<span class="nc" id="L829">                    } else {</span>
<span class="nc" id="L830">                        img = EncodedImage.createFromImage(sourceImage, false);</span>
                    }
                    EncodedImage adapted;
<span class="nc bnc" id="L833" title="All 2 branches missed.">                    if (adapter.isAsyncAdapter()) {</span>
<span class="nc" id="L834">                        adapt = img;</span>
<span class="nc" id="L835">                        Display.getInstance().invokeAndBlock(this);</span>
<span class="nc" id="L836">                        adapted = adaptedIns;</span>
<span class="nc" id="L837">                        adaptedIns = null;</span>
<span class="nc" id="L838">                        adapt = null;</span>
                    } else {
                        try {
<span class="nc" id="L841">                            adapted = adapter.adaptImage(img, placeholder);</span>
<span class="nc" id="L842">                        } catch (Exception err) {</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">                            if (exceptionHandler != null) {</span>
<span class="nc" id="L844">                                exceptionHandler.onError(URLImage.this, err);</span>
                            } else {
<span class="nc" id="L846">                                Log.p(&quot;Failed to load image from URL: &quot; + url);</span>
<span class="nc" id="L847">                                Log.e(err);</span>
                            }
<span class="nc" id="L849">                            return;</span>
<span class="nc" id="L850">                        }</span>
                    }
<span class="nc bnc" id="L852" title="All 2 branches missed.">                    if (storageFile != null) {</span>
<span class="nc" id="L853">                        OutputStream o = Storage.getInstance().createOutputStream(storageFile);</span>
<span class="nc" id="L854">                        o.write(adapted.getImageData());</span>
<span class="nc" id="L855">                        o.close();</span>
<span class="nc" id="L856">                        Storage.getInstance().deleteStorageFile(storageFile + IMAGE_SUFFIX);</span>
<span class="nc" id="L857">                        pendingToStorage.remove(storageFile);</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">                    } else if (fileSystemFile != null) {</span>
<span class="nc" id="L859">                        OutputStream o = FileSystemStorage.getInstance().openOutputStream(fileSystemFile);</span>
<span class="nc" id="L860">                        o.write(adapted.getImageData());</span>
<span class="nc" id="L861">                        o.close();</span>
<span class="nc" id="L862">                        FileSystemStorage.getInstance().delete(fileSystemFile + IMAGE_SUFFIX);</span>
<span class="nc" id="L863">                        pendingToFile.remove(fileSystemFile);</span>
                    }
<span class="nc" id="L865">                } catch (IOException ex) {</span>
<span class="nc bnc" id="L866" title="All 2 branches missed.">                    if (exceptionHandler != null) {</span>
<span class="nc" id="L867">                        exceptionHandler.onError(URLImage.this, ex);</span>
                    } else {
<span class="nc" id="L869">                        Log.e(ex);</span>
                    }
<span class="nc" id="L871">                    return;</span>
<span class="nc" id="L872">                }</span>
            }
<span class="nc" id="L874">            fetching = false;</span>
            // invoke fetch again to load the local files
<span class="nc" id="L876">            fetch();</span>
<span class="nc" id="L877">        }</span>

        /**
         * Used in cases where the source image is already downloaded ( so we don't need to try to load it from storage/file system.
         *
         * @param sourceImage
         */
        void setSourceImage(Image sourceImage) {
<span class="nc" id="L885">            this.sourceImage = sourceImage;</span>
<span class="nc" id="L886">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>