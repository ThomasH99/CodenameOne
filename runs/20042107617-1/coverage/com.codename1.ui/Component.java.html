<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Component.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codenameone-core-unittests</a> &gt; <a href="index.source.html" class="el_package">com.codename1.ui</a> &gt; <span class="el_source">Component.java</span></div><h1>Component.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores
 * CA 94065 USA or visit www.oracle.com if you need additional information or
 * have any questions.
 */
package com.codename1.ui;

import com.codename1.cloud.BindTarget;
import com.codename1.compat.java.util.Objects;
import com.codename1.components.InfiniteProgress;
import com.codename1.components.InteractionDialog;
import com.codename1.impl.CodenameOneImplementation;
import com.codename1.ui.TextSelection.TextSelectionSupport;
import com.codename1.ui.animations.Animation;
import com.codename1.ui.animations.ComponentAnimation;
import com.codename1.ui.animations.Motion;
import com.codename1.ui.events.ActionEvent;
import com.codename1.ui.events.ActionListener;
import com.codename1.ui.events.ComponentStateChangeEvent;
import com.codename1.ui.events.FocusListener;
import com.codename1.ui.events.ScrollListener;
import com.codename1.ui.events.StyleListener;
import com.codename1.ui.geom.Dimension;
import com.codename1.ui.geom.Rectangle;
import com.codename1.ui.layouts.FlowLayout;
import com.codename1.ui.plaf.Border;
import com.codename1.ui.plaf.LookAndFeel;
import com.codename1.ui.plaf.RoundBorder;
import com.codename1.ui.plaf.Style;
import com.codename1.ui.plaf.UIManager;
import com.codename1.ui.util.EventDispatcher;
import com.codename1.ui.util.Resources;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

/**
 * &lt;p&gt;The component class is the basis of all UI widgets in Codename One, to arrange multiple components
 * together we use the Container class which itself &quot;IS A&quot; Component subclass. The Container is a
 * Component that contains Components effectively allowing us to nest Containers infinitely to build any type
 * of visual hierarchy we want by nesting Containers.
 * &lt;/p&gt;
 *
 * &lt;h3&gt;Style Change Events&lt;/h3&gt;
 *
 * &lt;p&gt;Styles fire a change event for each style change that occurs.  {@link Component} listens to all changes events
 * of its styles, and adjusts some of its properties accordingly.  Currently (as of 6.0) each style change will trigger
 * a {@link Container#revalidate() } call on the Style's Component's parent container, which is expensive.  You can disable this
 * {@link Container#revalidate() } call by calling {@link CN.setProperty(&quot;Component.revalidateOnStyleChange&quot;, &quot;false&quot;)}.  This will
 * likely be the default behavior in a future version, so we recommend you disable this explicitly for both performance reasons, and
 * to avoid regressions when the default is changed.&lt;/p&gt;
 *
 * @author Chen Fishbein
 * @see Container
 */
public class Component implements Animation, StyleListener, Editable {

    /**
     * The default cursor
     */
    public static final int DEFAULT_CURSOR = 0;
    // -1 = the element should be focusable, but should not be reachable via sequential keyboard navigation. Mostly useful to create accessible widgets 
    // 0 =  the element should be focusable in sequential keyboard navigation, but its order is defined by the container's source order.
    /**
     * The crosshair cursor type.
     */
    public static final int CROSSHAIR_CURSOR = 1;
    /**
     * The text cursor type.
     */
    public static final int TEXT_CURSOR = 2;
    /**
     * The wait cursor type.
     */
    public static final int WAIT_CURSOR = 3;
    /**
     * The south-west-resize cursor type.
     */
    public static final int SW_RESIZE_CURSOR = 4;
    /**
     * The south-east-resize cursor type.
     */
    public static final int SE_RESIZE_CURSOR = 5;
    /**
     * The north-west-resize cursor type.
     */
    public static final int NW_RESIZE_CURSOR = 6;
    /**
     * The north-east-resize cursor type.
     */
    public static final int NE_RESIZE_CURSOR = 7;
    /**
     * The north-resize cursor type.
     */
    public static final int N_RESIZE_CURSOR = 8;
    /**
     * The south-resize cursor type.
     */
    public static final int S_RESIZE_CURSOR = 9;
    /**
     * The west-resize cursor type.
     */
    public static final int W_RESIZE_CURSOR = 10;
    /**
     * The east-resize cursor type.
     */
    public static final int E_RESIZE_CURSOR = 11;
    /**
     * The hand cursor type.
     */
    public static final int HAND_CURSOR = 12;
    /**
     * The move cursor type.
     */
    public static final int MOVE_CURSOR = 13;
    /**
     * Used by getDragRegionStatus to indicate no dragability
     */
    public static final int DRAG_REGION_NOT_DRAGGABLE = 1;
    /**
     * Used by getDragRegionStatus to indicate limited dragability
     */
    public static final int DRAG_REGION_POSSIBLE_DRAG_X = 10;
    /**
     * Used by getDragRegionStatus to indicate limited dragability
     */
    public static final int DRAG_REGION_POSSIBLE_DRAG_Y = 11;
    /**
     * Used by getDragRegionStatus to indicate limited dragability
     */
    public static final int DRAG_REGION_POSSIBLE_DRAG_XY = 12;
    /**
     * Used by getDragRegionStatus to indicate likely dragability
     */
    public static final int DRAG_REGION_LIKELY_DRAG_X = 21;
    /**
     * Used by getDragRegionStatus to indicate likely dragability
     */
    public static final int DRAG_REGION_LIKELY_DRAG_Y = 22;
    /**
     * Used by getDragRegionStatus to indicate likely dragability
     */
    public static final int DRAG_REGION_LIKELY_DRAG_XY = 23;
    /**
     * Used by getDragRegionStatus to indicate immediate dragability
     */
    public static final int DRAG_REGION_IMMEDIATELY_DRAG_X = 31;
    /**
     * Used by getDragRegionStatus to indicate immediate dragability
     */
    public static final int DRAG_REGION_IMMEDIATELY_DRAG_Y = 32;
    /**
     * Used by getDragRegionStatus to indicate immediate dragability
     */
    public static final int DRAG_REGION_IMMEDIATELY_DRAG_XY = 33;
    /**
     * Baseline resize behavior constant used to properly align components.
     * Indicates as the size of the component
     * changes the baseline remains a fixed distance from the top of the
     * component.
     *
     * @see #getBaselineResizeBehavior
     */
    public static final int BRB_CONSTANT_ASCENT = 1;
    /**
     * Baseline resize behavior constant used to properly align components. Indicates as the size of the component
     * changes the baseline remains a fixed distance from the bottom of the
     * component.
     *
     * @see #getBaselineResizeBehavior
     */
    public static final int BRB_CONSTANT_DESCENT = 2;
    /**
     * Baseline resize behavior constant used to properly align components. Indicates as the size of the component
     * changes the baseline remains a fixed distance from the center of the
     * component.
     *
     * @see #getBaselineResizeBehavior
     */
    public static final int BRB_CENTER_OFFSET = 3;
    /**
     * Baseline resize behavior constant used to properly align components. Indicates as the size of the component
     * changes the baseline can not be determined using one of the other
     * constants.
     *
     * @see #getBaselineResizeBehavior
     */
    public static final int BRB_OTHER = 4;
    /**
     * Indicates a Component center alignment
     */
    public static final int CENTER = 4;
    /**
     * Box-orientation constant used to specify the top of a box.
     */
    public static final int TOP = 0;
    /**
     * Box-orientation constant used to specify the left side of a box.
     */
    public static final int LEFT = 1;
    /**
     * Box-orientation constant used to specify the bottom of a box.
     */
    public static final int BOTTOM = 2;
    /**
     * Box-orientation constant used to specify the right side of a box.
     */
    public static final int RIGHT = 3;
    /**
     * Alignment to the baseline constraint
     */
    public static final int BASELINE = 5;
<span class="fc" id="L232">    private static final Rectangle tmpRect = new Rectangle();</span>
    /**
     * A flag to dictate whether style changes should trigger a revalidate() call
     * on the component's parent.  Eventually we would like to phase this to be {@literal false}
     * but for now, we'll leave it as {@literal true}.
     * &lt;p&gt;
     * Users can disable this with {@code CN.setProperty(&quot;Component.revalidateOnStyleChange&quot;, &quot;false&quot;)}.
     */
<span class="fc" id="L240">    static boolean revalidateOnStyleChange = true;</span>
<span class="fc" id="L241">    static int restoreDragPercentage = -1;</span>
<span class="fc" id="L242">    private static byte defaultDragTransparency = 55;</span>
<span class="fc" id="L243">    private static boolean disableSmoothScrolling = false;</span>
    private static boolean paintLockEnableChecked;
    private static boolean paintLockEnabled;
<span class="fc" id="L246">    private final Rectangle bounds = new Rectangle(0, 0, new Dimension(0, 0));</span>
<span class="fc" id="L247">    private final Object dirtyRegionLock = new Object();</span>
    boolean hasLead;
    /**
     * The elevation at which this component was rendered in its last rendering.
     *
     * @since 8.0
     */
    int renderedElevation;
    /**
     * The index at which this component was rendered in its last rendering.  This acts as a z-index within
     * an elevation layer.
     *
     * @since 8.0
     */
    int renderedElevationComponentIndex;
    Dimension scrollSize;
<span class="fc" id="L263">    boolean shouldCalcPreferredSize = true;</span>
<span class="fc" id="L264">    boolean shouldCalcScrollSize = true;</span>
    Motion draggedMotionX;
    Motion draggedMotionY;
    boolean noBind;
    EventDispatcher pointerPressedListeners;
    EventDispatcher pointerReleasedListeners;
    EventDispatcher pointerDraggedListeners;
    EventDispatcher dragFinishedListeners;
    EventDispatcher longPressListeners;
    boolean isUnselectedStyle;
    /**
     * A flag used by {@link Container#paintElevatedPane(Graphics)} to turn off rendering of elevated components
     * when rendering the non-elevated pane.
     */
    boolean doNotPaint;
    /**
     * A flag that tracks whether the component is current registered as an animated with {@link Form#registerAnimatedInternal(Animation)}.
     * Using this flag allows for a small efficiency improvement.  The flag is set in {@link Form#registerAnimatedInternal(Animation)} and
     * unset in {@link Form#deregisterAnimatedInternal()}.
     */
    boolean internalRegisteredAnimated;
    private int tabIndex;
<span class="fc" id="L286">    private int preferredTabIndex = -1;</span>
    /**
     * Indicates whether the component displays the material design ripple effect
     */
    private boolean rippleEffect;
    private int cursor;
    private String selectText;
    private boolean alwaysTensile;
<span class="fc" id="L294">    private int tensileLength = -1;</span>
    /**
     * Prevent a lead component hierarchy from this specific component, this allows a component within that
     * hierarchy to still act as a standalone component
     */
    private boolean blockLead;
    /**
     * Allows us to determine which component will receive focus next when traversing
     * with the down key
     */
    private Component nextFocusDown;
    private Component nextFocusUp;
    private Editable editingDelegate;
    /**
     * Indicates whether component is enabled or disabled
     */
<span class="fc" id="L310">    private boolean enabled = true;</span>
    /**
     * Allows us to determine which component will receive focus next when traversing
     * with the right key
     */
    private Component nextFocusRight;
    private Component nextFocusLeft;
    private String name;
    /**
     * A flag to toggle between lightweight elevation shadow generation and heavyweight generation.  The lightweight
     * does the work entirely in CN1 and it cuts corners.  In simulator, it turns out that the heavyweight implementation
     * is too slow to be useful.  This may not be the case on other platforms, but, for now, we'll leave this flag on.
     * Later on, after evaluation, this flag will likely be removed, and the best strategy will be decided upon.
     */
<span class="fc" id="L324">    private final boolean useLightweightElevationShadow = true;</span>
    /**
     * This property is useful for blocking in z-order touch events, sometimes we might want to grab touch events in
     * a specific component without making it focusable.
     */
    private boolean grabsPointerEvents;
    /**
     * Indicates whether tensile drag (dragging beyond the boundary of the component and
     * snapping back) is enabled for this component.
     */
    private boolean tensileDragEnabled;
    /**
     * Indicates whether tensile highlight (drawing a highlight effect when reaching the edge) is enabled for this component.
     */
    private boolean tensileHighlightEnabled;
    private int tensileHighlightIntensity;
    /**
     * Indicates whether the component should &quot;trigger&quot; tactile touch when pressed by the user
     * in a touch screen UI.
     */
    private boolean tactileTouch;
<span class="fc" id="L345">    private boolean visible = true;</span>
    /**
     * Used as an optimization to mark that this component is currently being
     * used as a cell renderer
     */
    private boolean cellRenderer;
    private Rectangle painterBounds;
    private int scrollX;
    private int scrollY;
<span class="fc" id="L354">    private boolean sizeRequestedByUser = false;</span>
    private Dimension preferredSize;
<span class="fc" id="L356">    private boolean scrollSizeRequestedByUser = false;</span>
    private Style unSelectedStyle;
    private Style pressedStyle;
    private Style selectedStyle;
    private Style disabledStyle;
    private Style allStyles;
    private Container parent;
    private Component owner;
<span class="fc" id="L364">    private boolean focused = false;</span>
<span class="fc" id="L365">    private boolean handlesInput = false;</span>
<span class="fc" id="L366">    private boolean focusable = true;</span>
<span class="fc" id="L367">    private boolean isScrollVisible = true;</span>
    private boolean repaintPending;
    private boolean snapToGrid;
<span class="fc" id="L370">    private byte dragTransparency = defaultDragTransparency;</span>
    // A flag to indicate whether to paint the component's background.
    // Setting this to false will cause the component's background to not be painted.
<span class="fc" id="L373">    private boolean opaque = true;</span>
    private boolean hideInPortrait;
    /**
     * Indicates that this component and all its children should be hidden when the device is switched to landscape mode
     */
    private boolean hideInLandscape;
<span class="fc" id="L379">    private int scrollOpacity = 0xff;</span>
    private boolean ignorePointerEvents;
    /**
     * Indicates the decrement units for the scroll opacity
     */
<span class="fc" id="L384">    private int scrollOpacityChangeSpeed = 5;</span>
    /**
     * Indicates that moving through the component should work as an animation
     */
    private boolean smoothScrolling;
    /**
     * Animation speed in milliseconds allowing a developer to slow down or accelerate
     * the smooth animation mode
     */
    private int animationSpeed;
    private Motion animationMotion;
    // Reference that is only filled when a drag motion is a decelration motion
    // for tensile scrolling
    private Motion decelerationMotion;
    /**
     * Allows us to flag a drag operation in action thus preventing the mouse pointer
     * release event from occurring.
     */
    private boolean dragActivated;
    private int oldx, oldy, draggedx, draggedy;
<span class="fc" id="L404">    private int initialScrollY = -1;</span>
<span class="fc" id="L405">    private int destScrollY = -1;</span>
    private int lastScrollY;
    private int lastScrollX;
    private int pullY;
    private boolean shouldGrabScrollEvents;
    /**
     * Indicates if the component is in the initialized state, a component is initialized
     * when its initComponent() method was invoked. The initMethod is invoked before showing the
     * component to the user.
     */
    private boolean initialized;
    private HashMap&lt;String, Object&gt; clientProperties;
<span class="fc" id="L417">    private Rectangle dirtyRegion = null;</span>
    private Label componentLabel;
    private String portraitUiid;
    private String landscapeUiid;
    private Resources inlineStylesTheme;
    private String inlineAllStyles;
    private String inlinePressedStyles;
    private String inlineDisabledStyles;
    private String inlineSelectedStyles;
    private String inlineUnselectedStyles;
    /**
     * Is the component a bidi RTL component
     */
    private boolean rtl;
    private boolean flatten;
    private Object paintLockImage;
    private boolean draggable;
    private boolean dragAndDropInitialized;
    private boolean dropTarget;
    private Image dragImage;
    private Component dropTargetComponent;
<span class="fc" id="L438">    private int dragCallbacks = 0;</span>
    private String cloudBoundProperty;
    private String cloudDestinationProperty;
    private Runnable refreshTask;
    private ActionListener&lt;?&gt; refreshTaskDragListener;
    private double pinchDistance;
    private Component[] sameWidth;
    private Component[] sameHeight;
    private EventDispatcher focusListeners;
    private EventDispatcher scrollListeners;
    private EventDispatcher dropListener;
    private EventDispatcher dragOverListener;
    private EventDispatcher stateChangeListeners;
    private String tooltip;
    private String accessibilityText;
    /**
     * The native overlay object.  Used in Javascript port for some components so that there is
     * an inivisible &quot;native&quot; peer overlaid on the component itself to catch events.  E.g.
     * TextFields on iOS can't be programmatically focused except through a user-initiated event -
     * but since CN1 runs on the EDT, CN1 events aren't considered user-initiated so we can't create
     * a native text editor on demand the way we do in desktop port - the native text editor must
     * be *always* present.
     */
<span class="fc" id="L461">    private Object nativeOverlay = null;</span>
    /**
     * Optional string the specifies the preferred size of the component. Format is {@literal &lt;width&gt; &lt;height&gt;}
     * where {@literal &lt;width&gt;} and {@literal &lt;height&gt;} are both scalar values.  E.g. &quot;15px&quot;, &quot;20.5mm&quot;, or &quot;inherit&quot;
     * to indicate that it should inherit the value returned from {@link #calcPreferredSize() } for that coordinate.
     */
    private String preferredSizeStr;
    /**
     * A cached image that is used for rendering drop-shadows.  This is only updated when the component elevation, width, or height
     * is changed.  Otherwise it is reused for painting shadows.
     *
     * @see #paintShadows(Graphics, int, int)
     */
    private Image cachedShadowImage;
    /**
     * The elevation of the component when the {@link #cachedShadowImage} was created.
     */
    private int cachedShadowElevation;
    /**
     * The width of the component when the {@link #cachedShadowImage} was created.
     */
    private int cachedShadowWidth,

    /**
     * The height of the component when the  {@link #cachedShadowImage} was created.
     */
    cachedShadowHeight;
    /**
     * Flag to indicate whether the component has elevation.
     */
    private boolean _hasElevation;
    /**
     * A flag to prevent reentry into painting the shadow.
     */
<span class="fc" id="L495">    private boolean paintinShadowInBackground_ = false;</span>
    private boolean inPinch;
    private boolean pinchBlocksDragAndDrop;
    /**
     * Holds a reference to the current surface this this component is registered with.
     *
     * @see #registerElevatedInternal(Component)
     * @see Container#addElevatedComponent(Component)
     * @see Container#removeElevatedComponent(Component)
     * @since 8.0
     */
    private Container _parentSurface;


    /**
     * Creates a new instance of Component
     */
<span class="fc" id="L512">    protected Component() {</span>
<span class="fc" id="L513">        initLaf(getUIManager());</span>
<span class="fc" id="L514">        setCursor(DEFAULT_CURSOR);</span>
<span class="fc" id="L515">    }</span>

    /**
     * This is identical to invoking {@link #sameWidth} followed by {@link #sameHeight}
     *
     * @param c the components to group together, this will override all previous width/height grouping
     */
    public static void setSameSize(Component... c) {
<span class="fc" id="L523">        setSameWidth(c);</span>
<span class="fc" id="L524">        setSameHeight(c);</span>
<span class="fc" id="L525">    }</span>

    /**
     * Checks to see if this platform supports cursors.  If the platform doesn't support cursors then any cursors
     * set with {@link #setCursor(int) } will simply be ignored.
     *
     * @return True if the platform supports custom cursors.
     */
    public static boolean isSetCursorSupported() {
<span class="fc" id="L534">        return Display.getInstance().getImplementation().isSetCursorSupported();</span>
    }

    /**
     * Parses the preferred size given as a string
     *
     * @param preferredSize a string representing a width/height preferred size using common units e.g. mm, px etc.
     * @param baseSize      used as the starting point for the calculation, typically the preferred size of the component
     * @return the parsed results
     */
    public static Dimension parsePreferredSize(String preferredSize, Dimension baseSize) {
<span class="fc" id="L545">        int spacePos = preferredSize.indexOf(&quot; &quot;);</span>
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">        if (spacePos == -1) {</span>
<span class="nc" id="L547">            return baseSize;</span>
        }
<span class="fc" id="L549">        String wStr = preferredSize.substring(0, spacePos).trim();</span>
<span class="fc" id="L550">        String hStr = preferredSize.substring(spacePos + 1).trim();</span>
        int unitPos;
<span class="fc" id="L552">        float pixelsPerMM = Display.getInstance().convertToPixels(1000f) / 1000f;</span>
        try {
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">            if ((unitPos = wStr.indexOf(&quot;mm&quot;)) != -1) {</span>
<span class="nc" id="L555">                baseSize.setWidth(Math.round(Float.parseFloat(wStr.substring(0, unitPos)) * pixelsPerMM));</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">            } else if ((unitPos = wStr.indexOf(&quot;px&quot;)) != -1) {</span>
<span class="fc" id="L557">                baseSize.setWidth(Integer.parseInt(wStr.substring(0, unitPos)));</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">            } else if (!&quot;inherit&quot;.equals(wStr)) {</span>
<span class="fc" id="L559">                baseSize.setWidth(Integer.parseInt(wStr));</span>
            }
<span class="nc" id="L561">        } catch (Throwable t) {</span>
<span class="fc" id="L562">        }</span>

        try {
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">            if ((unitPos = hStr.indexOf(&quot;mm&quot;)) != -1) {</span>
<span class="nc" id="L566">                baseSize.setHeight(Math.round(Float.parseFloat(hStr.substring(0, unitPos)) * pixelsPerMM));</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">            } else if ((unitPos = hStr.indexOf(&quot;px&quot;)) != -1) {</span>
<span class="fc" id="L568">                baseSize.setHeight(Integer.parseInt(hStr.substring(0, unitPos)));</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">            } else if (!&quot;inherit&quot;.equals(hStr)) {</span>
<span class="fc" id="L570">                baseSize.setHeight(Integer.parseInt(hStr));</span>
            }
<span class="nc" id="L572">        } catch (Throwable t) {</span>
<span class="fc" id="L573">        }</span>
<span class="fc" id="L574">        return baseSize;</span>
    }

    /**
     * Disable smooth scrolling on all components
     *
     * @param disableSmoothScrolling false to disable
     */
    static void setDisableSmoothScrolling(boolean disableSmoothScrolling) {
<span class="fc" id="L583">        Component.disableSmoothScrolling = disableSmoothScrolling;</span>
<span class="fc" id="L584">    }</span>

    /**
     * Returns the default translucency used in the {@link #getDragImage()} method.
     *
     * @return a number between 0 and 255 where 255 indicates an opaque image.
     */
    public static byte getDefaultDragTransparency() {
<span class="fc" id="L592">        return defaultDragTransparency;</span>
    }

    /**
     * Sets the default translucency of the {@link #getDragImage()} method.
     *
     * @param defaultDragTransparency a number between 0 and 255 where 255
     *                                indicates an opaque image.
     */
    public static void setDefaultDragTransparency(byte defaultDragTransparency) {
<span class="fc" id="L602">        Component.defaultDragTransparency = defaultDragTransparency;</span>
<span class="fc" id="L603">    }</span>

    boolean isDragAndDropInitialized() {
<span class="fc" id="L606">        return dragAndDropInitialized;</span>
    }

    /**
     * Gets the delegate that handles the editing of this component.
     *
     * @return The editing delegate for this component.
     * @since 6.0
     */
    public Editable getEditingDelegate() {
<span class="fc" id="L616">        return this.editingDelegate;</span>
    }

    /**
     * Sets the editing delegate for this component.  The editing delegate allows you to define the
     * editing workflow for a component.  If a delegate is registered, then editing methods such as
     * {@link #isEditable() }, {@link #isEditing() }, {@link #startEditingAsync() }, and {@link #stopEditing(java.lang.Runnable) }
     * will be delegated to the delegate object.
     *
     * @param editable An editable delegate.
     * @since 6.0
     */
    public void setEditingDelegate(Editable editable) {
<span class="fc" id="L629">        this.editingDelegate = editable;</span>
<span class="fc" id="L630">    }</span>

    /**
     * Gets the custom cursor for this component.  This will only be used if the platform supports custom cursors.
     * You can call {@link #isSetCursorSupported() } to find out.
     *
     * @return The cursor to set on this component.  One of {@link #DEFAULT_CURSOR}, {@link #CROSSHAIR_CURSOR}, {@link #TEXT_CURSOR},
     * {@link #WAIT_CURSOR}, {@link #SW_RESIZE_CURSOR}, {@link #SE_RESIZE_CURSOR}, {@link #S_RESIZE_CURSOR}, {@link #NE_RESIZE_CURSOR},
     * {@link #NW_RESIZE_CURSOR}, {@link #W_RESIZE_CURSOR}, {@link #HAND_CURSOR}, or {@link #MOVE_CURSOR}.
     */
    public int getCursor() {
<span class="fc" id="L641">        return this.cursor;</span>
    }

    /**
     * Sets a custom mouse cursor for this component if the platform supports mouse cursors, notice that this isn't applicable for touch devices.
     * This will only be used if the platform supports custom cursors.
     * You can call {@link #isSetCursorSupported() } to find out.
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Since cursors incur some overhead, they are turned off at the form level by default.
     * If you want your custom cursors to be used, then you'll need to enable cursors in the form using {@link Form#setEnableCursors(boolean) }.&lt;/p&gt;
     *
     * @param cursor The cursor to set on this component.  One of {@link #DEFAULT_CURSOR}, {@link #CROSSHAIR_CURSOR}, {@link #TEXT_CURSOR},
     *               {@link #WAIT_CURSOR}, {@link #SW_RESIZE_CURSOR}, {@link #SE_RESIZE_CURSOR}, {@link #S_RESIZE_CURSOR}, {@link #NE_RESIZE_CURSOR},
     *               {@link #NW_RESIZE_CURSOR}, {@link #W_RESIZE_CURSOR}, {@link #HAND_CURSOR}, or {@link #MOVE_CURSOR}.
     * @see Form#setEnableCursors(boolean)
     * @see Form#isEnableCursors()
     */
    public void setCursor(int cursor) {
<span class="fc" id="L659">        this.cursor = cursor;</span>
<span class="fc" id="L660">    }</span>

    /**
     * Creates the native overlay for this component. A native overlay is used on some platforms (e.g. Javascript)
     * to help with user interaction of the component in a native way.
     *
     * @see #hideNativeOverlay()
     * @see #updateNativeOverlay()
     * @see #getNativeOverlay()
     */
    protected void showNativeOverlay() {
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">        if (nativeOverlay == null) {</span>
<span class="fc" id="L672">            nativeOverlay = Display.getInstance().getImplementation().createNativeOverlay(this);</span>
        }
<span class="fc" id="L674">    }</span>

    /**
     * Hides the native overlay for this component.
     *
     * @see #showNativeOverlay()
     * @see #updateNativeOverlay()
     * @see #getNativeOverlay()
     */
    protected void hideNativeOverlay() {
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">        if (nativeOverlay != null) {</span>
<span class="nc" id="L685">            Display.getInstance().getImplementation().hideNativeOverlay(this, nativeOverlay);</span>
<span class="nc" id="L686">            nativeOverlay = null;</span>
        }
<span class="fc" id="L688">    }</span>

    /**
     * Updates the native overlay for this component.  This is called each time the component
     * is laid out, so it can change the position and visibility to match the current context.
     *
     * @see #showNativeOverlay()
     * @see #hideNativeOverlay()
     * @see #getNativeOverlay()
     */
    protected void updateNativeOverlay() {
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">        if (nativeOverlay != null) {</span>
<span class="nc" id="L700">            Display.getInstance().getImplementation().updateNativeOverlay(this, nativeOverlay);</span>
        }
<span class="fc" id="L702">    }</span>

    /**
     * Gets the native overlay for this component.  May be null. Native overlays are used in the Javascript
     * port to assist with user interaction on touch devices.  Text fields use native overlays to position
     * an invisible native text field above themselves so that the keyboard will be activated properly when
     * the user taps the text field.
     *
     * @return The native overlay
     */
    public Object getNativeOverlay() {
<span class="nc" id="L713">        return nativeOverlay;</span>
    }

    /**
     * Returns a &quot;meta style&quot; that allows setting styles once to all the different Style objects, the getters for this
     * style will be meaningless and will return 0 values. Usage:
     *
     * &lt;script src=&quot;https://gist.github.com/codenameone/31a32bdcf014a9e55a95.js&quot;&gt;&lt;/script&gt;
     *
     * @return a unified style object for the purpose of setting on object object instances
     */
    public Style getAllStyles() {
<span class="fc bfc" id="L725" title="All 2 branches covered.">        if (allStyles == null) {</span>
<span class="fc" id="L726">            allStyles = Style.createProxyStyle(getUnselectedStyle(), getSelectedStyle(), getPressedStyle(), getDisabledStyle());</span>
        }
<span class="fc" id="L728">        return allStyles;</span>
    }

    /**
     * Returns the array of components that have an equal width
     *
     * @return components in the same width group
     */
    public Component[] getSameWidth() {
<span class="fc" id="L737">        return sameWidth;</span>
    }

    /**
     * Places all of these components in the same width group, to remove a component from
     * the group invoke this method with that component only.
     *
     * @param c the components to group together, this will override all previous width grouping
     */
    public static void setSameWidth(Component... c) {
<span class="fc bfc" id="L747" title="All 2 branches covered.">        if (c.length == 1) {</span>
            // special case, remove grouping
<span class="fc bfc" id="L749" title="All 2 branches covered.">            if (c[0].sameWidth != null) {</span>
<span class="fc" id="L750">                ArrayList&lt;Component&gt; lst = new ArrayList&lt;Component&gt;(Arrays.asList(c[0].sameWidth));</span>
<span class="fc" id="L751">                lst.remove(c[0]);</span>
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">                if (lst.size() == 1) {</span>
<span class="nc" id="L753">                    lst.get(0).sameWidth = null;</span>
                } else {
<span class="pc bpc" id="L755" title="1 of 2 branches missed.">                    if (lst.size() &gt; 0) {</span>
<span class="fc" id="L756">                        Component[] cmps = new Component[lst.size()];</span>
<span class="fc" id="L757">                        lst.toArray(cmps);</span>
<span class="fc" id="L758">                        setSameWidth(cmps);</span>
                    }
                }
<span class="fc" id="L761">                c[0].sameWidth = null;</span>
<span class="fc" id="L762">            }</span>
        } else {
<span class="fc bfc" id="L764" title="All 2 branches covered.">            for (Component cc : c) {</span>
<span class="fc" id="L765">                cc.sameWidth = c;</span>
            }
        }
<span class="fc" id="L768">    }</span>

    /**
     * Returns the array of components that have an equal height
     *
     * @return components in the same height group
     */
    public Component[] getSameHeight() {
<span class="fc" id="L776">        return sameHeight;</span>
    }

    /**
     * Places all of these components in the same height group, to remove a component from
     * the group invoke this method with that component only.
     *
     * @param c the components to group together, this will override all previous height grouping
     */
    public static void setSameHeight(Component... c) {
<span class="fc bfc" id="L786" title="All 2 branches covered.">        if (c.length == 1) {</span>
            // special case, remove grouping
<span class="pc bpc" id="L788" title="1 of 2 branches missed.">            if (c[0].sameHeight != null) {</span>
<span class="fc" id="L789">                ArrayList&lt;Component&gt; lst = new ArrayList&lt;Component&gt;(Arrays.asList(c[0].sameHeight));</span>
<span class="fc" id="L790">                lst.remove(c[0]);</span>
<span class="pc bpc" id="L791" title="1 of 2 branches missed.">                if (lst.size() == 1) {</span>
<span class="fc" id="L792">                    lst.get(0).sameHeight = null;</span>
                } else {
<span class="nc bnc" id="L794" title="All 2 branches missed.">                    if (lst.size() &gt; 0) {</span>
<span class="nc" id="L795">                        Component[] cmps = new Component[lst.size()];</span>
<span class="nc" id="L796">                        lst.toArray(cmps);</span>
<span class="nc" id="L797">                        setSameHeight(cmps);</span>
                    }
                }
<span class="fc" id="L800">                c[0].sameHeight = null;</span>
<span class="fc" id="L801">            }</span>
        } else {
<span class="fc bfc" id="L803" title="All 2 branches covered.">            for (Component cc : c) {</span>
<span class="fc" id="L804">                cc.sameHeight = c;</span>
            }
        }
<span class="fc" id="L807">    }</span>

    /**
     * This method initializes the Component defaults constants
     */
    protected void initLaf(UIManager uim) {
<span class="pc bpc" id="L813" title="1 of 4 branches missed.">        if (uim == getUIManager() &amp;&amp; isInitialized()) {</span>
<span class="nc" id="L814">            return;</span>
        }
<span class="fc" id="L816">        selectText = uim.localize(&quot;select&quot;, &quot;Select&quot;);</span>
<span class="fc" id="L817">        LookAndFeel laf = uim.getLookAndFeel();</span>
<span class="fc" id="L818">        animationSpeed = laf.getDefaultSmoothScrollingSpeed();</span>
<span class="fc" id="L819">        rtl = laf.isRTL();</span>
<span class="fc" id="L820">        tactileTouch = isFocusable();</span>
<span class="fc" id="L821">        tensileDragEnabled = laf.isDefaultTensileDrag();</span>
<span class="fc" id="L822">        snapToGrid = laf.isDefaultSnapToGrid();</span>
<span class="fc" id="L823">        alwaysTensile = laf.isDefaultAlwaysTensile();</span>
<span class="fc" id="L824">        tensileHighlightEnabled = laf.isDefaultTensileHighlight();</span>
<span class="fc" id="L825">        scrollOpacityChangeSpeed = laf.getFadeScrollBarSpeed();</span>
<span class="fc" id="L826">        isScrollVisible = laf.isScrollVisible();</span>

<span class="pc bpc" id="L828" title="1 of 2 branches missed.">        if (tensileHighlightEnabled) {</span>
<span class="nc" id="L829">            tensileLength = 3;</span>
        } else {
<span class="fc" id="L831">            tensileLength = -1;</span>
        }
<span class="fc" id="L833">    }</span>

    /**
     * Gets the UIID that would be used for this component if inline styles are used.
     * Generally this UIID follows the format: {@literal id[name]} where &quot;id&quot; is the UIID of
     * the component, and &quot;name&quot; is the name of the component.
     *
     * @return the style text or null
     * @see #getInlineStylesUIID()
     */
    private String getInlineStylesUIID() {
<span class="nc" id="L844">        return getUIID() + &quot;[&quot; + getName() + &quot;]&quot;;</span>
    }

    /**
     * Gets the UIID that would be used for this component if inline styles are used.
     * Generally this UIID follows the format: {@literal id[name]} where &quot;id&quot; is the UIID of
     * the component, and &quot;name&quot; is the name of the component.
     *
     * @param id UIID to use as the base.
     * @return the style text or null
     * @see #getInlineStylesUIID()
     */
    private String getInlineStylesUIID(String id) {
<span class="nc" id="L857">        return id + &quot;[&quot; + getName() + &quot;]&quot;;</span>
    }

    /**
     * Checks to see if the component has any inline styles registered for its unselected state.
     *
     * @return True if the component has inline styles registered for the unselected state.
     */
    private boolean hasInlineUnselectedStyle() {
<span class="pc bpc" id="L866" title="5 of 6 branches missed.">        return getInlineStylesTheme() != null &amp;&amp; (inlineAllStyles != null || inlineUnselectedStyles != null);</span>
    }

    /**
     * Checks to see if the component has any inline styles registered for its pressed state.
     *
     * @return True if the component has inline styles registered for the pressed state.
     */
    private boolean hasInlinePressedStyle() {
<span class="pc bpc" id="L875" title="5 of 6 branches missed.">        return getInlineStylesTheme() != null &amp;&amp; (inlineAllStyles != null || inlinePressedStyles != null);</span>
    }

    /**
     * Checks to see if the component has any inline styles registered for its disabled state.
     *
     * @return True if the component has inline styles registered for the disabled state.
     */
    private boolean hasInlineDisabledStyle() {
<span class="pc bpc" id="L884" title="5 of 6 branches missed.">        return getInlineStylesTheme() != null &amp;&amp; (inlineAllStyles != null || inlineDisabledStyles != null);</span>
    }

    /**
     * Checks to see if the component has any inline styles registered for its selected state.
     *
     * @return True if the component has inline styles registered for the selected state.
     */
    private boolean hasInlineSelectedStyle() {
<span class="pc bpc" id="L893" title="5 of 6 branches missed.">        return getInlineStylesTheme() != null &amp;&amp; (inlineAllStyles != null || inlineSelectedStyles != null);</span>
    }

    /**
     * Gets array of style strings to be used for inline unselected style. This may include
     * the {@link #inlineAllStyles} string and/or the {@link #inlineUnselectedStyles} string.
     *
     * @return Array of inline style strings to be applied to pressed state.  Or null if
     * none specified.
     */
    private String[] getInlineUnselectedStyleStrings() {
<span class="nc bnc" id="L904" title="All 2 branches missed.">        if (inlineAllStyles != null) {</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">            if (inlineUnselectedStyles != null) {</span>
<span class="nc" id="L906">                return new String[]{inlineAllStyles, inlineUnselectedStyles};</span>
            } else {
<span class="nc" id="L908">                return new String[]{inlineAllStyles};</span>
            }
        } else {
<span class="nc bnc" id="L911" title="All 2 branches missed.">            if (inlineUnselectedStyles != null) {</span>
<span class="nc" id="L912">                return new String[]{inlineUnselectedStyles};</span>
            } else {
<span class="nc" id="L914">                return null;</span>
            }

        }
    }

    /**
     * Gets array of style strings to be used for inline selected style. This may include
     * the {@link #inlineAllStyles} string and/or the {@link #inlineSelectedStyles} string.
     *
     * @return Array of inline style strings to be applied to pressed state.  Or null if
     * none specified.
     */
    private String[] getInlineSelectedStyleStrings() {
<span class="nc bnc" id="L928" title="All 2 branches missed.">        if (inlineAllStyles != null) {</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">            if (inlineSelectedStyles != null) {</span>
<span class="nc" id="L930">                return new String[]{inlineAllStyles, inlineSelectedStyles};</span>
            } else {
<span class="nc" id="L932">                return new String[]{inlineAllStyles};</span>
            }
        } else {
<span class="nc bnc" id="L935" title="All 2 branches missed.">            if (inlineSelectedStyles != null) {</span>
<span class="nc" id="L936">                return new String[]{inlineSelectedStyles};</span>
            } else {
<span class="nc" id="L938">                return null;</span>
            }

        }
    }

    /**
     * Gets array of style strings to be used for inline pressed style. This may include
     * the {@link #inlineAllStyles} string and/or the {@link #inlinePressedStyles} string.
     *
     * @return Array of inline style strings to be applied to pressed state.  Or null if
     * none specified.
     */
    private String[] getInlinePressedStyleStrings() {
<span class="nc bnc" id="L952" title="All 2 branches missed.">        if (inlineAllStyles != null) {</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">            if (inlinePressedStyles != null) {</span>
<span class="nc" id="L954">                return new String[]{inlineAllStyles, inlinePressedStyles};</span>
            } else {
<span class="nc" id="L956">                return new String[]{inlineAllStyles};</span>
            }
        } else {
<span class="nc bnc" id="L959" title="All 2 branches missed.">            if (inlinePressedStyles != null) {</span>
<span class="nc" id="L960">                return new String[]{inlinePressedStyles};</span>
            } else {
<span class="nc" id="L962">                return null;</span>
            }

        }
    }

    /**
     * Gets array of style strings to be used for inline disabled style. This may include
     * the {@link #inlineAllStyles} string and/or the {@link #inlineDisabledStyles} string.
     *
     * @return Array of inline style strings to be applied to disabled state.  Or null if
     * none specified.
     */
    private String[] getInlineDisabledStyleStrings() {
<span class="nc bnc" id="L976" title="All 2 branches missed.">        if (inlineAllStyles != null) {</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">            if (inlineDisabledStyles != null) {</span>
<span class="nc" id="L978">                return new String[]{inlineAllStyles, inlineDisabledStyles};</span>
            } else {
<span class="nc" id="L980">                return new String[]{inlineAllStyles};</span>
            }
        } else {
<span class="nc bnc" id="L983" title="All 2 branches missed.">            if (inlineDisabledStyles != null) {</span>
<span class="nc" id="L984">                return new String[]{inlineDisabledStyles};</span>
            } else {
<span class="nc" id="L986">                return null;</span>
            }

        }
    }

    void setSurface(boolean surface) {

<span class="fc" id="L994">    }</span>

    private void initStyle() {
<span class="pc bpc" id="L997" title="1 of 2 branches missed.">        if (hasInlineUnselectedStyle()) {</span>
<span class="nc" id="L998">            unSelectedStyle = getUIManager().parseComponentStyle(getInlineStylesTheme(), getUIID(), getInlineStylesUIID(), getInlineUnselectedStyleStrings());</span>
        } else {
<span class="fc" id="L1000">            unSelectedStyle = getUIManager().getComponentStyle(getUIID());</span>
        }
<span class="fc" id="L1002">        initUnselectedStyle(unSelectedStyle);</span>
<span class="fc" id="L1003">        lockStyleImages(unSelectedStyle);</span>
<span class="pc bpc" id="L1004" title="1 of 2 branches missed.">        if (unSelectedStyle != null) {</span>
<span class="pc bpc" id="L1005" title="1 of 4 branches missed.">            if (initialized &amp;&amp; unSelectedStyle.getElevation() &gt; 0) {</span>
<span class="nc" id="L1006">                registerElevatedInternal(this);</span>
            }
<span class="fc bfc" id="L1008" title="All 2 branches covered.">            if (initialized) {</span>
<span class="fc" id="L1009">                setSurface(unSelectedStyle.isSurface());</span>
            }
<span class="fc" id="L1011">            unSelectedStyle.addStyleListener(this);</span>
<span class="pc bpc" id="L1012" title="1 of 2 branches missed.">            if (unSelectedStyle.getBgPainter() == null) {</span>
<span class="fc" id="L1013">                unSelectedStyle.setBgPainter(new BGPainter());</span>
            }
<span class="fc bfc" id="L1015" title="All 2 branches covered.">            if (cellRenderer) {</span>
<span class="fc" id="L1016">                unSelectedStyle.markAsRendererStyle();</span>
            }
        }
<span class="fc bfc" id="L1019" title="All 2 branches covered.">        if (disabledStyle != null) {</span>
<span class="pc bpc" id="L1020" title="2 of 4 branches missed.">            if (initialized &amp;&amp; disabledStyle.getElevation() &gt; 0) {</span>
<span class="nc" id="L1021">                registerElevatedInternal(this);</span>
            }
<span class="pc bpc" id="L1023" title="1 of 2 branches missed.">            if (initialized) {</span>
<span class="fc" id="L1024">                setSurface(disabledStyle.isSurface());</span>
            }
<span class="fc" id="L1026">            disabledStyle.addStyleListener(this);</span>
<span class="pc bpc" id="L1027" title="1 of 2 branches missed.">            if (disabledStyle.getBgPainter() == null) {</span>
<span class="nc" id="L1028">                disabledStyle.setBgPainter(new BGPainter());</span>
            }
<span class="pc bpc" id="L1030" title="1 of 2 branches missed.">            if (cellRenderer) {</span>
<span class="nc" id="L1031">                disabledStyle.markAsRendererStyle();</span>
            }
        }
<span class="fc" id="L1034">    }</span>

    /**
     * This method should be used by the Component to retrieve the correct UIManager to work with
     *
     * @return a UIManager instance
     */
    public UIManager getUIManager() {
<span class="fc" id="L1042">        Container parent = getParent();</span>
        //if no parent return the default UIManager
<span class="fc bfc" id="L1044" title="All 2 branches covered.">        if (parent == null) {</span>
<span class="fc" id="L1045">            return UIManager.getInstance();</span>
        }
<span class="fc" id="L1047">        return parent.getUIManager();</span>
    }

    /**
     * Returns the current component x location relatively to its parent container
     *
     * @return the current x coordinate of the components origin
     */
    public int getX() {
<span class="fc" id="L1056">        return bounds.getX();</span>
    }

    /**
     * Sets the Component x location relative to the parent container, this method
     * is exposed for the purpose of external layout managers and should not be invoked
     * directly.
     *
     * @param x the current x coordinate of the components origin
     */
    public void setX(int x) {
<span class="fc" id="L1067">        bounds.setX(x);</span>
<span class="fc bfc" id="L1068" title="All 2 branches covered.">        if (Form.activePeerCount &gt; 0) {</span>
<span class="fc" id="L1069">            onParentPositionChange();</span>
        }
<span class="fc" id="L1071">    }</span>

    /**
     * Gets the x-coordinate of the outer bounds of this component.  The outer bounds are formed
     * by the bounds outside the margin of the component.  (i.e. {@code x - leftMargin}).
     *
     * @return The outer X bound.
     */
    public int getOuterX() {
<span class="fc" id="L1080">        return getX() - getStyle().getMarginLeftNoRTL();</span>
    }

    /**
     * Gets x-coordinate of the inner bounds of this component.  The inner bounds are formed by
     * the bounds of the padding of the component.  i.e. {@code x + leftPadding}.
     *
     * @return The inner x bound.
     */
    public int getInnerX() {
<span class="fc" id="L1090">        return getX() + getStyle().getMarginLeftNoRTL();</span>
    }

    /**
     * Returns the component y location relatively to its parent container
     *
     * @return the current y coordinate of the components origin
     */
    public int getY() {
<span class="fc" id="L1099">        return bounds.getY();</span>
    }

    /**
     * Sets the Component y location relative to the parent container, this method
     * is exposed for the purpose of external layout managers and should not be invoked
     * directly.
     *
     * @param y the current y coordinate of the components origin
     */
    public void setY(int y) {
<span class="fc" id="L1110">        bounds.setY(y);</span>
<span class="fc bfc" id="L1111" title="All 2 branches covered.">        if (Form.activePeerCount &gt; 0) {</span>
<span class="fc" id="L1112">            onParentPositionChange();</span>
        }
<span class="fc" id="L1114">    }</span>

    /**
     * Gets the Y-coordinate of the outer bounds of this component.  The outer bounds are formed
     * by the bound of the margin of the component.  i.e. {@code y - leftMargin}.
     *
     * @return The outer y bound.
     */
    public int getOuterY() {
<span class="fc" id="L1123">        return getY() - getStyle().getMarginTop();</span>
    }

    /**
     * Gets the inner y-coordinate of the inner bounds of this component. The inner bounds are formed
     * by the bound of the padding of the component.  i.e. {@code y + leftPadding}.
     *
     * @return The inner y bound.
     */
    public int getInnerY() {
<span class="fc" id="L1133">        return getY() + getStyle().getPaddingTop();</span>
    }

    /**
     * Returns whether the component is visible or not
     *
     * @return true if component is visible; otherwise false
     */
    public boolean isVisible() {
<span class="fc" id="L1142">        return visible;</span>
    }

    /**
     * Toggles visibility of the component
     *
     * @param visible true if component is visible; otherwise false
     */
    public void setVisible(boolean visible) {
<span class="fc" id="L1151">        this.visible = visible;</span>
<span class="fc" id="L1152">    }</span>

    void getVisibleRect(Rectangle r, boolean init) {
<span class="pc bpc" id="L1155" title="1 of 4 branches missed.">        if (!isVisible() || !initialized) {</span>
<span class="fc" id="L1156">            r.setWidth(0);</span>
<span class="fc" id="L1157">            r.setHeight(0);</span>
<span class="fc" id="L1158">            return;</span>
        }

<span class="fc" id="L1161">        int w = getWidth();</span>
<span class="fc" id="L1162">        int h = getHeight();</span>
<span class="fc" id="L1163">        int x = getAbsoluteX() + scrollX;</span>
<span class="fc" id="L1164">        int y = getAbsoluteY() + scrollY;</span>
<span class="fc bfc" id="L1165" title="All 2 branches covered.">        if (init) {</span>
<span class="fc" id="L1166">            r.setBounds(x, y, w, h);</span>
<span class="pc bpc" id="L1167" title="2 of 4 branches missed.">            if (w &lt;= 0 || h &lt;= 0) {</span>
<span class="nc" id="L1168">                return;</span>
            }
        } else {
<span class="fc" id="L1171">            Rectangle.intersection(x, y, w, h, r.getX(), r.getY(), r.getWidth(), r.getHeight(), r);</span>
<span class="pc bpc" id="L1172" title="2 of 4 branches missed.">            if (r.getWidth() &lt;= 0 || r.getHeight() &lt;= 0) {</span>
<span class="nc" id="L1173">                return;</span>
            }
        }


<span class="fc" id="L1178">        Container parent = getParent();</span>
<span class="fc bfc" id="L1179" title="All 2 branches covered.">        if (parent != null) {</span>
<span class="fc" id="L1180">            parent.getVisibleRect(r, false);</span>

        }

<span class="fc" id="L1184">    }</span>

    boolean isVisibleOnForm() {
<span class="fc" id="L1187">        getVisibleRect(tmpRect, true);</span>
<span class="pc bpc" id="L1188" title="1 of 4 branches missed.">        return (tmpRect.getWidth() &gt; 0 &amp;&amp; tmpRect.getHeight() &gt; 0);</span>
    }

    /**
     * Client properties allow the association of meta-data with a component, this
     * is useful for some applications that construct GUI's on the fly and need
     * to track the connection between the UI and the data.
     *
     * @param key the key used for putClientProperty
     * @return the value set to putClientProperty or null if no value is set to the property
     */
    public Object getClientProperty(String key) {
<span class="fc bfc" id="L1200" title="All 2 branches covered.">        if (clientProperties == null) {</span>
<span class="fc" id="L1201">            return null;</span>
        }
<span class="fc" id="L1203">        return clientProperties.get(key);</span>
    }

    /**
     * Convenience method that strips margin and padding from the component, and
     * returns itself for chaining.
     *
     * @return Self for chaining.
     * @see Style#stripMarginAndPadding()
     * @since 7.0
     */
    public Component stripMarginAndPadding() {
<span class="fc" id="L1215">        getAllStyles().stripMarginAndPadding();</span>
<span class="fc" id="L1216">        return this;</span>

    }

    /**
     * Gets the lead component for this component.
     *
     * @return The lead component or null if none is found.
     */
    Component getLeadComponent() {
<span class="pc bpc" id="L1226" title="1 of 2 branches missed.">        if (isBlockLead()) {</span>
<span class="nc" id="L1227">            return null;</span>
        }
<span class="fc" id="L1229">        Container p = getParent();</span>
<span class="fc bfc" id="L1230" title="All 2 branches covered.">        if (p != null) {</span>
<span class="fc" id="L1231">            return p.getLeadComponent();</span>
        }
<span class="fc" id="L1233">        return null;</span>
    }

    /**
     * Clears all client properties from this Component
     */
    public void clearClientProperties() {
<span class="pc bpc" id="L1240" title="1 of 2 branches missed.">        if (clientProperties != null) {</span>
<span class="fc" id="L1241">            clientProperties.clear();</span>
<span class="fc" id="L1242">            clientProperties = null;</span>
        }
<span class="fc" id="L1244">    }</span>

    /**
     * Client properties allow the association of meta-data with a component, this
     * is useful for some applications that construct GUI's on the fly and need
     * to track the connection between the UI and the data. Setting the value to
     * null will remove the client property from the component.
     *
     * @param key   arbitrary key for the property
     * @param value the value assigned to the given client property
     */
    public void putClientProperty(String key, Object value) {
<span class="fc bfc" id="L1256" title="All 2 branches covered.">        if (clientProperties == null) {</span>
<span class="pc bpc" id="L1257" title="1 of 2 branches missed.">            if (value == null) {</span>
<span class="nc" id="L1258">                return;</span>
            }
<span class="fc" id="L1260">            clientProperties = new HashMap&lt;String, Object&gt;();</span>
        }
<span class="fc bfc" id="L1262" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L1263">            clientProperties.remove(key);</span>
<span class="fc bfc" id="L1264" title="All 2 branches covered.">            if (clientProperties.size() == 0) {</span>
<span class="fc" id="L1265">                clientProperties = null;</span>
            }
        } else {
<span class="fc" id="L1268">            clientProperties.put(key, value);</span>
        }
<span class="fc" id="L1270">    }</span>

    /**
     * gets the Component dirty region,  this method is for internal use only and SHOULD NOT be invoked by user code.
     * Use repaint(int,int,int,int)
     *
     * @return returns the region that needs repainting or null for the whole component
     */
    public final Rectangle getDirtyRegion() {
<span class="fc" id="L1279">        return dirtyRegion;</span>
    }

    /**
     * sets the Component dirty region, this method is for internal use only and SHOULD NOT be invoked by user code.
     * Use repaint(int,int,int,int)
     *
     * @param dirty the region that needs repainting or null for the whole component
     */
    public final void setDirtyRegion(Rectangle dirty) {
<span class="fc" id="L1289">        synchronized (dirtyRegionLock) {</span>
<span class="fc" id="L1290">            this.dirtyRegion = dirty;</span>
<span class="fc" id="L1291">        }</span>

<span class="fc" id="L1293">    }</span>

    /**
     * Checks whether the component's background should be painted.
     *
     * @return {@literal true} if the component's background should be painted.
     */
    public boolean isOpaque() {
<span class="fc" id="L1301">        return opaque;</span>
    }

    /**
     * Sets whether or not to paint the component background.  Default is {@literal true}
     *
     * @param opaque False to not paint the component's background.
     * @since 6.0
     */
    public void setOpaque(boolean opaque) {
<span class="fc" id="L1311">        this.opaque = opaque;</span>
<span class="fc" id="L1312">    }</span>

    /**
     * Returns the component width
     *
     * @return the component width
     */
    public int getWidth() {
<span class="fc" id="L1320">        return bounds.getSize().getWidth();</span>
    }

    /**
     * Sets the Component width, this method is exposed for the purpose of
     * external layout managers and should not be invoked directly.&lt;br&gt;
     * If a user wishes to affect the component size, setPreferredSize should
     * be used.
     *
     * @param width the width of the component
     * @see #setPreferredSize
     */
    public void setWidth(int width) {
<span class="fc" id="L1333">        bounds.getSize().setWidth(width);</span>
<span class="fc" id="L1334">    }</span>

    /**
     * Gets the outer width of this component. This is the width of the component including horizontal margins.
     *
     * @return The outer width.
     */
    public int getOuterWidth() {
<span class="fc" id="L1342">        return getWidth() + getStyle().getHorizontalMargins();</span>
    }

    /**
     * Gets the inner width of this component.  This is the width of the component removing horizontal padding.
     *
     * @return The inner width.
     */
    public int getInnerWidth() {
<span class="fc" id="L1351">        return getWidth() - getStyle().getHorizontalPadding();</span>
    }

    /**
     * Returns the component height
     *
     * @return the component height
     */
    public int getHeight() {
<span class="fc" id="L1360">        return bounds.getSize().getHeight();</span>
    }

    /**
     * Sets the Component height, this method is exposed for the purpose of
     * external layout managers and should not be invoked directly.&lt;br&gt;
     * If a user wishes to affect the component size, setPreferredSize should
     * be used.
     *
     * @param height the height of the component
     * @see #setPreferredSize
     */
    public void setHeight(int height) {
<span class="fc" id="L1373">        bounds.getSize().setHeight(height);</span>
<span class="fc" id="L1374">    }</span>

    /**
     * Gets the outer height of this component.  This is the height of the component including vertical margins.
     *
     * @return The outer height.
     */
    public int getOuterHeight() {
<span class="fc" id="L1382">        return getHeight() + getStyle().getVerticalMargins();</span>
    }

    /**
     * Gets the inner height of this component.  This is the height of the component removing vertical padding.
     *
     * @return The inner height.
     */
    public int getInnerHeight() {
<span class="fc" id="L1391">        return getHeight() - getStyle().getVerticalPadding();</span>
    }

    /**
     * Indicates if the section within the X/Y area is a &quot;drag region&quot; where
     * we expect people to drag and never actually &quot;press&quot; in which case we
     * can instantly start dragging making perceived performance faster. This
     * is invoked by the implementation code to optimize drag start behavior
     *
     * @param x x location for the touch
     * @param y y location for the touch
     * @return true if the touch is in a region specifically designated as a &quot;drag region&quot;
     * @deprecated replaced with getDragRegionStatus
     */
    protected boolean isDragRegion(int x, int y) {
<span class="fc" id="L1406">        return isDraggable();</span>
    }

    /**
     * Indicates if the section within the X/Y area is a &quot;drag region&quot; where
     * we expect people to drag or press in which case we
     * can instantly start dragging making perceived performance faster. This
     * is invoked by the implementation code to optimize drag start behavior
     *
     * @param x x location for the touch
     * @param y y location for the touch
     * @return one of the DRAG_REGION_* values
     */
    protected int getDragRegionStatus(int x, int y) {
<span class="pc bpc" id="L1420" title="1 of 2 branches missed.">        if (isDraggable()) {</span>
<span class="fc" id="L1421">            return DRAG_REGION_LIKELY_DRAG_XY;</span>
        }
<span class="nc" id="L1423">        Component c = getScrollableFast();</span>
<span class="nc bnc" id="L1424" title="All 2 branches missed.">        if (c != null) {</span>
<span class="nc" id="L1425">            boolean xc = c.scrollableXFlag();</span>
<span class="nc" id="L1426">            boolean yc = c.scrollableYFlag();</span>
<span class="nc bnc" id="L1427" title="All 2 branches missed.">            if (isDragRegion(x, y)) {</span>
<span class="nc bnc" id="L1428" title="All 4 branches missed.">                if (xc &amp;&amp; yc) {</span>
<span class="nc" id="L1429">                    return DRAG_REGION_LIKELY_DRAG_XY;</span>
                }
<span class="nc bnc" id="L1431" title="All 2 branches missed.">                if (xc) {</span>
<span class="nc" id="L1432">                    return DRAG_REGION_LIKELY_DRAG_X;</span>
                }
<span class="nc bnc" id="L1434" title="All 2 branches missed.">                if (yc) {</span>
<span class="nc" id="L1435">                    return DRAG_REGION_LIKELY_DRAG_Y;</span>
                }
            } else {
<span class="nc bnc" id="L1438" title="All 4 branches missed.">                if (xc &amp;&amp; yc) {</span>
<span class="nc" id="L1439">                    return DRAG_REGION_POSSIBLE_DRAG_XY;</span>
                }
<span class="nc bnc" id="L1441" title="All 2 branches missed.">                if (xc) {</span>
<span class="nc" id="L1442">                    return DRAG_REGION_POSSIBLE_DRAG_X;</span>
                }
<span class="nc bnc" id="L1444" title="All 2 branches missed.">                if (yc) {</span>
<span class="nc" id="L1445">                    return DRAG_REGION_POSSIBLE_DRAG_Y;</span>
                }
            }
        }
<span class="nc" id="L1449">        return DRAG_REGION_NOT_DRAGGABLE;</span>
    }

    /**
     * This callback allows subcomponents who are interested in following position change of their parents
     * to receive such an event
     */
    void onParentPositionChange() {
<span class="fc" id="L1457">    }</span>

    /**
     * The baseline for the component text according to which it should be aligned
     * with other components for best visual look.
     *
     * @param width  the component width
     * @param height the component height
     * @return baseline value from the top of the component
     */
    public int getBaseline(int width, int height) {
<span class="fc" id="L1468">        return height - getStyle().getPaddingBottom();</span>
    }

    /**
     * Returns a constant indicating how the baseline varies with the size
     * of the component.
     *
     * @return one of BRB_CONSTANT_ASCENT, BRB_CONSTANT_DESCENT,
     * BRB_CENTER_OFFSET or BRB_OTHER
     */
    public int getBaselineResizeBehavior() {
<span class="fc" id="L1479">        return BRB_OTHER;</span>
    }

    /**
     * Returns the preferred size string that can be used to specify the preferred size of the component
     * using pixels or millimetres.  This string is applied to the preferred size just after is is initially
     * calculated using {@link #calcPreferredSize() }.
     *
     * @return the preferred size string
     * @deprecated This method is primarily for use by the GUI builder.  Use {@link #getPreferredSize() } to find
     * the preferred size of a component.
     */
    public String getPreferredSizeStr() {
<span class="fc" id="L1492">        return preferredSizeStr;</span>
    }

    /**
     * @param value The preferred size to set in format &quot;width height&quot;, where width and height can be a scalar
     *              value with px or mm units. Or the special value &quot;inherit&quot; which will just inherit the default preferred size.
     * @deprecated this method shouldn't be used, use sameWidth/Height, padding, margin or override calcPeferredSize
     * to reach similar functionality
     */
    public void setPreferredSizeStr(String value) {
<span class="fc" id="L1502">        preferredSizeStr = value;</span>
<span class="fc" id="L1503">        setPreferredSize(null);</span>
<span class="fc" id="L1504">    }</span>

    /**
     * Returns the Component Preferred Size, there is no guarantee the Component will
     * be sized at its Preferred Size. The final size of the component may be
     * smaller than its preferred size or even larger than the size.&lt;br&gt;
     * The Layout manager can take this value into consideration, but there is
     * no guarantee or requirement.
     *
     * @return the component preferred size
     */
    public Dimension getPreferredSize() {
<span class="fc" id="L1516">        return preferredSize();</span>
    }

    /**
     * Sets the Component Preferred Size, there is no guarantee the Component will
     * be sized at its Preferred Size. The final size of the component may be
     * smaller than its preferred size or even larger than the size.&lt;br&gt;
     * The Layout manager can take this value into consideration, but there is
     * no guarantee or requirement.
     *
     * @param d the component dimension
     * @deprecated this method shouldn't be used, use sameWidth/Height, padding, margin or override calcPeferredSize
     * to reach similar functionality
     */
    public void setPreferredSize(Dimension d) {
<span class="fc bfc" id="L1531" title="All 2 branches covered.">        if (d == null) {</span>
<span class="fc" id="L1532">            sizeRequestedByUser = false;</span>
<span class="fc" id="L1533">            preferredSize = null;</span>
<span class="fc" id="L1534">            shouldCalcPreferredSize = true;</span>
<span class="fc" id="L1535">            return;</span>
        }
<span class="fc" id="L1537">        Dimension dim = preferredSize();</span>
<span class="fc" id="L1538">        dim.setWidth(d.getWidth());</span>
<span class="fc" id="L1539">        dim.setHeight(d.getHeight());</span>
<span class="fc" id="L1540">        sizeRequestedByUser = true;</span>
<span class="fc" id="L1541">    }</span>

    Dimension getPreferredSizeWithMargin() {
<span class="fc" id="L1544">        Dimension d = preferredSize();</span>
<span class="fc" id="L1545">        Style s = getStyle();</span>
<span class="fc" id="L1546">        return new Dimension(d.getWidth() + s.getHorizontalMargins(), d.getHeight() + s.getVerticalMargins());</span>
    }

    /**
     * Returns the Components dimension in scrolling, this is very similar to the
     * preferred size aspect only it represents actual scrolling limits.
     *
     * @return the component actual size with all scrolling
     */
    public Dimension getScrollDimension() {
<span class="fc bfc" id="L1556" title="All 6 branches covered.">        if (!scrollSizeRequestedByUser &amp;&amp; (scrollSize == null || shouldCalcScrollSize)) {</span>
<span class="fc" id="L1557">            scrollSize = calcScrollSize();</span>
<span class="fc" id="L1558">            shouldCalcScrollSize = false;</span>
        }
<span class="fc" id="L1560">        return scrollSize;</span>
    }

    /**
     * Method that can be overriden to represent the actual size of the component
     * when it differs from the desireable size for the viewport
     *
     * @return scroll size, by default this is the same as the preferred size
     */
    protected Dimension calcScrollSize() {
<span class="fc" id="L1570">        return calcPreferredSize();</span>
    }

    /**
     * Set the size for the scroll area
     *
     * @param d dimension of the scroll area
     */
    public void setScrollSize(Dimension d) {
<span class="fc bfc" id="L1579" title="All 2 branches covered.">        if (d == null) {</span>
<span class="fc" id="L1580">            shouldCalcScrollSize = true;</span>
<span class="fc" id="L1581">            scrollSize = null;</span>
<span class="fc" id="L1582">            scrollSizeRequestedByUser = false;</span>
<span class="fc" id="L1583">            return;</span>
        }
<span class="fc" id="L1585">        scrollSize = d;</span>
<span class="fc" id="L1586">        scrollSizeRequestedByUser = true;</span>
<span class="fc" id="L1587">    }</span>

    /**
     * Helper method to retrieve the preferred width of the component.
     *
     * @return preferred width of the component
     * @see #getPreferredSize
     */
    public int getPreferredW() {
<span class="fc" id="L1596">        return getPreferredSize().getWidth();</span>
    }

    /**
     * Helper method to set the preferred width of the component.
     *
     * @param preferredW the preferred width of the component
     * @see #setPreferredSize
     * @deprecated this method shouldn't be used, use sameWidth/Height, padding, margin or override calcPeferredSize
     * to reach similar functionality
     */
    public void setPreferredW(int preferredW) {
<span class="fc" id="L1608">        setPreferredSize(new Dimension(preferredW, getPreferredH()));</span>
<span class="fc" id="L1609">    }</span>

    /**
     * Helper method to retrieve the preferred height of the component.
     *
     * @return preferred height of the component
     * @see #getPreferredSize
     */
    public int getPreferredH() {
<span class="fc" id="L1618">        return getPreferredSize().getHeight();</span>
    }

    /**
     * Helper method to set the preferred height of the component.
     *
     * @param preferredH the preferred height of the component
     * @see #setPreferredSize
     * @deprecated this method shouldn't be used, use sameWidth/Height, padding, margin or override calcPeferredSize
     * to reach similar functionality
     */
    public void setPreferredH(int preferredH) {
<span class="fc" id="L1630">        setPreferredSize(new Dimension(getPreferredW(), preferredH));</span>
<span class="fc" id="L1631">    }</span>

    /**
     * Gets the preferred height including the vertical margins.
     *
     * @return The preferred outer height.
     */
    public int getOuterPreferredH() {
<span class="fc" id="L1639">        return getPreferredH() + getStyle().getVerticalMargins();</span>
    }

    /**
     * Gets the preferred height removing vertical padding.
     *
     * @return The preferred inner height.
     */
    public int getInnerPreferredH() {
<span class="fc" id="L1648">        return getPreferredH() - getStyle().getVerticalPadding();</span>
    }

    /**
     * Gets the preferred width including horizontal margins.
     *
     * @return The preferred outer width.
     */
    public int getOuterPreferredW() {
<span class="fc" id="L1657">        return getPreferredW() + getStyle().getHorizontalMargins();</span>
    }

    /**
     * Gets the preferred width removing horizontal padding.
     *
     * @return preferred width
     */
    public int getInnerPreferredW() {
<span class="fc" id="L1666">        return getPreferredW() - getStyle().getHorizontalPadding();</span>
    }

    /**
     * Sets the Component size, this method is exposed for the purpose of
     * external layout managers and should not be invoked directly.&lt;br&gt;
     * If a user wishes to affect the component size, setPreferredSize should
     * be used.
     *
     * @param d the component dimension
     * @see #setPreferredSize
     */
    public void setSize(Dimension d) {
<span class="fc" id="L1679">        Dimension d2 = bounds.getSize();</span>
<span class="fc" id="L1680">        d2.setWidth(d.getWidth());</span>
<span class="fc" id="L1681">        d2.setHeight(d.getHeight());</span>
<span class="fc" id="L1682">    }</span>

    /**
     * Unique identifier for a component.
     * This id is used to retrieve a suitable Style.
     *
     * @return unique string identifying this component for the style sheet
     */
    public String getUIID() {
<span class="fc bfc" id="L1691" title="All 2 branches covered.">        if (landscapeUiid != null) {</span>
<span class="pc bpc" id="L1692" title="1 of 2 branches missed.">            if (Display.impl.isPortrait()) {</span>
<span class="fc" id="L1693">                return portraitUiid;</span>
            }
<span class="nc" id="L1695">            return landscapeUiid;</span>
        }
<span class="fc" id="L1697">        return portraitUiid;</span>
    }

    /**
     * This method sets the Component the Unique identifier.
     * This method should be used before a component has been initialized
     *
     * @param id UIID unique identifier for component type
     */
    public void setUIID(String id) {
<span class="fc" id="L1707">        this.portraitUiid = id;</span>
<span class="fc" id="L1708">        unSelectedStyle = null;</span>
<span class="fc" id="L1709">        selectedStyle = null;</span>
<span class="fc" id="L1710">        disabledStyle = null;</span>
<span class="fc" id="L1711">        pressedStyle = null;</span>
<span class="fc" id="L1712">        allStyles = null;</span>
<span class="fc bfc" id="L1713" title="All 2 branches covered.">        if (!sizeRequestedByUser) {</span>
<span class="fc" id="L1714">            preferredSize = null;</span>
        }
<span class="fc" id="L1716">    }</span>

    boolean onOrientationChange() {
<span class="pc bpc" id="L1719" title="1 of 2 branches missed.">        if (landscapeUiid != null) {</span>
<span class="nc" id="L1720">            unSelectedStyle = null;</span>
<span class="nc" id="L1721">            selectedStyle = null;</span>
<span class="nc" id="L1722">            disabledStyle = null;</span>
<span class="nc" id="L1723">            pressedStyle = null;</span>
<span class="nc" id="L1724">            allStyles = null;</span>
<span class="nc bnc" id="L1725" title="All 2 branches missed.">            if (!sizeRequestedByUser) {</span>
<span class="nc" id="L1726">                preferredSize = null;</span>
            }
<span class="nc" id="L1728">            return true;</span>
        }
<span class="fc" id="L1730">        return false;</span>
    }

    /**
     * This method sets the Component the Unique identifier.
     *
     * @param portraitUiid  UIID unique identifier for component type in portrait mode
     * @param landscapeUiid UIID unique identifier for component type in landscape mode
     */
    public void setUIID(String portraitUiid, String landscapeUiid) {
<span class="fc" id="L1740">        this.landscapeUiid = landscapeUiid;</span>
<span class="fc" id="L1741">        setUIID(portraitUiid);</span>
<span class="fc" id="L1742">    }</span>

    /**
     * Gets inline styles that are to be applied to all states of this component.
     *
     * @return Inline styles applied to all states.
     */
    public String getInlineAllStyles() {
<span class="fc" id="L1750">        return inlineAllStyles;</span>
    }

    /**
     * Registers inline styles that should be applied to all states of the component.
     *
     * @param styles a style in the format of {@code
     *               &quot;fgColor:ff0000; font:18mm; border: 1px solid ff0000; bgType:none; padding: 3mm; margin: 1mm&quot; }
     */
    public void setInlineAllStyles(String styles) {
<span class="pc bpc" id="L1760" title="1 of 4 branches missed.">        if (styles != null &amp;&amp; styles.trim().length() == 0) {</span>
<span class="fc" id="L1761">            styles = null;</span>
        }
<span class="pc bpc" id="L1763" title="1 of 2 branches missed.">        if (!Objects.equals(styles, inlineAllStyles)) {</span>
<span class="fc" id="L1764">            this.inlineAllStyles = styles;</span>
<span class="fc" id="L1765">            unSelectedStyle = null;</span>
<span class="fc" id="L1766">            selectedStyle = null;</span>
<span class="fc" id="L1767">            disabledStyle = null;</span>
<span class="fc" id="L1768">            pressedStyle = null;</span>
<span class="fc" id="L1769">            allStyles = null;</span>
<span class="pc bpc" id="L1770" title="1 of 2 branches missed.">            if (!sizeRequestedByUser) {</span>
<span class="fc" id="L1771">                preferredSize = null;</span>
            }
        }
<span class="fc" id="L1774">    }</span>

    /**
     * Gets inline styles that are to be applied to the selected state of this component.
     *
     * @return Inline styles applied to selected state
     */
    public String getInlineSelectedStyles() {
<span class="fc" id="L1782">        return this.inlineSelectedStyles;</span>
    }

    /**
     * Registers inline styles that should be applied to the selected state of the component.
     *
     * @param styles style format
     * @see #setInlineAllStyles(String)
     */
    public void setInlineSelectedStyles(String styles) {
<span class="pc bpc" id="L1792" title="1 of 4 branches missed.">        if (styles != null &amp;&amp; styles.trim().length() == 0) {</span>
<span class="fc" id="L1793">            styles = null;</span>
        }
<span class="pc bpc" id="L1795" title="1 of 2 branches missed.">        if (!Objects.equals(styles, inlineSelectedStyles)) {</span>
<span class="fc" id="L1796">            this.inlineSelectedStyles = styles;</span>

<span class="fc" id="L1798">            unSelectedStyle = null;</span>
<span class="fc" id="L1799">            selectedStyle = null;</span>
<span class="fc" id="L1800">            disabledStyle = null;</span>
<span class="fc" id="L1801">            pressedStyle = null;</span>
<span class="fc" id="L1802">            allStyles = null;</span>
<span class="pc bpc" id="L1803" title="1 of 2 branches missed.">            if (!sizeRequestedByUser) {</span>
<span class="fc" id="L1804">                preferredSize = null;</span>
            }
        }

<span class="fc" id="L1808">    }</span>

    /**
     * Gets inline styles that are to be applied to the unselected state of this component.
     *
     * @return Inline styles applied to unselected state
     */
    public String getInlineUnselectedStyles() {
<span class="fc" id="L1816">        return this.inlineUnselectedStyles;</span>
    }

    /**
     * Registers inline styles that should be applied to the unselected state of the component.
     *
     * @param styles style format
     * @see #setInlineAllStyles(String)
     */
    public void setInlineUnselectedStyles(String styles) {
<span class="pc bpc" id="L1826" title="1 of 4 branches missed.">        if (styles != null &amp;&amp; styles.trim().length() == 0) {</span>
<span class="fc" id="L1827">            styles = null;</span>
        }
<span class="pc bpc" id="L1829" title="1 of 2 branches missed.">        if (!Objects.equals(styles, inlineUnselectedStyles)) {</span>
<span class="fc" id="L1830">            this.inlineUnselectedStyles = styles;</span>

<span class="fc" id="L1832">            unSelectedStyle = null;</span>
<span class="fc" id="L1833">            selectedStyle = null;</span>
<span class="fc" id="L1834">            disabledStyle = null;</span>
<span class="fc" id="L1835">            pressedStyle = null;</span>
<span class="fc" id="L1836">            allStyles = null;</span>
<span class="pc bpc" id="L1837" title="1 of 2 branches missed.">            if (!sizeRequestedByUser) {</span>
<span class="fc" id="L1838">                preferredSize = null;</span>
            }
        }

<span class="fc" id="L1842">    }</span>

    /**
     * Gets inline styles that are to be applied to the disabled state of this component.
     *
     * @return Inline styles applied to disabled state
     */
    public String getInlineDisabledStyles() {
<span class="fc" id="L1850">        return this.inlineDisabledStyles;</span>
    }

    /**
     * Registers inline styles that should be applied to the disabled state of the component.
     *
     * @param styles style format
     * @see #setInlineAllStyles(String)
     */
    public void setInlineDisabledStyles(String styles) {
<span class="pc bpc" id="L1860" title="1 of 4 branches missed.">        if (styles != null &amp;&amp; styles.trim().length() == 0) {</span>
<span class="fc" id="L1861">            styles = null;</span>
        }
<span class="pc bpc" id="L1863" title="1 of 2 branches missed.">        if (!Objects.equals(styles, inlineDisabledStyles)) {</span>
<span class="fc" id="L1864">            this.inlineDisabledStyles = styles;</span>
<span class="fc" id="L1865">            unSelectedStyle = null;</span>
<span class="fc" id="L1866">            selectedStyle = null;</span>
<span class="fc" id="L1867">            disabledStyle = null;</span>
<span class="fc" id="L1868">            pressedStyle = null;</span>
<span class="fc" id="L1869">            allStyles = null;</span>
<span class="pc bpc" id="L1870" title="1 of 2 branches missed.">            if (!sizeRequestedByUser) {</span>
<span class="fc" id="L1871">                preferredSize = null;</span>
            }
        }
<span class="fc" id="L1874">    }</span>

    /**
     * Gets inline styles that are to be applied to the pressed state of this component.
     *
     * @return Inline styles applied to pressed state
     */
    public String getInlinePressedStyles() {
<span class="fc" id="L1882">        return this.inlinePressedStyles;</span>

    }

    /**
     * Registers inline styles that should be applied to the pressed state of the component.
     *
     * @param styles style format
     * @see #setInlineAllStyles(String)
     */
    public void setInlinePressedStyles(String styles) {
<span class="pc bpc" id="L1893" title="1 of 4 branches missed.">        if (styles != null &amp;&amp; styles.trim().length() == 0) {</span>
<span class="fc" id="L1894">            styles = null;</span>
        }
<span class="pc bpc" id="L1896" title="1 of 2 branches missed.">        if (!Objects.equals(styles, inlinePressedStyles)) {</span>
<span class="fc" id="L1897">            this.inlinePressedStyles = styles;</span>
<span class="fc" id="L1898">            unSelectedStyle = null;</span>
<span class="fc" id="L1899">            selectedStyle = null;</span>
<span class="fc" id="L1900">            disabledStyle = null;</span>
<span class="fc" id="L1901">            pressedStyle = null;</span>
<span class="fc" id="L1902">            allStyles = null;</span>
<span class="pc bpc" id="L1903" title="1 of 2 branches missed.">            if (!sizeRequestedByUser) {</span>
<span class="fc" id="L1904">                preferredSize = null;</span>
            }
        }
<span class="fc" id="L1907">    }</span>

    /**
     * This method will remove the Component from its parent.
     */
    public void remove() {
<span class="fc bfc" id="L1913" title="All 2 branches covered.">        if (parent != null) {</span>
<span class="fc" id="L1914">            parent.removeComponent(this);</span>
        }
<span class="fc" id="L1916">    }</span>

    /**
     * Returns the container in which this component is contained
     *
     * @return the parent container in which this component is contained
     */
    public Container getParent() {
<span class="fc" id="L1924">        return parent;</span>
    }

    /**
     * Sets the Component Parent.
     * This method should not be called by the user.
     *
     * @param parent the parent container
     */
    void setParent(Container parent) {
<span class="fc bfc" id="L1934" title="All 2 branches covered.">        if (parent == this) {</span>
<span class="fc" id="L1935">            throw new IllegalArgumentException(&quot;Attempt to add self as parent&quot;);</span>
        }
<span class="fc" id="L1937">        this.parent = parent;</span>
<span class="fc" id="L1938">    }</span>

    /**
     * Gets the &quot;owner&quot; of this component as set by {@link #setOwner(com.codename1.ui.Component) }.
     *
     * @return The owner component or null.
     * @since 7.0
     */
    public Component getOwner() {
<span class="fc" id="L1947">        return owner;</span>
    }

    /**
     * Sets the owner of this component to the specified component.  This can be useful
     * for denoting a hierarchical relationship that is outside the actual parent-child
     * component hierarchy.  E.g. If there is a popup dialog that allows the user to select
     * input for a text field, then you could set the text field as the owner of the popup
     * dialog to denote a virtual parent-child relationship.
     *
     * &lt;p&gt;This is used by {@link InteractionDialog#setDisposeWhenPointerOutOfBounds(boolean) } to figure out whether a
     * pointer event actually occurred outside the bounds of the dialog.  The {@link #containsOrOwns(int, int) } method
     * is used instead of {@link #contains(int, int) } so that it can cover the case where the pointer event occurred
     * on a component that is logically a child of the dialog, but not physically.&lt;/p&gt;
     * popup dialog is opened, then
     *
     * @param owner The component to set as the owner of this component.
     * @see #isOwnedBy(com.codename1.ui.Component)
     * @see #containsOrOwns(int, int)
     * @since 6.0
     */
    public void setOwner(Component owner) {
<span class="fc" id="L1969">        this.owner = owner;</span>
<span class="fc" id="L1970">    }</span>

    /**
     * Checks to see if this component is owned by the given other component.  A component {@literal A} is
     * deemed to be owned by another component {@literal B} if any of the following conditions are true:
     * &lt;ul&gt;
     * &lt;li&gt;{@literal B} is the owner of {@literal A}&lt;/li&gt;
     * &lt;li&gt;{@literal B} contains {@literal A}'s owner.&lt;/li&gt;
     * &lt;li&gt;{@literal A}'s owner is owned by {@literal B}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param cmp the owner
     * @return True if this component is owned by {@literal cmp}.
     * @see #setOwner(com.codename1.ui.Component)
     * @see #containsOrOwns(int, int)
     * @since 6.0
     */
    public boolean isOwnedBy(Component cmp) {
<span class="fc" id="L1988">        Component c = this.owner;</span>
<span class="fc bfc" id="L1989" title="All 2 branches covered.">        Container cnt = (cmp instanceof Container) ? (Container) cmp : null;</span>
<span class="fc bfc" id="L1990" title="All 2 branches covered.">        while (c != null) {</span>
<span class="pc bpc" id="L1991" title="1 of 2 branches missed.">            if (c == cmp) {</span>
<span class="fc" id="L1992">                return true;</span>
            }
<span class="nc bnc" id="L1994" title="All 2 branches missed.">            if (cnt != null) {</span>
<span class="nc bnc" id="L1995" title="All 2 branches missed.">                if (cnt.contains(c)) {</span>
<span class="nc" id="L1996">                    return true;</span>
                }
            }
<span class="nc" id="L1999">            c = c.owner;</span>
        }
<span class="fc" id="L2001">        c = this.getParent();</span>
<span class="fc bfc" id="L2002" title="All 2 branches covered.">        while (c != null) {</span>
<span class="pc bpc" id="L2003" title="1 of 2 branches missed.">            if (c.isOwnedBy(cmp)) {</span>
<span class="nc" id="L2004">                return true;</span>
            }
<span class="fc" id="L2006">            c = c.getParent();</span>
        }

<span class="fc" id="L2009">        return false;</span>
    }

    /**
     * Checks to see if this component either contains the given point, or
     * if it owns the component that contains the given point.
     *
     * @param x X-coordinate in absolute coordinates.
     * @param y Y-coordinate in absolute coordinates.
     * @return True if the coordinate is either inside the bounds of this component
     * or a component owned by this component.
     * @see #setOwner(com.codename1.ui.Component)
     * @see #isOwnedBy(com.codename1.ui.Component)
     * @since 6.0
     */
    public boolean containsOrOwns(int x, int y) {
<span class="fc bfc" id="L2025" title="All 2 branches covered.">        if (contains(x, y)) {</span>
<span class="fc" id="L2026">            return true;</span>
        }
<span class="fc" id="L2028">        Form f = getComponentForm();</span>
<span class="fc bfc" id="L2029" title="All 2 branches covered.">        if (f != null) {</span>
<span class="fc" id="L2030">            Component cmp = f.getComponentAt(x, y);</span>
<span class="pc bpc" id="L2031" title="2 of 4 branches missed.">            return cmp != null &amp;&amp; cmp.isOwnedBy(this);</span>
        }
<span class="fc" id="L2033">        return false;</span>

    }

    /**
     * Registers interest in receiving callbacks for focus gained events, a focus event
     * is invoked when the component accepts the focus. A special case exists for the
     * Form which sends a focus even for every selection within the form.
     *
     * @param l listener interface implementing the observable pattern
     */
    public void addFocusListener(FocusListener l) {
<span class="fc bfc" id="L2045" title="All 2 branches covered.">        if (focusListeners == null) {</span>
<span class="fc" id="L2046">            focusListeners = new EventDispatcher();</span>
        }
<span class="fc" id="L2048">        focusListeners.addListener(l);</span>
<span class="fc" id="L2049">    }</span>

    /**
     * Deregisters interest in receiving callbacks for focus gained events
     *
     * @param l listener interface implementing the observable pattern
     */
    public void removeFocusListener(FocusListener l) {
<span class="pc bpc" id="L2057" title="1 of 2 branches missed.">        if (focusListeners == null) {</span>
<span class="nc" id="L2058">            return;</span>
        }
<span class="fc" id="L2060">        focusListeners.removeListener(l);</span>
<span class="fc" id="L2061">    }</span>

    /**
     * Registers interest in receiving callbacks for scroll gained events,
     * a scroll event is invoked when the component is scrolled.
     *
     * @param l listener interface implementing the observable pattern
     */
    public void addScrollListener(ScrollListener l) {
<span class="pc bpc" id="L2070" title="1 of 2 branches missed.">        if (scrollListeners == null) {</span>
<span class="fc" id="L2071">            scrollListeners = new EventDispatcher();</span>
        }
<span class="fc" id="L2073">        scrollListeners.addListener(l);</span>
<span class="fc" id="L2074">    }</span>

    /**
     * Deregisters interest in receiving callbacks for scroll gained events
     *
     * @param l listener interface implementing the observable pattern
     */
    public void removeScrollListener(ScrollListener l) {
<span class="pc bpc" id="L2082" title="1 of 2 branches missed.">        if (scrollListeners == null) {</span>
<span class="nc" id="L2083">            return;</span>
        }
<span class="fc" id="L2085">        scrollListeners.removeListener(l);</span>
<span class="pc bpc" id="L2086" title="1 of 2 branches missed.">        if (!scrollListeners.hasListeners()) {</span>
<span class="fc" id="L2087">            scrollListeners = null;</span>
        }
<span class="fc" id="L2089">    }</span>

    /**
     * When working in 3 softbutton mode &quot;fire&quot; key (center softbutton) is sent to this method
     * in order to allow 3 button devices to work properly. When overriding this method
     * you should also override isSelectableInteraction to indicate that a command is placed
     * appropriately on top of the fire key for 3 soft button phones.
     */
    protected void fireClicked() {
<span class="nc" id="L2098">    }</span>

    /**
     * This method allows a component to indicate that it is interested in an &quot;implicit&quot; select
     * command to appear in the &quot;fire&quot; button when 3 softbuttons are defined in a device.
     *
     * @return true if this is a selectable interaction
     */
    protected boolean isSelectableInteraction() {
<span class="fc" id="L2107">        return false;</span>
    }

    /**
     * Fired when component gains focus
     */
    void fireFocusGained() {
<span class="fc" id="L2114">        fireFocusGained(this);</span>
<span class="fc" id="L2115">    }</span>

    /**
     * Fired when component lost focus
     */
    void fireFocusLost() {
<span class="fc" id="L2121">        fireFocusLost(this);</span>
<span class="fc" id="L2122">    }</span>

    /**
     * Fired when component gains focus
     */
    void fireFocusGained(Component cmp) {
<span class="pc bpc" id="L2128" title="1 of 2 branches missed.">        if (cmp.isCellRenderer()) {</span>
<span class="nc" id="L2129">            return;</span>
        }

<span class="fc bfc" id="L2132" title="All 2 branches covered.">        if (focusListeners != null) {</span>
<span class="fc" id="L2133">            focusListeners.fireFocus(cmp);</span>
        }
<span class="fc" id="L2135">        focusGainedInternal();</span>
<span class="fc" id="L2136">        focusGained();</span>
<span class="fc bfc" id="L2137" title="All 2 branches covered.">        if (isSelectableInteraction()) {</span>
<span class="fc" id="L2138">            Form f = getComponentForm();</span>
<span class="pc bpc" id="L2139" title="1 of 2 branches missed.">            if (f != null) {</span>
<span class="fc" id="L2140">                f.getMenuBar().addSelectCommand(getSelectCommandText());</span>
            }
        }
<span class="fc" id="L2143">    }</span>

    /**
     * Allows determining the text for the select command used in the 3rd softbutton
     * mode.
     *
     * @return text for the interaction with the softkey
     */
    public String getSelectCommandText() {
<span class="fc" id="L2152">        return selectText;</span>
    }

    /**
     * Allows determining the text for the select command used in the 3rd softbutton
     * mode.
     *
     * @param selectText text for the interaction with the softkey
     */
    public void setSelectCommandText(String selectText) {
<span class="fc" id="L2162">        this.selectText = selectText;</span>
<span class="fc" id="L2163">    }</span>

    /**
     * Fired when component lost focus
     */
    void fireFocusLost(Component cmp) {
<span class="pc bpc" id="L2169" title="1 of 2 branches missed.">        if (cmp.isCellRenderer()) {</span>
<span class="nc" id="L2170">            return;</span>
        }
<span class="fc bfc" id="L2172" title="All 2 branches covered.">        if (isSelectableInteraction()) {</span>
<span class="fc" id="L2173">            Form f = getComponentForm();</span>
<span class="pc bpc" id="L2174" title="1 of 2 branches missed.">            if (f != null) {</span>
<span class="fc" id="L2175">                f.getMenuBar().removeSelectCommand();</span>
            }
        }

<span class="fc bfc" id="L2179" title="All 2 branches covered.">        if (focusListeners != null) {</span>
<span class="fc" id="L2180">            focusListeners.fireFocus(cmp);</span>
        }
<span class="fc" id="L2182">        focusLostInternal();</span>
<span class="fc" id="L2183">        focusLost();</span>
<span class="fc" id="L2184">    }</span>

    /**
     * This method allows us to detect an action event internally without
     * implementing the action listener interface.
     */
    void fireActionEvent() {
<span class="fc" id="L2191">    }</span>

    /**
     * Allows us to indicate the label associated with this component thus providing
     * visual feedback related for this component e.g. starting the ticker when
     * the component receives focus.
     *
     * @return the label associated with this component
     */
    public Label getLabelForComponent() {
<span class="fc" id="L2201">        return componentLabel;</span>
    }

    /**
     * Allows us to indicate the label associated with this component thus providing
     * visual feedback related for this component e.g. starting the ticker when
     * the component receives focus.
     *
     * @param componentLabel a label associated with this component
     */
    public void setLabelForComponent(Label componentLabel) {
<span class="fc" id="L2212">        this.componentLabel = componentLabel;</span>
<span class="fc" id="L2213">    }</span>

    /**
     * This method is useful since it is not a part of the public API yet
     * allows a component within this package to observe focus events
     * without implementing a public interface or creating a new class
     */
    void focusGainedInternal() {
<span class="fc" id="L2221">        startComponentLableTicker();</span>
<span class="fc" id="L2222">        String text = getAccessibilityText();</span>
<span class="pc bpc" id="L2223" title="1 of 4 branches missed.">        if (text != null &amp;&amp; text.length() &gt; 0) {</span>
<span class="fc" id="L2224">            announceForAccessibility(text);</span>
        }
<span class="fc" id="L2226">    }</span>

    void startComponentLableTicker() {
<span class="pc bpc" id="L2229" title="1 of 4 branches missed.">        if (componentLabel != null &amp;&amp; componentLabel.isTickerEnabled()) {</span>
<span class="pc bpc" id="L2230" title="1 of 2 branches missed.">            if (componentLabel.shouldTickerStart()) {</span>
<span class="nc" id="L2231">                componentLabel.startTicker(getUIManager().getLookAndFeel().getTickerSpeed(), true);</span>
            }
        }
<span class="fc" id="L2234">    }</span>

    void stopComponentLableTicker() {
<span class="pc bpc" id="L2237" title="2 of 6 branches missed.">        if (componentLabel != null &amp;&amp; componentLabel.isTickerEnabled() &amp;&amp; componentLabel.isTickerRunning()) {</span>
<span class="nc" id="L2238">            componentLabel.stopTicker();</span>
        }
<span class="fc" id="L2240">    }</span>

    /**
     * Callback allowing a developer to track when the component gains focus
     */
    protected void focusGained() {
<span class="fc" id="L2246">    }</span>

    /**
     * Callback allowing a developer to track wheh the component loses focus
     */
    protected void focusLost() {
<span class="fc" id="L2252">    }</span>

    /**
     * This method is useful since it is not a part of the public API yet
     * allows a component within this package to observe focus events
     * without implementing a public interface or creating a new class
     */
    void focusLostInternal() {
<span class="fc" id="L2260">        stopComponentLableTicker();</span>
<span class="fc" id="L2261">    }</span>

    /**
     * This method paints all the parents Components Background.
     *
     * @param g the graphics object
     */
    public void paintBackgrounds(Graphics g) {
<span class="pc bpc" id="L2269" title="1 of 2 branches missed.">        if (Display.impl.shouldPaintBackground()) {</span>
<span class="fc" id="L2270">            drawPainters(g, this.getParent(), this, getAbsoluteX() + getScrollX(),</span>
<span class="fc" id="L2271">                    getAbsoluteY() + getScrollY(),</span>
<span class="fc" id="L2272">                    getWidth(), getHeight());</span>
        }
<span class="fc" id="L2274">    }</span>

    /**
     * Convenience method used by {@link #drawShadow(Graphics, Image, int, int, int, int, int, int, int, float)} to convert device independent
     * pixels (1/96th of an inch) into pixels.
     *
     * @param dp Value in device independent pixels (1/96th of an inch).
     * @return Value converted to pixels.
     */
    private int dp2px(int dp) {
<span class="nc" id="L2284">        return CN.convertToPixels(dp / 96f * 25.4f);</span>
    }

    /**
     * Initial implementation used separate shadow rendering on each platform's native layer via the
     * platform's drawShadow() method.  However, performance in the simulator was terrible, so I implemented
     * a cross-platform fallback solution in {@link #drawShadow(Graphics, Image, int, int, int, int, int, int, int, float)} that
     * was reasonably fast.  After some experimentation it seems that using this cross-platform solution is good enough
     * to use on all platforms, however, it is an approximation and doesn't include any blur.
     * &lt;p&gt;
     * This method acts as a switch to allow us to enable native shadow rendering if it is supported, and it has
     * been explicitly enabled either with a display property or a component client property.
     *
     * @return True if native shadow rendering should be used for elevation.
     */
    private boolean useNativeShadowRendering() {
<span class="nc bnc" id="L2300" title="All 2 branches missed.">        if (!Display.impl.isDrawShadowSupported()) return false;</span>
<span class="nc bnc" id="L2301" title="All 2 branches missed.">        if (Boolean.TRUE.equals(getClientProperty(&quot;Component.nativeShadowRendering&quot;))) return true;</span>
<span class="nc" id="L2302">        return &quot;true&quot;.equals(CN.getProperty(&quot;Component.nativeShadowRendering&quot;, &quot;false&quot;));</span>
    }

    /**
     * Wrapper for {@link Graphics#drawShadow(Image, int, int, int, int, int, int, int, float)} that takes coordinates in device-independent
     * pixels (1/96th of an inch).  These are converted to pixels and passed to {@link Graphics#drawShadow(Image, int, int, int, int, int, int, int, float)}
     *
     * @param g
     * @param img
     * @param relativeX
     * @param relativeY
     * @param offsetX
     * @param offsetY
     * @param blurRadius
     * @param spreadRadius
     * @param color
     * @param opacity
     */
    private void drawShadow(Graphics g, Image img, int relativeX, int relativeY, int offsetX, int offsetY, int blurRadius, int spreadRadius, int color, float opacity) {


<span class="nc bnc" id="L2323" title="All 2 branches missed.">        if (!useNativeShadowRendering()) {</span>
            // Cross-platform &quot;fast&quot; shadow implementation.
            // No blur.
<span class="nc" id="L2326">            int[] rgb = img.getRGBCached();</span>
<span class="nc" id="L2327">            int[] mask = new int[rgb.length];</span>
<span class="nc" id="L2328">            System.arraycopy(rgb, 0, mask, 0, rgb.length);</span>
<span class="nc" id="L2329">            int len = mask.length;</span>
<span class="nc" id="L2330">            color = (color &amp; 0x00ffffff);</span>
<span class="nc" id="L2331">            int blurRadiusPixels = dp2px(blurRadius);</span>
<span class="nc" id="L2332">            int spreadRadiusPixels = dp2px(spreadRadius);</span>
<span class="nc" id="L2333">            int offsetXPixels = dp2px(offsetX);</span>
<span class="nc" id="L2334">            int offsetYPixels = dp2px(offsetY);</span>
<span class="nc bnc" id="L2335" title="All 2 branches missed.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L2336">                int pixel = mask[i];</span>
<span class="nc" id="L2337">                int alphaMask = (pixel &amp; 0xff000000);</span>
<span class="nc" id="L2338">                int alpha = alphaMask &gt;&gt; 24;</span>

<span class="nc bnc" id="L2340" title="All 2 branches missed.">                if (alpha != 0) {</span>
                    //int adjustedAlpha = (int)(alpha * (float)opacity);
<span class="nc" id="L2342">                    mask[i] = (alphaMask | color);</span>
                }
            }

<span class="nc" id="L2346">            int origAlpha = g.getAlpha();</span>

<span class="nc" id="L2348">            Image maskImage = Image.createImage(mask, img.getWidth(), img.getHeight());</span>

<span class="nc" id="L2350">            float step = 1;</span>
<span class="nc bnc" id="L2351" title="All 2 branches missed.">            for (int rad = blurRadiusPixels; rad &gt; 0; rad--) {</span>

<span class="nc" id="L2353">                g.setAlpha((int) (255 / step * opacity * (1 - rad / (1 + (float) blurRadiusPixels))));</span>
                //System.out.println(&quot;rad=&quot;+rad+&quot;;alpha=&quot;+g.getAlpha());
<span class="nc" id="L2355">                g.drawImage(maskImage,</span>
                        relativeX + offsetXPixels - rad - spreadRadiusPixels,
                        relativeY + offsetYPixels - rad - spreadRadiusPixels,
<span class="nc" id="L2358">                        img.getWidth() + 2 * (spreadRadiusPixels + rad),</span>
<span class="nc" id="L2359">                        img.getHeight() + 2 * (spreadRadiusPixels + rad));</span>
<span class="nc" id="L2360">                step += 0.5;</span>
            }
<span class="nc" id="L2362">            g.setAlpha((int) (opacity * 255 / step));</span>

            //System.out.println(&quot;drawing;alpha=&quot;+g.getAlpha());


<span class="nc" id="L2367">            g.drawImage(maskImage, relativeX + offsetXPixels - spreadRadiusPixels, relativeY + offsetYPixels - spreadRadiusPixels, img.getWidth() + 2 * spreadRadiusPixels, img.getHeight() + 2 * spreadRadiusPixels);</span>
            //g.drawImage(maskImage, relativeX + offsetXPixels, relativeY + offsetYPixels);

<span class="nc" id="L2370">            g.setAlpha(origAlpha);</span>


<span class="nc" id="L2373">        } else {</span>
            // Use native shadow support.
<span class="nc" id="L2375">            g.drawShadow(img, relativeX, relativeY, dp2px(offsetX), dp2px(offsetY), dp2px(blurRadius), dp2px(spreadRadius), color, opacity);</span>
        }
<span class="nc" id="L2377">    }</span>

    /**
     * Checks to see if the component has elevation.  A component is considered to have elevation if either the current style
     * has a non-zero elevation value, or the component has *ever* had elevation in the past.  Once this is switched &quot;on&quot;, it
     * doesn't switch off.
     *
     * &lt;p&gt;This is used by Container to efficiently paint shadows of its children.  It helps it to know if the child component
     * has ever had elevation as it may need to &quot;erase&quot; the previous shadow.&lt;/p&gt;
     *
     * @return
     */
    boolean hasElevation() {
<span class="pc bpc" id="L2390" title="1 of 2 branches missed.">        if (_hasElevation) return true;</span>
<span class="fc" id="L2391">        Style s = getStyle();</span>
<span class="pc bpc" id="L2392" title="1 of 2 branches missed.">        if (s.getElevation() &gt; 0) {</span>
<span class="nc" id="L2393">            _hasElevation = true;</span>
        }
<span class="fc" id="L2395">        return _hasElevation;</span>
    }

    /**
     * Finds the nearest ancestor surface of this component.  This is the surface onto which drop-shadows will be
     * painted and projected.
     *
     * @return The surface if one is found.  Null if this component has no elevation, or no surface is found.  It is possible that
     * this will return a non-null value even if the component currently has zero elevation.  This occurs if the component has *ever* been
     * styled to have elevation.
     */
    Container findSurface() {
<span class="fc" id="L2407">        return _findSurface();</span>
    }

    /**
     * Calculates the shadow's X-offset at the given elevation.
     *
     * @param elevation THe elevation.
     * @return
     */
    int calculateShadowOffsetX(int elevation) {

<span class="pc bpc" id="L2418" title="1 of 2 branches missed.">        if (elevation &lt;= 0) {</span>
<span class="nc" id="L2419">            return 0;</span>
        }
<span class="pc bpc" id="L2421" title="10 of 11 branches missed.">        switch (elevation) {</span>
            case 1:
<span class="nc" id="L2423">                return dp2px(-4);</span>
            case 2:
<span class="nc" id="L2425">                return dp2px(-4);</span>
            case 3:
<span class="nc" id="L2427">                return dp2px(-9);</span>
            case 4:
<span class="nc" id="L2429">                return dp2px(-10);</span>
            case 6:
<span class="nc" id="L2431">                return dp2px(-19);</span>
            case 8:
<span class="nc" id="L2433">                return dp2px(-19);</span>
            case 9:
<span class="nc" id="L2435">                return dp2px(-22);</span>
            case 12:
<span class="nc" id="L2437">                return dp2px(-31);</span>
            case 16:
<span class="nc" id="L2439">                return dp2px(-42);</span>
            case 24:
<span class="nc" id="L2441">                return dp2px(-65);</span>

        }
<span class="fc" id="L2444">        return 0;</span>
    }

    /**
     * Caldulates the shadow X-offset in pixels at the componentl's current elevation.
     *
     * @return The x-offset in pixels.
     */
    int calculateShadowOffsetX() {
<span class="fc" id="L2453">        return calculateShadowOffsetX(getStyle().getElevation());</span>
    }

    /**
     * Calculates the shadow Y offset in pixels at the component's current elevation.
     *
     * @return The y-offset in pixels.
     * @see Style#getElevation()
     */
    int calculateShadowOffsetY() {
<span class="fc" id="L2463">        return calculateShadowOffsetY(getStyle().getElevation());</span>
    }

    /**
     * Calculates the shadow Y offset in pixels at the given elevation.
     *
     * @param elevation The elevation.
     * @return The y-offset.
     */
    int calculateShadowOffsetY(int elevation) {
<span class="fc" id="L2473">        return calculateShadowOffsetX(elevation);</span>
    }

    /**
     * Calculates the width of the shadow that this component would project against at its current elevation.
     *
     * @return The width in pixels.
     * @see Style#getElevation()
     */
    int calculateShadowWidth() {
<span class="fc" id="L2483">        return calculateShadowWidth(getStyle().getElevation());</span>
    }

    /**
     * Calculates the width of the shadow that this component would project against a surface at the given
     * elevation.
     *
     * @param elevation The elvation.
     * @return The width in pixels.
     */
    int calculateShadowWidth(int elevation) {
<span class="fc" id="L2494">        return getWidth() - 2 * calculateShadowOffsetX(elevation);</span>
    }

    /**
     * Calculates the height of the shadow that this component would project against at its current elevation.
     *
     * @return The height in pixels.
     * @see Style#getElevation()
     */
    int calculateShadowHeight() {
<span class="fc" id="L2504">        return calculateShadowHeight(getStyle().getElevation());</span>
    }

    /**
     * Calculates the height of the shadow that this component would project against a surface at the given
     * elevation.
     *
     * @param elevation The elvation.
     * @return The width in pixels.
     */
    int calculateShadowHeight(int elevation) {
<span class="fc" id="L2515">        return getHeight() - 2 * calculateShadowOffsetY(elevation);</span>
    }

    /**
     * Paints the drop-shadow projections for this component based on its elevation value.
     *
     * &lt;p&gt;This is called by the ancestor &quot;surface&quot; container of the component, after it paints its background, but
     * before painting its children.  If the {@link Style#getElevation()} of the component is {@literal 0}, then no shadow
     * will be painted.  Similarly, if the component has no ancestor container which is a surface (i.e. {@link Container#isSurface()} is true,
     * the shadow will not be painted.&lt;/p&gt;
     *
     * &lt;p&gt;NOTE: It is also possible that the shadow will not be visible if other opaque components are painted in front of
     * the ancestor surface container.  This is one of the limitations of this approach for simulating elevation.&lt;/p&gt;
     *
     * &lt;p&gt;Note: Not all platforms support drawing shadows.  Use {@link CodenameOneImplementation#isDrawShadowSupported()} to check
     * for support at runtime.&lt;/p&gt;
     *
     * @param g         The graphics context onto which the shadow should be painted.
     * @param relativeX The relative X coordinate onto which the shadow should be drawn.
     * @param relativeY The relative Y coordinate onto which the shadow should be drawn.
     * @see Container#paintElevatedPane(Graphics)
     * @see Container#isSurface()
     * @see Style#getElevation()
     * @since 8.0
     */

    public void paintShadows(Graphics g, final int relativeX, final int relativeY) {
<span class="fc" id="L2542">        final int elevation = getStyle().getElevation();</span>
<span class="fc bfc" id="L2543" title="All 2 branches covered.">        if (elevation &lt;= 0) {</span>
<span class="fc" id="L2544">            return;</span>
        }
<span class="pc bpc" id="L2546" title="2 of 4 branches missed.">        if (getWidth() == 0 || getHeight() == 0) return;</span>
<span class="fc" id="L2547">        synchronized (this) {</span>
<span class="pc bpc" id="L2548" title="1 of 2 branches missed.">            if (cachedShadowImage != null) {</span>
<span class="nc bnc" id="L2549" title="All 6 branches missed.">                if (cachedShadowWidth != getWidth() || cachedShadowHeight != getHeight() || cachedShadowElevation != elevation) {</span>

<span class="nc bnc" id="L2551" title="All 10 branches missed.">                    if (cachedShadowElevation == elevation &amp;&amp; cachedShadowWidth / (float) getWidth() &gt; 0.5f &amp;&amp; cachedShadowWidth / (float) getWidth() &lt; 2f &amp;&amp; cachedShadowHeight / (float) getHeight() &gt; 0.5f &amp;&amp; cachedShadowHeight / (float) getHeight() &lt; 2f) {</span>
                        // If the size change isn't too drastic, we can salvage the existing shadow image for performance reasons.
<span class="nc" id="L2553">                        cachedShadowImage = cachedShadowImage.scaled(calculateShadowWidth(), calculateShadowHeight());</span>
<span class="nc" id="L2554">                        cachedShadowWidth = getWidth();</span>
<span class="nc" id="L2555">                        cachedShadowHeight = getHeight();</span>
                    } else {
<span class="nc" id="L2557">                        cachedShadowImage = null;</span>
                    }
                }
            }
<span class="pc bpc" id="L2561" title="1 of 2 branches missed.">            if (cachedShadowImage != null) {</span>
<span class="nc" id="L2562">                g.drawImage(cachedShadowImage, relativeX + calculateShadowOffsetX(), relativeY + calculateShadowOffsetY());</span>
<span class="nc" id="L2563">                return;</span>
            }
<span class="fc" id="L2565">        }</span>

<span class="fc" id="L2567">        final Image fimg = this.toImage();</span>
<span class="pc bpc" id="L2568" title="1 of 2 branches missed.">        if (fimg == null) return;</span>
<span class="pc bpc" id="L2569" title="1 of 2 branches missed.">        if (paintinShadowInBackground_) {</span>
            // We are already painting the shadow in a background thread, so don't do it twice.
            // Just be patient.
<span class="nc" id="L2572">            return;</span>
        }
<span class="fc" id="L2574">        paintinShadowInBackground_ = true;</span>

<span class="fc" id="L2576">        Runnable createImageTask = new Runnable() {</span>
            public void run() {
                // We paint shadow in a background thread to avoid jank on the EDT.  It is possible that this
                // will cause problems on some platforms.  If that is the case, we can hedge and move it onto
                // the EDT in certain cases.


<span class="fc" id="L2583">                CN.setProperty(&quot;platformHint.showEDTWarnings&quot;, &quot;false&quot;); // Yes we know it's an EDT violation... Don't show me the error in simulator.</span>
                try {
<span class="fc" id="L2585">                    Image paddedImage = Image.createImage(calculateShadowWidth(), calculateShadowHeight(), 0x0);</span>
<span class="fc" id="L2586">                    Graphics paddedImageG = paddedImage.getGraphics();</span>
<span class="fc" id="L2587">                    paddedImageG.drawImage(fimg, -calculateShadowOffsetX(), -calculateShadowOffsetY());</span>
<span class="fc" id="L2588">                    Image img = paddedImage;</span>


<span class="fc" id="L2591">                    final Image shadowImage = Image.createImage(calculateShadowWidth(), calculateShadowHeight(), 0x0);</span>

<span class="fc" id="L2593">                    Graphics g = shadowImage.getGraphics();</span>

<span class="fc" id="L2595">                    int relativeX = 0;</span>
<span class="fc" id="L2596">                    int relativeY = 0;</span>


<span class="pc bpc" id="L2599" title="9 of 10 branches missed.">                    switch (elevation) {</span>
                        case 1:
                        case 2:
                            //drawShadow(g, img, relativeX, relativeY, 0, 1, 1, 0, 0, 0.14f);
                            //drawShadow(g, img, relativeX, relativeY, 0, 2, 1, -1, 0, 0.12f);
<span class="nc" id="L2604">                            drawShadow(g, img, relativeX, relativeY, 0, 1, 3, 0, 0, 0.2f);</span>
<span class="nc" id="L2605">                            break;</span>
                        case 3:
                            //drawShadow(g, img, relativeX, relativeY, 0, 3, 4, 0, 0, 0.14f);
                            //drawShadow(g, img, relativeX, relativeY, 0, 3, 3, -2, 0, 0.12f);
<span class="nc" id="L2609">                            drawShadow(g, img, relativeX, relativeY, 0, 1, 8, 0, 0, 0.2f);</span>
<span class="nc" id="L2610">                            break;</span>

                        case 4:

                            //drawShadow(g, img, relativeX, relativeY, 0, 4, 5, 0, 0, 0.14f);
                            //System.out.println(&quot;Shadow 1 took &quot;+(System.currentTimeMillis()-startTime)+&quot;ms&quot;);
                            //long shadow2Start = System.currentTimeMillis();
                            //drawShadow(g, img, relativeX, relativeY, 0, 1, 10, 0, 0, 0.12f);
                            //System.out.println(&quot;Shadow 2 took &quot;+(System.currentTimeMillis()-shadow2Start)+&quot;ms&quot;);
                            //shadow2Start = System.currentTimeMillis();
<span class="nc" id="L2620">                            drawShadow(g, img, relativeX, relativeY, 0, 2, 4, -1, 0, 0.2f);</span>
                            //System.out.println(&quot;Shadow 3 took &quot;+(System.currentTimeMillis()-shadow2Start)+&quot;ms&quot;);
<span class="nc" id="L2622">                            break;</span>

                        case 6:
                            //drawShadow(g, img, relativeX, relativeY, 0, 6, 10, 0, 0, 0.14f);
                            //drawShadow(g, img, relativeX, relativeY, 0, 1, 18, 0, 0, 0.12f);
<span class="nc" id="L2627">                            drawShadow(g, img, relativeX, relativeY, 0, 3, 5, -1, 0, 0.2f);</span>
<span class="nc" id="L2628">                            break;</span>

                        case 8:
<span class="nc" id="L2631">                            drawShadow(g, img, relativeX, relativeY, 0, 8, 10, 1, 0, 0.14f);</span>
                            //drawShadow(g, img, relativeX, relativeY, 0, 3, 4, 2, 0, 0.12f);
                            //drawShadow(g, img, relativeX, relativeY, 0, 5, 5, -3, 0, 0.2f);
<span class="nc" id="L2634">                            break;</span>
                        case 9:
<span class="nc" id="L2636">                            drawShadow(g, img, relativeX, relativeY, 0, 9, 12, 1, 0, 0.14f);</span>
                            //drawShadow(g, img, relativeX, relativeY, 0, 3, 16, 2, 0, 0.12f);
                            //drawShadow(g, img, relativeX, relativeY, 0, 5, 6, -3, 0, 0.2f);
<span class="nc" id="L2639">                            break;</span>

                        case 12:
<span class="nc" id="L2642">                            drawShadow(g, img, relativeX, relativeY, 0, 12, 17, 2, 0, 0.14f);</span>
                            //drawShadow(g, img, relativeX, relativeY, 0, 5, 22, 4, 0, 0.12f);
                            //drawShadow(g, img, relativeX, relativeY, 0, 7, 8, -4, 0, 0.2f);
<span class="nc" id="L2645">                            break;</span>

                        case 16:
<span class="nc" id="L2648">                            drawShadow(g, img, relativeX, relativeY, 0, 16, 24, 2, 0, 0.14f);</span>
                            //drawShadow(g, img, relativeX, relativeY, 0, 6, 30, 5, 0, 0.12f);
                            //drawShadow(g, img, relativeX, relativeY, 0, 8, 10, -5, 0, 0.2f);
<span class="nc" id="L2651">                            break;</span>

                        case 24:
<span class="nc" id="L2654">                            drawShadow(g, img, relativeX, relativeY, 0, 24, 38, 3, 0, 0.14f);</span>
                            //drawShadow(g, img, relativeX, relativeY, 0, 24, 38, 3, 0, 1f);
                            //drawShadow(g, img, relativeX, relativeY, 0, 9, 46, 8, 0, 0.12f);
                            //drawShadow(g, img, relativeX, relativeY, 0, 11, 15, -7, 0, 0.2f);
                            break;

                    }
<span class="fc" id="L2661">                    synchronized (this) {</span>
<span class="fc" id="L2662">                        cachedShadowImage = shadowImage;</span>
<span class="fc" id="L2663">                        cachedShadowHeight = getHeight();</span>
<span class="fc" id="L2664">                        cachedShadowWidth = getWidth();</span>
<span class="fc" id="L2665">                        cachedShadowElevation = elevation;</span>
<span class="fc" id="L2666">                        paintinShadowInBackground_ = false;</span>
<span class="fc" id="L2667">                    }</span>

<span class="fc" id="L2669">                    CN.callSerially(new Runnable() {</span>
                        public void run() {
<span class="fc" id="L2671">                            Container surface = findSurface();</span>
<span class="pc bpc" id="L2672" title="1 of 2 branches missed.">                            if (surface != null) {</span>
<span class="nc" id="L2673">                                surface.repaint();</span>
                            }
<span class="fc" id="L2675">                        }</span>
                    });
                } finally {
<span class="fc" id="L2678">                    CN.setProperty(&quot;platformHint.showEDTWarnings&quot;, &quot;true&quot;); // Reinstate EDT violation warnings now that we're done.</span>

<span class="fc" id="L2680">                    paintinShadowInBackground_ = false; // release the lock so that painting can resume.</span>
                }

<span class="fc" id="L2683">            }</span>
        };
<span class="pc bpc" id="L2685" title="1 of 2 branches missed.">        if (canCreateImageOffEdt()) {</span>
<span class="fc" id="L2686">            CN.scheduleBackgroundTask(createImageTask);</span>
        } else {
<span class="nc" id="L2688">            createImageTask.run();</span>
        }

        //origG.drawImage(cachedShadowImage, origRelativeX + calculateShadowOffsetX(), origRelativeY + calculateShadowOffsetY());


<span class="fc" id="L2694">    }</span>

    private boolean canCreateImageOffEdt() {
<span class="fc" id="L2697">        String platform = CN.getPlatformName();</span>
<span class="pc bpc" id="L2698" title="3 of 4 branches missed.">        return !&quot;ios&quot;.equals(platform) || CN.isSimulator();</span>
    }

    /**
     * Returns the absolute X location based on the component hierarchy, this method
     * calculates a location on the screen for the component rather than a relative
     * location as returned by getX()
     *
     * @return the absolute x location of the component
     * @see #getX
     */
    public int getAbsoluteX() {
<span class="fc" id="L2710">        int x = getX() - getScrollX();</span>
<span class="fc" id="L2711">        Container parent = getParent();</span>
<span class="fc bfc" id="L2712" title="All 2 branches covered.">        if (parent != null) {</span>
<span class="fc" id="L2713">            x += parent.getAbsoluteX();</span>
        }
<span class="fc" id="L2715">        return x;</span>
    }

    /**
     * Returns the absolute Y location based on the component hierarchy, this method
     * calculates a location on the screen for the component rather than a relative
     * location as returned by getX()
     *
     * @return the absolute y location of the component
     * @see #getY
     */
    public int getAbsoluteY() {
<span class="fc" id="L2727">        int y = getY() - getScrollY();</span>
<span class="fc" id="L2728">        Container parent = getParent();</span>
<span class="fc bfc" id="L2729" title="All 2 branches covered.">        if (parent != null) {</span>
<span class="fc" id="L2730">            y += parent.getAbsoluteY();</span>
        }
<span class="fc" id="L2732">        return y;</span>
    }

    int getRelativeX(Container relativeTo) {
<span class="fc" id="L2736">        int x = getX() - getScrollX();</span>
<span class="fc" id="L2737">        Container parent = getParent();</span>
<span class="pc bpc" id="L2738" title="3 of 4 branches missed.">        if (parent != relativeTo &amp;&amp; parent != null) {</span>
<span class="nc" id="L2739">            x += parent.getRelativeX(relativeTo);</span>
        }
<span class="fc" id="L2741">        return x;</span>
    }

    int getRelativeY(Container relativeTo) {
<span class="fc" id="L2745">        int y = getY() - getScrollY();</span>
<span class="fc" id="L2746">        Container parent = getParent();</span>
<span class="pc bpc" id="L2747" title="3 of 4 branches missed.">        if (parent != relativeTo &amp;&amp; parent != null) {</span>
<span class="nc" id="L2748">            y += parent.getRelativeY(relativeTo);</span>
        }
<span class="fc" id="L2750">        return y;</span>
    }

    /**
     * This method performs the paint of the component internally including drawing
     * the scrollbars and scrolling the component. This functionality is hidden
     * from developers to prevent errors
     *
     * @param g the component graphics
     */
    final void paintInternal(Graphics g) {
<span class="fc" id="L2761">        paintInternal(g, true);</span>
<span class="fc" id="L2762">    }</span>

    final void paintInternal(Graphics g, boolean paintIntersects) {
<span class="fc" id="L2765">        Display d = Display.getInstance();</span>
<span class="fc" id="L2766">        CodenameOneImplementation impl = d.getImplementation();</span>
<span class="pc bpc" id="L2767" title="1 of 4 branches missed.">        if (!isVisible() || doNotPaint) {</span>
<span class="fc" id="L2768">            return;</span>
        }

<span class="pc bpc" id="L2771" title="1 of 2 branches missed.">        if (paintLockImage != null) {</span>
<span class="nc bnc" id="L2772" title="All 2 branches missed.">            if (paintLockImage instanceof Image) {</span>
<span class="nc" id="L2773">                Image i = (Image) paintLockImage;</span>
<span class="nc" id="L2774">                g.drawImage(i, getX(), getY());</span>
<span class="nc" id="L2775">            } else {</span>
<span class="nc" id="L2776">                Image i = (Image) d.extractHardRef(paintLockImage);</span>
<span class="nc bnc" id="L2777" title="All 2 branches missed.">                if (i == null) {</span>
<span class="nc" id="L2778">                    i = ImageFactory.createImage(this, getWidth(), getHeight(), 0);</span>
<span class="nc" id="L2779">                    int x = getX();</span>
<span class="nc" id="L2780">                    int y = getY();</span>
<span class="nc" id="L2781">                    setX(0);</span>
<span class="nc" id="L2782">                    setY(0);</span>
<span class="nc" id="L2783">                    paintInternalImpl(i.getGraphics(), paintIntersects);</span>
<span class="nc" id="L2784">                    setX(x);</span>
<span class="nc" id="L2785">                    setY(y);</span>
<span class="nc" id="L2786">                    paintLockImage = d.createSoftWeakRef(i);</span>
                }
<span class="nc" id="L2788">                g.drawImage(i, getX(), getY());</span>
            }
<span class="nc" id="L2790">            return;</span>
        }
<span class="fc" id="L2792">        impl.beforeComponentPaint(this, g);</span>
<span class="fc" id="L2793">        paintInternalImpl(g, paintIntersects);</span>
<span class="fc" id="L2794">        impl.afterComponentPaint(this, g);</span>
<span class="fc" id="L2795">    }</span>

    protected boolean isInClippingRegion(Graphics g) {
<span class="fc" id="L2798">        int oX = g.getClipX();</span>
<span class="fc" id="L2799">        int oY = g.getClipY();</span>
<span class="fc" id="L2800">        int oWidth = g.getClipWidth();</span>
<span class="fc" id="L2801">        int oHeight = g.getClipHeight();</span>
<span class="fc" id="L2802">        return bounds.intersects(oX, oY, oWidth, oHeight);</span>
    }

    private void paintInternalImpl(Graphics g, boolean paintIntersects) {
<span class="fc" id="L2806">        int oX = g.getClipX();</span>
<span class="fc" id="L2807">        int oY = g.getClipY();</span>
<span class="fc" id="L2808">        int oWidth = g.getClipWidth();</span>
<span class="fc" id="L2809">        int oHeight = g.getClipHeight();</span>
<span class="fc bfc" id="L2810" title="All 2 branches covered.">        if (bounds.intersects(oX, oY, oWidth, oHeight)) {</span>
<span class="fc" id="L2811">            Style s = getStyle();</span>
<span class="pc bpc" id="L2812" title="1 of 4 branches missed.">            if (s.getOpacity() &lt; 255 &amp;&amp; g.isAlphaSupported()) {</span>
<span class="nc" id="L2813">                int oldAlpha = g.getAlpha();</span>
<span class="nc" id="L2814">                g.setAlpha(s.getOpacity());</span>
<span class="nc" id="L2815">                internalPaintImpl(g, paintIntersects);</span>
<span class="nc" id="L2816">                g.setAlpha(oldAlpha);</span>
<span class="nc" id="L2817">            } else {</span>
<span class="fc" id="L2818">                internalPaintImpl(g, paintIntersects);</span>
            }

<span class="fc" id="L2821">            g.setClip(oX, oY, oWidth, oHeight);</span>
<span class="fc" id="L2822">        } else {</span>
<span class="fc" id="L2823">            Display.impl.nothingWithinComponentPaint(this);</span>
        }
<span class="fc" id="L2825">    }</span>

    void internalPaintImpl(Graphics g, boolean paintIntersects) {
<span class="fc" id="L2828">        g.clipRect(getX(), getY(), getWidth(), getHeight());</span>
<span class="fc" id="L2829">        paintComponentBackground(g);</span>

<span class="fc bfc" id="L2831" title="All 2 branches covered.">        if (isScrollable()) {</span>
<span class="pc bpc" id="L2832" title="1 of 6 branches missed.">            if (refreshTask != null &amp;&amp; !InfiniteProgress.isDefaultMaterialDesignMode() &amp;&amp;</span>
<span class="pc bpc" id="L2833" title="1 of 2 branches missed.">                    (draggedMotionY == null || getClientProperty(&quot;$pullToRelease&quot;) != null)) {</span>
<span class="fc" id="L2834">                paintPullToRefresh(g);</span>
            }
<span class="fc" id="L2836">            int scrollX = getScrollX();</span>
<span class="fc" id="L2837">            int scrollY = getScrollY();</span>
<span class="fc" id="L2838">            g.translate(-scrollX, -scrollY);</span>
<span class="fc" id="L2839">            paint(g);</span>
<span class="fc" id="L2840">            g.translate(scrollX, scrollY);</span>
<span class="fc bfc" id="L2841" title="All 2 branches covered.">            if (isScrollVisible) {</span>
<span class="fc" id="L2842">                paintScrollbars(g);</span>
            }
<span class="fc" id="L2844">        } else {</span>
<span class="fc" id="L2845">            paint(g);</span>
        }
<span class="fc bfc" id="L2847" title="All 2 branches covered.">        if (isBorderPainted()) {</span>
<span class="fc" id="L2848">            paintBorder(g);</span>
        }

        //paint all the intersecting Components above the Component
<span class="fc bfc" id="L2852" title="All 4 branches covered.">        if (paintIntersects &amp;&amp; parent != null) {</span>
<span class="fc" id="L2853">            paintIntersectingComponentsAbove(g);</span>
        }
<span class="fc" id="L2855">    }</span>

    /**
     * Paints intersecting components that appear above this component.
     *
     * @param g Graphics context
     * @deprecated For internal use only
     */
    public void paintIntersectingComponentsAbove(Graphics g) {
<span class="fc" id="L2864">        Container parent = getParent();</span>
<span class="fc" id="L2865">        Component component = this;</span>
<span class="fc" id="L2866">        int tx = g.getTranslateX();</span>
<span class="fc" id="L2867">        int ty = g.getTranslateY();</span>

<span class="fc" id="L2869">        g.translate(-tx, -ty);</span>
<span class="fc" id="L2870">        int x1 = getAbsoluteX() + getScrollX();</span>
<span class="fc" id="L2871">        int y1 = getAbsoluteY() + getScrollY();</span>
<span class="fc" id="L2872">        int w = getWidth();</span>
<span class="fc" id="L2873">        int h = getHeight();</span>

<span class="fc bfc" id="L2875" title="All 2 branches covered.">        while (parent != null) {</span>
<span class="fc" id="L2876">            int ptx = parent.getAbsoluteX() + parent.getScrollX();</span>
<span class="fc" id="L2877">            int pty = parent.getAbsoluteY() + parent.getScrollY();</span>
<span class="fc" id="L2878">            g.translate(ptx, pty);</span>
<span class="fc" id="L2879">            parent.paintIntersecting(g, component, x1, y1, w, h, true, 0);</span>


<span class="pc bpc" id="L2882" title="1 of 2 branches missed.">            if (parent.isSurface()) {</span>
                // If this is a surface, then we need to render the elevated pane
<span class="nc" id="L2884">                parent.paintElevatedPane(g, true, x1, y1, w, h, this.renderedElevation, this.renderedElevationComponentIndex, true);</span>
            }
<span class="fc" id="L2886">            g.translate(-ptx, -pty);</span>
<span class="fc" id="L2887">            component = parent;</span>
<span class="fc" id="L2888">            parent = parent.getParent();</span>
<span class="fc" id="L2889">        }</span>
<span class="fc" id="L2890">        g.translate(tx, ty);</span>

<span class="fc" id="L2892">    }</span>

    /**
     * Paints the UI for the scrollbars on the component, this will be invoked only
     * for scrollable components. This method invokes the appropriate X/Y versions
     * to do all the work.
     *
     * @param g the component graphics
     */
    protected void paintScrollbars(Graphics g) {
<span class="fc bfc" id="L2902" title="All 2 branches covered.">        if (isScrollableX()) {</span>
<span class="fc" id="L2903">            paintScrollbarX(g);</span>
        }
<span class="pc bpc" id="L2905" title="1 of 2 branches missed.">        if (isScrollableY()) {</span>
<span class="fc" id="L2906">            paintScrollbarY(g);</span>
        }
<span class="fc" id="L2908">    }</span>

    private void paintPullToRefresh(Graphics g) {
<span class="pc bpc" id="L2911" title="2 of 4 branches missed.">        if (!dragActivated &amp;&amp; scrollY == -getUIManager().getLookAndFeel().getPullToRefreshHeight()</span>
<span class="nc bnc" id="L2912" title="All 2 branches missed.">                &amp;&amp; getClientProperty(&quot;$pullToRelease&quot;) != null</span>
<span class="nc bnc" id="L2913" title="All 2 branches missed.">                &amp;&amp; getClientProperty(&quot;$pullToRelease&quot;).equals(&quot;update&quot;)) {</span>

<span class="nc" id="L2915">            putClientProperty(&quot;$pullToRelease&quot;, &quot;updating&quot;);</span>
<span class="nc" id="L2916">            draggedMotionY = null;</span>
            //execute the task
<span class="nc" id="L2918">            Display.getInstance().callSerially(new Runnable() {</span>

                public void run() {
<span class="nc" id="L2921">                    refreshTask.run();</span>
                    //once the task has finished scroll to 0
<span class="nc" id="L2923">                    startTensile(scrollY, 0, true);</span>
<span class="nc" id="L2924">                    putClientProperty(&quot;$pullToRelease&quot;, null);</span>
<span class="nc" id="L2925">                }</span>
            });
        }
<span class="pc bpc" id="L2928" title="1 of 2 branches missed.">        boolean updating = getClientProperty(&quot;$pullToRelease&quot;) != null</span>
<span class="pc bnc" id="L2929" title="All 2 branches missed.">                &amp;&amp; getClientProperty(&quot;$pullToRelease&quot;).equals(&quot;updating&quot;);</span>
<span class="fc" id="L2930">        getUIManager().getLookAndFeel().drawPullToRefresh(g, this, updating);</span>
<span class="fc" id="L2931">    }</span>

    /**
     * Paints the UI for the scrollbar on the X axis, this method allows component
     * subclasses to customize the look of a scrollbar
     *
     * @param g the component graphics
     */
    protected void paintScrollbarX(Graphics g) {
<span class="fc" id="L2940">        float scrollW = getScrollDimension().getWidth();</span>
<span class="fc" id="L2941">        float block = ((float) getWidth()) / scrollW;</span>
        float offset;
<span class="pc bpc" id="L2943" title="1 of 2 branches missed.">        if (getScrollX() + getWidth() == scrollW) {</span>
            // normalize the offset to avoid rounding errors to the bottom of the screen
<span class="nc" id="L2945">            offset = 1 - block;</span>
        } else {
<span class="fc" id="L2947">            offset = (((float) getScrollX() + getWidth()) / scrollW) - block;</span>
        }
<span class="fc" id="L2949">        getUIManager().getLookAndFeel().drawHorizontalScroll(g, this, offset, block);</span>
<span class="fc" id="L2950">    }</span>

    /**
     * This method is used internally by the look and feel to implement the fading scrollbar
     * behavior.
     *
     * @return the opacity of the scrollbar
     */
    public int getScrollOpacity() {
<span class="pc bpc" id="L2959" title="1 of 2 branches missed.">        if (Display.getInstance().shouldRenderSelection()) {</span>
<span class="fc" id="L2960">            scrollOpacity = 0xff;</span>
        }
<span class="fc" id="L2962">        return scrollOpacity;</span>
    }

    /**
     * Returns the component bounds with absolute screen coordinates, for components that include an internal selection behavior
     * and are not containers (currently only List) this method allows returning the position of the selection
     * itself which is useful for things such as the popup dialog and similar UI's that need to reference the
     * position of the selection externally
     *
     * @return the bounds of the component with absolute screen coordinates
     */
    public Rectangle getSelectedRect() {
<span class="fc" id="L2974">        return new Rectangle(getAbsoluteX(), getAbsoluteY(), bounds.getSize());</span>
    }

    /**
     * Paints the UI for the scrollbar on the Y axis, this method allows component
     * subclasses to customize the look of a scrollbar
     *
     * @param g the component graphics
     */
    protected void paintScrollbarY(Graphics g) {
<span class="fc" id="L2984">        float scrollH = getScrollDimension().getHeight();</span>
<span class="fc" id="L2985">        float block = ((float) getHeight()) / scrollH;</span>
        float offset;
<span class="fc bfc" id="L2987" title="All 2 branches covered.">        if (getScrollY() + getHeight() == scrollH) {</span>
            // normalize the offset to avoid rounding errors to the bottom of the screen
<span class="fc" id="L2989">            offset = 1 - block;</span>
        } else {
<span class="fc" id="L2991">            offset = (((float) getScrollY() + getHeight()) / scrollH) - block;</span>
        }
<span class="fc" id="L2993">        getUIManager().getLookAndFeel().drawVerticalScroll(g, this, offset, block);</span>
<span class="fc" id="L2994">    }</span>

    /**
     * &lt;p&gt;Paints this component as a root by going to all the parent components and
     * setting the absolute translation based on coordinates and scroll status.
     * Restores translation when the painting is finished.&lt;br&gt;
     * One of the uses of this method is to create a &quot;screenshot&quot; as is demonstrated in the code below
     * that creates an image for sharing on social media&lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/codenameone/6bf5e68b329ae59a25e3.js&quot;&gt;&lt;/script&gt;
     *
     * @param g the graphics to paint this Component on
     */
    final public void paintComponent(Graphics g) {
<span class="fc" id="L3007">        repaintPending = false;</span>
<span class="fc" id="L3008">        paintComponent(g, true);</span>
<span class="fc" id="L3009">    }</span>

    /**
     * &lt;p&gt;Paints this component as a root by going to all the parent components and
     * setting the absolute translation based on coordinates and scroll status.
     * Restores translation when the painting is finished.&lt;br&gt;
     * One of the uses of this method is to create a &quot;screenshot&quot; as is demonstrated in the code below
     * that creates an image for sharing on social media&lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/codenameone/6bf5e68b329ae59a25e3.js&quot;&gt;&lt;/script&gt;
     *
     * @param g          the graphics to paint this Component on
     * @param background if true paints all parents background
     */
    final public void paintComponent(Graphics g, boolean background) {
<span class="fc bfc" id="L3023" title="All 2 branches covered.">        if (!isVisible()) {</span>
<span class="fc" id="L3024">            return;</span>
        }
<span class="fc" id="L3026">        int clipX = g.getClipX();</span>
<span class="fc" id="L3027">        int clipY = g.getClipY();</span>
<span class="fc" id="L3028">        int clipW = g.getClipWidth();</span>
<span class="fc" id="L3029">        int clipH = g.getClipHeight();</span>
        //g.pushClip();
<span class="fc" id="L3031">        Container parent = getParent();</span>
<span class="fc" id="L3032">        int translateX = 0;</span>
<span class="fc" id="L3033">        int translateY = 0;</span>
<span class="fc bfc" id="L3034" title="All 2 branches covered.">        while (parent != null) {</span>
<span class="fc" id="L3035">            translateX += parent.getX();</span>
<span class="fc" id="L3036">            translateY += parent.getY();</span>
            //if (parent.isScrollable()) {
<span class="pc bpc" id="L3038" title="1 of 2 branches missed.">            if (parent.isScrollableX()) {</span>
<span class="nc" id="L3039">                translateX -= parent.getScrollX();</span>
            }
<span class="pc bpc" id="L3041" title="1 of 2 branches missed.">            if (parent.isScrollableY()) {</span>
<span class="nc" id="L3042">                translateY -= parent.getScrollY();</span>
            }
            // since scrollability can translate everything... we should clip based on the
            // current scroll
<span class="fc" id="L3046">            int parentX = parent.getAbsoluteX() + parent.getScrollX();</span>
<span class="pc bpc" id="L3047" title="1 of 2 branches missed.">            if (isRTL()) {</span>
<span class="nc" id="L3048">                parentX += parent.getSideGap();</span>
            }
<span class="fc" id="L3050">            g.clipRect(parentX, parent.getAbsoluteY() + parent.getScrollY(),</span>
<span class="fc" id="L3051">                    parent.getWidth() - parent.getSideGap(), parent.getHeight() - parent.getBottomGap());</span>

<span class="fc" id="L3053">            parent = parent.getParent();</span>
<span class="fc" id="L3054">        }</span>

<span class="fc" id="L3056">        g.clipRect(translateX + getX(), translateY + getY(), getWidth(), getHeight());</span>
<span class="fc bfc" id="L3057" title="All 2 branches covered.">        if (background) {</span>
<span class="fc" id="L3058">            paintBackgrounds(g);</span>
        }


<span class="fc" id="L3062">        g.translate(translateX, translateY);</span>
<span class="fc" id="L3063">        paintInternal(g);</span>
<span class="fc" id="L3064">        g.translate(-translateX, -translateY);</span>

<span class="fc" id="L3066">        paintGlassImpl(g);</span>

<span class="fc" id="L3068">        g.setClip(clipX, clipY, clipW, clipH);</span>
        //g.popClip();
<span class="fc" id="L3070">    }</span>

    /**
     * This method can be overriden by a component to draw on top of itself or its children
     * after the component or the children finished drawing in a similar way to the glass
     * pane but more refined per component
     *
     * @param g the graphics context
     */
    void paintGlassImpl(Graphics g) {
<span class="fc bfc" id="L3080" title="All 2 branches covered.">        if (parent != null) {</span>
<span class="fc" id="L3081">            parent.paintGlassImpl(g);</span>
        }
<span class="fc" id="L3083">        paintTensile(g);</span>
<span class="fc" id="L3084">    }</span>

    /**
     * Returns the area of this component that is currently hidden by the virtual keyboard.
     *
     * @return The height of the area under the virtual keyboard in pixels
     */
    private int getInvisibleAreaUnderVKB() {
<span class="fc" id="L3092">        Form f = getComponentForm();</span>
<span class="fc bfc" id="L3093" title="All 2 branches covered.">        if (f != null) {</span>
<span class="fc" id="L3094">            int invisibleAreaUnderVKB = Form.getInvisibleAreaUnderVKB(f);</span>
<span class="pc bpc" id="L3095" title="1 of 2 branches missed.">            if (invisibleAreaUnderVKB == 0) {</span>
<span class="fc" id="L3096">                return 0;</span>
            }
<span class="nc" id="L3098">            int bottomGap = f.getHeight() - getAbsoluteY() - getScrollY() - getHeight();</span>
<span class="nc bnc" id="L3099" title="All 2 branches missed.">            if (bottomGap &lt; invisibleAreaUnderVKB) {</span>
<span class="nc" id="L3100">                return invisibleAreaUnderVKB - bottomGap;</span>
            } else {
<span class="nc" id="L3102">                return 0;</span>
            }
        }
<span class="fc" id="L3105">        return 0;</span>
    }

    void paintTensile(Graphics g) {
<span class="pc bpc" id="L3109" title="1 of 2 branches missed.">        if (tensileHighlightIntensity &gt; 0) {</span>
<span class="nc" id="L3110">            int i = getScrollDimension().getHeight() - getHeight() + getInvisibleAreaUnderVKB();</span>
<span class="nc bnc" id="L3111" title="All 2 branches missed.">            if (scrollY &gt;= i - 1) {</span>
<span class="nc" id="L3112">                getUIManager().getLookAndFeel().paintTensileHighlight(this, g, false, tensileHighlightIntensity);</span>
            } else {
<span class="nc bnc" id="L3114" title="All 2 branches missed.">                if (scrollY &lt; 1) {</span>
<span class="nc" id="L3115">                    getUIManager().getLookAndFeel().paintTensileHighlight(this, g, true, tensileHighlightIntensity);</span>
                } else {
<span class="nc" id="L3117">                    tensileHighlightIntensity = 0;</span>
                }
            }
        }
<span class="fc" id="L3121">    }</span>

    private void drawPainters(com.codename1.ui.Graphics g, Component par, Component c,
                              int x, int y, int w, int h) {
<span class="pc bpc" id="L3125" title="5 of 6 branches missed.">        if (flatten &amp;&amp; getWidth() &gt; 0 &amp;&amp; getHeight() &gt; 0) {</span>
<span class="nc" id="L3126">            Image i = (Image) getClientProperty(&quot;$FLAT&quot;);</span>
<span class="nc" id="L3127">            int absX = getAbsoluteX() + getScrollX();</span>
<span class="nc" id="L3128">            int absY = getAbsoluteY() + getScrollY();</span>
<span class="nc bnc" id="L3129" title="All 6 branches missed.">            if (i == null || i.getWidth() != getWidth() || i.getHeight() != getHeight()) {</span>
<span class="nc" id="L3130">                i = ImageFactory.createImage(this, getWidth(), getHeight(), 0);</span>
<span class="nc" id="L3131">                Graphics tg = i.getGraphics();</span>
                //tg.translate(g.getTranslateX(), g.getTranslateY());
<span class="nc" id="L3133">                drawPaintersImpl(tg, par, c, x, y, w, h);</span>
<span class="nc" id="L3134">                paintBackgroundImpl(tg);</span>
<span class="nc" id="L3135">                putClientProperty(&quot;$FLAT&quot;, i);</span>
            }
<span class="nc" id="L3137">            int tx = g.getTranslateX();</span>
<span class="nc" id="L3138">            int ty = g.getTranslateY();</span>
<span class="nc" id="L3139">            g.translate(-tx + absX, -ty + absY);</span>
<span class="nc" id="L3140">            g.drawImage(i, 0, 0);</span>
<span class="nc" id="L3141">            g.translate(tx - absX, ty - absY);</span>
<span class="nc" id="L3142">            return;</span>
        }
<span class="fc" id="L3144">        drawPaintersImpl(g, par, c, x, y, w, h);</span>
<span class="fc" id="L3145">    }</span>

    private void drawPaintersImpl(com.codename1.ui.Graphics g, Component par, Component c,
                                  int x, int y, int w, int h) {
<span class="fc bfc" id="L3149" title="All 2 branches covered.">        if (par == null) {</span>
<span class="fc" id="L3150">            return;</span>
        } else {
<span class="fc bfc" id="L3152" title="All 2 branches covered.">            if (par.getStyle().getBgTransparency() != ((byte) 0xFF)) {</span>
<span class="fc" id="L3153">                drawPainters(g, par.getParent(), par, x, y, w, h);</span>
            }
        }

<span class="fc bfc" id="L3157" title="All 2 branches covered.">        if (!par.isVisible()) {</span>
<span class="fc" id="L3158">            return;</span>
        }

<span class="fc" id="L3161">        int transX = par.getAbsoluteX() + par.getScrollX();</span>
<span class="fc" id="L3162">        int transY = par.getAbsoluteY() + par.getScrollY();</span>

<span class="fc" id="L3164">        g.translate(transX, transY);</span>


<span class="fc bfc" id="L3167" title="All 2 branches covered.">        if (par.isBorderPainted()) {</span>
<span class="fc" id="L3168">            Border b = par.getBorder();</span>
<span class="pc bpc" id="L3169" title="1 of 2 branches missed.">            if (b.isBackgroundPainter()) {</span>
<span class="nc" id="L3170">                g.translate(-par.getX(), -par.getY());</span>
<span class="nc" id="L3171">                par.paintBorderBackground(g);</span>
<span class="nc" id="L3172">                par.paintBorder(g);</span>
<span class="nc" id="L3173">                g.translate(par.getX() - transX, par.getY() - transY);</span>
<span class="nc" id="L3174">                return;</span>
            }
        }
<span class="fc" id="L3177">        Painter p = par.getStyle().getBgPainter();</span>
<span class="pc bpc" id="L3178" title="1 of 2 branches missed.">        if (p != null) {</span>
            Rectangle rect;
<span class="fc bfc" id="L3180" title="All 2 branches covered.">            if (painterBounds == null) {</span>
<span class="fc" id="L3181">                painterBounds = new Rectangle(0, 0, par.getWidth(), par.getHeight());</span>
<span class="fc" id="L3182">                rect = painterBounds;</span>
            } else {
<span class="fc" id="L3184">                rect = painterBounds;</span>
<span class="fc" id="L3185">                rect.getSize().setWidth(par.getWidth());</span>
<span class="fc" id="L3186">                rect.getSize().setHeight(par.getHeight());</span>
            }
<span class="fc" id="L3188">            p.paint(g, rect);</span>
        }
<span class="fc" id="L3190">        par.paintBackground(g);</span>
<span class="fc" id="L3191">        ((Container) par).paintIntersecting(g, c, x, y, w, h, false, 0);</span>
<span class="fc" id="L3192">        g.translate(-transX, -transY);</span>
<span class="fc" id="L3193">    }</span>

    private void paintRippleEffect(Graphics g) {
<span class="pc bpc" id="L3196" title="5 of 6 branches missed.">        if (isRippleEffect() &amp;&amp; Form.rippleComponent == this &amp;&amp; Form.rippleMotion != null) {</span>
<span class="nc" id="L3197">            paintRippleOverlay(g, Form.rippleX, Form.rippleY, Form.rippleMotion.getValue());</span>
        }
<span class="fc" id="L3199">    }</span>

    /**
     * Normally returns getStyle().getBorder() but some subclasses might use this
     * to programmatically replace the border in runtime e.g. for a pressed border effect
     *
     * @return the border that is drawn according to the current component state
     */
    protected Border getBorder() {
<span class="fc" id="L3208">        return getStyle().getBorder();</span>
    }

    /**
     * Paints the background of the component, invoked with the clipping region
     * and appropriate scroll translation.
     *
     * @param g the component graphics
     */
    void paintComponentBackground(Graphics g) {
<span class="pc bpc" id="L3218" title="1 of 4 branches missed.">        if (isFlatten() || !opaque) {</span>
<span class="fc" id="L3219">            return;</span>
        }
<span class="fc" id="L3221">        paintBackgroundImpl(g);</span>
<span class="fc" id="L3222">    }</span>

    /**
     * Returns the scrollable parent of this component
     *
     * @return the component itself or its parent which is scrollable
     */
    public Component getScrollable() {
<span class="pc bpc" id="L3230" title="1 of 2 branches missed.">        if (isScrollable()) {</span>
<span class="fc" id="L3231">            return this;</span>
        }
<span class="nc" id="L3233">        Component p = getParent();</span>
<span class="nc bnc" id="L3234" title="All 2 branches missed.">        if (p == null) {</span>
<span class="nc" id="L3235">            return null;</span>
        }
<span class="nc" id="L3237">        return p.getScrollable();</span>
    }

    /**
     * Returns the scrollable parent of this component
     */
    private Component getScrollableFast() {
<span class="nc bnc" id="L3244" title="All 4 branches missed.">        if (scrollableXFlag() || scrollableYFlag()) {</span>
<span class="nc" id="L3245">            return this;</span>
        }
<span class="nc" id="L3247">        Component p = getParent();</span>
<span class="nc bnc" id="L3248" title="All 2 branches missed.">        if (p == null) {</span>
<span class="nc" id="L3249">            return null;</span>
        }
<span class="nc" id="L3251">        return p.getScrollableFast();</span>
    }

    private void paintBackgroundImpl(Graphics g) {
<span class="fc bfc" id="L3255" title="All 2 branches covered.">        if (isBorderPainted()) {</span>
<span class="fc" id="L3256">            Border b = getBorder();</span>
<span class="pc bpc" id="L3257" title="1 of 4 branches missed.">            if (b != null &amp;&amp; b.isBackgroundPainter()) {</span>
<span class="fc" id="L3258">                b.paintBorderBackground(g, this);</span>
<span class="fc" id="L3259">                paintRippleEffect(g);</span>
<span class="fc" id="L3260">                return;</span>
            }
        }
<span class="fc bfc" id="L3263" title="All 2 branches covered.">        if (getStyle().getBgPainter() != null) {</span>
<span class="fc" id="L3264">            getStyle().getBgPainter().paint(g, bounds);</span>
        }
<span class="fc" id="L3266">        paintBackground(g);</span>
<span class="fc" id="L3267">        paintRippleEffect(g);</span>
<span class="fc" id="L3268">    }</span>

    /**
     * This method paints the Component background, it should be overriden
     * by subclasses to perform custom background drawing.
     *
     * @param g the component graphics
     */
    protected void paintBackground(Graphics g) {
<span class="fc" id="L3277">    }</span>

    /**
     * This method paints the Component on the screen, it should be overriden
     * by subclasses to perform custom drawing or invoke the UI API's to let
     * the PLAF perform the rendering.
     *
     * @param g the component graphics
     */
    public void paint(Graphics g) {
<span class="fc" id="L3287">    }</span>

    /**
     * Indicates whether the component should/could scroll by default a component
     * is not scrollable.
     *
     * @return whether the component is scrollable
     */
    protected boolean isScrollable() {
<span class="fc bfc" id="L3296" title="All 4 branches covered.">        return isScrollableX() || isScrollableY();</span>
    }

    /**
     * Indicates whether the component should/could scroll on the X axis
     *
     * @return whether the component is scrollable on the X axis
     */
    public boolean isScrollableX() {
<span class="fc" id="L3305">        return false;</span>
    }

    /**
     * Indicates whether the component should/could scroll on the Y axis
     *
     * @return whether the component is scrollable on the X axis
     */
    public boolean isScrollableY() {
<span class="fc" id="L3314">        return false;</span>
    }

    boolean scrollableXFlag() {
<span class="fc" id="L3318">        return isScrollableX();</span>
    }

    boolean scrollableYFlag() {
<span class="fc" id="L3322">        return isScrollableY();</span>
    }

    /**
     * Indicates the X position of the scrolling, this number is relative to the
     * component position and so a position of 0 would indicate the x position
     * of the component.
     *
     * @return the X position of the scrolling
     */
    public int getScrollX() {
<span class="fc" id="L3333">        return scrollX;</span>
    }

    /**
     * Indicates the X position of the scrolling, this number is relative to the
     * component position and so a position of 0 would indicate the x position
     * of the component.
     *
     * @param scrollX the X position of the scrolling
     */
    protected void setScrollX(int scrollX) {
        // the setter must always update the value regardless...
<span class="fc" id="L3345">        int scrollXtmp = scrollX;</span>
<span class="pc bpc" id="L3346" title="2 of 4 branches missed.">        if (!isSmoothScrolling() || !isTensileDragEnabled()) {</span>
<span class="nc" id="L3347">            scrollXtmp = Math.min(scrollXtmp, getScrollDimension().getWidth() - getWidth());</span>
<span class="nc" id="L3348">            scrollXtmp = Math.max(scrollXtmp, 0);</span>
        }
<span class="pc bpc" id="L3350" title="1 of 2 branches missed.">        if (isScrollableX()) {</span>
<span class="nc bnc" id="L3351" title="All 2 branches missed.">            if (Form.activePeerCount &gt; 0) {</span>
<span class="nc" id="L3352">                onParentPositionChange();</span>
            }
<span class="nc" id="L3354">            repaint();</span>
        }
<span class="pc bpc" id="L3356" title="1 of 2 branches missed.">        if (scrollListeners != null) {</span>
<span class="nc" id="L3357">            scrollListeners.fireScrollEvent(scrollXtmp, this.scrollY, this.scrollX, this.scrollY);</span>
        }
<span class="fc" id="L3359">        this.scrollX = scrollXtmp;</span>
<span class="fc" id="L3360">        onScrollX(scrollX);</span>
<span class="fc" id="L3361">    }</span>

    /**
     * Indicates the Y position of the scrolling, this number is relative to the
     * component position and so a position of 0 would indicate the y position
     * of the component.
     *
     * @return the Y position of the scrolling
     */
    public int getScrollY() {
<span class="fc" id="L3371">        return scrollY;</span>
    }

    /**
     * Indicates the Y position of the scrolling, this number is relative to the
     * component position and so a position of 0 would indicate the y position
     * of the component.
     *
     * @param scrollY the Y position of the scrolling
     */
    protected void setScrollY(int scrollY) {
<span class="fc bfc" id="L3382" title="All 2 branches covered.">        if (this.scrollY != scrollY) {</span>
<span class="fc" id="L3383">            CodenameOneImplementation ci = Display.impl;</span>

<span class="pc bpc" id="L3385" title="2 of 4 branches missed.">            if (ci.isAsyncEditMode() &amp;&amp; ci.isEditingText()) {</span>
<span class="nc" id="L3386">                Component editingText = ci.getEditingText();</span>
<span class="nc bnc" id="L3387" title="All 6 branches missed.">                if (editingText != null &amp;&amp; this instanceof Container &amp;&amp; ((Container) this).contains(editingText)) {</span>
<span class="nc" id="L3388">                    ci.hideTextEditor();</span>
                }
            }
        }
        // the setter must always update the value regardless...
<span class="fc" id="L3393">        int scrollYtmp = scrollY;</span>
<span class="pc bpc" id="L3394" title="2 of 4 branches missed.">        if (!isSmoothScrolling() || !isTensileDragEnabled()) {</span>
<span class="nc" id="L3395">            int v = getInvisibleAreaUnderVKB();</span>
<span class="nc" id="L3396">            int h = getScrollDimension().getHeight() - getHeight() + v;</span>
<span class="nc" id="L3397">            scrollYtmp = Math.min(scrollYtmp, h);</span>
<span class="nc" id="L3398">            scrollYtmp = Math.max(scrollYtmp, 0);</span>
        }
<span class="fc bfc" id="L3400" title="All 2 branches covered.">        if (isScrollableY()) {</span>
<span class="pc bpc" id="L3401" title="1 of 2 branches missed.">            if (Form.activePeerCount &gt; 0) {</span>
<span class="nc" id="L3402">                onParentPositionChange();</span>
            }
<span class="fc" id="L3404">            repaint();</span>
        }
<span class="fc bfc" id="L3406" title="All 2 branches covered.">        if (scrollListeners != null) {</span>
<span class="fc" id="L3407">            scrollListeners.fireScrollEvent(this.scrollX, scrollYtmp, this.scrollX, this.scrollY);</span>
        }
<span class="fc" id="L3409">        this.scrollY = scrollYtmp;</span>
<span class="fc" id="L3410">        onScrollY(this.scrollY);</span>
<span class="fc" id="L3411">    }</span>

    /**
     * This method can be overriden to receive scroll events, unlike overriding setScrollX
     * it will receive all calls for scrolling. Normally you should not override this method
     * and try to find a more creative solution since scrolling is very specific to platform
     * behavior.
     *
     * @param scrollX the X position of the scrolling
     */
    protected void onScrollX(int scrollX) {
<span class="fc" id="L3422">    }</span>

    /**
     * This method can be overriden to receive scroll events, unlike overriding setScrollY
     * it will receive all calls for scrolling. Normally you should not override this method
     * and try to find a more creative solution since scrolling is very specific to platform
     * behavior.
     *
     * @param scrollY the Y position of the scrolling
     */
    protected void onScrollY(int scrollY) {
<span class="fc" id="L3433">    }</span>

    void resetScroll() {
<span class="pc bpc" id="L3436" title="1 of 2 branches missed.">        if (scrollListeners != null) {</span>
<span class="nc bnc" id="L3437" title="All 4 branches missed.">            if (scrollX != 0 || scrollY != 0) {</span>
<span class="nc" id="L3438">                scrollListeners.fireScrollEvent(0, 0, this.scrollX, this.scrollY);</span>
            }
        }
<span class="fc" id="L3441">        scrollX = 0;</span>
<span class="fc" id="L3442">        scrollY = 0;</span>
<span class="fc" id="L3443">    }</span>

    /**
     * Gets the current dragged x values when the Component is being dragged
     *
     * @return dragged x value
     */
    public int getDraggedx() {
<span class="fc" id="L3451">        return draggedx;</span>
    }

    /**
     * Gets the current dragged y values when the Component is being dragged
     *
     * @return dragged y value
     */
    public int getDraggedy() {
<span class="fc" id="L3460">        return draggedy;</span>
    }

    private void updateTensileHighlightIntensity(int lastScroll, int scroll, boolean motion) {
<span class="pc bpc" id="L3464" title="1 of 2 branches missed.">        if (tensileHighlightEnabled) {</span>
<span class="nc" id="L3465">            int h = getScrollDimension().getHeight() - getHeight() + getInvisibleAreaUnderVKB();</span>
<span class="nc bnc" id="L3466" title="All 2 branches missed.">            if (h &lt;= 0) {</span>
                // layout hasn't completed yet
<span class="nc" id="L3468">                tensileHighlightIntensity = 0;</span>
<span class="nc" id="L3469">                return;</span>
            }
<span class="nc bnc" id="L3471" title="All 2 branches missed.">            if (h &gt; this.scrollY) {</span>
<span class="nc bnc" id="L3472" title="All 2 branches missed.">                if (this.scrollY &lt; 0) {</span>
<span class="nc bnc" id="L3473" title="All 4 branches missed.">                    if (scroll &gt; lastScroll || motion) {</span>
<span class="nc" id="L3474">                        tensileHighlightIntensity = 255;</span>
                    }
                }
            } else {
<span class="nc bnc" id="L3478" title="All 4 branches missed.">                if (lastScroll &gt; scroll || motion) {</span>
<span class="nc" id="L3479">                    tensileHighlightIntensity = 255;</span>
                }
            }
        }
<span class="fc" id="L3483">    }</span>

    /**
     * Returns the gap to be left for the bottom scrollbar on the X axis. This
     * method is used by layout managers to determine the room they should
     * leave for the scrollbar
     *
     * @return the gap to be left for the bottom scrollbar on the X axis
     */
    public int getBottomGap() {
<span class="pc bpc" id="L3493" title="3 of 4 branches missed.">        if (isScrollableX() &amp;&amp; isScrollVisible()) {</span>
<span class="nc" id="L3494">            return getUIManager().getLookAndFeel().getHorizontalScrollHeight();</span>
        }
<span class="fc" id="L3496">        return 0;</span>
    }

    /**
     * Returns the gap to be left for the side scrollbar on the Y axis. This
     * method is used by layout managers to determine the room they should
     * leave for the scrollbar. (note: side scrollbar rather than left scrollbar
     * is used for a future version that would support bidi).
     *
     * @return the gap to be left for the side scrollbar on the Y axis
     */
    public int getSideGap() {
<span class="fc bfc" id="L3508" title="All 4 branches covered.">        if (isScrollableY() &amp;&amp; isScrollVisible()) {</span>
<span class="fc" id="L3509">            return getUIManager().getLookAndFeel().getVerticalScrollWidth();</span>
        }
<span class="fc" id="L3511">        return 0;</span>
    }

    /**
     * Returns true if the given absolute coordinate is contained in the Component
     *
     * &lt;p&gt;NOTE: This will return true upon a &quot;hit&quot; even if the component is not
     * visible, or if that part of the component is currently clipped by a parent
     * component.  To check if a point is contained in the visible component bounds
     * use {@link #visibleBoundsContains(int, int) }&lt;/p&gt;
     *
     * @param x the given absolute x coordinate
     * @param y the given absolute y coordinate
     * @return true if the given absolute coordinate is contained in the
     * Component; otherwise false
     * @see #visibleBoundsContains(int, int)
     */
    public boolean contains(int x, int y) {
<span class="fc" id="L3529">        int absX = getAbsoluteX() + getScrollX();</span>
<span class="fc" id="L3530">        int absY = getAbsoluteY() + getScrollY();</span>
<span class="fc bfc" id="L3531" title="All 8 branches covered.">        return (x &gt;= absX &amp;&amp; x &lt; absX + getWidth() &amp;&amp; y &gt;= absY &amp;&amp; y &lt; absY + getHeight());</span>
    }

    /**
     * Returns true if the given absolute coordinate is contained inside the visible bounds
     * of the component.  This differs from {@link #contains(int, int) } in that it will
     * return {@literal false} if the component or any of its ancestors are not visible,
     * or if (x, y) are contained inside the bounds of the component, but are clipped.
     *
     * @param x the given absolute x coordinate
     * @param y the given absolute y coordinate
     * @return true if the given absolute coordinate is contained in the
     * Component's visible bounds; otherwise false
     * @see #contains(int, int)
     */
    public boolean visibleBoundsContains(int x, int y) {
<span class="pc bpc" id="L3547" title="1 of 4 branches missed.">        boolean contains = isVisible() &amp;&amp; contains(x, y);</span>
<span class="fc bfc" id="L3548" title="All 2 branches covered.">        if (contains) {</span>
<span class="fc" id="L3549">            Container parent = getParent();</span>
<span class="fc bfc" id="L3550" title="All 2 branches covered.">            while (parent != null) {</span>
<span class="pc bpc" id="L3551" title="1 of 2 branches missed.">                if (!parent.visibleBoundsContains(x, y)) {</span>
<span class="nc" id="L3552">                    contains = false;</span>
                }
<span class="pc bpc" id="L3554" title="1 of 2 branches missed.">                if (!contains) {</span>
<span class="nc" id="L3555">                    break;</span>
                }
<span class="fc" id="L3557">                parent = parent.getParent();</span>
            }
        }
<span class="fc" id="L3560">        return contains;</span>
    }

    /**
     * Calculates the preferred size based on component content. This method is
     * invoked lazily by getPreferred size.
     *
     * @return the calculated preferred size based on component content
     */
    protected Dimension calcPreferredSize() {
<span class="fc" id="L3570">        return new Dimension(0, 0);</span>
    }

    /**
     * Checks if this component has a fixed preferred size either via an explicit call to
     * {@link #setPreferredH(int) } and {@link #setPreferredW(int) }, or via a preferred
     * size style string.
     *
     * @return True if this component has a fixed preferred size.
     * @since 7.0
     */
    public boolean hasFixedPreferredSize() {
<span class="pc bpc" id="L3582" title="1 of 4 branches missed.">        return sizeRequestedByUser || preferredSizeStr != null;</span>
    }

    private Dimension preferredSizeImpl() {
<span class="fc bfc" id="L3586" title="All 6 branches covered.">        if (!sizeRequestedByUser &amp;&amp; (shouldCalcPreferredSize || preferredSize == null)) {</span>
<span class="fc" id="L3587">            shouldCalcPreferredSize = false;</span>
<span class="pc bpc" id="L3588" title="1 of 4 branches missed.">            if (hideInPortrait &amp;&amp; Display.INSTANCE.isPortrait()) {</span>
<span class="fc" id="L3589">                preferredSize = new Dimension(0, 0);</span>
            } else {
<span class="pc bpc" id="L3591" title="3 of 4 branches missed.">                if (hideInLandscape &amp;&amp; !Display.INSTANCE.isPortrait()) {</span>
<span class="nc" id="L3592">                    preferredSize = new Dimension(0, 0);</span>
                } else {
<span class="fc" id="L3594">                    preferredSize = calcPreferredSize();</span>
<span class="fc bfc" id="L3595" title="All 2 branches covered.">                    if (preferredSizeStr != null) {</span>
<span class="fc" id="L3596">                        Component.parsePreferredSize(preferredSizeStr, preferredSize);</span>
                    }
                }
            }
        }
<span class="fc" id="L3601">        return preferredSize;</span>
    }

    private Dimension preferredSize() {
<span class="fc bfc" id="L3605" title="All 4 branches covered.">        if (sameWidth != null || sameHeight != null) {</span>
<span class="pc bpc" id="L3606" title="2 of 6 branches missed.">            if (!sizeRequestedByUser &amp;&amp; (shouldCalcPreferredSize || preferredSize == null)) {</span>
<span class="fc bfc" id="L3607" title="All 2 branches covered.">                if (sameWidth != null) {</span>
<span class="fc" id="L3608">                    int w = -1;</span>
<span class="fc bfc" id="L3609" title="All 2 branches covered.">                    for (Component c : sameWidth) {</span>
<span class="fc" id="L3610">                        int d = c.preferredSizeImpl().getWidth();</span>
<span class="fc bfc" id="L3611" title="All 2 branches covered.">                        if (w &lt; d) {</span>
<span class="fc" id="L3612">                            w = d;</span>
                        }
                    }
<span class="fc bfc" id="L3615" title="All 2 branches covered.">                    for (Component c : sameWidth) {</span>
<span class="fc" id="L3616">                        c.preferredSizeImpl().setWidth(w);</span>
                    }
                }
<span class="fc bfc" id="L3619" title="All 2 branches covered.">                if (sameHeight != null) {</span>
<span class="fc" id="L3620">                    int h = -1;</span>
<span class="fc bfc" id="L3621" title="All 2 branches covered.">                    for (Component c : sameHeight) {</span>
<span class="fc" id="L3622">                        int d = c.preferredSizeImpl().getHeight();</span>
<span class="fc bfc" id="L3623" title="All 2 branches covered.">                        if (h &lt; d) {</span>
<span class="fc" id="L3624">                            h = d;</span>
                        }
                    }
<span class="fc bfc" id="L3627" title="All 2 branches covered.">                    for (Component c : sameHeight) {</span>
<span class="fc" id="L3628">                        c.preferredSizeImpl().setHeight(h);</span>
                    }
                }
            }
        }
<span class="fc" id="L3633">        return preferredSizeImpl();</span>
    }

    /**
     * Returns the component bounds which is sometimes more convenient than invoking
     * getX/Y/Width/Height. Bounds are relative to parent container.&lt;br&gt;
     * Changing values within the bounds can lead to unpredicted behavior.
     *
     * @return the component bounds
     * @see #getX
     * @see #getY
     * @see #getBounds(com.codename1.ui.geom.Rectangle)
     */
    protected Rectangle getBounds() {
<span class="fc" id="L3647">        return bounds;</span>
    }

    /**
     * Returns the bounds of this component in the provided Rectangle.
     *
     * @param rect An &quot;out&quot; parameter to store the component bounds in.  Cannot be null.
     * @return The same Rectangle that was passed as a parameter.
     * @see #getBounds()
     * @since 7.0
     */
    public Rectangle getBounds(Rectangle rect) {
<span class="fc" id="L3659">        rect.setBounds(getBounds());</span>
<span class="fc" id="L3660">        return rect;</span>
    }

    /**
     * Returns the component bounds for scrolling which might differ from the getBounds for large components
     * e.g. list.
     *
     * @return the component bounds
     * @see #getX
     * @see #getY
     * @see #getVisibleBounds(com.codename1.ui.geom.Rectangle)
     */
    protected Rectangle getVisibleBounds() {
<span class="fc" id="L3673">        return bounds;</span>
    }

    /**
     * Returns the component bounds for scrolling which might differ from the getBounds for large components
     * into the provided rectangle.
     *
     * @param rect An &quot;out&quot; parameter to store the bounds in.  Cannot be null.
     * @return The same Rectangle that was passed as a parameter.
     * @see #getVisibleBounds()
     * @since 7.0
     */
    public Rectangle getVisibleBounds(Rectangle rect) {
<span class="fc" id="L3686">        rect.setBounds(getVisibleBounds());</span>
<span class="fc" id="L3687">        return rect;</span>
    }

    /**
     * Returns true if this component can receive focus and is enabled
     *
     * @return true if this component can receive focus; otherwise false
     */
    public boolean isFocusable() {
<span class="fc bfc" id="L3696" title="All 6 branches covered.">        return focusable &amp;&amp; enabled &amp;&amp; isVisible();</span>
    }

    /**
     * A simple setter to determine if this Component can get focused
     *
     * @param focusable indicate whether this component can get focused
     */
    public void setFocusable(boolean focusable) {
<span class="fc" id="L3705">        this.focusable = focusable;</span>
<span class="fc" id="L3706">    }</span>

    /**
     * Restores the state of the focusable flag to its default state
     */
    protected void resetFocusable() {
<span class="fc" id="L3712">        setFocusable(false);</span>
<span class="fc" id="L3713">    }</span>

    /**
     * Gets the tab index of the component. This value is only useful immediately
     * after calling {@link Form#getTabIterator(com.codename1.ui.Component) } on the
     * form or {@link Container#updateTabIndices(int) } in the parent component.
     *
     * @return The tab index of the component.
     * @see #getPreferredTabIndex()
     * @see #setTabIndex(int)
     * @see #setPreferredTabIndex(int)
     * @see Form#getTabIterator(com.codename1.ui.Component)
     * @see Container#updateTabIndices(int)
     * @deprecated This method is used internally when querying the traversal order of the form.  Use {@link #getPreferredTabIndex() } to get the preferred tab index.
     */
    public int getTabIndex() {
<span class="fc" id="L3729">        return tabIndex;</span>
    }

    /**
     * Sets the tab index of the component.  This method is for internal use only.  To set the
     * preferred tab index, use {@link #setPreferredTabIndex(int) }
     *
     * @param index The tab index.
     * @see #getPreferredTabIndex()
     * @see #setPreferredTabIndex(int)
     * @see #getTabIndex()
     * @see Form#getTabIterator(com.codename1.ui.Component)
     * @deprecated This method is called internally by the layout manager each time the traversal order of the form is queried.  Use {@link #setPreferredTabIndex(int) } instead.
     */
    public void setTabIndex(int index) {
<span class="fc" id="L3744">        tabIndex = index;</span>
<span class="fc" id="L3745">    }</span>

    /**
     * Gets the preferred tab index of this component.  Tab indices are used to specify the traversal order
     * when tabbing from component to component in a form.
     *
     * &lt;p&gt;Tab index meanings work similar to the HTML {@literal tabIndex}
     * attribute. A tab Index of {@literal -1} (the default value) results in the field not being traversable
     * using the keyboard (or using the next/prev buttons in devices' virtual keyboards).  A tab index of {@literal 0}
     * results in the component's traversal order being dictated by the natural traversal order of the form.&lt;/p&gt;
     *
     * &lt;p&gt;Use {@link Form#getTabIterator(com.codename1.ui.Component) } to obtain the complete traversal order for
     * all components in the form.&lt;/p&gt;
     *
     * &lt;p&gt;Best practice is to only explicitly set preferred tabIndex values of {@literal 0} if you want the component
     * to be traversable, or {@literal -1} if you don't want the component to be traversable.  Explicitly setting
     * a positive preferred tab index may result in unexpected results.&lt;/p&gt;
     *
     * &lt;h3&gt;How the Preferred Tab Index is Used&lt;/h3&gt;
     *
     * &lt;p&gt;When the user tries to &quot;tab&quot; to the next field (or presses the &quot;Next&quot; button on the virtual keyboard), this
     * triggers a call to {@link Form#getTabIterator(com.codename1.ui.Component) }, crawls the component hierarchy and
     * returns a {@link java.util.ListIterator} of all of the traversable fields in the form in the order they should
     * be traversed. This order is determined by the layout managers on the form.  The core layout managers define
     * sensible traversal orders by default.  If you have a custom layout manager, you can override its traversal
     * order by implementing the {@link com.codename1.ui.layouts.Layout#overridesTabIndices(com.codename1.ui.Container) } and
     * {@link com.codename1.ui.layouts.Layout#getChildrenInTraversalOrder(com.codename1.ui.Container) } methods.&lt;/p&gt;
     *
     * @return the tabbing index
     */
    public int getPreferredTabIndex() {
<span class="pc bpc" id="L3776" title="2 of 6 branches missed.">        if (isEnabled() &amp;&amp; isVisible() &amp;&amp; isFocusable()) {</span>
<span class="fc" id="L3777">            return preferredTabIndex;</span>
        }
<span class="fc" id="L3779">        return -1;</span>
    }

    /**
     * Sets the preferred tab index of the component.
     *
     * @param index The preferred tab index
     * @see #getPreferredTabIndex()
     * @see Form#getTabIterator(com.codename1.ui.Component)
     * @see Container#updateTabIndices(int)
     */
    public void setPreferredTabIndex(int index) {
<span class="fc" id="L3791">        preferredTabIndex = index;</span>
<span class="fc" id="L3792">    }</span>

    /**
     * Checks if this component should be traversable using the keyboard using tab, next, previous keys.
     *
     * &lt;p&gt;Note: This method is marked final because it is just a convenience wrapper around {@link #getPreferredTabIndex() }&lt;/p&gt;
     *
     * @return true if traversable in tab indexing
     */
    public final boolean isTraversable() {
<span class="fc bfc" id="L3802" title="All 2 branches covered.">        return getPreferredTabIndex() &gt;= 0;</span>
    }

    /**
     * Sets whether this component is traversable using the keyboard using tab, next, previous keys.  This is
     * just a wrapper around {@link #setPreferredTabIndex(int) } that sets the tab index to 0 if the component
     * should be traversable, and -1 if it shouldn't be.
     *
     * &lt;p&gt;Note:  This method is marked final because this is just a convenience wrapper around {@link #setPreferredTabIndex(int) }&lt;/p&gt;
     *
     * @param traversable True to make the component traversable.
     */
    public final void setTraversable(boolean traversable) {
<span class="pc bpc" id="L3815" title="1 of 4 branches missed.">        if (traversable &amp;&amp; getPreferredTabIndex() &lt; 0) {</span>
<span class="fc" id="L3816">            setPreferredTabIndex(0);</span>
<span class="pc bpc" id="L3817" title="2 of 4 branches missed.">        } else if (!traversable &amp;&amp; getPreferredTabIndex() &gt;= 0) {</span>
<span class="fc" id="L3818">            setPreferredTabIndex(-1);</span>
        }
<span class="fc" id="L3820">    }</span>

    /**
     * Indicates the values within the component have changed and preferred
     * size should be recalculated
     *
     * @param shouldCalcPreferredSize indicate whether this component need to
     *                                recalculate his preferred size
     */
    public void setShouldCalcPreferredSize(boolean shouldCalcPreferredSize) {
<span class="fc bfc" id="L3830" title="All 2 branches covered.">        if (!shouldCalcScrollSize) {</span>
<span class="fc" id="L3831">            this.shouldCalcScrollSize = shouldCalcPreferredSize;</span>
        }
<span class="fc bfc" id="L3833" title="All 2 branches covered.">        if (shouldCalcPreferredSize != this.shouldCalcPreferredSize) {</span>
<span class="fc" id="L3834">            this.shouldCalcPreferredSize = shouldCalcPreferredSize;</span>
<span class="fc" id="L3835">            this.shouldCalcScrollSize = shouldCalcPreferredSize;</span>
<span class="fc bfc" id="L3836" title="All 4 branches covered.">            if (shouldCalcPreferredSize &amp;&amp; getParent() != null) {</span>
<span class="fc" id="L3837">                this.shouldCalcPreferredSize = true;</span>
<span class="fc" id="L3838">                getParent().setShouldLayout(true);</span>
            }
        }
<span class="fc bfc" id="L3841" title="All 2 branches covered.">        if (shouldCalcPreferredSize) {</span>
<span class="fc" id="L3842">            setShouldCalcPreferredSizeGroup(sameWidth);</span>
<span class="fc" id="L3843">            setShouldCalcPreferredSizeGroup(sameHeight);</span>
        }
<span class="fc" id="L3845">    }</span>

    private void setShouldCalcPreferredSizeGroup(Component[] cmps) {
<span class="pc bpc" id="L3848" title="1 of 2 branches missed.">        if (cmps != null) {</span>
<span class="nc bnc" id="L3849" title="All 2 branches missed.">            for (Component c : cmps) {</span>
<span class="nc" id="L3850">                c.shouldCalcPreferredSize = true;</span>
            }
        }
<span class="fc" id="L3853">    }</span>

    /**
     * Prevents key events from being grabbed for focus traversal. E.g. a list component
     * might use the arrow keys for internal navigation so it will switch this flag to
     * true in order to prevent the focus manager from moving to the next component.
     *
     * @return true if key events are being used for focus traversal
     * ; otherwise false
     */
    public boolean handlesInput() {
<span class="fc" id="L3864">        return handlesInput;</span>
    }

    /**
     * Prevents key events from being grabbed for focus traversal. E.g. a list component
     * might use the arrow keys for internal navigation so it will switch this flag to
     * true in order to prevent the focus manager from moving to the next component.
     *
     * @param handlesInput indicates whether key events can be grabbed for
     *                     focus traversal
     */
    public void setHandlesInput(boolean handlesInput) {
<span class="fc" id="L3876">        this.handlesInput = handlesInput;</span>
<span class="fc" id="L3877">    }</span>

    /**
     * Returns true if the component has focus
     *
     * @return true if the component has focus; otherwise false
     * @see #requestFocus
     */
    public boolean hasFocus() {
<span class="fc" id="L3886">        return focused;</span>
    }

    /**
     * This flag doesn't really give focus, its a state that determines
     * what colors from the Style should be used when painting the component.
     * Actual focus is determined by the parent form
     *
     * @param focused sets the state that determines what colors from the
     *                Style should be used when painting a focused component
     * @see #requestFocus
     * @deprecated this method shouldn't be invoked by user code, use requestFocus() instead
     */
    public void setFocus(boolean focused) {
<span class="fc" id="L3900">        this.focused = focused;</span>
<span class="fc" id="L3901">    }</span>

    /**
     * Returns the Component Form or null if this Component
     * is not added yet to a form
     *
     * @return the Component Form
     */
    public Form getComponentForm() {
<span class="fc" id="L3910">        Form retVal = null;</span>
<span class="fc" id="L3911">        Component parent = getParent();</span>
<span class="fc bfc" id="L3912" title="All 2 branches covered.">        if (parent != null) {</span>
<span class="fc" id="L3913">            retVal = parent.getComponentForm();</span>
        }
<span class="fc" id="L3915">        return retVal;</span>
    }

    /**
     * Repaint the given component to the screen
     *
     * @param cmp the given component on the screen
     */
    void repaint(Component cmp) {
<span class="pc bpc" id="L3924" title="1 of 8 branches missed.">        if (isCellRenderer() || cmp.getWidth() &lt;= 0 || cmp.getHeight() &lt;= 0 || paintLockImage != null) {</span>
<span class="fc" id="L3925">            return;</span>
        }
        // null parent repaint can happen when a component is removed and modified which
        // is common for a popup
<span class="fc" id="L3929">        Component parent = getParent();</span>

<span class="fc bfc" id="L3931" title="All 4 branches covered.">        if (parent != null &amp;&amp; parent.isVisible()) {</span>
<span class="fc" id="L3932">            parent.repaint(cmp);</span>
        }
<span class="fc" id="L3934">    }</span>

    /**
     * Repaint this Component, the repaint call causes a callback of the paint
     * method on the event dispatch thread.
     *
     * @see Display
     */
    public void repaint() {

<span class="fc" id="L3944">        repaintPending = true;</span>
<span class="pc bpc" id="L3945" title="1 of 2 branches missed.">        if (dirtyRegion != null) {</span>
<span class="nc" id="L3946">            setDirtyRegion(null);</span>
        }

<span class="fc" id="L3949">        repaint(this);</span>
<span class="fc" id="L3950">    }</span>

    private Container _findSurface() {
<span class="fc" id="L3953">        Container parent = getParent();</span>
<span class="fc bfc" id="L3954" title="All 2 branches covered.">        if (parent == null) return null;</span>
<span class="fc bfc" id="L3955" title="All 2 branches covered.">        if (parent.isSurface()) {</span>
<span class="fc" id="L3956">            return parent;</span>
        }
<span class="fc" id="L3958">        return ((Component) parent)._findSurface();</span>
    }

    /**
     * Repaints a specific region within the component
     *
     * @param x boundary of the region to repaint in absolute screen coordinates not component coordinates
     * @param y boundary of the region to repaint in absolute screen coordinates not component coordinates
     * @param w boundary of the region to repaint
     * @param h boundary of the region to repaint
     */
    public void repaint(int x, int y, int w, int h) {
        Rectangle rect;
<span class="fc" id="L3971">        synchronized (dirtyRegionLock) {</span>
<span class="pc bpc" id="L3972" title="1 of 2 branches missed.">            if (dirtyRegion == null) {</span>
<span class="fc bfc" id="L3973" title="All 2 branches covered.">                if (repaintPending) {</span>
<span class="fc" id="L3974">                    return;</span>
                }
<span class="fc" id="L3976">                rect = new Rectangle(x, y, w, h);</span>
<span class="fc" id="L3977">                setDirtyRegion(rect);</span>
<span class="nc bnc" id="L3978" title="All 4 branches missed.">            } else if (dirtyRegion.getX() != x || dirtyRegion.getY() != y ||</span>
<span class="nc bnc" id="L3979" title="All 4 branches missed.">                    dirtyRegion.getSize().getWidth() != w || dirtyRegion.getSize().getHeight() != h) {</span>
<span class="nc" id="L3980">                rect = new Rectangle(dirtyRegion);</span>
<span class="nc" id="L3981">                Dimension size = rect.getSize();</span>

<span class="nc" id="L3983">                int x1 = Math.min(rect.getX(), x);</span>
<span class="nc" id="L3984">                int y1 = Math.min(rect.getY(), y);</span>

<span class="nc" id="L3986">                int x2 = Math.max(x + w, rect.getX() + size.getWidth());</span>
<span class="nc" id="L3987">                int y2 = Math.max(y + h, rect.getY() + size.getHeight());</span>

<span class="nc" id="L3989">                rect.setX(x1);</span>
<span class="nc" id="L3990">                rect.setY(y1);</span>
<span class="nc" id="L3991">                size.setWidth(x2 - x1);</span>
<span class="nc" id="L3992">                size.setHeight(y2 - y1);</span>
<span class="nc" id="L3993">                setDirtyRegion(rect);</span>
            }
<span class="fc" id="L3995">        }</span>

<span class="fc" id="L3997">        repaint(this);</span>
<span class="fc" id="L3998">    }</span>

    /**
     * If this Component is focused this method is invoked when the user presses
     * and holds the key
     *
     * @param keyCode the key code value to indicate a physical key.
     */
    protected void longKeyPress(int keyCode) {
<span class="fc" id="L4007">    }</span>

    /**
     * If this Component is focused, the key pressed event
     * will call this method
     *
     * @param keyCode the key code value to indicate a physical key.
     */
    public void keyPressed(int keyCode) {
<span class="fc" id="L4016">    }</span>

    /**
     * If this Component is focused, the key released event
     * will call this method
     *
     * @param keyCode the key code value to indicate a physical key.
     */
    public void keyReleased(int keyCode) {
<span class="fc" id="L4025">    }</span>

    /**
     * If this Component is focused, the key repeat event
     * will call this method.
     *
     * @param keyCode the key code value to indicate a physical key.
     */
    public void keyRepeated(int keyCode) {
<span class="fc" id="L4034">        keyPressed(keyCode);</span>
<span class="fc" id="L4035">        keyReleased(keyCode);</span>
<span class="fc" id="L4036">    }</span>

    /**
     * Allows defining the physics for the animation motion behavior directly
     * by plugging in an alternative motion object
     *
     * @return the component motion object
     */
    private Motion getAnimationMotion() {
<span class="fc" id="L4045">        return animationMotion;</span>
    }

    /**
     * Allows defining the physics for the animation motion behavior directly
     * by plugging in an alternative motion object
     *
     * @param motion new motion object
     */
    private void setAnimationMotion(Motion motion) {
<span class="fc" id="L4055">        animationMotion = motion;</span>
<span class="fc" id="L4056">    }</span>

    /**
     * Returns the animation manager of the parent form or null if this component isn't currently associated with a form
     *
     * @return the animation manager instance
     */
    public AnimationManager getAnimationManager() {
<span class="fc" id="L4064">        Form f = getComponentForm();</span>
<span class="fc bfc" id="L4065" title="All 2 branches covered.">        if (f == null) {</span>
<span class="fc" id="L4066">            return null;</span>
        }
<span class="fc" id="L4068">        return f.getAnimationManager();</span>
    }

    /**
     * Scroll animation speed in milliseconds allowing a developer to slow down or accelerate
     * the smooth animation mode
     *
     * @return scroll animation speed in milliseconds
     */
    public int getScrollAnimationSpeed() {
<span class="fc" id="L4078">        return animationSpeed;</span>
    }

    /**
     * Scroll animation speed in milliseconds allowing a developer to slow down or accelerate
     * the smooth animation mode
     *
     * @param animationSpeed scroll animation speed in milliseconds
     */
    public void setScrollAnimationSpeed(int animationSpeed) {
<span class="fc" id="L4088">        this.animationSpeed = animationSpeed;</span>
<span class="fc" id="L4089">    }</span>

    /**
     * Prevent a lead component hierarchy from this specific component, this allows a component within that
     * hierarchy to still act as a standalone component
     *
     * @return the blockLead
     */
    public boolean isBlockLead() {
<span class="fc" id="L4098">        return blockLead;</span>
    }

    /**
     * Prevent a lead component hierarchy from this specific component, this allows a component within that
     * hierarchy to still act as a standalone component
     *
     * @param blockLead the blockLead to set
     */
    public void setBlockLead(boolean blockLead) {
<span class="fc" id="L4108">        this.blockLead = blockLead;</span>
<span class="fc bfc" id="L4109" title="All 2 branches covered.">        if (blockLead) {</span>
<span class="fc" id="L4110">            hasLead = false;</span>
        }
<span class="fc" id="L4112">    }</span>

    /**
     * @return the ignorePointerEvents
     */
    public boolean isIgnorePointerEvents() {
<span class="fc" id="L4118">        return ignorePointerEvents;</span>
    }

    /**
     * @param ignorePointerEvents the ignorePointerEvents to set
     */
    public void setIgnorePointerEvents(boolean ignorePointerEvents) {
<span class="fc" id="L4125">        this.ignorePointerEvents = ignorePointerEvents;</span>
<span class="fc" id="L4126">    }</span>

    /**
     * Indicates whether the component displays the material design ripple effect
     *
     * @return the rippleEffect
     */
    public boolean isRippleEffect() {
<span class="fc" id="L4134">        return rippleEffect;</span>
    }

    /**
     * Indicates whether the component displays the material design ripple effect
     *
     * @param rippleEffect the rippleEffect to set
     */
    public void setRippleEffect(boolean rippleEffect) {
<span class="fc" id="L4143">        this.rippleEffect = rippleEffect;</span>
<span class="fc" id="L4144">    }</span>

    /**
     * Gets the theme that is used by inline styles to reference images.
     *
     * @return the inlineStylesTheme
     * @see #setInlineStylesTheme(com.codename1.ui.util.Resources)
     * @see #getInlineAllStyles()
     * @see #getInlineSelectedStyles()
     * @see #getInlinePressedStyles()
     * @see #getInlineUnselectedStyles()
     * @see #getInlineDisabledStyles()
     */
    public Resources getInlineStylesTheme() {
<span class="fc" id="L4158">        return inlineStylesTheme;</span>
    }

    /**
     * Sets the theme that is used by inline styles to reference images.  Inline styles will be
     * disabled unless an inlineStylesTheme is registered with the component.
     *
     * @param inlineStylesTheme the theme that inline styles use to reference images.
     * @see #getInlineStylesTheme()
     * @see #setInlineAllStyles(java.lang.String)
     * @see #setInlinePressedStyles(java.lang.String)
     * @see #setInlineSelectedStyles(java.lang.String)
     * @see #setInlineDisabledStyles(java.lang.String)
     * @see #setInlineUnselectedStyles(java.lang.String)
     */
    public void setInlineStylesTheme(Resources inlineStylesTheme) {
<span class="nc" id="L4174">        this.inlineStylesTheme = inlineStylesTheme;</span>
<span class="nc" id="L4175">    }</span>

    /**
     * A component can indicate whether it is interested in rendering it's selection explicitly, this defaults to
     * true in non-touch UI's and false in touch UI's except for the case where a user clicks the screen.
     *
     * @return Defaults to false
     */
    protected boolean shouldRenderComponentSelection() {
<span class="fc" id="L4184">        return false;</span>
    }

    /**
     * Indicates that this component and all its children should be hidden when the device is switched to landscape mode
     *
     * @return the hideInLandscape
     */
    public boolean isHideInLandscape() {
<span class="fc" id="L4193">        return hideInLandscape;</span>
    }

    /**
     * Indicates that this component and all its children should be hidden when the device is switched to landscape mode
     *
     * @param hideInLandscape the hideInLandscape to set
     */
    public void setHideInLandscape(boolean hideInLandscape) {
<span class="fc" id="L4202">        this.hideInLandscape = hideInLandscape;</span>
<span class="fc" id="L4203">    }</span>

    /**
     * Creates an animation that will transform the current component to the styling of the destination UIID when
     * completed. Notice that fonts will only animate within the truetype and native familiy and we recommend that you
     * don't shift weight/typeface/style as this might diminish the effect.&lt;br&gt;
     * &lt;b&gt;Important: &lt;/b&gt; Only unselected styles are animated but once the animation completes all styles are applied.
     *
     * @param destUIID the UIID to which this component will gradually shift
     * @param duration the duration of the animation or the number of steps
     * @return an animation component that can either be stepped or played
     */
    public ComponentAnimation createStyleAnimation(final String destUIID, final int duration) {
<span class="fc" id="L4216">        final Style sourceStyle = getUnselectedStyle();</span>
<span class="pc bpc" id="L4217" title="1 of 2 branches missed.">        final Style destStyle = hasInlineUnselectedStyle() ?</span>
<span class="pc" id="L4218">                getUIManager().parseComponentStyle(getInlineStylesTheme(), destUIID, getInlineStylesUIID(destUIID), getInlineUnselectedStyleStrings())</span>
<span class="fc" id="L4219">                : getUIManager().getComponentStyle(destUIID);</span>
<span class="fc" id="L4220">        return createStyleAnimation(sourceStyle, destStyle, duration, destUIID);</span>

    }

    ComponentAnimation createStyleAnimation(final Style sourceStyle, final Style destStyle, final int duration, final String destUIID) {

<span class="fc" id="L4226">        Motion m = null;</span>
<span class="pc bpc" id="L4227" title="1 of 2 branches missed.">        if (sourceStyle.getFgColor() != destStyle.getFgColor()) {</span>
<span class="nc" id="L4228">            m = Motion.createLinearColorMotion(sourceStyle.getFgColor(), destStyle.getFgColor(), duration);</span>
        }
<span class="fc" id="L4230">        final Motion fgColorMotion = m;</span>
<span class="fc" id="L4231">        m = null;</span>

<span class="pc bpc" id="L4233" title="1 of 2 branches missed.">        if (sourceStyle.getOpacity() != destStyle.getOpacity()) {</span>
<span class="nc" id="L4234">            m = Motion.createLinearColorMotion(sourceStyle.getOpacity(), destStyle.getOpacity(), duration);</span>
        }
<span class="fc" id="L4236">        final Motion opacityMotion = m;</span>
<span class="fc" id="L4237">        m = null;</span>

<span class="pc bpc" id="L4239" title="3 of 4 branches missed.">        if (sourceStyle.getFont().getHeight() != destStyle.getFont().getHeight() &amp;&amp; sourceStyle.getFont().isTTFNativeFont()) {</span>
            // allows for fractional font sizes
<span class="nc" id="L4241">            m = Motion.createLinearMotion(Math.round(sourceStyle.getFont().getPixelSize() * 100), Math.round(destStyle.getFont().getPixelSize() * 100), duration);</span>
        }

<span class="fc" id="L4244">        final Motion fontMotion = m;</span>
<span class="fc" id="L4245">        m = null;</span>

<span class="fc bfc" id="L4247" title="All 2 branches covered.">        if (sourceStyle.getPaddingTop() != destStyle.getPaddingTop()) {</span>
<span class="fc" id="L4248">            m = Motion.createLinearMotion(sourceStyle.getPaddingTop(), destStyle.getPaddingTop(), duration);</span>
        }
<span class="fc" id="L4250">        final Motion paddingTop = m;</span>
<span class="fc" id="L4251">        m = null;</span>

<span class="fc bfc" id="L4253" title="All 2 branches covered.">        if (sourceStyle.getPaddingBottom() != destStyle.getPaddingBottom()) {</span>
<span class="fc" id="L4254">            m = Motion.createLinearMotion(sourceStyle.getPaddingBottom(), destStyle.getPaddingBottom(), duration);</span>
        }
<span class="fc" id="L4256">        final Motion paddingBottom = m;</span>
<span class="fc" id="L4257">        m = null;</span>

<span class="fc bfc" id="L4259" title="All 2 branches covered.">        if (sourceStyle.getPaddingLeftNoRTL() != destStyle.getPaddingLeftNoRTL()) {</span>
<span class="fc" id="L4260">            m = Motion.createLinearMotion(sourceStyle.getPaddingLeftNoRTL(), destStyle.getPaddingLeftNoRTL(), duration);</span>
        }
<span class="fc" id="L4262">        final Motion paddingLeft = m;</span>
<span class="fc" id="L4263">        m = null;</span>

<span class="fc bfc" id="L4265" title="All 2 branches covered.">        if (sourceStyle.getPaddingRightNoRTL() != destStyle.getPaddingRightNoRTL()) {</span>
<span class="fc" id="L4266">            m = Motion.createLinearMotion(sourceStyle.getPaddingRightNoRTL(), destStyle.getPaddingRightNoRTL(), duration);</span>
        }
<span class="fc" id="L4268">        final Motion paddingRight = m;</span>
<span class="fc" id="L4269">        m = null;</span>

<span class="fc bfc" id="L4271" title="All 2 branches covered.">        if (sourceStyle.getMarginTop() != destStyle.getMarginTop()) {</span>
<span class="fc" id="L4272">            m = Motion.createLinearMotion(sourceStyle.getMarginTop(), destStyle.getMarginTop(), duration);</span>
        }
<span class="fc" id="L4274">        final Motion marginTop = m;</span>
<span class="fc" id="L4275">        m = null;</span>

<span class="fc bfc" id="L4277" title="All 2 branches covered.">        if (sourceStyle.getMarginBottom() != destStyle.getMarginBottom()) {</span>
<span class="fc" id="L4278">            m = Motion.createLinearMotion(sourceStyle.getMarginBottom(), destStyle.getMarginBottom(), duration);</span>
        }
<span class="fc" id="L4280">        final Motion marginBottom = m;</span>
<span class="fc" id="L4281">        m = null;</span>

<span class="fc bfc" id="L4283" title="All 2 branches covered.">        if (sourceStyle.getMarginLeftNoRTL() != destStyle.getMarginLeftNoRTL()) {</span>
<span class="fc" id="L4284">            m = Motion.createLinearMotion(sourceStyle.getMarginLeftNoRTL(), destStyle.getMarginLeftNoRTL(), duration);</span>
        }
<span class="fc" id="L4286">        final Motion marginLeft = m;</span>
<span class="fc" id="L4287">        m = null;</span>

<span class="fc bfc" id="L4289" title="All 2 branches covered.">        if (sourceStyle.getMarginRightNoRTL() != destStyle.getMarginRightNoRTL()) {</span>
<span class="fc" id="L4290">            m = Motion.createLinearMotion(sourceStyle.getMarginRightNoRTL(), destStyle.getMarginRightNoRTL(), duration);</span>
        }
<span class="fc" id="L4292">        final Motion marginRight = m;</span>

<span class="pc bpc" id="L4294" title="3 of 8 branches missed.">        if (paddingLeft != null || paddingRight != null || paddingTop != null || paddingBottom != null) {</span>
            // convert the padding to pixels for smooth animation
<span class="fc" id="L4296">            int left = sourceStyle.getPaddingLeftNoRTL();</span>
<span class="fc" id="L4297">            int right = sourceStyle.getPaddingRightNoRTL();</span>
<span class="fc" id="L4298">            int top = sourceStyle.getPaddingTop();</span>
<span class="fc" id="L4299">            int bottom = sourceStyle.getPaddingBottom();</span>
<span class="fc" id="L4300">            sourceStyle.setPaddingUnit(Style.UNIT_TYPE_PIXELS, Style.UNIT_TYPE_PIXELS, Style.UNIT_TYPE_PIXELS, Style.UNIT_TYPE_PIXELS);</span>
<span class="fc" id="L4301">            sourceStyle.setPadding(top, bottom, left, right);</span>
        }

<span class="pc bpc" id="L4304" title="3 of 8 branches missed.">        if (marginLeft != null || marginRight != null || marginTop != null || marginBottom != null) {</span>
            // convert the margin to pixels for smooth animation
<span class="fc" id="L4306">            int left = sourceStyle.getMarginLeftNoRTL();</span>
<span class="fc" id="L4307">            int right = sourceStyle.getMarginRightNoRTL();</span>
<span class="fc" id="L4308">            int top = sourceStyle.getMarginTop();</span>
<span class="fc" id="L4309">            int bottom = sourceStyle.getMarginBottom();</span>
<span class="fc" id="L4310">            sourceStyle.setMarginUnit(Style.UNIT_TYPE_PIXELS, Style.UNIT_TYPE_PIXELS, Style.UNIT_TYPE_PIXELS, Style.UNIT_TYPE_PIXELS);</span>
<span class="fc" id="L4311">            sourceStyle.setMargin(top, bottom, left, right);</span>
        }

<span class="fc" id="L4314">        final AnimationTransitionPainter ap = new AnimationTransitionPainter();</span>
<span class="pc bpc" id="L4315" title="3 of 4 branches missed.">        if (sourceStyle.getBgTransparency() != 0 || destStyle.getBgTransparency() != 0 ||</span>
<span class="nc bnc" id="L4316" title="All 4 branches missed.">                (sourceStyle.getBorder() != null &amp;&amp; sourceStyle.getBorder().isEmptyBorder()) ||</span>
<span class="nc bnc" id="L4317" title="All 4 branches missed.">                (destStyle.getBorder() != null &amp;&amp; destStyle.getBorder().isEmptyBorder()) ||</span>
<span class="nc bnc" id="L4318" title="All 4 branches missed.">                sourceStyle.getBgImage() != null || destStyle.getBgImage() != null) {</span>
<span class="fc" id="L4319">            ap.original = sourceStyle.getBgPainter();</span>
<span class="fc" id="L4320">            ap.dest = destStyle.getBgPainter();</span>
<span class="fc" id="L4321">            ap.originalStyle = sourceStyle;</span>
<span class="fc" id="L4322">            ap.destStyle = destStyle;</span>
<span class="fc bfc" id="L4323" title="All 2 branches covered.">            if (ap.dest == null) {</span>
<span class="fc" id="L4324">                ap.dest = new BGPainter();</span>
            }
<span class="fc" id="L4326">            sourceStyle.setBgPainter(ap);</span>
        }

<span class="fc" id="L4329">        final Motion bgMotion = Motion.createLinearMotion(0, 255, duration);</span>

<span class="fc" id="L4331">        return new ComponentAnimation() {</span>
            private boolean finished;
            private boolean stepMode;
            private boolean started;

            @Override
            public boolean isStepModeSupported() {
<span class="nc" id="L4338">                return true;</span>
            }

            @Override
            public int getMaxSteps() {
<span class="fc" id="L4343">                return duration;</span>
            }


            @Override
            public void setStep(int step) {
<span class="fc" id="L4349">                stepMode = true;</span>
<span class="pc bpc" id="L4350" title="1 of 2 branches missed.">                if (!finished) {</span>
<span class="fc" id="L4351">                    bgMotion.setCurrentMotionTime(step);</span>
<span class="pc bpc" id="L4352" title="1 of 2 branches missed.">                    if (fgColorMotion != null) {</span>
<span class="nc" id="L4353">                        fgColorMotion.setCurrentMotionTime(step);</span>
                    }
<span class="pc bpc" id="L4355" title="1 of 2 branches missed.">                    if (opacityMotion != null) {</span>
<span class="nc" id="L4356">                        opacityMotion.setCurrentMotionTime(step);</span>
                    }
<span class="pc bpc" id="L4358" title="1 of 2 branches missed.">                    if (fontMotion != null) {</span>
<span class="nc" id="L4359">                        fontMotion.setCurrentMotionTime(step);</span>
                    }
<span class="pc bpc" id="L4361" title="1 of 2 branches missed.">                    if (paddingTop != null) {</span>
<span class="fc" id="L4362">                        paddingTop.setCurrentMotionTime(step);</span>
                    }
<span class="pc bpc" id="L4364" title="1 of 2 branches missed.">                    if (paddingBottom != null) {</span>
<span class="fc" id="L4365">                        paddingBottom.setCurrentMotionTime(step);</span>
                    }
<span class="pc bpc" id="L4367" title="1 of 2 branches missed.">                    if (paddingLeft != null) {</span>
<span class="fc" id="L4368">                        paddingLeft.setCurrentMotionTime(step);</span>
                    }
<span class="pc bpc" id="L4370" title="1 of 2 branches missed.">                    if (paddingRight != null) {</span>
<span class="fc" id="L4371">                        paddingRight.setCurrentMotionTime(step);</span>
                    }
<span class="pc bpc" id="L4373" title="1 of 2 branches missed.">                    if (marginTop != null) {</span>
<span class="fc" id="L4374">                        marginTop.setCurrentMotionTime(step);</span>
                    }
<span class="pc bpc" id="L4376" title="1 of 2 branches missed.">                    if (marginBottom != null) {</span>
<span class="fc" id="L4377">                        marginBottom.setCurrentMotionTime(step);</span>
                    }
<span class="pc bpc" id="L4379" title="1 of 2 branches missed.">                    if (marginLeft != null) {</span>
<span class="fc" id="L4380">                        marginLeft.setCurrentMotionTime(step);</span>
                    }
<span class="pc bpc" id="L4382" title="1 of 2 branches missed.">                    if (marginRight != null) {</span>
<span class="fc" id="L4383">                        marginRight.setCurrentMotionTime(step);</span>
                    }
                }
<span class="fc" id="L4386">                super.setStep(step);</span>
<span class="fc" id="L4387">            }</span>

            @Override
            public boolean isInProgress() {
<span class="pc bpc" id="L4391" title="3 of 4 branches missed.">                if (!stepMode &amp;&amp; !started) {</span>
<span class="nc" id="L4392">                    return true;</span>
                }
<span class="pc bpc" id="L4394" title="1 of 2 branches missed.">                return stepMode ||</span>
<span class="nc bnc" id="L4395" title="All 4 branches missed.">                        !(bgMotion.isFinished() &amp;&amp;</span>
<span class="nc bnc" id="L4396" title="All 4 branches missed.">                                (opacityMotion == null || opacityMotion.isFinished()) &amp;&amp;</span>
<span class="nc bnc" id="L4397" title="All 4 branches missed.">                                (fgColorMotion == null || fgColorMotion.isFinished()) &amp;&amp;</span>
<span class="nc bnc" id="L4398" title="All 4 branches missed.">                                (paddingLeft == null || paddingLeft.isFinished()) &amp;&amp;</span>
<span class="nc bnc" id="L4399" title="All 4 branches missed.">                                (paddingRight == null || paddingRight.isFinished()) &amp;&amp;</span>
<span class="nc bnc" id="L4400" title="All 4 branches missed.">                                (paddingTop == null || paddingTop.isFinished()) &amp;&amp;</span>
<span class="nc bnc" id="L4401" title="All 4 branches missed.">                                (paddingBottom == null || paddingBottom.isFinished()) &amp;&amp;</span>
<span class="nc bnc" id="L4402" title="All 4 branches missed.">                                (marginLeft == null || marginLeft.isFinished()) &amp;&amp;</span>
<span class="nc bnc" id="L4403" title="All 4 branches missed.">                                (marginRight == null || marginRight.isFinished()) &amp;&amp;</span>
<span class="nc bnc" id="L4404" title="All 4 branches missed.">                                (marginTop == null || marginTop.isFinished()) &amp;&amp;</span>
<span class="nc bnc" id="L4405" title="All 4 branches missed.">                                (marginBottom == null || marginBottom.isFinished()) &amp;&amp;</span>
<span class="pc bnc" id="L4406" title="All 2 branches missed.">                                (fontMotion == null || fontMotion.isFinished()));</span>
            }

            @Override
            protected void updateState() {
<span class="pc bpc" id="L4411" title="1 of 2 branches missed.">                if (finished) {</span>
<span class="nc" id="L4412">                    return;</span>
                }

<span class="pc bpc" id="L4415" title="2 of 4 branches missed.">                if (!started &amp;&amp; !stepMode) {</span>
<span class="nc" id="L4416">                    started = true;</span>
<span class="nc" id="L4417">                    bgMotion.start();</span>
<span class="nc bnc" id="L4418" title="All 2 branches missed.">                    if (opacityMotion != null) {</span>
<span class="nc" id="L4419">                        opacityMotion.start();</span>
                    }
<span class="nc bnc" id="L4421" title="All 2 branches missed.">                    if (fgColorMotion != null) {</span>
<span class="nc" id="L4422">                        fgColorMotion.start();</span>
                    }
<span class="nc bnc" id="L4424" title="All 2 branches missed.">                    if (fontMotion != null) {</span>
<span class="nc" id="L4425">                        fontMotion.start();</span>
                    }
<span class="nc bnc" id="L4427" title="All 2 branches missed.">                    if (paddingTop != null) {</span>
<span class="nc" id="L4428">                        paddingTop.start();</span>
                    }
<span class="nc bnc" id="L4430" title="All 2 branches missed.">                    if (paddingBottom != null) {</span>
<span class="nc" id="L4431">                        paddingBottom.start();</span>
                    }
<span class="nc bnc" id="L4433" title="All 2 branches missed.">                    if (paddingLeft != null) {</span>
<span class="nc" id="L4434">                        paddingLeft.start();</span>
                    }
<span class="nc bnc" id="L4436" title="All 2 branches missed.">                    if (paddingRight != null) {</span>
<span class="nc" id="L4437">                        paddingRight.start();</span>
                    }
<span class="nc bnc" id="L4439" title="All 2 branches missed.">                    if (marginTop != null) {</span>
<span class="nc" id="L4440">                        marginTop.start();</span>
                    }
<span class="nc bnc" id="L4442" title="All 2 branches missed.">                    if (marginBottom != null) {</span>
<span class="nc" id="L4443">                        marginBottom.start();</span>
                    }
<span class="nc bnc" id="L4445" title="All 2 branches missed.">                    if (marginLeft != null) {</span>
<span class="nc" id="L4446">                        marginLeft.start();</span>
                    }
<span class="nc bnc" id="L4448" title="All 2 branches missed.">                    if (marginRight != null) {</span>
<span class="nc" id="L4449">                        marginRight.start();</span>
                    }
                }

<span class="pc bpc" id="L4453" title="1 of 2 branches missed.">                if (!isInProgress()) {</span>
<span class="nc" id="L4454">                    finished = true;</span>
<span class="nc bnc" id="L4455" title="All 2 branches missed.">                    if (destUIID != null) {</span>
<span class="nc" id="L4456">                        setUIID(destUIID);</span>
                    }
                } else {
<span class="fc" id="L4459">                    boolean requiresRevalidate = false;</span>
<span class="pc bpc" id="L4460" title="1 of 2 branches missed.">                    if (opacityMotion != null) {</span>
<span class="nc" id="L4461">                        sourceStyle.setOpacity(opacityMotion.getValue());</span>
                    }
<span class="pc bpc" id="L4463" title="1 of 2 branches missed.">                    if (fgColorMotion != null) {</span>
<span class="nc" id="L4464">                        sourceStyle.setFgColor(fgColorMotion.getValue());</span>
                    }
<span class="fc" id="L4466">                    ap.alpha = bgMotion.getValue();</span>
<span class="pc bpc" id="L4467" title="1 of 2 branches missed.">                    if (fontMotion != null) {</span>
<span class="nc" id="L4468">                        Font fnt = sourceStyle.getFont();</span>
<span class="nc" id="L4469">                        fnt = fnt.derive(((float) fontMotion.getValue()) / 100.0f, fnt.getStyle());</span>
<span class="nc" id="L4470">                        requiresRevalidate = true;</span>
<span class="nc" id="L4471">                        sourceStyle.setFont(fnt);</span>
                    }
<span class="pc bpc" id="L4473" title="1 of 2 branches missed.">                    if (paddingTop != null) {</span>
<span class="fc" id="L4474">                        sourceStyle.setPadding(TOP, paddingTop.getValue());</span>
<span class="fc" id="L4475">                        requiresRevalidate = true;</span>
                    }
<span class="pc bpc" id="L4477" title="1 of 2 branches missed.">                    if (paddingBottom != null) {</span>
<span class="fc" id="L4478">                        sourceStyle.setPadding(BOTTOM, paddingBottom.getValue());</span>
<span class="fc" id="L4479">                        requiresRevalidate = true;</span>
                    }
<span class="pc bpc" id="L4481" title="1 of 2 branches missed.">                    if (paddingLeft != null) {</span>
<span class="fc" id="L4482">                        sourceStyle.setPadding(LEFT, paddingLeft.getValue());</span>
<span class="fc" id="L4483">                        requiresRevalidate = true;</span>
                    }
<span class="pc bpc" id="L4485" title="1 of 2 branches missed.">                    if (paddingRight != null) {</span>
<span class="fc" id="L4486">                        sourceStyle.setPadding(RIGHT, paddingRight.getValue());</span>
<span class="fc" id="L4487">                        requiresRevalidate = true;</span>
                    }
<span class="pc bpc" id="L4489" title="1 of 2 branches missed.">                    if (marginTop != null) {</span>
<span class="fc" id="L4490">                        sourceStyle.setMargin(TOP, marginTop.getValue());</span>
<span class="fc" id="L4491">                        requiresRevalidate = true;</span>
                    }
<span class="pc bpc" id="L4493" title="1 of 2 branches missed.">                    if (marginBottom != null) {</span>
<span class="fc" id="L4494">                        sourceStyle.setMargin(BOTTOM, marginBottom.getValue());</span>
<span class="fc" id="L4495">                        requiresRevalidate = true;</span>
                    }
<span class="pc bpc" id="L4497" title="1 of 2 branches missed.">                    if (marginLeft != null) {</span>
<span class="fc" id="L4498">                        sourceStyle.setMargin(LEFT, marginLeft.getValue());</span>
<span class="fc" id="L4499">                        requiresRevalidate = true;</span>
                    }
<span class="pc bpc" id="L4501" title="1 of 2 branches missed.">                    if (marginRight != null) {</span>
<span class="fc" id="L4502">                        sourceStyle.setMargin(RIGHT, marginRight.getValue());</span>
<span class="fc" id="L4503">                        requiresRevalidate = true;</span>
                    }
<span class="pc bpc" id="L4505" title="1 of 2 branches missed.">                    if (!Component.revalidateOnStyleChange) {</span>
                        // If revalidation on stylechange is not enabled, then the style animation
                        // won't work. We need to explicitly revalidate or repaint here.
<span class="nc bnc" id="L4508" title="All 2 branches missed.">                        if (requiresRevalidate) {</span>
<span class="nc" id="L4509">                            Container parent = getParent();</span>
<span class="nc bnc" id="L4510" title="All 2 branches missed.">                            if (parent != null) parent.revalidate();</span>
<span class="nc" id="L4511">                            else repaint();</span>
<span class="nc" id="L4512">                        } else {</span>
<span class="nc" id="L4513">                            repaint();</span>
                        }
                    }
                }
<span class="fc" id="L4517">            }</span>

            @Override
            public void flush() {
<span class="nc" id="L4521">                bgMotion.finish();</span>
<span class="nc bnc" id="L4522" title="All 2 branches missed.">                if (opacityMotion != null) {</span>
<span class="nc" id="L4523">                    opacityMotion.finish();</span>
                }
<span class="nc bnc" id="L4525" title="All 2 branches missed.">                if (fgColorMotion != null) {</span>
<span class="nc" id="L4526">                    fgColorMotion.finish();</span>
                }
<span class="nc bnc" id="L4528" title="All 2 branches missed.">                if (fontMotion != null) {</span>
<span class="nc" id="L4529">                    fontMotion.finish();</span>
                }
<span class="nc bnc" id="L4531" title="All 2 branches missed.">                if (paddingTop != null) {</span>
<span class="nc" id="L4532">                    paddingTop.finish();</span>
                }
<span class="nc bnc" id="L4534" title="All 2 branches missed.">                if (paddingBottom != null) {</span>
<span class="nc" id="L4535">                    paddingBottom.finish();</span>
                }
<span class="nc bnc" id="L4537" title="All 2 branches missed.">                if (paddingLeft != null) {</span>
<span class="nc" id="L4538">                    paddingLeft.finish();</span>
                }
<span class="nc bnc" id="L4540" title="All 2 branches missed.">                if (paddingRight != null) {</span>
<span class="nc" id="L4541">                    paddingRight.finish();</span>
                }
<span class="nc bnc" id="L4543" title="All 2 branches missed.">                if (marginTop != null) {</span>
<span class="nc" id="L4544">                    marginTop.finish();</span>
                }
<span class="nc bnc" id="L4546" title="All 2 branches missed.">                if (marginBottom != null) {</span>
<span class="nc" id="L4547">                    marginBottom.finish();</span>
                }
<span class="nc bnc" id="L4549" title="All 2 branches missed.">                if (marginLeft != null) {</span>
<span class="nc" id="L4550">                    marginLeft.finish();</span>
                }
<span class="nc bnc" id="L4552" title="All 2 branches missed.">                if (marginRight != null) {</span>
<span class="nc" id="L4553">                    marginRight.finish();</span>
                }
<span class="nc" id="L4555">                updateState();</span>
<span class="nc" id="L4556">            }</span>
        };
    }

    /**
     * Indicates that scrolling through the component should work as an animation
     *
     * @return whether this component use smooth scrolling
     */
    public boolean isSmoothScrolling() {
<span class="fc bfc" id="L4566" title="All 4 branches covered.">        return smoothScrolling &amp;&amp; !disableSmoothScrolling;</span>
    }

    /**
     * Indicates that scrolling through the component should work as an animation
     *
     * @param smoothScrolling indicates if a component uses smooth scrolling
     */
    public void setSmoothScrolling(boolean smoothScrolling) {
<span class="fc" id="L4575">        this.smoothScrolling = smoothScrolling;</span>
<span class="fc" id="L4576">    }</span>

    /**
     * Invoked for devices where the pointer can hover without actually clicking
     * the display. This is true for PC mouse pointer as well as some devices such
     * as the BB storm.
     *
     * @param x the pointer x coordinate
     * @param y the pointer y coordinate
     */
    public void pointerHover(int[] x, int[] y) {
<span class="fc" id="L4587">    }</span>

    void clearDrag() {
<span class="fc" id="L4590">        Component leadParent = LeadUtil.leadParentImpl(this);</span>
<span class="pc bpc" id="L4591" title="2 of 4 branches missed.">        if (leadParent != null &amp;&amp; leadParent != this) {</span>
<span class="nc" id="L4592">            leadParent.clearDrag();</span>
<span class="nc" id="L4593">            return;</span>
        }
        //if we are in the middle of a tensile animation reset the scrolling location
        //before killing the scrolling
<span class="pc bpc" id="L4597" title="1 of 2 branches missed.">        if (draggedMotionX != null) {</span>
<span class="nc bnc" id="L4598" title="All 2 branches missed.">            if (draggedMotionX.getValue() &lt; 0) {</span>
<span class="nc" id="L4599">                setScrollX(0);</span>
<span class="nc bnc" id="L4600" title="All 2 branches missed.">            } else if (draggedMotionX.getValue() &gt; getScrollDimension().getWidth() - getWidth()) {</span>
<span class="nc" id="L4601">                setScrollX(getScrollDimension().getWidth() - getWidth());</span>
            }
        }
<span class="pc bpc" id="L4604" title="1 of 2 branches missed.">        if (draggedMotionY != null) {</span>
<span class="nc" id="L4605">            int dmv = draggedMotionY.getValue();</span>
<span class="nc bnc" id="L4606" title="All 2 branches missed.">            if (dmv &lt; 0) {</span>
<span class="nc" id="L4607">                setScrollY(0);</span>
            } else {
<span class="nc" id="L4609">                int hh = getScrollDimension().getHeight() - getHeight();</span>
<span class="nc bnc" id="L4610" title="All 2 branches missed.">                if (dmv &gt; hh) {</span>
<span class="nc" id="L4611">                    setScrollY(Math.max(0, hh));</span>
                }
            }
        }
<span class="fc" id="L4615">        draggedMotionX = null;</span>
<span class="fc" id="L4616">        draggedMotionY = null;</span>

<span class="fc" id="L4618">        Component parent = getParent();</span>
<span class="fc bfc" id="L4619" title="All 2 branches covered.">        if (parent != null) {</span>
<span class="fc" id="L4620">            parent.clearDrag();</span>
        }
<span class="pc bpc" id="L4622" title="1 of 2 branches missed.">        if (getClientProperty(&quot;$pullToRelease&quot;) != null</span>
<span class="nc bnc" id="L4623" title="All 2 branches missed.">                &amp;&amp; !getClientProperty(&quot;$pullToRelease&quot;).equals(&quot;updating&quot;)) {</span>
<span class="nc" id="L4624">            putClientProperty(&quot;$pullToRelease&quot;, null);</span>
        }
<span class="fc" id="L4626">    }</span>

    /**
     * Invoked for devices where the pointer can hover without actually clicking
     * the display. This is true for PC mouse pointer as well as some devices such
     * as the BB storm.
     *
     * @param x the pointer x coordinate
     * @param y the pointer y coordinate
     */
    public void pointerHoverReleased(int[] x, int[] y) {
<span class="fc" id="L4637">    }</span>

    /**
     * Invoked for devices where the pointer can hover without actually clicking
     * the display. This is true for PC mouse pointer as well as some devices such
     * as the BB storm.
     *
     * @param x the pointer x coordinate
     * @param y the pointer y coordinate
     */
    public void pointerHoverPressed(int[] x, int[] y) {
<span class="fc" id="L4648">    }</span>

    /**
     * Invoked by subclasses interested in handling pinch to zoom events, if true is returned
     * other drag events will not be broadcast
     *
     * @param scale the scaling of the pinch operation a number larger than 1 means scaling up and smaller than 1 means scaling down.
     *              It is recommended that code would threshold the number (so a change between 1.0 and 1.02 shouldn't necessarily trigger zoom).
     *              Notice that this number is relevant to current zoom levels and unaware of them so you should also enforce limits of maximum/minimum
     *              zoom levels.
     * @return false by default
     */
    protected boolean pinch(float scale) {
<span class="fc" id="L4661">        return false;</span>
    }

    private double distance(int[] x, int[] y) {
<span class="nc" id="L4665">        int disx = x[0] - x[1];</span>
<span class="nc" id="L4666">        int disy = y[0] - y[1];</span>
<span class="nc" id="L4667">        return Math.sqrt(disx * disx + disy * disy);</span>
    }

    /**
     * To be implemented by subclasses interested in being notified when a pinch zoom has
     * ended (i.e the user has removed one of their fingers, but is still dragging).
     *
     * @param x The x-coordinate of the remaining finger in the drag.  (Absolute)
     * @param y The y-coordinate of the remaining finger in the drag. (Absolute)
     * @since 7.0
     */
    protected void pinchReleased(int x, int y) {

<span class="fc" id="L4680">    }</span>

    /**
     * Invoked by subclasses interested in handling pinch to do their own actions based on the position of the two fingers, if true is returned
     * other drag events will not be broadcast
     *
     * @param x the pointer x coordinate
     * @param y the pointer y coordinate
     * @return false by default, true if pinch is handled
     */
    protected boolean pinch(int[] x, int[] y) {
<span class="fc" id="L4691">        return false;</span>
    }

    /**
     * returns true if pinch will block drag and drop
     */
    public boolean isPinchBlocksDragAndDrop() {
<span class="fc" id="L4698">        return pinchBlocksDragAndDrop;</span>
    }

    /**
     * If a component supports pinch as well as drag and drop the two may conflict (if one finger is placed a bit before the other, the drag
     * timer will be initiated and may trigger drag even if the second finger has been placed before).
     * Setting setPinchBlocksDragAndDrop to true will prevent drag from triggering.
     *
     * @param block if true will prevent drag and drop to trigger if two fingers are placed to pinch before the drag is initiated
     */
    public void setPinchBlocksDragAndDrop(boolean block) {
<span class="fc" id="L4709">        pinchBlocksDragAndDrop = block;</span>
<span class="fc" id="L4710">    }</span>

    /**
     * If this Component is focused, the pointer dragged event
     * will call this method
     *
     * @param x the pointer x coordinate
     * @param y the pointer y coordinate
     */
    public void pointerDragged(int[] x, int[] y) {
<span class="pc bpc" id="L4720" title="1 of 2 branches missed.">        if (x.length &gt; 1) {</span>
<span class="nc" id="L4721">            double currentDis = distance(x, y);</span>

            // prevent division by 0
<span class="nc bnc" id="L4724" title="All 2 branches missed.">            if (pinchDistance &lt;= 0) {</span>
<span class="nc" id="L4725">                pinchDistance = currentDis;</span>
            }
<span class="nc" id="L4727">            double scale = currentDis / pinchDistance;</span>
<span class="nc" id="L4728">            boolean pinchXY = pinch(x, y); // ensure that both pinch(scale) and pinch(x,y) are called</span>
<span class="nc bnc" id="L4729" title="All 4 branches missed.">            if (pinch((float) scale) || pinchXY) {</span>
<span class="nc" id="L4730">                inPinch = true;</span>
<span class="nc bnc" id="L4731" title="All 2 branches missed.">                if (pinchBlocksDragAndDrop)</span>
<span class="nc" id="L4732">                    dragActivated = false;</span>
<span class="nc" id="L4733">                return;</span>
            }
<span class="nc" id="L4735">        } else {</span>
<span class="pc bpc" id="L4736" title="1 of 2 branches missed.">            if (inPinch) {</span>
                // if we were in a pinch zoom, but the user
                // removes a finger, then we need a way to signal to the component
                // that the pinch portion is over
<span class="nc" id="L4740">                inPinch = false;</span>
<span class="nc" id="L4741">                pinchReleased(x[0], y[0]);</span>
            }
        }
<span class="fc" id="L4744">        pointerDragged(x[0], y[0]);</span>
<span class="fc" id="L4745">    }</span>

    /**
     * This method returns an image representing the dragged component, it can be overriden by subclasses to customize the look
     * of the image, the image will be overlaid on top of the form during a drag and drop operation
     *
     * @return an image
     */
    protected Image getDragImage() {
<span class="fc" id="L4754">        Image draggedImage = ImageFactory.createImage(this, getWidth(), getHeight(), 0x00ff7777);</span>
<span class="fc" id="L4755">        Graphics g = draggedImage.getGraphics();</span>

<span class="fc" id="L4757">        g.translate(-getX(), -getY());</span>
<span class="fc" id="L4758">        paintComponentBackground(g);</span>
<span class="fc" id="L4759">        paint(g);</span>
<span class="pc bpc" id="L4760" title="1 of 2 branches missed.">        if (isBorderPainted()) {</span>
<span class="nc" id="L4761">            paintBorder(g);</span>
        }
<span class="fc" id="L4763">        g.translate(getX(), getY());</span>

<span class="pc bpc" id="L4765" title="1 of 2 branches missed.">        if (dragTransparency &lt; 255) {</span>
            // remove all occurrences of the rare color
<span class="fc" id="L4767">            draggedImage = draggedImage.modifyAlpha(dragTransparency, 0xff7777);</span>
        }
<span class="fc" id="L4769">        return draggedImage;</span>
    }

    /**
     * Returns the translucency used in the {@link #getDragImage()} method.
     *
     * @return a number between 0 and 255 where 255 indicates an opaque image.
     */
    public byte getDragTransparency() {
<span class="fc" id="L4778">        return dragTransparency;</span>
    }

    /**
     * Sets the translucency of the {@link #getDragImage()} method.
     *
     * @param dragTransparency a number between 0 and 255 where 255
     *                         indicates an opaque image.
     */
    public void setDragTransparency(byte dragTransparency) {
<span class="fc" id="L4788">        this.dragTransparency = dragTransparency;</span>
<span class="fc" id="L4789">    }</span>

    /**
     * Returns the component as an image.
     *
     * @return This component as an image.
     */
    public Image toImage() {
<span class="pc bpc" id="L4797" title="2 of 4 branches missed.">        if (getWidth() &lt;= 0 || getHeight() &lt;= 0) {</span>
<span class="nc" id="L4798">            return null;</span>
        }
<span class="fc" id="L4800">        Image image = ImageFactory.createImage(this, getWidth(), getHeight(), 0x0);</span>
<span class="fc" id="L4801">        Graphics g = image.getGraphics();</span>

<span class="fc" id="L4803">        g.translate(-getX(), -getY());</span>
<span class="fc" id="L4804">        paintComponentBackground(g);</span>
<span class="fc" id="L4805">        paint(g);</span>
<span class="pc bpc" id="L4806" title="1 of 2 branches missed.">        if (isBorderPainted()) {</span>
<span class="nc" id="L4807">            paintBorder(g);</span>
        }
<span class="fc" id="L4809">        g.translate(getX(), getY());</span>
<span class="fc" id="L4810">        return image;</span>
    }

    /**
     * Invoked on the focus component to let it know that drag has started on the parent container
     * for the case of a component that doesn't support scrolling
     */
    protected void dragInitiated() {
<span class="fc" id="L4818">    }</span>

    void drawDraggedImage(Graphics g) {
<span class="pc bpc" id="L4821" title="1 of 2 branches missed.">        if (dragImage == null) {</span>
<span class="fc" id="L4822">            dragImage = getDragImage();</span>
        }
<span class="fc" id="L4824">        drawDraggedImage(g, dragImage, draggedx, draggedy);</span>
<span class="fc" id="L4825">    }</span>

    /**
     * Draws the given image at x/y, this method can be overriden to draw additional information such as positive
     * or negative drop indication
     *
     * @param g   the graphics context
     * @param img the image
     * @param x   x position
     * @param y   y position
     */
    protected void drawDraggedImage(Graphics g, Image img, int x, int y) {
//        g.drawImage(img, x - getWidth() / 2, y - getHeight() / 2);
<span class="fc" id="L4838">        g.drawImage(img, x, y);</span>
<span class="fc" id="L4839">    }</span>

    /**
     * This method allows a component to indicate if it is a drop target for the given component at the given x/y location
     * (in component coordiate space). This method can also update the drop tagets appearance to indicate the
     * drop location.
     *
     * @param dragged the component being dragged
     * @param x       the x location over the component
     * @param y       the y location over the component
     * @return true if a drop at this location will be successful
     */
    protected boolean draggingOver(Component dragged, int x, int y) {
<span class="fc" id="L4852">        return dropTarget;</span>
    }

    /**
     * This callback method indicates that a component drag has just entered this component
     *
     * @param dragged the component being dragged
     */
    protected void dragEnter(Component dragged) {
<span class="fc" id="L4861">    }</span>

    /**
     * This callback method provides an indication for a drop target that a drag operation is exiting the bounds of
     * this component and it should clear all relevant state if such state exists. E.g. if a component provides
     * drop indication visuaization in draggingOver this visualization should be cleared..
     *
     * @param dragged the component being dragged
     */
    protected void dragExit(Component dragged) {
<span class="fc" id="L4871">    }</span>

    /**
     * Performs a drop operation of the component at the given X/Y location in coordinate space, this method
     * should be overriden by subclasses to perform all of the logic related to moving a component, by default
     * this method does nothing and so dragging a component and dropping it has no effect
     *
     * @param dragged the component being dropped
     * @param x       the x coordinate of the drop
     * @param y       the y coordinate of the drop
     */
    public void drop(Component dragged, int x, int y) {
<span class="fc" id="L4883">    }</span>

    /**
     * Finds the drop target in the given screen coordinates
     *
     * @param source the component being dragged
     * @param x      the screen x coordinate
     * @param y      the screen y coordinate
     * @return a component drop target or null if no drop target is available at that coordinate
     */
    private Component findDropTarget(Component source, int x, int y) {
<span class="fc" id="L4894">        Form f = getComponentForm();</span>
<span class="pc bpc" id="L4895" title="1 of 2 branches missed.">        if (f != null) {</span>
<span class="fc" id="L4896">            Component c = f.findDropTargetAt(x, y);</span>
<span class="fc bfc" id="L4897" title="All 2 branches covered.">            while (c != null) {</span>
<span class="pc bpc" id="L4898" title="2 of 4 branches missed.">                if (c.isDropTarget() &amp;&amp; c.draggingOver(source, x - c.getAbsoluteX() - c.getScrollX(), y - c.getAbsoluteY() - c.getScrollY())) {</span>
<span class="fc" id="L4899">                    return c;</span>
                }
<span class="nc" id="L4901">                c = c.getParent();</span>
            }
        }
<span class="fc" id="L4904">        return null;</span>
    }

    /**
     * &lt;p&gt;This method adds a refresh task to the Component, the task will be
     * executed if the user has pulled the scroll beyond a certain height.&lt;/p&gt;
     *
     * &lt;script src=&quot;https://gist.github.com/codenameone/da87714157f97c739b2a.js&quot;&gt;&lt;/script&gt;
     * &lt;img src=&quot;https://www.codenameone.com/img/developer-guide/pull-to-refresh.png&quot; alt=&quot;Simple pull to refresh demo&quot; /&gt;
     *
     * @param task the refresh task to execute.
     */
    public void addPullToRefresh(Runnable task) {
<span class="fc" id="L4917">        this.refreshTask = task;</span>
<span class="fc" id="L4918">    }</span>

    /**
     * Checks if the component responds to pointer events.  A component is considered
     * to respond to pointer events if it is visible and enabled, and is either scrollable,
     * focusable, or has the {@link #isGrabsPointerEvents() } flag {@literal true}.
     *
     * @return True if the pointer responds to pointer events.
     */
    public boolean respondsToPointerEvents() {
<span class="pc bpc" id="L4928" title="3 of 6 branches missed.">        boolean isScrollable = CN.isEdt() ? isScrollable() : (scrollableXFlag() || scrollableYFlag());</span>
<span class="pc bpc" id="L4929" title="2 of 12 branches missed.">        return isVisible() &amp;&amp; isEnabled() &amp;&amp; (isScrollable || isFocusable() || isGrabsPointerEvents() || isDraggable());</span>
    }

    private boolean pointerReleaseMaterialPullToRefresh() {
<span class="nc bnc" id="L4933" title="All 4 branches missed.">        if (refreshTask != null &amp;&amp; InfiniteProgress.isDefaultMaterialDesignMode()) {</span>
<span class="nc" id="L4934">            Container c = getComponentForm().getLayeredPane(InfiniteProgress.class, true);</span>
<span class="nc bnc" id="L4935" title="All 2 branches missed.">            if (c.getComponentCount() &gt; 0) {</span>
<span class="nc" id="L4936">                Component cc = c.getComponentAt(0);</span>
<span class="nc bnc" id="L4937" title="All 2 branches missed.">                if (cc instanceof InfiniteProgress) {</span>
<span class="nc" id="L4938">                    return false;</span>
                }
<span class="nc" id="L4940">                Motion opacityMotion = (Motion) cc.getClientProperty(&quot;cn1$opacityMotion&quot;);</span>
<span class="nc" id="L4941">                c.removeAll();</span>
<span class="nc bnc" id="L4942" title="All 2 branches missed.">                if (opacityMotion.isFinished()) {</span>
<span class="nc" id="L4943">                    final InfiniteProgress ip = new InfiniteProgress();</span>
<span class="nc" id="L4944">                    ip.setUIID(&quot;RefreshLabel&quot;);</span>
<span class="nc" id="L4945">                    ip.getUnselectedStyle().</span>
<span class="nc" id="L4946">                            setBorder(RoundBorder.create().</span>
<span class="nc" id="L4947">                                    color(getUnselectedStyle().getBgColor()).</span>
<span class="nc" id="L4948">                                    shadowX(0).</span>
<span class="nc" id="L4949">                                    shadowY(0).</span>
<span class="nc" id="L4950">                                    shadowSpread(1, true).</span>
<span class="nc" id="L4951">                                    shadowOpacity(100));</span>
<span class="nc" id="L4952">                    Style s = ip.getUnselectedStyle();</span>
<span class="nc" id="L4953">                    s.setMarginUnit(Style.UNIT_TYPE_DIPS);</span>
<span class="nc" id="L4954">                    s.setMarginTop(10);</span>
<span class="nc" id="L4955">                    c.add(ip);</span>
<span class="nc" id="L4956">                    Display.INSTANCE.callSerially(new Runnable() {</span>
                        @Override
                        public void run() {
<span class="nc" id="L4959">                            refreshTask.run();</span>
<span class="nc" id="L4960">                            ip.remove();</span>
<span class="nc" id="L4961">                        }</span>
                    });
                }
<span class="nc" id="L4964">                c.revalidate();</span>
<span class="nc" id="L4965">                return true;</span>
            }
        }
<span class="nc" id="L4968">        return false;</span>
    }

    private boolean updateMaterialPullToRefresh(final Form p, int y) {
<span class="nc bnc" id="L4972" title="All 4 branches missed.">        if (refreshTask != null &amp;&amp; InfiniteProgress.isDefaultMaterialDesignMode() &amp;&amp;</span>
<span class="nc bnc" id="L4973" title="All 2 branches missed.">                pullY &lt; getHeight() / 4 &amp;&amp;</span>
<span class="nc bnc" id="L4974" title="All 4 branches missed.">                scrollableYFlag() &amp;&amp; getScrollY() == 0) {</span>
<span class="nc" id="L4975">            int mm = Display.INSTANCE.convertToPixels(1);</span>
<span class="nc bnc" id="L4976" title="All 2 branches missed.">            if (mm &lt; y - pullY) {</span>
<span class="nc" id="L4977">                p.clearComponentsAwaitingRelease();</span>
<span class="nc" id="L4978">                Container c = p.getLayeredPane(InfiniteProgress.class, true);</span>
<span class="nc" id="L4979">                c.setLayout(new FlowLayout(CENTER));</span>
                Motion rotationMotion;
                Motion opacityMotion;
                Label refreshLabel;
<span class="nc bnc" id="L4983" title="All 2 branches missed.">                if (c.getComponentCount() == 0) {</span>
<span class="nc" id="L4984">                    refreshLabel = new Label(&quot;&quot;, &quot;RefreshLabel&quot;);</span>
<span class="nc" id="L4985">                    FontImage.setMaterialIcon(refreshLabel, FontImage.MATERIAL_REFRESH, 5);</span>
<span class="nc" id="L4986">                    refreshLabel.</span>
<span class="nc" id="L4987">                            getUnselectedStyle().setBorder(RoundBorder.create().</span>
<span class="nc" id="L4988">                                    color(getUnselectedStyle().getBgColor()).</span>
<span class="nc" id="L4989">                                    shadowX(0).</span>
<span class="nc" id="L4990">                                    shadowY(0).</span>
<span class="nc" id="L4991">                                    shadowSpread(1, true).</span>
<span class="nc" id="L4992">                                    shadowOpacity(100));</span>
<span class="nc" id="L4993">                    opacityMotion = Motion.createLinearMotion(</span>
<span class="nc" id="L4994">                            40, 255, getHeight() / 4);</span>
<span class="nc" id="L4995">                    opacityMotion.setStartTime(pullY);</span>

<span class="nc" id="L4997">                    rotationMotion = Motion.createLinearMotion(</span>
<span class="nc" id="L4998">                            0, 360, getHeight() / 4);</span>
<span class="nc" id="L4999">                    rotationMotion.setStartTime(pullY);</span>
<span class="nc" id="L5000">                    refreshLabel.putClientProperty(&quot;cn1$opacityMotion&quot;, opacityMotion);</span>
<span class="nc" id="L5001">                    refreshLabel.putClientProperty(&quot;cn1$rotationMotion&quot;, rotationMotion);</span>
<span class="nc" id="L5002">                    c.add(refreshLabel);</span>
<span class="nc" id="L5003">                    p.addPointerReleasedListener(new ActionListener&lt;ActionEvent&gt;() {</span>
                        public void actionPerformed(ActionEvent evt) {
<span class="nc" id="L5005">                            pointerReleaseMaterialPullToRefresh();</span>
<span class="nc" id="L5006">                            p.removePointerReleasedListener(this);</span>
<span class="nc" id="L5007">                            evt.consume();</span>
<span class="nc" id="L5008">                        }</span>
                    });
                } else {
<span class="nc" id="L5011">                    Component cc = c.getComponentAt(0);</span>
<span class="nc bnc" id="L5012" title="All 2 branches missed.">                    if (cc instanceof InfiniteProgress) {</span>
<span class="nc" id="L5013">                        return false;</span>
                    }
<span class="nc" id="L5015">                    refreshLabel = (Label) cc;</span>
<span class="nc" id="L5016">                    opacityMotion = (Motion) refreshLabel.getClientProperty(&quot;cn1$opacityMotion&quot;);</span>
<span class="nc" id="L5017">                    rotationMotion = (Motion) refreshLabel.getClientProperty(&quot;cn1$rotationMotion&quot;);</span>
                }
<span class="nc" id="L5019">                rotationMotion.setCurrentMotionTime(y);</span>
<span class="nc" id="L5020">                opacityMotion.setCurrentMotionTime(y);</span>
<span class="nc" id="L5021">                Style s = refreshLabel.getAllStyles();</span>
<span class="nc" id="L5022">                s.setOpacity(opacityMotion.getValue());</span>
<span class="nc" id="L5023">                Image i = refreshLabel.getIcon().rotate(rotationMotion.getValue());</span>
<span class="nc" id="L5024">                refreshLabel.setIcon(i);</span>
<span class="nc" id="L5025">                s.setMarginUnit(Style.UNIT_TYPE_PIXELS);</span>
<span class="nc" id="L5026">                s.setMarginTop(Math.min(getHeight() / 5, y - pullY));</span>
<span class="nc" id="L5027">                c.revalidate();</span>
<span class="nc" id="L5028">                return true;</span>
            }
        }
<span class="nc" id="L5031">        return false;</span>
    }

    /**
     * If this Component is focused, the pointer dragged event
     * will call this method
     *
     * @param x the pointer x coordinate
     * @param y the pointer y coordinate
     */
    public void pointerDragged(final int x, final int y) {
<span class="fc" id="L5042">        Form f = getComponentForm();</span>
<span class="pc bpc" id="L5043" title="1 of 2 branches missed.">        if (f != null) {</span>
<span class="fc" id="L5044">            pointerDragged(x, y, f.getCurrentPointerPress());</span>
        } else {
<span class="nc" id="L5046">            pointerDragged(x, y, null);</span>
        }
<span class="fc" id="L5048">    }</span>

    private void pointerDragged(final int x, final int y, final Object currentPointerPress) {
<span class="fc" id="L5051">        Component leadParent = LeadUtil.leadParentImpl(this);</span>
<span class="fc" id="L5052">        leadParent.pointerDragged(this, x, y, currentPointerPress);</span>

<span class="fc" id="L5054">    }</span>

    /**
     * If this Component is focused, the pointer dragged event
     * will call this method
     *
     * @param x                   the pointer x coordinate
     * @param y                   the pointer y coordinate
     * @param currentPointerPress Object useed to track the current pointer press.  Each time
     *                            the pointer is pressed, a new Object is generated, and is passed to pointerDragged.
     *                            This is to help prevent infinite loops of pointerDragged after a pointer press has been released.
     */
    private void pointerDragged(final Component lead, final int x, final int y, final Object currentPointerPress) {
<span class="fc" id="L5067">        Form p = getComponentForm();</span>
<span class="pc bpc" id="L5068" title="1 of 2 branches missed.">        if (p == null) {</span>
<span class="nc" id="L5069">            return;</span>
        }
<span class="pc bpc" id="L5071" title="1 of 2 branches missed.">        if (currentPointerPress != p.getCurrentPointerPress()) {</span>
<span class="nc" id="L5072">            return;</span>
        }

<span class="fc bfc" id="L5075" title="All 4 branches covered.">        if (lead.pointerDraggedListeners != null &amp;&amp; lead.pointerDraggedListeners.hasListeners()) {</span>
<span class="fc" id="L5076">            lead.pointerDraggedListeners.fireActionEvent(new ActionEvent(lead, ActionEvent.Type.PointerDrag, x, y));</span>
        }

<span class="fc bfc" id="L5079" title="All 2 branches covered.">        if (dragAndDropInitialized) {</span>
            //keep call to pointerDragged to move the parent scroll if needed
<span class="fc bfc" id="L5081" title="All 2 branches covered.">            if (dragCallbacks &lt; 2) {</span>
<span class="fc" id="L5082">                dragCallbacks++;</span>
<span class="fc" id="L5083">                Display.getInstance().callSerially(new Runnable() {</span>
                    public void run() {
<span class="pc bpc" id="L5085" title="1 of 2 branches missed.">                        if (dragActivated) {</span>
<span class="nc" id="L5086">                            lead.pointerDragged(x, y, currentPointerPress);</span>
                        }
<span class="fc" id="L5088">                        dragCallbacks--;</span>
<span class="fc" id="L5089">                    }</span>
                });
            }

<span class="fc bfc" id="L5093" title="All 2 branches covered.">            if (!dragActivated) {</span>
<span class="fc" id="L5094">                dragActivated = true;</span>
<span class="fc" id="L5095">                setVisible(false);</span>
<span class="fc" id="L5096">                p.setDraggedComponent(this);</span>
<span class="fc" id="L5097">                oldx = x;</span>
<span class="fc" id="L5098">                oldy = y;</span>
<span class="fc" id="L5099">                draggedx = getAbsoluteX();</span>
<span class="fc" id="L5100">                draggedy = getAbsoluteY();</span>
            }
<span class="fc" id="L5102">            Component dropTo = findDropTarget(this, x, y);</span>
<span class="pc bpc" id="L5103" title="1 of 4 branches missed.">            if (dropTo != null &amp;&amp; lead.dragOverListener != null) {</span>
<span class="nc" id="L5104">                ActionEvent ev = new ActionEvent(lead, dropTo, x, y);</span>
<span class="nc" id="L5105">                lead.dragOverListener.fireActionEvent(ev);</span>
<span class="nc bnc" id="L5106" title="All 2 branches missed.">                if (ev.isConsumed()) {</span>
<span class="nc" id="L5107">                    return;</span>
                }
            }
<span class="fc bfc" id="L5110" title="All 2 branches covered.">            if (dropTargetComponent != dropTo) {</span>
<span class="pc bpc" id="L5111" title="1 of 2 branches missed.">                if (dropTargetComponent != null) {</span>
<span class="nc" id="L5112">                    dropTargetComponent.dragExit(this);</span>
                }
<span class="fc" id="L5114">                dropTargetComponent = dropTo;</span>
<span class="pc bpc" id="L5115" title="1 of 2 branches missed.">                if (dropTargetComponent != null) {</span>
<span class="fc" id="L5116">                    dropTargetComponent.dragEnter(this);</span>
                }
            }

            // we repaint twice to create an intersection of the old and new position
<span class="fc" id="L5121">            p.repaint(draggedx, draggedy, getWidth(), getHeight());</span>
<span class="fc" id="L5122">            draggedx = draggedx + (x - oldx);</span>
<span class="fc" id="L5123">            draggedy = draggedy + (y - oldy);</span>
<span class="fc" id="L5124">            oldx = x;</span>
<span class="fc" id="L5125">            oldy = y;</span>
<span class="fc" id="L5126">            p.repaint(draggedx, draggedy, getWidth(), getHeight());</span>
<span class="fc" id="L5127">            Container scrollParent = getParent();</span>
<span class="pc bpc" id="L5128" title="1 of 4 branches missed.">            while (scrollParent != null &amp;&amp; !scrollParent.isScrollable()) {</span>
<span class="fc" id="L5129">                scrollParent = scrollParent.getParent();</span>
            }
<span class="pc bpc" id="L5131" title="1 of 2 branches missed.">            if (scrollParent != null) {</span>
<span class="nc" id="L5132">                Style s = getStyle();</span>
<span class="nc" id="L5133">                int w = getWidth() - s.getHorizontalPadding();</span>
<span class="nc" id="L5134">                int h = getHeight() - s.getVerticalPadding();</span>

                Rectangle view;
<span class="nc" id="L5137">                int invisibleAreaUnderVKB = getInvisibleAreaUnderVKB();</span>
<span class="nc" id="L5138">                view = new Rectangle(getScrollX(), getScrollY(), w, h - invisibleAreaUnderVKB);</span>
                //if the dragging component is out of bounds move the scrollable parent
<span class="nc bnc" id="L5140" title="All 2 branches missed.">                if (!view.contains(draggedx - scrollParent.getAbsoluteX(), draggedy - scrollParent.getAbsoluteY(), getWidth(), getHeight())) {</span>
<span class="nc bnc" id="L5141" title="All 6 branches missed.">                    if ((scrollParent.isScrollableY() &amp;&amp; scrollParent.getScrollY() &gt;= 0 &amp;&amp; scrollParent.getScrollY() + (draggedy + getHeight()) &lt; scrollParent.getScrollDimension().getHeight()) ||</span>
<span class="nc bnc" id="L5142" title="All 6 branches missed.">                            (scrollParent.isScrollableX() &amp;&amp; scrollParent.getScrollX() &gt;= 0 &amp;&amp; scrollParent.getScrollX() + (draggedx + getWidth()) &lt; scrollParent.getScrollDimension().getWidth())) {</span>
<span class="nc" id="L5143">                        int yposition = draggedy - scrollParent.getAbsoluteY() - 40;</span>
<span class="nc bnc" id="L5144" title="All 2 branches missed.">                        if (yposition &lt; 0) {</span>
<span class="nc" id="L5145">                            yposition = 0;</span>
                        }
<span class="nc" id="L5147">                        int xposition = draggedx - scrollParent.getAbsoluteX() - 40;</span>
<span class="nc bnc" id="L5148" title="All 2 branches missed.">                        if (xposition &lt; 0) {</span>
<span class="nc" id="L5149">                            xposition = 0;</span>
                        }
                        int height;
                        int width;
<span class="nc bnc" id="L5153" title="All 4 branches missed.">                        if (isHidden() &amp;&amp; dragImage != null) {</span>
<span class="nc" id="L5154">                            height = dragImage.getHeight() + 80;</span>
<span class="nc" id="L5155">                            width = dragImage.getWidth() + 80;</span>
                        } else {
<span class="nc" id="L5157">                            height = getHeight() + 80;</span>
<span class="nc" id="L5158">                            width = getWidth() + 80;</span>
                        }
<span class="nc bnc" id="L5160" title="All 2 branches missed.">                        if (scrollParent.getScrollY() + draggedy + height &gt;= scrollParent.getScrollDimension().getHeight()) {</span>
<span class="nc" id="L5161">                            yposition = draggedy - scrollParent.getAbsoluteY();</span>
<span class="nc" id="L5162">                            height = scrollParent.getScrollDimension().getHeight() - yposition;</span>
                        }
<span class="nc bnc" id="L5164" title="All 2 branches missed.">                        if (scrollParent.getScrollX() + draggedx + width &gt;= scrollParent.getScrollDimension().getWidth()) {</span>
<span class="nc" id="L5165">                            xposition = draggedx - scrollParent.getAbsoluteX();</span>
<span class="nc" id="L5166">                            width = scrollParent.getScrollDimension().getWidth() - xposition;</span>
                        }

<span class="nc" id="L5169">                        scrollParent.scrollRectToVisible(xposition, yposition, width, height, scrollParent);</span>
                    }
                }
            }

<span class="fc" id="L5174">            return;</span>
        }
<span class="pc bpc" id="L5176" title="1 of 4 branches missed.">        if (dragActivated &amp;&amp; p.getDraggedComponent() == null) {</span>
<span class="fc" id="L5177">            dragActivated = false;</span>
        }

<span class="pc bpc" id="L5180" title="1 of 2 branches missed.">        if (!dragActivated) {</span>
<span class="pc bpc" id="L5181" title="1 of 2 branches missed.">            boolean draggedOnX = Math.abs(p.initialPressX - x) &gt; Math.abs(p.initialPressY - y);</span>
<span class="pc bpc" id="L5182" title="2 of 8 branches missed.">            shouldGrabScrollEvents = (isScrollableX() &amp;&amp; draggedOnX) || isScrollableY() &amp;&amp; !draggedOnX;</span>
        }

<span class="pc bpc" id="L5185" title="1 of 6 branches missed.">        if (isScrollable() &amp;&amp; isSmoothScrolling() &amp;&amp; shouldGrabScrollEvents) {</span>
<span class="pc bpc" id="L5186" title="1 of 2 branches missed.">            if (!dragActivated) {</span>
<span class="fc" id="L5187">                dragActivated = true;</span>
<span class="fc" id="L5188">                lastScrollY = y;</span>
<span class="fc" id="L5189">                lastScrollX = x;</span>
<span class="fc" id="L5190">                p.setDraggedComponent(this);</span>
<span class="fc" id="L5191">                p.registerAnimatedInternal(this);</span>
<span class="fc" id="L5192">                Component fc = p.getFocused();</span>
<span class="pc bpc" id="L5193" title="3 of 4 branches missed.">                if (fc != null &amp;&amp; fc != this) {</span>
<span class="nc" id="L5194">                    fc.dragInitiated();</span>
                }
            }

            // we drag inversly to get a feel of grabbing a physical screen
            // and pulling it in the reverse direction of the drag
<span class="pc bpc" id="L5200" title="1 of 2 branches missed.">            if (isScrollableY()) {</span>
                int tl;
<span class="pc bpc" id="L5202" title="5 of 6 branches missed.">                if (getTensileLength() &gt; -1 &amp;&amp; (refreshTask == null || InfiniteProgress.isDefaultMaterialDesignMode())) {</span>
<span class="nc" id="L5203">                    tl = getTensileLength();</span>
                } else {
<span class="fc" id="L5205">                    tl = getHeight() / 2;</span>
                }
<span class="pc bpc" id="L5207" title="2 of 4 branches missed.">                if (!isSmoothScrolling() || !isTensileDragEnabled()) {</span>
<span class="nc" id="L5208">                    tl = 0;</span>
                }
<span class="fc" id="L5210">                int scroll = getScrollY() + (lastScrollY - y);</span>

<span class="pc bpc" id="L5212" title="1 of 4 branches missed.">                if (isAlwaysTensile() &amp;&amp; getScrollDimension().getHeight() + getInvisibleAreaUnderVKB() &lt;= getHeight()) {</span>
<span class="pc bpc" id="L5213" title="2 of 4 branches missed.">                    if (scroll &gt;= -tl &amp;&amp; scroll &lt; getHeight() + tl) {</span>
<span class="fc" id="L5214">                        setScrollY(scroll);</span>
                    }
                } else {
<span class="pc bpc" id="L5217" title="2 of 4 branches missed.">                    if (scroll &gt;= -tl &amp;&amp; scroll &lt; getScrollDimension().getHeight() + getInvisibleAreaUnderVKB() - getHeight() + tl) {</span>
<span class="fc" id="L5218">                        setScrollY(scroll);</span>
                    }
                }
<span class="fc" id="L5221">                updateTensileHighlightIntensity(lastScrollY, y, false);</span>
            }
<span class="pc bpc" id="L5223" title="1 of 2 branches missed.">            if (isScrollableX()) {</span>
                int tl;
<span class="nc bnc" id="L5225" title="All 2 branches missed.">                if (getTensileLength() &gt; -1) {</span>
<span class="nc" id="L5226">                    tl = getTensileLength();</span>
                } else {
<span class="nc" id="L5228">                    tl = getWidth() / 2;</span>
                }
<span class="nc bnc" id="L5230" title="All 4 branches missed.">                if (!isSmoothScrolling() || !isTensileDragEnabled()) {</span>
<span class="nc" id="L5231">                    tl = 0;</span>
                }
<span class="nc" id="L5233">                int scroll = getScrollX() + (lastScrollX - x);</span>
<span class="nc bnc" id="L5234" title="All 4 branches missed.">                if (scroll &gt;= -tl &amp;&amp; scroll &lt; getScrollDimension().getWidth() - getWidth() + tl) {</span>
<span class="nc" id="L5235">                    setScrollX(scroll);</span>
                }
            }
<span class="fc" id="L5238">            lastScrollY = y;</span>
<span class="fc" id="L5239">            lastScrollX = x;</span>
        } else {
            //try to find a scrollable element until you reach the Form
<span class="fc" id="L5242">            Component parent = getParent();</span>
<span class="fc bfc" id="L5243" title="All 2 branches covered.">            if (!(parent instanceof Form)) {</span>
<span class="fc" id="L5244">                parent.pointerDragged(x, y);</span>
            }
        }
<span class="fc" id="L5247">    }</span>

    /**
     * Returns true if the component is interested in receiving drag/pointer release events even
     * after the gesture exceeded its boundaries. This is useful for spinners etc. where the motion
     * might continue beyond the size of the component
     *
     * @return false by default
     */
    protected boolean isStickyDrag() {
<span class="fc" id="L5257">        return false;</span>
    }

    private void initScrollMotion() {
        // the component might not be registered for animation if it started off
        // as smaller than the screen and grew (e.g. by adding components to the container
        // once it is visible).
<span class="fc" id="L5264">        Form f = getComponentForm();</span>
<span class="pc bpc" id="L5265" title="1 of 2 branches missed.">        if (f != null) {</span>
<span class="fc" id="L5266">            f.registerAnimatedInternal(this);</span>
        }

<span class="fc" id="L5269">        Motion m = Motion.createLinearMotion(initialScrollY, destScrollY, getScrollAnimationSpeed());</span>
<span class="fc" id="L5270">        setAnimationMotion(m);</span>
<span class="fc" id="L5271">        m.start();</span>
<span class="fc" id="L5272">    }</span>

    /**
     * If this Component is focused, the pointer pressed event
     * will call this method
     *
     * @param x the pointer x coordinate
     * @param y the pointer y coordinate
     */
    public void pointerPressed(int[] x, int[] y) {
<span class="fc" id="L5282">        Component leadParent = LeadUtil.leadParentImpl(this);</span>
<span class="fc" id="L5283">        leadParent.inPinch = false;</span>
<span class="fc" id="L5284">        leadParent.dragActivated = false;</span>
<span class="fc" id="L5285">        pointerPressed(x[0], y[0]);</span>
<span class="fc" id="L5286">        leadParent.scrollOpacity = 0xff;</span>
<span class="fc" id="L5287">    }</span>

    /**
     * This method allows a developer to define only a specific portion of a component as draggable
     * by default it returns true if the component is defined as &quot;draggable&quot;
     *
     * @param x the x coordinate relative to the component
     * @param y the y coordinate relative to the component
     * @return true if a press in this point might indicate the desire to begin a drag operation
     */
    protected boolean isDragAndDropOperation(int x, int y) {
<span class="fc" id="L5298">        Component leadParent = LeadUtil.leadParentImpl(this);</span>
<span class="fc" id="L5299">        return leadParent.draggable;</span>
    }

    /**
     * If this Component is focused, the pointer pressed event
     * will call this method
     *
     * @param x the pointer x coordinate
     * @param y the pointer y coordinate
     */
    public void pointerPressed(int x, int y) {
<span class="fc" id="L5310">        Component leadParent = LeadUtil.leadParentImpl(this);</span>
<span class="fc" id="L5311">        leadParent.dragActivated = false;</span>
<span class="pc bpc" id="L5312" title="1 of 4 branches missed.">        if (pointerPressedListeners != null &amp;&amp; pointerPressedListeners.hasListeners()) {</span>
<span class="fc" id="L5313">            pointerPressedListeners.fireActionEvent(new ActionEvent(this, ActionEvent.Type.PointerPressed, x, y));</span>
        }
<span class="fc" id="L5315">        leadParent.clearDrag();</span>
<span class="fc bfc" id="L5316" title="All 2 branches covered.">        if (leadParent.isDragAndDropOperation(x, y)) {</span>
<span class="fc" id="L5317">            int restore = Display.getInstance().getDragStartPercentage();</span>
<span class="pc bpc" id="L5318" title="1 of 2 branches missed.">            if (restore &gt; 1) {</span>
<span class="fc" id="L5319">                Component.restoreDragPercentage = restore;</span>
            }
<span class="fc" id="L5321">            Display.getInstance().setDragStartPercentage(1);</span>
        }
<span class="fc" id="L5323">    }</span>

    void initDragAndDrop(int x, int y) {
<span class="fc" id="L5326">        Component leadParent = LeadUtil.leadParentImpl(this);</span>
<span class="fc" id="L5327">        leadParent.dragAndDropInitialized = leadParent.isDragAndDropOperation(x, y);</span>
<span class="fc" id="L5328">    }</span>

    /**
     * If this Component is focused, the pointer released event
     * will call this method
     *
     * @param x the pointer x coordinate
     * @param y the pointer y coordinate
     */
    public void pointerReleased(int[] x, int[] y) {
<span class="fc" id="L5338">        pointerReleased(x[0], y[0]);</span>
<span class="fc" id="L5339">    }</span>

    /**
     * If this Component is focused this method is invoked when the user presses
     * and holds the pointer on the Component
     */
    public void longPointerPress(int x, int y) {
<span class="pc bpc" id="L5346" title="1 of 4 branches missed.">        if (longPressListeners != null &amp;&amp; longPressListeners.hasListeners()) {</span>
<span class="fc" id="L5347">            ActionEvent ev = new ActionEvent(this, ActionEvent.Type.LongPointerPress, x, y);</span>
<span class="fc" id="L5348">            longPressListeners.fireActionEvent(ev);</span>
        }
<span class="fc" id="L5350">    }</span>

    /**
     * If this Component is focused, the pointer released event
     * will call this method
     *
     * @param x the pointer x coordinate
     * @param y the pointer y coordinate
     */
    public void pointerReleased(int x, int y) {
<span class="fc" id="L5360">        Component leadParent = LeadUtil.leadParentImpl(this);</span>
<span class="pc bpc" id="L5361" title="1 of 2 branches missed.">        if (leadParent.inPinch) {</span>
<span class="nc" id="L5362">            leadParent.inPinch = false;</span>
        }
<span class="pc bpc" id="L5364" title="3 of 4 branches missed.">        if (pointerReleasedListeners != null &amp;&amp; pointerReleasedListeners.hasListeners()) {</span>
<span class="nc" id="L5365">            ActionEvent ev = new ActionEvent(this, ActionEvent.Type.PointerReleased, x, y);</span>
<span class="nc" id="L5366">            pointerReleasedListeners.fireActionEvent(ev);</span>
<span class="nc bnc" id="L5367" title="All 2 branches missed.">            if (ev.isConsumed()) {</span>
<span class="nc" id="L5368">                return;</span>
            }
        }
<span class="fc" id="L5371">        pointerReleaseImpl(x, y);</span>
<span class="fc" id="L5372">        leadParent.scrollOpacity = 0xff;</span>
<span class="fc" id="L5373">    }</span>

    /**
     * Indicates whether tensile drag (dragging beyond the boundry of the component and
     * snapping back) is enabled for this component.
     *
     * @return true when tensile drag is enabled
     */
    public boolean isTensileDragEnabled() {
<span class="fc" id="L5382">        return tensileDragEnabled;</span>
    }

    /**
     * Indicates whether tensile drag (dragging beyond the boundry of the component and
     * snapping back) is enabled for this component.
     *
     * @param tensileDragEnabled true to enable tensile drag
     */
    public void setTensileDragEnabled(boolean tensileDragEnabled) {
<span class="fc" id="L5392">        this.tensileDragEnabled = tensileDragEnabled;</span>
<span class="fc" id="L5393">    }</span>

    /**
     * Returns text selection support object for this component.  Only used by
     * components that support text selection (e.g. Labels, un-editable text fields, etc..).
     *
     * @return text selection support object
     * @since 7.0
     */
    public TextSelectionSupport getTextSelectionSupport() {
<span class="nc" id="L5403">        return null;</span>
    }

    boolean isScrollDecelerationMotionInProgress() {
<span class="fc" id="L5407">        Motion dmY = draggedMotionY;</span>
<span class="pc bpc" id="L5408" title="1 of 2 branches missed.">        if (dmY != null) {</span>
<span class="nc bnc" id="L5409" title="All 4 branches missed.">            if (dmY == decelerationMotion &amp;&amp; !dmY.isFinished()) {</span>
<span class="nc" id="L5410">                return true;</span>
            }
        }
<span class="fc" id="L5413">        Motion dmX = draggedMotionX;</span>
<span class="pc bpc" id="L5414" title="1 of 2 branches missed.">        if (dmX != null) {</span>
<span class="nc bnc" id="L5415" title="All 4 branches missed.">            if (dmX == decelerationMotion &amp;&amp; !dmX.isFinished()) {</span>
<span class="nc" id="L5416">                return true;</span>
            }
        }
<span class="fc" id="L5419">        Container parent = getParent();</span>
<span class="pc bpc" id="L5420" title="1 of 2 branches missed.">        if (parent != null) {</span>
<span class="nc" id="L5421">            return parent.isScrollDecelerationMotionInProgress();</span>
        }

<span class="fc" id="L5424">        return false;</span>
    }

    void startTensile(int offset, int dest, boolean vertical) {
        Motion draggedMotion;
<span class="nc bnc" id="L5429" title="All 2 branches missed.">        if (tensileDragEnabled) {</span>
<span class="nc" id="L5430">            final int distance = Math.abs(offset - dest);</span>
<span class="nc" id="L5431">            final int duration = Math.max(300, (int) Math.round(1000 * distance / (double) CN.getDisplayHeight()));</span>
<span class="nc" id="L5432">            draggedMotion = Motion.createDecelerationMotion(offset, dest, duration);</span>
<span class="nc" id="L5433">            draggedMotion.start();</span>
<span class="nc" id="L5434">        } else {</span>
<span class="nc" id="L5435">            draggedMotion = Motion.createLinearMotion(offset, dest, 0);</span>
<span class="nc" id="L5436">            draggedMotion.start();</span>
        }
<span class="nc" id="L5438">        decelerationMotion = draggedMotion;</span>

<span class="nc bnc" id="L5440" title="All 2 branches missed.">        if (vertical) {</span>
<span class="nc" id="L5441">            draggedMotionY = draggedMotion;</span>
        } else {
<span class="nc" id="L5443">            draggedMotionX = draggedMotion;</span>
        }
        // just to be sure, there are some cases where this doesn't work as expected
<span class="nc" id="L5446">        Form p = getComponentForm();</span>
<span class="nc bnc" id="L5447" title="All 2 branches missed.">        if (p != null) {</span>
<span class="nc" id="L5448">            p.registerAnimatedInternal(this);</span>
        }
<span class="nc" id="L5450">    }</span>

    private boolean chooseScrollXOrY(int x, int y) {
<span class="fc" id="L5453">        boolean ix = isScrollableX();</span>
<span class="fc" id="L5454">        boolean iy = isScrollableY();</span>
<span class="pc bpc" id="L5455" title="3 of 4 branches missed.">        if (ix &amp;&amp; iy) {</span>
<span class="nc" id="L5456">            Form parent = getComponentForm();</span>
<span class="nc bnc" id="L5457" title="All 2 branches missed.">            return Math.abs(parent.initialPressX - x) &gt; Math.abs(parent.initialPressY - y);</span>
        }
<span class="fc" id="L5459">        return ix;</span>
    }

    /**
     * Binds an action listener to drop events which are invoked when this component is dropped on a target
     *
     * @param l the callback
     */
    public void addDropListener(ActionListener l) {
<span class="pc bpc" id="L5468" title="1 of 2 branches missed.">        if (dropListener == null) {</span>
<span class="fc" id="L5469">            dropListener = new EventDispatcher();</span>
        }
<span class="fc" id="L5471">        dropListener.addListener(l);</span>
<span class="fc" id="L5472">    }</span>

    /**
     * Removes an action listener to drop events which are invoked when this component is dropped on a target
     *
     * @param l the callback
     */
    public void removeDropListener(ActionListener l) {
<span class="pc bpc" id="L5480" title="1 of 2 branches missed.">        if (dropListener == null) {</span>
<span class="nc" id="L5481">            return;</span>
        }
<span class="fc" id="L5483">        dropListener.removeListener(l);</span>
<span class="pc bpc" id="L5484" title="1 of 2 branches missed.">        if (!dropListener.hasListeners()) {</span>
<span class="fc" id="L5485">            dropListener = null;</span>
        }
<span class="fc" id="L5487">    }</span>

    /**
     * Broadcasts an event when dragging over a component
     *
     * @param l the listener
     */
    public void addDragOverListener(ActionListener l) {
<span class="pc bpc" id="L5495" title="1 of 2 branches missed.">        if (dragOverListener == null) {</span>
<span class="fc" id="L5496">            dragOverListener = new EventDispatcher();</span>
        }
<span class="fc" id="L5498">        dragOverListener.addListener(l);</span>
<span class="fc" id="L5499">    }</span>

    /**
     * Removes an action listener to drag over events
     *
     * @param l the callback
     */
    public void removeDragOverListener(ActionListener l) {
<span class="pc bpc" id="L5507" title="1 of 2 branches missed.">        if (dragOverListener == null) {</span>
<span class="nc" id="L5508">            return;</span>
        }
<span class="fc" id="L5510">        dragOverListener.removeListener(l);</span>
<span class="pc bpc" id="L5511" title="1 of 2 branches missed.">        if (!dragOverListener.hasListeners()) {</span>
<span class="fc" id="L5512">            dragOverListener = null;</span>
        }
<span class="fc" id="L5514">    }</span>

    /**
     * Callback indicating that the drag has finished either via drop or by releasing the component
     *
     * @param x the x location
     * @param y the y location
     */
    protected void dragFinished(int x, int y) {
<span class="fc" id="L5523">    }</span>

    void dragFinishedImpl(int x, int y) {
<span class="fc" id="L5526">        LeadUtil.leadParentImpl(this).dragFinishedImpl(this, x, y);</span>
<span class="fc" id="L5527">    }</span>

    private void dragFinishedImpl(Component lead, int x, int y) {
<span class="pc bpc" id="L5530" title="2 of 4 branches missed.">        if (dragAndDropInitialized &amp;&amp; dragActivated) {</span>
<span class="fc" id="L5531">            Form p = getComponentForm();</span>
<span class="pc bpc" id="L5532" title="1 of 2 branches missed.">            if (p == null) {</span>
                //The component was removed from the form during the drag
<span class="nc" id="L5534">                dragActivated = false;</span>
<span class="nc" id="L5535">                dragAndDropInitialized = false;</span>
<span class="nc" id="L5536">                setVisible(true);</span>
<span class="nc" id="L5537">                dragImage = null;</span>
<span class="nc" id="L5538">                dropTargetComponent = null;</span>
<span class="nc" id="L5539">                return;</span>
            }
<span class="fc" id="L5541">            p.setDraggedComponent(null);</span>
<span class="fc" id="L5542">            Component dropTo = findDropTarget(this, x, y);</span>
<span class="pc bpc" id="L5543" title="1 of 2 branches missed.">            if (dropTargetComponent != dropTo) {</span>
<span class="nc bnc" id="L5544" title="All 2 branches missed.">                if (dropTargetComponent != null) {</span>
<span class="nc" id="L5545">                    dropTargetComponent.dragExit(this);</span>
                }
<span class="nc" id="L5547">                dropTargetComponent = dropTo;</span>
<span class="nc bnc" id="L5548" title="All 2 branches missed.">                if (dropTargetComponent != null) {</span>
<span class="nc" id="L5549">                    dropTargetComponent.dragEnter(this);</span>
                }
            }
<span class="fc bfc" id="L5552" title="All 2 branches covered.">            if (dropTargetComponent != null) {</span>
<span class="fc" id="L5553">                p.repaint(x, y, getWidth(), getHeight());</span>
<span class="fc" id="L5554">                getParent().scrollRectToVisible(getX(), getY(), getWidth(), getHeight(), getParent());</span>
<span class="pc bpc" id="L5555" title="1 of 2 branches missed.">                if (lead.dropListener != null) {</span>
<span class="fc" id="L5556">                    ActionEvent ev = new ActionEvent(lead, ActionEvent.Type.PointerDrag, dropTargetComponent, x, y);</span>
<span class="fc" id="L5557">                    lead.dropListener.fireActionEvent(ev);</span>
<span class="fc bfc" id="L5558" title="All 2 branches covered.">                    if (!ev.isConsumed()) {</span>
<span class="fc" id="L5559">                        dropTargetComponent.drop(this, x, y);</span>
                    }
<span class="fc" id="L5561">                } else {</span>
<span class="nc" id="L5562">                    dropTargetComponent.drop(this, x, y);</span>
                }
            } else {
<span class="pc bpc" id="L5565" title="1 of 2 branches missed.">                if (lead.dragOverListener != null) {</span>
<span class="nc" id="L5566">                    ActionEvent ev = new ActionEvent(lead, ActionEvent.Type.PointerDrag, null, x, y);</span>
<span class="nc" id="L5567">                    lead.dragOverListener.fireActionEvent(ev);</span>
                }
<span class="fc" id="L5569">                p.repaint();</span>
            }
<span class="fc" id="L5571">            setVisible(true);</span>
<span class="fc" id="L5572">            dragImage = null;</span>
<span class="fc" id="L5573">            dropTargetComponent = null;</span>
        }
<span class="pc bpc" id="L5575" title="3 of 4 branches missed.">        if (getUIManager().getLookAndFeel().isFadeScrollBar() &amp;&amp; isScrollable()) {</span>
<span class="nc" id="L5576">            Form frm = getComponentForm();</span>
<span class="nc bnc" id="L5577" title="All 2 branches missed.">            if (frm != null) {</span>
<span class="nc" id="L5578">                frm.registerAnimatedInternal(this);</span>
            }
        }
<span class="fc" id="L5581">        dragActivated = false;</span>
<span class="fc" id="L5582">        dragAndDropInitialized = false;</span>
<span class="pc bpc" id="L5583" title="1 of 4 branches missed.">        if (lead.dragFinishedListeners != null &amp;&amp; lead.dragFinishedListeners.hasListeners()) {</span>
<span class="fc" id="L5584">            ActionEvent ev = new ActionEvent(lead, ActionEvent.Type.DragFinished, x, y);</span>
<span class="fc" id="L5585">            lead.dragFinishedListeners.fireActionEvent(ev);</span>
<span class="pc bpc" id="L5586" title="1 of 2 branches missed.">            if (ev.isConsumed()) {</span>
<span class="nc" id="L5587">                return;</span>
            }
        }
<span class="fc" id="L5590">        lead.dragFinished(x, y);</span>
<span class="fc" id="L5591">    }</span>

    /**
     * Adds a listener to the dragFinished event
     *
     * @param l callback to receive drag finished events events
     */
    public void addDragFinishedListener(ActionListener l) {
<span class="fc bfc" id="L5599" title="All 2 branches covered.">        if (dragFinishedListeners == null) {</span>
<span class="fc" id="L5600">            dragFinishedListeners = new EventDispatcher();</span>
        }
<span class="fc" id="L5602">        dragFinishedListeners.addListener(l);</span>
<span class="fc" id="L5603">    }</span>

    /**
     * Adds a listener to be notified when the state of this component is changed
     * to and from initialized.
     *
     * @param l Listener to be subscribed.
     * @since 7.0
     */
    public void addStateChangeListener(ActionListener&lt;ComponentStateChangeEvent&gt; l) {
<span class="pc bpc" id="L5613" title="1 of 2 branches missed.">        if (stateChangeListeners == null) {</span>
<span class="fc" id="L5614">            stateChangeListeners = new EventDispatcher();</span>
        }
<span class="fc" id="L5616">        stateChangeListeners.addListener(l);</span>
<span class="fc" id="L5617">    }</span>

    /**
     * Removes a listener from being notified when the state of this component is
     * changed to and from initialized.
     *
     * @param l Listener to be unsubscribed.
     * @since 7.0
     */
    public void removeStateChangeListener(ActionListener&lt;ComponentStateChangeEvent&gt; l) {
<span class="pc bpc" id="L5627" title="1 of 2 branches missed.">        if (stateChangeListeners != null) {</span>
<span class="fc" id="L5628">            stateChangeListeners.removeListener(l);</span>
        }
<span class="fc" id="L5630">    }</span>

    /**
     * Adds a listener to the pointer event
     *
     * @param l callback to receive pointer events
     */
    public void addPointerPressedListener(ActionListener l) {
<span class="fc bfc" id="L5638" title="All 2 branches covered.">        if (pointerPressedListeners == null) {</span>
<span class="fc" id="L5639">            pointerPressedListeners = new EventDispatcher();</span>
        }
<span class="fc" id="L5641">        pointerPressedListeners.addListener(l);</span>
<span class="fc" id="L5642">    }</span>

    /**
     * Adds a listener to the pointer event
     *
     * @param l callback to receive pointer events
     * @since 7.0
     */
    public void addLongPressListener(ActionListener l) {
<span class="fc bfc" id="L5651" title="All 2 branches covered.">        if (longPressListeners == null) {</span>
<span class="fc" id="L5652">            longPressListeners = new EventDispatcher();</span>
        }
<span class="fc" id="L5654">        longPressListeners.addListener(l);</span>
<span class="fc" id="L5655">    }</span>

    /**
     * Invoked to draw the ripple effect overlay in Android where the finger of the user causes a growing
     * circular overlay over time. This method is invoked after paintBackground and is invoked repeatedly until
     * the users finger is removed, it will only be invoked if isRippleEffect returns true
     *
     * @param g        the graphics object for the component clipped to the background
     * @param x        the x position of the touch
     * @param y        the y position of the touch
     * @param position a value between 0 and 1000 with 0 indicating the beginning of the ripple effect and 1000
     *                 indicating the completion of it
     */
    public void paintRippleOverlay(Graphics g, int x, int y, int position) {
<span class="fc" id="L5669">        int a = g.getAlpha();</span>
<span class="fc" id="L5670">        int c = g.getColor();</span>
<span class="fc" id="L5671">        g.concatenateAlpha(20);</span>
<span class="fc" id="L5672">        g.setColor(0);</span>
<span class="fc bfc" id="L5673" title="All 2 branches covered.">        if (position == 1000) {</span>
<span class="fc" id="L5674">            g.fillRect(getX(), getY(), getWidth(), getHeight());</span>
        } else {
<span class="fc" id="L5676">            float ratio = ((float) position) / 1000.0f;</span>
<span class="fc" id="L5677">            int w = (int) (((float) getWidth()) * ratio);</span>
<span class="fc" id="L5678">            w = Math.max(w, Display.INSTANCE.convertToPixels(4));</span>
<span class="fc" id="L5679">            g.fillArc(x - getParent().getAbsoluteX() - w / 2, y - getParent().getAbsoluteY() - w / 2, w, w, 0, 360);</span>
        }
<span class="fc" id="L5681">        g.setAlpha(a);</span>
<span class="fc" id="L5682">        g.setColor(c);</span>
<span class="fc" id="L5683">    }</span>

    /**
     * Removes the listener from the pointer event
     *
     * @param l callback to remove
     */
    public void removePointerPressedListener(ActionListener l) {
<span class="pc bpc" id="L5691" title="1 of 2 branches missed.">        if (pointerPressedListeners != null) {</span>
<span class="fc" id="L5692">            pointerPressedListeners.removeListener(l);</span>
        }
<span class="fc" id="L5694">    }</span>

    /**
     * Removes the listener from the pointer event
     *
     * @param l callback to remove
     * @since 7.0
     */
    public void removeLongPressListener(ActionListener l) {
<span class="pc bpc" id="L5703" title="1 of 2 branches missed.">        if (longPressListeners != null) {</span>
<span class="fc" id="L5704">            longPressListeners.removeListener(l);</span>
        }
<span class="fc" id="L5706">    }</span>

    /**
     * Removes the listener from the drag finished event
     *
     * @param l callback to remove
     */
    public void removeDragFinishedListener(ActionListener l) {
<span class="pc bpc" id="L5714" title="1 of 2 branches missed.">        if (dragFinishedListeners != null) {</span>
<span class="fc" id="L5715">            dragFinishedListeners.removeListener(l);</span>
        }
<span class="fc" id="L5717">    }</span>

    /**
     * Adds a listener to the pointer event
     *
     * @param l callback to receive pointer events
     */
    public void addPointerReleasedListener(ActionListener l) {
<span class="fc bfc" id="L5725" title="All 2 branches covered.">        if (pointerReleasedListeners == null) {</span>
<span class="fc" id="L5726">            pointerReleasedListeners = new EventDispatcher();</span>
        }
<span class="fc" id="L5728">        pointerReleasedListeners.addListener(l);</span>
<span class="fc" id="L5729">    }</span>

    /**
     * Removes the listener from the pointer event
     *
     * @param l callback to remove
     */
    public void removePointerReleasedListener(ActionListener l) {
<span class="pc bpc" id="L5737" title="1 of 2 branches missed.">        if (pointerReleasedListeners != null) {</span>
<span class="fc" id="L5738">            pointerReleasedListeners.removeListener(l);</span>
        }
<span class="fc" id="L5740">    }</span>

    /**
     * Adds a listener to the pointer event
     *
     * @param l callback to receive pointer events
     */
    public void addPointerDraggedListener(ActionListener l) {
<span class="fc bfc" id="L5748" title="All 2 branches covered.">        if (pointerDraggedListeners == null) {</span>
<span class="fc" id="L5749">            pointerDraggedListeners = new EventDispatcher();</span>
        }
<span class="fc" id="L5751">        pointerDraggedListeners.addListener(l);</span>
<span class="fc" id="L5752">    }</span>

    /**
     * Removes the listener from the pointer event
     *
     * @param l callback to remove
     */
    public void removePointerDraggedListener(ActionListener l) {
<span class="pc bpc" id="L5760" title="1 of 2 branches missed.">        if (pointerDraggedListeners != null) {</span>
<span class="fc" id="L5761">            pointerDraggedListeners.removeListener(l);</span>
        }
<span class="fc" id="L5763">    }</span>

    private void pointerReleaseImpl(int x, int y) {
<span class="fc" id="L5766">        LeadUtil.leadParentImpl(this).pointerReleaseImpl(this, x, y);</span>
<span class="fc" id="L5767">    }</span>

    private void pointerReleaseImpl(Component lead, int x, int y) {
<span class="fc bfc" id="L5770" title="All 2 branches covered.">        if (restoreDragPercentage &gt; -1) {</span>
<span class="fc" id="L5771">            Display.getInstance().setDragStartPercentage(restoreDragPercentage);</span>
        }
<span class="fc" id="L5773">        pinchDistance = -1;</span>
<span class="fc bfc" id="L5774" title="All 2 branches covered.">        if (dragActivated) {</span>
<span class="fc" id="L5775">            dragActivated = false;</span>
<span class="fc" id="L5776">            boolean startedTensileX = false;</span>
<span class="fc" id="L5777">            boolean startedTensileY = false;</span>
<span class="pc bpc" id="L5778" title="1 of 2 branches missed.">            if (isScrollableX()) {</span>
<span class="nc bnc" id="L5779" title="All 2 branches missed.">                if (scrollX &lt; 0) {</span>
<span class="nc" id="L5780">                    startTensile(scrollX, 0, false);</span>
<span class="nc" id="L5781">                    startedTensileX = true;</span>
                } else {
<span class="nc bnc" id="L5783" title="All 2 branches missed.">                    if (scrollX &gt; getScrollDimension().getWidth() - getWidth()) {</span>
<span class="nc" id="L5784">                        startTensile(scrollX, Math.max(getScrollDimension().getWidth() - getWidth(), 0), false);</span>
<span class="nc" id="L5785">                        startedTensileX = true;</span>
                    }
                }
            }
<span class="pc bpc" id="L5789" title="1 of 2 branches missed.">            if (isScrollableY()) {</span>
<span class="pc bpc" id="L5790" title="1 of 2 branches missed.">                if (scrollY &lt; 0) {</span>
<span class="nc bnc" id="L5791" title="All 4 branches missed.">                    if (refreshTask != null &amp;&amp; !InfiniteProgress.isDefaultMaterialDesignMode()) {</span>
<span class="nc" id="L5792">                        putClientProperty(&quot;$pullToRelease&quot;, &quot;normal&quot;);</span>
<span class="nc bnc" id="L5793" title="All 2 branches missed.">                        if (scrollY &lt; -getUIManager().getLookAndFeel().getPullToRefreshHeight()) {</span>
<span class="nc" id="L5794">                            putClientProperty(&quot;$pullToRelease&quot;, &quot;update&quot;);</span>
<span class="nc" id="L5795">                            startTensile(scrollY, -getUIManager().getLookAndFeel().getPullToRefreshHeight(), true);</span>
<span class="nc" id="L5796">                            startedTensileY = true;</span>
                        }
                    } else {
<span class="nc" id="L5799">                        startTensile(scrollY, 0, true);</span>
<span class="nc" id="L5800">                        startedTensileY = true;</span>
                    }
                } else {
<span class="fc" id="L5803">                    int scrh = getScrollDimension().getHeight() - getHeight() + getInvisibleAreaUnderVKB();</span>
<span class="pc bpc" id="L5804" title="1 of 2 branches missed.">                    if (scrollY &gt; scrh) {</span>
<span class="nc" id="L5805">                        startTensile(scrollY, Math.max(scrh, 0), true);</span>
<span class="nc" id="L5806">                        startedTensileY = true;</span>
                    }
                }
            }
<span class="fc" id="L5810">            boolean shouldScrollX = chooseScrollXOrY(x, y);</span>
<span class="pc bpc" id="L5811" title="5 of 8 branches missed.">            if (shouldScrollX &amp;&amp; startedTensileX || !shouldScrollX &amp;&amp; startedTensileY) {</span>
<span class="nc" id="L5812">                return;</span>
            }

<span class="fc" id="L5815">            int scroll = scrollY;</span>
<span class="pc bpc" id="L5816" title="1 of 2 branches missed.">            if (shouldScrollX) {</span>
<span class="nc" id="L5817">                scroll = scrollX;</span>
            }
<span class="pc bpc" id="L5819" title="1 of 2 branches missed.">            float speed = getDragSpeed(!shouldScrollX);</span>
            int tl;
<span class="pc bpc" id="L5821" title="1 of 2 branches missed.">            if (getTensileLength() &gt; -1) {</span>
<span class="nc" id="L5822">                tl = getTensileLength();</span>
            } else {
<span class="fc" id="L5824">                tl = getWidth() / 2;</span>
            }
<span class="pc bpc" id="L5826" title="1 of 2 branches missed.">            if (!isTensileDragEnabled()) {</span>
<span class="nc" id="L5827">                tl = 0;</span>
            }
<span class="pc bpc" id="L5829" title="1 of 2 branches missed.">            if (!shouldScrollX) {</span>
<span class="pc bpc" id="L5830" title="1 of 2 branches missed.">                if (speed &lt; 0) {</span>
<span class="nc bnc" id="L5831" title="All 2 branches missed.">                    if (UIManager.getInstance().getThemeConstant(&quot;ScrollMotion&quot;, &quot;DECAY&quot;).equals(&quot;DECAY&quot;)) {</span>
<span class="nc" id="L5832">                        int timeConstant = UIManager.getInstance().getThemeConstant(&quot;ScrollMotionTimeConstantInt&quot;, 500);</span>

<span class="nc" id="L5834">                        draggedMotionY = Motion.createExponentialDecayMotion(scroll, -tl / 2, speed, timeConstant);</span>
<span class="nc" id="L5835">                    } else {</span>
<span class="nc" id="L5836">                        draggedMotionY = Motion.createFrictionMotion(scroll, -tl / 2, speed, 0.0007f);</span>
                    }
                } else {
<span class="pc bpc" id="L5839" title="1 of 2 branches missed.">                    if (UIManager.getInstance().getThemeConstant(&quot;ScrollMotion&quot;, &quot;DECAY&quot;).equals(&quot;DECAY&quot;)) {</span>
<span class="fc" id="L5840">                        int timeConstant = UIManager.getInstance().getThemeConstant(&quot;ScrollMotionTimeConstantInt&quot;, 500);</span>
<span class="fc" id="L5841">                        draggedMotionY = Motion.createExponentialDecayMotion(scroll, getScrollDimension().getHeight() -</span>
<span class="fc" id="L5842">                                getHeight() + getInvisibleAreaUnderVKB() + tl / 2, speed, timeConstant);</span>
<span class="fc" id="L5843">                    } else {</span>
<span class="nc" id="L5844">                        draggedMotionY = Motion.createFrictionMotion(scroll, getScrollDimension().getHeight() -</span>
<span class="nc" id="L5845">                                getHeight() + getInvisibleAreaUnderVKB() + tl / 2, speed, 0.0007f);</span>
                    }
                }
            } else {
<span class="nc bnc" id="L5849" title="All 2 branches missed.">                if (speed &lt; 0) {</span>
<span class="nc" id="L5850">                    draggedMotionX = Motion.createFrictionMotion(scroll, -tl / 2, speed, 0.0007f);</span>
                } else {
<span class="nc" id="L5852">                    draggedMotionX = Motion.createFrictionMotion(scroll, getScrollDimension().getWidth() -</span>
<span class="nc" id="L5853">                            getWidth() + tl / 2, speed, 0.0007f);</span>
                }
            }
<span class="pc bpc" id="L5856" title="1 of 2 branches missed.">            if (draggedMotionX != null) {</span>
<span class="nc" id="L5857">                draggedMotionX.start();</span>
            }
<span class="pc bpc" id="L5859" title="1 of 2 branches missed.">            if (draggedMotionY != null) {</span>
<span class="fc" id="L5860">                draggedMotionY.start();</span>
            }
        }
<span class="fc" id="L5863">    }</span>

    /**
     * This method returns the dragging speed based on the latest dragged
     * events
     *
     * @param vertical indicates what axis speed is required
     * @return the dragging speed
     */
    protected float getDragSpeed(boolean vertical) {
<span class="fc" id="L5873">        return Display.getInstance().getDragSpeed(vertical);</span>
    }

    /**
     * Returns the current Component Style allowing code to draw the current component, you
     * should normally use getUnselected/Pressed/DisabledStyle() and not this method since
     * it will return different values based on component state.
     *
     * @return the component Style object
     */
    public Style getStyle() {
<span class="fc bfc" id="L5884" title="All 2 branches covered.">        if (unSelectedStyle == null) {</span>
<span class="fc" id="L5885">            initStyle();</span>
        }
<span class="fc" id="L5887">        isUnselectedStyle = false;</span>

<span class="pc bpc" id="L5889" title="1 of 4 branches missed.">        if (hasLead &amp;&amp; !blockLead) {</span>
<span class="fc" id="L5890">            Component lead = getLeadComponent();</span>
<span class="fc bfc" id="L5891" title="All 2 branches covered.">            if (lead != null) {</span>
<span class="pc bpc" id="L5892" title="1 of 2 branches missed.">                if (!lead.isEnabled()) {</span>
<span class="nc" id="L5893">                    return getDisabledStyle();</span>
                }

<span class="fc bfc" id="L5896" title="All 2 branches covered.">                if (lead.isPressedStyle()) {</span>
<span class="fc" id="L5897">                    return getPressedStyle();</span>
                }

<span class="pc bpc" id="L5900" title="1 of 4 branches missed.">                if (lead.hasFocus() &amp;&amp; Display.getInstance().shouldRenderSelection(this)) {</span>
<span class="fc" id="L5901">                    return getSelectedStyle();</span>
                }
            }
<span class="fc" id="L5904">            isUnselectedStyle = true;</span>
<span class="fc" id="L5905">            return unSelectedStyle;</span>
        }

<span class="fc bfc" id="L5908" title="All 2 branches covered.">        if (!isEnabled()) {</span>
<span class="fc" id="L5909">            return getDisabledStyle();</span>
        }

<span class="fc bfc" id="L5912" title="All 2 branches covered.">        if (isPressedStyle()) {</span>
<span class="fc" id="L5913">            return getPressedStyle();</span>
        }

<span class="pc bpc" id="L5916" title="1 of 4 branches missed.">        if (hasFocus() &amp;&amp; Display.getInstance().shouldRenderSelection(this)) {</span>
<span class="fc" id="L5917">            return getSelectedStyle();</span>
        }
<span class="fc" id="L5919">        isUnselectedStyle = true;</span>
<span class="fc" id="L5920">        return unSelectedStyle;</span>
    }

    boolean isPressedStyle() {
<span class="fc" id="L5924">        return false;</span>
    }

    /**
     * Returns the Component Style for the pressed state allowing us to manipulate
     * the look of the component when it is pressed
     *
     * @return the component Style object
     */
    public Style getPressedStyle() {
<span class="fc bfc" id="L5934" title="All 2 branches covered.">        if (pressedStyle == null) {</span>
<span class="pc bpc" id="L5935" title="1 of 2 branches missed.">            if (hasInlinePressedStyle()) {</span>
<span class="nc" id="L5936">                pressedStyle = getUIManager().parseComponentCustomStyle(getInlineStylesTheme(), getUIID(), getInlineStylesUIID(), &quot;press&quot;, getInlinePressedStyleStrings());</span>
            } else {
<span class="fc" id="L5938">                pressedStyle = getUIManager().getComponentCustomStyle(getUIID(), &quot;press&quot;);</span>
            }
<span class="fc" id="L5940">            initPressedStyle(pressedStyle);</span>
<span class="pc bpc" id="L5941" title="1 of 4 branches missed.">            if (initialized &amp;&amp; pressedStyle.getElevation() &gt; 0) {</span>
<span class="nc" id="L5942">                registerElevatedInternal(this);</span>
            }
<span class="fc bfc" id="L5944" title="All 2 branches covered.">            if (initialized) {</span>
<span class="fc" id="L5945">                setSurface(pressedStyle.isSurface());</span>
            }
<span class="fc" id="L5947">            pressedStyle.addStyleListener(this);</span>
<span class="pc bpc" id="L5948" title="1 of 2 branches missed.">            if (pressedStyle.getBgPainter() == null) {</span>
<span class="fc" id="L5949">                pressedStyle.setBgPainter(new BGPainter());</span>
            }
        }
<span class="fc" id="L5952">        return pressedStyle;</span>
    }

    /**
     * Sets the Component Style for the pressed state allowing us to manipulate
     * the look of the component when it is pressed
     *
     * @param style the component Style object
     */
    public void setPressedStyle(Style style) {
<span class="pc bpc" id="L5962" title="1 of 2 branches missed.">        if (pressedStyle != null) {</span>
<span class="nc" id="L5963">            pressedStyle.removeStyleListener(this);</span>
        }
<span class="fc" id="L5965">        pressedStyle = style;</span>
<span class="fc" id="L5966">        initPressedStyle(style);</span>
<span class="pc bpc" id="L5967" title="1 of 4 branches missed.">        if (initialized &amp;&amp; pressedStyle.getElevation() &gt; 0) {</span>
<span class="nc" id="L5968">            registerElevatedInternal(this);</span>
        }
<span class="fc bfc" id="L5970" title="All 2 branches covered.">        if (initialized) {</span>
<span class="fc" id="L5971">            setSurface(pressedStyle.isSurface());</span>
        }
<span class="fc" id="L5973">        pressedStyle.addStyleListener(this);</span>
<span class="fc bfc" id="L5974" title="All 2 branches covered.">        if (pressedStyle.getBgPainter() == null) {</span>
<span class="fc" id="L5975">            pressedStyle.setBgPainter(new BGPainter());</span>
        }
<span class="fc" id="L5977">        setShouldCalcPreferredSize(true);</span>
<span class="fc" id="L5978">        checkAnimation();</span>
<span class="fc" id="L5979">    }</span>

    /**
     * Can be overridden by subclasses to perform initialization when the unselected style is set to a new value.
     *
     * @param unselectedStyle The unselected style.
     * @since 8.0
     */
    protected void initUnselectedStyle(Style unselectedStyle) {

<span class="fc" id="L5989">    }</span>

    /**
     * Can be overridden by subclasses to perform initialization when the pressed style is set to a new value.
     *
     * @param unselectedStyle The pressed style.
     * @since 8.0
     */
    protected void initPressedStyle(Style pressedStyle) {

<span class="fc" id="L5999">    }</span>

    /**
     * Can be overridden by subclasses to perform initialization when the disabled style is set to a new value.
     *
     * @param unselectedStyle The disabled style.
     * @since 8.0
     */
    protected void initDisabledStyle(Style disabledStyle) {

<span class="fc" id="L6009">    }</span>

    /**
     * Can be overridden by subclasses to perform initialization when the selected style is set to a new value.
     *
     * @param unselectedStyle The selected style.
     * @since 8.0
     */
    protected void initSelectedStyle(Style selectedStyle) {

<span class="fc" id="L6019">    }</span>

    /**
     * Returns the Component Style for the unselected mode allowing us to manipulate
     * the look of the component
     *
     * @return the component Style object
     */
    public Style getUnselectedStyle() {
<span class="fc bfc" id="L6028" title="All 2 branches covered.">        if (unSelectedStyle == null) {</span>
<span class="fc" id="L6029">            initStyle();</span>
        }
<span class="fc" id="L6031">        return unSelectedStyle;</span>
    }

    /**
     * Changes the Component Style by replacing the Component Style with the given Style
     *
     * @param style the component Style object
     */
    public void setUnselectedStyle(Style style) {
<span class="pc bpc" id="L6040" title="1 of 2 branches missed.">        if (this.unSelectedStyle != null) {</span>
<span class="fc" id="L6041">            this.unSelectedStyle.removeStyleListener(this);</span>
        }
<span class="fc" id="L6043">        this.unSelectedStyle = style;</span>
<span class="fc" id="L6044">        initUnselectedStyle(style);</span>
<span class="pc bpc" id="L6045" title="3 of 4 branches missed.">        if (initialized &amp;&amp; unSelectedStyle.getElevation() &gt; 0) {</span>
<span class="nc" id="L6046">            registerElevatedInternal(this);</span>
        }
<span class="pc bpc" id="L6048" title="1 of 2 branches missed.">        if (initialized) {</span>
<span class="nc" id="L6049">            setSurface(unSelectedStyle.isSurface());</span>
        }
<span class="fc" id="L6051">        this.unSelectedStyle.addStyleListener(this);</span>
<span class="pc bpc" id="L6052" title="1 of 2 branches missed.">        if (this.unSelectedStyle.getBgPainter() == null) {</span>
<span class="fc" id="L6053">            this.unSelectedStyle.setBgPainter(new BGPainter());</span>
        }
<span class="fc" id="L6055">        setShouldCalcPreferredSize(true);</span>
<span class="fc" id="L6056">        checkAnimation();</span>
<span class="fc" id="L6057">    }</span>

    /**
     * Returns the Component Style for the selected state allowing us to manipulate
     * the look of the component when it owns focus
     *
     * @return the component Style object
     */
    public Style getSelectedStyle() {
<span class="fc bfc" id="L6066" title="All 2 branches covered.">        if (selectedStyle == null) {</span>
<span class="pc bpc" id="L6067" title="1 of 2 branches missed.">            if (hasInlineSelectedStyle()) {</span>
<span class="nc" id="L6068">                selectedStyle = getUIManager().parseComponentSelectedStyle(getInlineStylesTheme(), getUIID(), getInlineStylesUIID(), getInlineSelectedStyleStrings());</span>
            } else {
<span class="fc" id="L6070">                selectedStyle = getUIManager().getComponentSelectedStyle(getUIID());</span>
            }
<span class="fc" id="L6072">            initSelectedStyle(selectedStyle);</span>
<span class="pc bpc" id="L6073" title="1 of 4 branches missed.">            if (initialized &amp;&amp; selectedStyle.getElevation() &gt; 0) {</span>
<span class="nc" id="L6074">                registerElevatedInternal(this);</span>
            }
<span class="fc bfc" id="L6076" title="All 2 branches covered.">            if (initialized) {</span>
<span class="fc" id="L6077">                setSurface(selectedStyle.isSurface());</span>
            }
<span class="fc" id="L6079">            selectedStyle.addStyleListener(this);</span>
<span class="pc bpc" id="L6080" title="1 of 2 branches missed.">            if (selectedStyle.getBgPainter() == null) {</span>
<span class="fc" id="L6081">                selectedStyle.setBgPainter(new BGPainter());</span>
            }
<span class="fc bfc" id="L6083" title="All 2 branches covered.">            if (cellRenderer) {</span>
<span class="fc" id="L6084">                selectedStyle.markAsRendererStyle();</span>
            }
        }
<span class="fc" id="L6087">        return selectedStyle;</span>
    }

    /**
     * Changes the Component selected Style by replacing the Component Style with the given Style
     *
     * @param style the component Style object
     */
    public void setSelectedStyle(Style style) {
<span class="fc bfc" id="L6096" title="All 2 branches covered.">        if (this.selectedStyle != null) {</span>
<span class="fc" id="L6097">            this.selectedStyle.removeStyleListener(this);</span>
        }
<span class="fc" id="L6099">        this.selectedStyle = style;</span>
<span class="fc" id="L6100">        initSelectedStyle(style);</span>
<span class="pc bpc" id="L6101" title="1 of 4 branches missed.">        if (initialized &amp;&amp; selectedStyle.getElevation() &gt; 0) {</span>
<span class="nc" id="L6102">            registerElevatedInternal(this);</span>
        }
<span class="fc bfc" id="L6104" title="All 2 branches covered.">        if (initialized) {</span>
<span class="fc" id="L6105">            setSurface(selectedStyle.isSurface());</span>
        }
<span class="fc" id="L6107">        this.selectedStyle.addStyleListener(this);</span>
<span class="fc bfc" id="L6108" title="All 2 branches covered.">        if (this.selectedStyle.getBgPainter() == null) {</span>
<span class="fc" id="L6109">            this.selectedStyle.setBgPainter(new BGPainter());</span>
        }
<span class="fc" id="L6111">        setShouldCalcPreferredSize(true);</span>
<span class="fc" id="L6112">        checkAnimation();</span>
<span class="fc" id="L6113">    }</span>

    /**
     * Returns the Component Style for the disabled state allowing us to manipulate
     * the look of the component when its disabled
     *
     * @return the component Style object
     */
    public Style getDisabledStyle() {
<span class="fc bfc" id="L6122" title="All 2 branches covered.">        if (disabledStyle == null) {</span>
<span class="pc bpc" id="L6123" title="1 of 2 branches missed.">            if (hasInlineDisabledStyle()) {</span>
<span class="nc" id="L6124">                disabledStyle = getUIManager().parseComponentCustomStyle(getInlineStylesTheme(), getUIID(), getInlineStylesUIID(), &quot;dis&quot;, getInlineDisabledStyleStrings());</span>
            } else {
<span class="fc" id="L6126">                disabledStyle = getUIManager().getComponentCustomStyle(getUIID(), &quot;dis&quot;);</span>
            }
<span class="fc" id="L6128">            initDisabledStyle(disabledStyle);</span>
<span class="pc bpc" id="L6129" title="1 of 4 branches missed.">            if (initialized &amp;&amp; disabledStyle.getElevation() &gt; 0) {</span>
<span class="nc" id="L6130">                registerElevatedInternal(this);</span>
            }
<span class="fc bfc" id="L6132" title="All 2 branches covered.">            if (initialized) {</span>
<span class="fc" id="L6133">                setSurface(disabledStyle.isSurface());</span>
            }
<span class="fc" id="L6135">            disabledStyle.addStyleListener(this);</span>
<span class="pc bpc" id="L6136" title="1 of 2 branches missed.">            if (disabledStyle.getBgPainter() == null) {</span>
<span class="fc" id="L6137">                disabledStyle.setBgPainter(new BGPainter());</span>
            }
        }
<span class="fc" id="L6140">        return disabledStyle;</span>
    }

    /**
     * Changes the Component disalbed Style by replacing the Component Style with the given Style
     *
     * @param style the component Style object
     */
    public void setDisabledStyle(Style style) {
<span class="pc bpc" id="L6149" title="1 of 2 branches missed.">        if (this.disabledStyle != null) {</span>
<span class="nc" id="L6150">            this.disabledStyle.removeStyleListener(this);</span>
        }
<span class="fc" id="L6152">        this.disabledStyle = style;</span>
<span class="fc" id="L6153">        initDisabledStyle(style);</span>
<span class="pc bpc" id="L6154" title="2 of 4 branches missed.">        if (initialized &amp;&amp; disabledStyle.getElevation() &gt; 0) {</span>
<span class="nc" id="L6155">            registerElevatedInternal(this);</span>
        }
<span class="pc bpc" id="L6157" title="1 of 2 branches missed.">        if (initialized) {</span>
<span class="fc" id="L6158">            setSurface(disabledStyle.isSurface());</span>
        }
<span class="fc" id="L6160">        this.disabledStyle.addStyleListener(this);</span>
<span class="pc bpc" id="L6161" title="1 of 2 branches missed.">        if (this.disabledStyle.getBgPainter() == null) {</span>
<span class="fc" id="L6162">            this.disabledStyle.setBgPainter(new BGPainter());</span>
        }
<span class="fc" id="L6164">        setShouldCalcPreferredSize(true);</span>
<span class="fc" id="L6165">        checkAnimation();</span>
<span class="fc" id="L6166">    }</span>

    /**
     * Allows subclasses to create their own custom style types and install the background painter into them
     *
     * @param s the custom style
     */
    protected void installDefaultPainter(Style s) {
<span class="pc bpc" id="L6174" title="1 of 2 branches missed.">        if (s.getBgPainter() == null) {</span>
<span class="fc" id="L6175">            s.setBgPainter(new BGPainter(s));</span>
        }
<span class="fc" id="L6177">    }</span>

    /**
     * Changes the current component to the focused component, will work only
     * for a component that belongs to a parent form.
     */
    public void requestFocus() {
<span class="fc" id="L6184">        Form rootForm = getComponentForm();</span>
<span class="fc bfc" id="L6185" title="All 2 branches covered.">        if (rootForm != null) {</span>
<span class="fc" id="L6186">            Component.setDisableSmoothScrolling(true);</span>
<span class="fc" id="L6187">            rootForm.requestFocus(this);</span>
<span class="fc" id="L6188">            Component.setDisableSmoothScrolling(false);</span>
        }
<span class="fc" id="L6190">    }</span>

    /**
     * Finds all children (and self) that have negative scroll positions.
     *
     * &lt;p&gt;This is primarily to solve https://github.com/codenameone/CodenameOne/issues/2476&lt;/p&gt;
     *
     * @param out A set to add found components to.
     * @return The set of found components (reference to the same set that is passed as an arg).
     */
    java.util.Set&lt;Component&gt; findNegativeScrolls(java.util.Set&lt;Component&gt; out) {
<span class="nc bnc" id="L6201" title="All 4 branches missed.">        if (scrollableYFlag() &amp;&amp; getScrollY() &lt; 0) {</span>
<span class="nc" id="L6202">            out.add(this);</span>
        }
<span class="nc bnc" id="L6204" title="All 2 branches missed.">        if (this instanceof Container) {</span>
<span class="nc bnc" id="L6205" title="All 2 branches missed.">            for (Component child : (Container) this) {</span>
<span class="nc" id="L6206">                child.findNegativeScrolls(out);</span>
<span class="nc" id="L6207">            }</span>
        }
<span class="nc" id="L6209">        return out;</span>
    }

    /**
     * Overriden to return a useful value for debugging purposes
     *
     * @return a string representation of this component
     */
    public String toString() {
<span class="fc" id="L6218">        String className = getClass().getName();</span>
<span class="fc" id="L6219">        className = className.substring(className.lastIndexOf('.') + 1);</span>
<span class="fc" id="L6220">        return className + &quot;[&quot; + paramString() + &quot;]&quot;;</span>
    }

    /**
     * Returns a string representing the state of this component. This
     * method is intended to be used only for debugging purposes, and the
     * content and format of the returned string may vary between
     * implementations. The returned string may be empty but may not be
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @return a string representation of this component's state
     */
    protected String paramString() {
<span class="fc" id="L6233">        return &quot;x=&quot; + getX() + &quot; y=&quot; + getY() + &quot; width=&quot; + getWidth() + &quot; height=&quot; + getHeight() + &quot; name=&quot; + getName();</span>
    }

    /**
     * Makes sure the component is up to date with the current theme, ONLY INVOKE THIS METHOD IF YOU CHANGED THE THEME!
     */
    public void refreshTheme() {
<span class="fc" id="L6240">        refreshTheme(true);</span>
<span class="fc" id="L6241">    }</span>

    /**
     * Makes sure the component is up to date with the current theme, ONLY INVOKE THIS METHOD IF YOU CHANGED THE THEME!
     *
     * @param merge indicates if the current styles should be merged with the new styles
     */
    public void refreshTheme(boolean merge) {
<span class="fc" id="L6249">        refreshTheme(getUIID(), merge);</span>
<span class="fc" id="L6250">        initLaf(getUIManager());</span>
<span class="fc" id="L6251">    }</span>

    /**
     * Makes sure the component is up to date with the given UIID
     *
     * @param id    The Style Id to update the Component with
     * @param merge indicates if the current styles should be merged with the new styles
     */
    protected void refreshTheme(String id, boolean merge) {
<span class="fc" id="L6260">        UIManager manager = getUIManager();</span>

<span class="fc bfc" id="L6262" title="All 2 branches covered.">        if (merge) {</span>
<span class="fc" id="L6263">            Style unSelected = getUnselectedStyle();</span>
<span class="pc bpc" id="L6264" title="1 of 2 branches missed.">            if (hasInlineUnselectedStyle()) {</span>
<span class="nc" id="L6265">                setUnselectedStyle(mergeStyle(unSelected, manager.parseComponentStyle(getInlineStylesTheme(), id, getInlineStylesUIID(id), getInlineUnselectedStyleStrings())));</span>
            } else {
<span class="fc" id="L6267">                setUnselectedStyle(mergeStyle(unSelected, manager.getComponentStyle(id)));</span>
            }
<span class="fc bfc" id="L6269" title="All 2 branches covered.">            if (selectedStyle != null) {</span>
<span class="pc bpc" id="L6270" title="1 of 2 branches missed.">                if (hasInlineSelectedStyle()) {</span>
<span class="nc" id="L6271">                    setSelectedStyle(mergeStyle(selectedStyle, manager.parseComponentSelectedStyle(getInlineStylesTheme(), id, getInlineStylesUIID(id), getInlineSelectedStyleStrings())));</span>
                } else {
<span class="fc" id="L6273">                    setSelectedStyle(mergeStyle(selectedStyle, manager.getComponentSelectedStyle(id)));</span>
                }
            }
<span class="pc bpc" id="L6276" title="1 of 2 branches missed.">            if (disabledStyle != null) {</span>
<span class="nc bnc" id="L6277" title="All 2 branches missed.">                if (hasInlineDisabledStyle()) {</span>
<span class="nc" id="L6278">                    setDisabledStyle(mergeStyle(disabledStyle, manager.parseComponentCustomStyle(getInlineStylesTheme(), id, getInlineStylesUIID(id), &quot;dis&quot;, getInlineDisabledStyleStrings())));</span>
                } else {
<span class="nc" id="L6280">                    setDisabledStyle(mergeStyle(disabledStyle, manager.getComponentCustomStyle(id, &quot;dis&quot;)));</span>
                }
            }
<span class="pc bpc" id="L6283" title="1 of 2 branches missed.">            if (pressedStyle != null) {</span>
<span class="nc bnc" id="L6284" title="All 2 branches missed.">                if (hasInlinePressedStyle()) {</span>
<span class="nc" id="L6285">                    setPressedStyle(mergeStyle(pressedStyle, manager.parseComponentCustomStyle(getInlineStylesTheme(), id, getInlineStylesUIID(id), &quot;press&quot;, getInlinePressedStyleStrings())));</span>
                } else {
<span class="nc" id="L6287">                    setPressedStyle(mergeStyle(pressedStyle, manager.getComponentCustomStyle(id, &quot;press&quot;)));</span>
                }
            }
<span class="fc" id="L6290">        } else {</span>
<span class="fc" id="L6291">            unSelectedStyle = null;</span>
<span class="fc" id="L6292">            unSelectedStyle = getUnselectedStyle();</span>
<span class="fc" id="L6293">            selectedStyle = null;</span>
<span class="fc" id="L6294">            disabledStyle = null;</span>
<span class="fc" id="L6295">            pressedStyle = null;</span>
<span class="fc" id="L6296">            allStyles = null;</span>

        }
<span class="fc" id="L6299">        checkAnimation();</span>
<span class="fc" id="L6300">        manager.getLookAndFeel().bind(this);</span>
<span class="fc" id="L6301">    }</span>

    Style mergeStyle(Style toMerge, Style newStyle) {
<span class="fc bfc" id="L6304" title="All 2 branches covered.">        if (toMerge.isModified()) {</span>
<span class="fc" id="L6305">            toMerge.merge(newStyle);</span>
<span class="fc" id="L6306">            return toMerge;</span>
        } else {
<span class="fc" id="L6308">            return newStyle;</span>
        }

    }

    /**
     * Indicates whether we are in the middle of a drag operation, this method allows
     * developers overriding the pointer released events to know when this is a drag
     * operation.
     *
     * @return true if we are in the middle of a drag; otherwise false
     */
    protected boolean isDragActivated() {
<span class="fc" id="L6321">        return dragActivated;</span>
    }

    void setDragActivated(boolean dragActivated) {
<span class="fc" id="L6325">        this.dragActivated = dragActivated;</span>
<span class="fc" id="L6326">    }</span>

    void checkAnimation() {
<span class="fc" id="L6329">        Image bgImage = getStyle().getBgImage();</span>
<span class="pc bpc" id="L6330" title="1 of 4 branches missed.">        if (bgImage != null &amp;&amp; bgImage.isAnimation()) {</span>
<span class="nc" id="L6331">            Form pf = getComponentForm();</span>
<span class="nc bnc" id="L6332" title="All 2 branches missed.">            if (pf != null) {</span>
                // animations are always running so the internal animation isn't
                // good enough. We never want to stop this sort of animation
<span class="nc" id="L6335">                pf.registerAnimated(this);</span>
            }
<span class="nc" id="L6337">        } else {</span>
<span class="fc" id="L6338">            Painter p = getStyle().getBgPainter();</span>
<span class="pc bpc" id="L6339" title="2 of 6 branches missed.">            if (p != null &amp;&amp; p.getClass() != BGPainter.class &amp;&amp; p instanceof Animation) {</span>
<span class="nc" id="L6340">                Form pf = getComponentForm();</span>
<span class="nc bnc" id="L6341" title="All 2 branches missed.">                if (pf != null) {</span>
<span class="nc" id="L6342">                    pf.registerAnimated(this);</span>
                }
<span class="nc" id="L6344">            } else {</span>
<span class="pc bpc" id="L6345" title="2 of 6 branches missed.">                if (scrollOpacity == 0xff &amp;&amp; isScrollable() &amp;&amp; getUIManager().getLookAndFeel().isFadeScrollBar()) {</span>
                    // trigger initial fade process on a fresh view.
<span class="nc" id="L6347">                    Form pf = getComponentForm();</span>
<span class="nc bnc" id="L6348" title="All 2 branches missed.">                    if (pf != null) {</span>
<span class="nc" id="L6349">                        pf.registerAnimatedInternal(this);</span>
                    }
                }
            }
        }
<span class="fc" id="L6354">    }</span>

    void deregisterAnimatedInternal() {
<span class="fc bfc" id="L6357" title="All 2 branches covered.">        if (!internalRegisteredAnimated) return;</span>
<span class="fc" id="L6358">        Form f = getComponentForm();</span>
<span class="pc bpc" id="L6359" title="1 of 2 branches missed.">        if (f != null) {</span>
<span class="fc" id="L6360">            f.deregisterAnimatedInternal(this);</span>
        }
<span class="fc" id="L6362">    }</span>

    /**
     * This method should be implemented correctly by subclasses to make snap to grid functionality work
     * as expected. Returns the ideal grid Y position closest to the current Y position.
     *
     * @return a valid Y position in the grid
     */
    protected int getGridPosY() {
<span class="fc" id="L6371">        return getScrollY();</span>
    }

    /**
     * This method should be implemented correctly by subclasses to make snap to grid functionality work
     * as expected. Returns the ideal grid X position closest to the current X position.
     *
     * @return a valid Y position in the grid
     */
    protected int getGridPosX() {
<span class="fc" id="L6381">        return getScrollX();</span>
    }

    boolean isTensileMotionInProgress() {
<span class="pc bpc" id="L6385" title="3 of 4 branches missed.">        return draggedMotionY != null &amp;&amp; !draggedMotionY.isFinished();</span>
    }

    /**
     * {@inheritDoc}
     */
    public boolean animate() {
<span class="pc bpc" id="L6392" title="1 of 2 branches missed.">        if (!visible) {</span>
<span class="nc" id="L6393">            return false;</span>
        }
<span class="fc" id="L6395">        Image bgImage = getStyle().getBgImage();</span>
<span class="pc bpc" id="L6396" title="5 of 6 branches missed.">        boolean animateBackground = bgImage != null &amp;&amp; bgImage.isAnimation() &amp;&amp; bgImage.animate();</span>
<span class="fc" id="L6397">        Motion m = getAnimationMotion();</span>

        // perform regular scrolling
<span class="pc bpc" id="L6400" title="2 of 6 branches missed.">        if (m != null &amp;&amp; destScrollY != -1 &amp;&amp; destScrollY != getScrollY()) {</span>
            // change the variable directly for efficiency both in removing redundant
            // repaints and scroll checks
<span class="fc" id="L6403">            setScrollY(m.getValue());</span>
<span class="pc bpc" id="L6404" title="1 of 2 branches missed.">            if (destScrollY == scrollY) {</span>
<span class="nc" id="L6405">                destScrollY = -1;</span>
<span class="nc" id="L6406">                deregisterAnimatedInternal();</span>
<span class="nc bnc" id="L6407" title="All 2 branches missed.">                updateTensileHighlightIntensity(0, 0, m != null);</span>
            }
<span class="fc" id="L6409">            return true;</span>
        }
<span class="fc" id="L6411">        boolean animateY = false;</span>
<span class="fc" id="L6412">        boolean animateX = false;</span>
        // perform the dragging motion if exists
<span class="fc bfc" id="L6414" title="All 2 branches covered.">        if (draggedMotionY != null) {</span>
            // change the variable directly for efficiency both in removing redundant
            // repaints and scroll checks
<span class="fc" id="L6417">            int dragVal = draggedMotionY.getValue();</span>
<span class="fc" id="L6418">            int iv = getInvisibleAreaUnderVKB();</span>
<span class="fc" id="L6419">            int edge = (getScrollDimension().getHeight() - getHeight() + iv);</span>
<span class="pc bpc" id="L6420" title="1 of 2 branches missed.">            if (!draggedMotionY.isFinished()</span>
<span class="nc bnc" id="L6421" title="All 2 branches missed.">                    &amp;&amp; draggedMotionY.isDecayMotion()</span>
<span class="nc bnc" id="L6422" title="All 2 branches missed.">                    &amp;&amp; draggedMotionY.countAvailableVelocitySamplingPoints() &gt; 1) {</span>
<span class="nc" id="L6423">                final Motion origDraggedMotionY = draggedMotionY;</span>
<span class="nc bnc" id="L6424" title="All 2 branches missed.">                if (dragVal &lt; 0) {</span>
                    // Once past 0, decay motion is too slow.  We need to hit it with heavy friction.
<span class="nc" id="L6426">                    draggedMotionY = Motion.createFrictionMotion(</span>
                            dragVal,
<span class="nc" id="L6428">                            -getTensileLength(),</span>
<span class="nc" id="L6429">                            (int) origDraggedMotionY.getVelocity(),</span>
                            0.01f
                    );
<span class="nc" id="L6432">                    draggedMotionY.start();</span>
<span class="nc" id="L6433">                    origDraggedMotionY.finish();</span>
<span class="nc bnc" id="L6434" title="All 2 branches missed.">                } else if (snapToGrid</span>
<span class="nc bnc" id="L6435" title="All 2 branches missed.">                        &amp;&amp; Math.abs(origDraggedMotionY.getVelocity()) * 1000 &lt; CN.convertToPixels(5)) {</span>
                    // If snapToGrid is enabled, the grid snap should take precendent if the drag is slower
                    // than some threshold.
<span class="nc" id="L6438">                    draggedMotionY = Motion.createFrictionMotion(</span>
                            dragVal,
<span class="nc" id="L6440">                            origDraggedMotionY.getDestinationValue(),</span>
<span class="nc" id="L6441">                            (int) origDraggedMotionY.getVelocity(),</span>
                            0.1f
                    );
<span class="nc" id="L6444">                    draggedMotionY.start();</span>
<span class="nc" id="L6445">                    origDraggedMotionY.finish();</span>
                }
            }
            // this can't be a part of the parent if since we need the last value to arrive
<span class="pc bpc" id="L6449" title="1 of 2 branches missed.">            if (draggedMotionY.isFinished()) {</span>
<span class="pc bpc" id="L6450" title="1 of 2 branches missed.">                if (dragVal &lt; 0) {</span>
<span class="nc" id="L6451">                    startTensile(dragVal, 0, true);</span>
                } else {
<span class="pc bpc" id="L6453" title="3 of 4 branches missed.">                    if (dragVal &gt; edge &amp;&amp; edge &gt; 0) {</span>
<span class="nc" id="L6454">                        startTensile(dragVal, getScrollDimension().getHeight() - getHeight() + iv, true);</span>
                    } else {
<span class="pc bpc" id="L6456" title="1 of 2 branches missed.">                        if (snapToGrid) {</span>
<span class="nc" id="L6457">                            boolean tVal = tensileDragEnabled;</span>
<span class="nc" id="L6458">                            tensileDragEnabled = true;</span>
<span class="nc" id="L6459">                            int dest = getGridPosY();</span>
<span class="nc" id="L6460">                            int scroll = getScrollY();</span>
<span class="nc bnc" id="L6461" title="All 2 branches missed.">                            if (Math.abs(dest - scroll) == 1) {</span>
                                // Fixes issue with exponential decay where it never actually reaches destination
                                // so it creates infinite loop
<span class="nc" id="L6464">                                setScrollY(dest);</span>
<span class="nc" id="L6465">                                draggedMotionY = null;</span>
<span class="nc bnc" id="L6466" title="All 2 branches missed.">                            } else if (dest != scroll) {</span>
<span class="nc" id="L6467">                                startTensile(scroll, dest, true);</span>
                            } else {
<span class="nc" id="L6469">                                draggedMotionY = null;</span>
                            }
<span class="nc" id="L6471">                            tensileDragEnabled = tVal;</span>
<span class="nc" id="L6472">                        } else {</span>
<span class="fc" id="L6473">                            draggedMotionY = null;</span>
                        }
                    }
                }
                // special callback to scroll Y to allow developers to override the setScrollY method effectively
<span class="fc" id="L6478">                setScrollY(dragVal);</span>
<span class="fc" id="L6479">                updateTensileHighlightIntensity(dragVal, getScrollDimension().getHeight() - getHeight() + getInvisibleAreaUnderVKB(), false);</span>
            }

<span class="pc bpc" id="L6482" title="1 of 2 branches missed.">            if (scrollListeners != null) {</span>
<span class="nc" id="L6483">                scrollListeners.fireScrollEvent(this.scrollX, dragVal, this.scrollX, this.scrollY);</span>
            }
<span class="fc" id="L6485">            scrollY = dragVal;</span>
<span class="fc" id="L6486">            onScrollY(scrollY);</span>
<span class="fc" id="L6487">            updateTensileHighlightIntensity(0, 0, false);</span>
<span class="fc" id="L6488">            animateY = true;</span>
        }
<span class="pc bpc" id="L6490" title="1 of 2 branches missed.">        if (draggedMotionX != null) {</span>
            // change the variable directly for efficiency both in removing redundant
            // repaints and scroll checks
<span class="nc" id="L6493">            int dragVal = draggedMotionX.getValue();</span>

            // this can't be a part of the parent if since we need the last value to arrive
<span class="nc bnc" id="L6496" title="All 2 branches missed.">            if (draggedMotionX.isFinished()) {</span>
<span class="nc bnc" id="L6497" title="All 2 branches missed.">                if (dragVal &lt; 0) {</span>
<span class="nc" id="L6498">                    startTensile(dragVal, 0, false);</span>
                } else {
<span class="nc" id="L6500">                    int edge = (getScrollDimension().getWidth() - getWidth());</span>
<span class="nc bnc" id="L6501" title="All 4 branches missed.">                    if (dragVal &gt; edge &amp;&amp; edge &gt; 0) {</span>
<span class="nc" id="L6502">                        startTensile(dragVal, getScrollDimension().getWidth() - getWidth(), false);</span>
                    } else {
<span class="nc bnc" id="L6504" title="All 6 branches missed.">                        if (snapToGrid &amp;&amp; getScrollX() &lt; edge &amp;&amp; getScrollX() &gt; 0) {</span>
<span class="nc" id="L6505">                            boolean tVal = tensileDragEnabled;</span>
<span class="nc" id="L6506">                            tensileDragEnabled = true;</span>
<span class="nc" id="L6507">                            int dest = getGridPosX();</span>
<span class="nc" id="L6508">                            int scroll = getScrollX();</span>
<span class="nc bnc" id="L6509" title="All 2 branches missed.">                            if (dest != scroll) {</span>
<span class="nc" id="L6510">                                startTensile(scroll, dest, false);</span>
                            } else {
<span class="nc" id="L6512">                                draggedMotionX = null;</span>
                            }
<span class="nc" id="L6514">                            tensileDragEnabled = tVal;</span>
<span class="nc" id="L6515">                        } else {</span>
<span class="nc" id="L6516">                            draggedMotionX = null;</span>
                        }
                    }
                }

                // special callback to scroll X to allow developers to override the setScrollY method effectively
<span class="nc" id="L6522">                setScrollX(dragVal);</span>
            }

<span class="nc bnc" id="L6525" title="All 2 branches missed.">            if (scrollListeners != null) {</span>
<span class="nc" id="L6526">                scrollListeners.fireScrollEvent(dragVal, this.scrollY, this.scrollX, this.scrollY);</span>
            }
<span class="nc" id="L6528">            scrollX = dragVal;</span>
<span class="nc" id="L6529">            onScrollX(scrollX);</span>
<span class="nc" id="L6530">            animateX = true;</span>
        }
<span class="pc bpc" id="L6532" title="1 of 4 branches missed.">        if (animateY || animateX) {</span>
<span class="fc" id="L6533">            return true;</span>
        }

<span class="pc bpc" id="L6536" title="1 of 2 branches missed.">        if (getClientProperty(&quot;$pullToRelease&quot;) != null) {</span>
<span class="nc" id="L6537">            return true;</span>
        }


<span class="fc" id="L6541">        Painter bgp = getStyle().getBgPainter();</span>
<span class="pc bpc" id="L6542" title="8 of 10 branches missed.">        boolean animateBackgroundB = bgp != null &amp;&amp; bgp.getClass() != BGPainter.class &amp;&amp; bgp instanceof Animation &amp;&amp; (bgp != this) &amp;&amp; ((Animation) bgp).animate();</span>
<span class="pc bpc" id="L6543" title="2 of 4 branches missed.">        animateBackground = animateBackgroundB || animateBackground;</span>

<span class="pc bpc" id="L6545" title="1 of 2 branches missed.">        if (getUIManager().getLookAndFeel().isFadeScrollBar()) {</span>
<span class="nc bnc" id="L6546" title="All 2 branches missed.">            if (tensileHighlightIntensity &gt; 0) {</span>
<span class="nc" id="L6547">                tensileHighlightIntensity = Math.max(0, tensileHighlightIntensity - (scrollOpacityChangeSpeed * 2));</span>
            }
<span class="nc bnc" id="L6549" title="All 4 branches missed.">            if (scrollOpacity &gt; 0 &amp;&amp; !dragActivated) {</span>
<span class="nc" id="L6550">                scrollOpacity = Math.max(0, scrollOpacity - scrollOpacityChangeSpeed);</span>
<span class="nc" id="L6551">                return true;</span>
            }
        }

<span class="pc bpc" id="L6555" title="8 of 16 branches missed.">        if (!animateBackground &amp;&amp; (destScrollY == -1 || destScrollY == scrollY) &amp;&amp;</span>
                !animateBackground &amp;&amp; m == null &amp;&amp; draggedMotionY == null &amp;&amp;
                draggedMotionX == null &amp;&amp; !dragActivated) {
<span class="fc" id="L6558">            tryDeregisterAnimated();</span>
        }

<span class="fc" id="L6561">        return animateBackground;</span>
    }

    /**
     * Removes the internal animation. This method may be overriden by sublcasses to block automatic removal
     */
    void tryDeregisterAnimated() {
<span class="fc" id="L6568">        deregisterAnimatedInternal();</span>
<span class="fc" id="L6569">    }</span>

    /**
     * Makes sure the component is visible in the scroll if this container
     * is scrollable
     *
     * @param rect            the rectangle that need to be visible
     * @param coordinateSpace the component according to whose coordinates
     *                        rect is defined. Rect's x/y are relative to that component
     *                        (they are not absolute).
     */
    protected void scrollRectToVisible(Rectangle rect, Component coordinateSpace) {
<span class="fc" id="L6581">        scrollRectToVisible(rect.getX(), rect.getY(),</span>
<span class="fc" id="L6582">                rect.getSize().getWidth(), rect.getSize().getHeight(), coordinateSpace);</span>
<span class="fc" id="L6583">    }</span>

    /**
     * Makes sure the component is visible in the scroll if this container
     * is scrollable
     *
     * @param x
     * @param y
     * @param width
     * @param height
     * @param coordinateSpace the component according to whose coordinates
     *                        rect is defined. Rect's x/y are relative to that component
     *                        (they are not absolute).
     */
    public void scrollRectToVisible(int x, int y, int width, int height, Component coordinateSpace) {
<span class="fc bfc" id="L6598" title="All 2 branches covered.">        if (isScrollable()) {</span>
<span class="fc" id="L6599">            int scrollPosition = getScrollY();</span>
<span class="fc" id="L6600">            Style s = getStyle();</span>
<span class="fc" id="L6601">            int w = getWidth() - s.getHorizontalPadding();</span>
<span class="fc" id="L6602">            int h = getHeight() - s.getVerticalPadding();</span>

            Rectangle view;
<span class="fc" id="L6605">            int invisibleAreaUnderVKB = getInvisibleAreaUnderVKB();</span>

<span class="pc bpc" id="L6607" title="2 of 4 branches missed.">            if (isSmoothScrolling() &amp;&amp; destScrollY &gt; -1) {</span>
<span class="nc" id="L6608">                view = new Rectangle(getScrollX(), destScrollY, w, h - invisibleAreaUnderVKB);</span>

            } else {
<span class="fc" id="L6611">                view = new Rectangle(getScrollX(), getScrollY(), w, h - invisibleAreaUnderVKB);</span>
            }

<span class="fc" id="L6614">            int relativeX = x;</span>
<span class="fc" id="L6615">            int relativeY = y;</span>

            // component needs to be in absolute coordinates...
<span class="fc" id="L6618">            Container parent = null;</span>
<span class="pc bpc" id="L6619" title="1 of 2 branches missed.">            if (coordinateSpace != null) {</span>
<span class="fc" id="L6620">                parent = coordinateSpace.getParent();</span>
            }
<span class="fc bfc" id="L6622" title="All 2 branches covered.">            if (parent == this) {</span>
<span class="pc bpc" id="L6623" title="1 of 2 branches missed.">                if (view.contains(x, y, width, height)) {</span>
<span class="fc" id="L6624">                    return;</span>
                }
            } else {
<span class="pc bpc" id="L6627" title="1 of 2 branches missed.">                while (parent != this) {</span>
                    // mostly a special case for list
<span class="fc bfc" id="L6629" title="All 2 branches covered.">                    if (parent == null) {</span>
<span class="fc" id="L6630">                        relativeX = x;</span>
<span class="fc" id="L6631">                        relativeY = y;</span>
<span class="fc" id="L6632">                        break;</span>
                    }
<span class="fc" id="L6634">                    relativeX += parent.getX();</span>
<span class="fc" id="L6635">                    relativeY += parent.getY();</span>
<span class="fc" id="L6636">                    parent = parent.getParent();</span>
                }
<span class="fc bfc" id="L6638" title="All 2 branches covered.">                if (view.contains(relativeX, relativeY, width, height)) {</span>
<span class="fc" id="L6639">                    return;</span>
                }
            }
<span class="pc bpc" id="L6642" title="1 of 2 branches missed.">            if (isScrollableX()) {</span>
<span class="nc bnc" id="L6643" title="All 2 branches missed.">                if (getScrollX() &gt; relativeX) {</span>
<span class="nc" id="L6644">                    setScrollX(relativeX);</span>
                }
<span class="nc" id="L6646">                int rightX = relativeX + width -</span>
<span class="nc" id="L6647">                        s.getHorizontalPadding();</span>
<span class="nc bnc" id="L6648" title="All 2 branches missed.">                if (getScrollX() + w &lt; rightX) {</span>
<span class="nc" id="L6649">                    setScrollX(getScrollX() + (rightX - (getScrollX() + w)));</span>
                } else {
<span class="nc bnc" id="L6651" title="All 2 branches missed.">                    if (getScrollX() &gt; relativeX) {</span>
<span class="nc" id="L6652">                        setScrollX(relativeX);</span>
                    }
                }
            }

<span class="pc bpc" id="L6657" title="1 of 2 branches missed.">            if (isScrollableY()) {</span>
<span class="pc bpc" id="L6658" title="1 of 2 branches missed.">                if (getScrollY() &gt; relativeY) {</span>
<span class="nc" id="L6659">                    scrollPosition = relativeY;</span>
                }
<span class="fc" id="L6661">                int bottomY = relativeY + height -</span>
<span class="fc" id="L6662">                        s.getVerticalPadding();</span>
<span class="pc bpc" id="L6663" title="1 of 2 branches missed.">                if (getScrollY() + h &lt; bottomY + invisibleAreaUnderVKB) {</span>
<span class="fc" id="L6664">                    scrollPosition = getScrollY() + (bottomY - (getScrollY() + h)) + invisibleAreaUnderVKB;</span>
                } else {
<span class="nc bnc" id="L6666" title="All 2 branches missed.">                    if (getScrollY() &gt; relativeY) {</span>
<span class="nc" id="L6667">                        scrollPosition = relativeY;</span>
                    }
                }
<span class="pc bpc" id="L6670" title="2 of 4 branches missed.">                if (isSmoothScrolling() &amp;&amp; isInitialized()) {</span>
<span class="fc" id="L6671">                    initialScrollY = getScrollY();</span>
<span class="fc" id="L6672">                    destScrollY = scrollPosition;</span>
<span class="fc" id="L6673">                    initScrollMotion();</span>
                } else {
<span class="nc" id="L6675">                    setScrollY(scrollPosition);</span>
                }
            }
<span class="fc" id="L6678">            repaint();</span>
<span class="fc" id="L6679">        } else {</span>
            //try to move parent scroll if you are not scrollable
<span class="fc" id="L6681">            Container parent = getParent();</span>
<span class="fc bfc" id="L6682" title="All 2 branches covered.">            if (parent != null) {</span>
<span class="fc" id="L6683">                parent.scrollRectToVisible(getAbsoluteX() - parent.getAbsoluteX() + x,</span>
<span class="fc" id="L6684">                        getAbsoluteY() - parent.getAbsoluteY() + y,</span>
                        width, height, parent);
            }
        }
<span class="fc" id="L6688">    }</span>

    /**
     * Indicates whether a border should be painted
     *
     * @return if the border will be painted
     * @deprecated use getStyle().getBorder() != null
     */
    private boolean isBorderPainted() {
<span class="fc bfc" id="L6697" title="All 2 branches covered.">        return getStyle().getBorder() != null;</span>
    }

    /**
     * Draws the component border if such a border exists. The border unlike the content
     * of the component will not be affected by scrolling for a scrollable component.
     *
     * @param g graphics context on which the border is painted
     */
    protected void paintBorder(Graphics g) {
<span class="fc" id="L6707">        Border b = getBorder();</span>
<span class="pc bpc" id="L6708" title="1 of 2 branches missed.">        if (b != null) {</span>
<span class="fc" id="L6709">            g.setColor(getStyle().getFgColor());</span>
<span class="fc" id="L6710">            int alpha = g.concatenateAlpha(getStyle().getFgAlpha());</span>
<span class="fc" id="L6711">            b.paint(g, this);</span>
<span class="fc" id="L6712">            g.setAlpha(alpha);</span>
        }
<span class="fc" id="L6714">    }</span>

    /**
     * Draws the component border background if such a border exists.
     *
     * @param g graphics context on which the border is painted
     */
    protected void paintBorderBackground(Graphics g) {
<span class="fc" id="L6722">        Border b = getBorder();</span>
<span class="pc bpc" id="L6723" title="1 of 2 branches missed.">        if (b != null) {</span>
<span class="nc" id="L6724">            b.paintBorderBackground(g, this);</span>
        }
<span class="fc" id="L6726">    }</span>

    /**
     * Used as an optimization to mark that this component is currently being
     * used as a cell renderer
     *
     * @return true is this component is currently being used as a cell renderer
     */
    public boolean isCellRenderer() {
<span class="fc" id="L6735">        return cellRenderer;</span>
    }

    /**
     * Used as an optimization to mark that this component is currently being
     * used as a cell renderer
     *
     * @param cellRenderer indicate whether this component is currently being
     *                     used as a cell renderer
     */
    public void setCellRenderer(boolean cellRenderer) {
<span class="fc" id="L6746">        this.cellRenderer = cellRenderer;</span>
<span class="pc bpc" id="L6747" title="1 of 2 branches missed.">        if (cellRenderer) {</span>
<span class="fc" id="L6748">            getUnselectedStyle().markAsRendererStyle();</span>
<span class="fc" id="L6749">            getSelectedStyle().markAsRendererStyle();</span>
<span class="fc" id="L6750">            getDisabledStyle().markAsRendererStyle();</span>
        }
<span class="fc" id="L6752">    }</span>

    /**
     * Indicate whether this component scroll is visible
     *
     * @return true is this component scroll is visible; otherwise false
     */
    public boolean isScrollVisible() {
<span class="fc" id="L6760">        return isScrollVisible;</span>
    }

    /**
     * Set whether this component scroll is visible
     *
     * @param isScrollVisible Indicate whether this component scroll is visible
     */
    public void setScrollVisible(boolean isScrollVisible) {
<span class="fc" id="L6769">        this.isScrollVisible = isScrollVisible;</span>
<span class="fc" id="L6770">    }</span>

    /**
     * Set whether this component scroll is visible
     *
     * @param isScrollVisible Indicate whether this component scroll is visible
     * @deprecated replaced by setScrollVisible to match the JavaBeans spec
     */
    public void setIsScrollVisible(boolean isScrollVisible) {
<span class="fc" id="L6779">        this.isScrollVisible = isScrollVisible;</span>
<span class="fc" id="L6780">    }</span>

    void lockStyleImages(Style stl) {
<span class="fc" id="L6783">        Image i = stl.getBgImage();</span>
<span class="fc bfc" id="L6784" title="All 2 branches covered.">        if (i != null) {</span>
<span class="fc" id="L6785">            i.lock();</span>
        } else {
<span class="fc" id="L6787">            Border b = stl.getBorder();</span>
<span class="fc bfc" id="L6788" title="All 2 branches covered.">            if (b != null) {</span>
<span class="fc" id="L6789">                b.lock();</span>
            }
        }
<span class="fc" id="L6792">    }</span>

    /**
     * Registers the given component with the nearest surface.  This will attempt to register
     * it with the parent container of &quot;this&quot;, if it is a surface.  If not, it will walk up
     * the component hierarchy until it finds a surface to add it to.
     *
     * @param cmp The component to register with the neares surface.
     * @see Container#addElevatedComponent(Component)
     * @see Container#removeElevatedComponent(Component)
     * @since 8.0
     */
    void registerElevatedInternal(Component cmp) {
<span class="pc bpc" id="L6805" title="1 of 2 branches missed.">        if (cmp._parentSurface != null) {</span>
            // It was already registered with a surface
<span class="nc" id="L6807">            cmp._parentSurface.removeElevatedComponent(cmp);</span>
<span class="nc" id="L6808">            cmp._parentSurface = null;</span>
        }
<span class="fc" id="L6810">        Container parent = getParent();</span>
<span class="fc bfc" id="L6811" title="All 2 branches covered.">        if (parent == null) return;</span>
<span class="pc bpc" id="L6812" title="1 of 2 branches missed.">        if (parent.isSurface()) {</span>
            // Let's keep a reference to the surface so that we can remove it later.
<span class="nc" id="L6814">            parent.addElevatedComponent(cmp);</span>
<span class="nc" id="L6815">            cmp._parentSurface = parent;</span>
        } else {
<span class="fc" id="L6817">            parent.registerElevatedInternal(cmp);</span>
        }
<span class="fc" id="L6819">    }</span>

    /**
     * Invoked internally to initialize and bind the component
     */
    void initComponentImpl() {
<span class="fc bfc" id="L6825" title="All 2 branches covered.">        if (!initialized) {</span>
<span class="fc" id="L6826">            initialized = true;</span>
<span class="fc" id="L6827">            UIManager manager = getUIManager();</span>
<span class="fc" id="L6828">            Style stl = getStyle();</span>
<span class="fc" id="L6829">            lockStyleImages(stl);</span>
<span class="fc" id="L6830">            manager.getLookAndFeel().bind(this);</span>
<span class="fc" id="L6831">            checkAnimation();</span>
<span class="pc bpc" id="L6832" title="1 of 4 branches missed.">            if (isRTL() &amp;&amp; isScrollableX()) {</span>
<span class="nc" id="L6833">                setScrollX(getScrollDimension().getWidth() - getWidth());</span>
            }

<span class="fc" id="L6836">            initComponent();</span>
<span class="pc bpc" id="L6837" title="1 of 2 branches missed.">            if (stl.getElevation() &gt; 0) {</span>
                // This component is elevated, so we need to register it with the surface so that it can
                // render its shadows.
<span class="nc" id="L6840">                registerElevatedInternal(this);</span>
            }
<span class="fc" id="L6842">            setSurface(stl.isSurface());</span>
<span class="pc bpc" id="L6843" title="1 of 2 branches missed.">            if (stateChangeListeners != null) {</span>
<span class="nc" id="L6844">                stateChangeListeners.fireActionEvent(new ComponentStateChangeEvent(this, true));</span>
            }
<span class="fc" id="L6846">            showNativeOverlay();</span>
<span class="pc bpc" id="L6847" title="1 of 4 branches missed.">            if (refreshTask != null &amp;&amp; InfiniteProgress.isDefaultMaterialDesignMode()) {</span>
<span class="nc" id="L6848">                final Form p = getComponentForm();</span>
<span class="nc bnc" id="L6849" title="All 2 branches missed.">                if (refreshTaskDragListener == null) {</span>
<span class="nc" id="L6850">                    refreshTaskDragListener = new ActionListener() {</span>
                        @Override
                        public void actionPerformed(ActionEvent evt) {
<span class="nc bnc" id="L6853" title="All 2 branches missed.">                            if (evt.getEventType() == ActionEvent.Type.PointerDrag) {</span>
<span class="nc bnc" id="L6854" title="All 2 branches missed.">                                if (updateMaterialPullToRefresh(p, evt.getY() - getAbsoluteY())) {</span>
<span class="nc" id="L6855">                                    evt.consume();</span>
                                }
                            } else {
<span class="nc" id="L6858">                                pullY = evt.getY() - getAbsoluteY();</span>
                            }
<span class="nc" id="L6860">                        }</span>
                    };
                }
<span class="nc" id="L6863">                p.addPointerDraggedListener(refreshTaskDragListener);</span>
<span class="nc" id="L6864">                p.addPointerPressedListener(refreshTaskDragListener);</span>
            }
        }
<span class="fc" id="L6867">    }</span>

    /**
     * Cleansup the initialization flags in the hierachy, notice that paint calls might
     * still occur after deinitilization mostly to perform transitions etc.
     * &lt;p&gt;However interactivity, animation and event tracking code can and probably
     * should be removed by this method.
     */
    void deinitializeImpl() {
<span class="fc bfc" id="L6876" title="All 2 branches covered.">        if (isInitialized()) {</span>
<span class="fc" id="L6877">            hideNativeOverlay();</span>
<span class="fc" id="L6878">            paintLockRelease();</span>
<span class="fc" id="L6879">            setInitialized(false);</span>
<span class="fc" id="L6880">            setDirtyRegion(null);</span>
<span class="fc" id="L6881">            Style stl = getStyle();</span>
<span class="fc" id="L6882">            Image i = stl.getBgImage();</span>
<span class="fc bfc" id="L6883" title="All 2 branches covered.">            if (i != null) {</span>
<span class="fc" id="L6884">                i.unlock();</span>
            } else {
<span class="fc" id="L6886">                Border b = stl.getBorder();</span>
<span class="fc bfc" id="L6887" title="All 2 branches covered.">                if (b != null) {</span>
<span class="fc" id="L6888">                    b.unlock();</span>
                }
            }
<span class="fc" id="L6891">            Painter p = stl.getBgPainter();</span>
<span class="pc bpc" id="L6892" title="1 of 2 branches missed.">            if (p instanceof BGPainter) {</span>
<span class="fc" id="L6893">                ((BGPainter) p).radialCache = null;</span>
            }
<span class="pc bpc" id="L6895" title="1 of 2 branches missed.">            if (stateChangeListeners != null) {</span>
<span class="nc" id="L6896">                stateChangeListeners.fireActionEvent(new ComponentStateChangeEvent(this, false));</span>
            }
<span class="fc" id="L6898">            deregisterAnimatedInternal();</span>
<span class="pc bpc" id="L6899" title="1 of 2 branches missed.">            if (_parentSurface != null) {</span>
<span class="nc" id="L6900">                _parentSurface.removeElevatedComponent(this);</span>
<span class="nc" id="L6901">                _parentSurface = null;</span>
            }
<span class="fc" id="L6903">            deinitialize();</span>
<span class="pc bpc" id="L6904" title="1 of 2 branches missed.">            if (refreshTaskDragListener != null) {</span>
<span class="nc" id="L6905">                Form f = getComponentForm();</span>
<span class="nc" id="L6906">                f.removePointerDraggedListener(refreshTaskDragListener);</span>
<span class="nc" id="L6907">                f.removePointerPressedListener(refreshTaskDragListener);</span>
            }
        }
<span class="fc" id="L6910">    }</span>

    /**
     * If the component {@link #isEditable() }, then this will start the editing
     * process.  For TextFields, this results in showing the keyboard and allowing
     * the user to edit the input.  For the Picker, this will display the popup.
     *
     * @see #stopEditing(java.lang.Runnable)
     * @see #isEditing()
     * @see #isEditable()
     * @see #getEditingDelegate()
     * @see #setEditingDelegate(com.codename1.ui.Editable)
     */
    public void startEditingAsync() {
        // Empty implementation overridden by subclass
<span class="pc bpc" id="L6925" title="1 of 2 branches missed.">        if (editingDelegate != null) {</span>
<span class="nc" id="L6926">            editingDelegate.startEditingAsync();</span>
        }
<span class="fc" id="L6928">    }</span>

    /**
     * Stops the editing process.
     *
     * @param onFinish Callback called when the editing is complete.
     * @see #startEditingAsync()
     * @see #isEditing()
     * @see #isEditable()
     * @see #getEditingDelegate()
     * @see #setEditingDelegate(com.codename1.ui.Editable)
     */
    public void stopEditing(Runnable onFinish) {
<span class="pc bpc" id="L6941" title="1 of 2 branches missed.">        if (editingDelegate != null) {</span>
<span class="nc" id="L6942">            editingDelegate.stopEditing(onFinish);</span>
        }
<span class="fc" id="L6944">    }</span>

    /**
     * Checks if the component is currently being edited.
     *
     * @return True if the component is currently being edited.
     * @see #startEditingAsync()
     * @see #stopEditing(java.lang.Runnable)
     * @see #isEditable()
     * @see #getEditingDelegate()
     * @see #setEditingDelegate(com.codename1.ui.Editable)
     */
    public boolean isEditing() {
<span class="pc bpc" id="L6957" title="1 of 2 branches missed.">        if (editingDelegate != null) {</span>
<span class="nc" id="L6958">            return editingDelegate.isEditing();</span>
        }
<span class="fc" id="L6960">        return false;</span>
    }

    /**
     * Checks to see if the component is editable.   This is used for next/previous
     * focus traversal on forms.
     *
     * @return
     * @see #getEditingDelegate()
     * @see #setEditingDelegate(com.codename1.ui.Editable)
     * @see #isEditing()
     * @see #startEditingAsync()
     * @see #stopEditing(java.lang.Runnable)
     */
    public boolean isEditable() {
<span class="pc bpc" id="L6975" title="1 of 2 branches missed.">        if (editingDelegate != null) {</span>
<span class="nc" id="L6976">            return editingDelegate.isEditable();</span>
        }
<span class="fc" id="L6978">        return false;</span>
    }

    /**
     * This is a callback method to inform the Component when it's been laidout
     * on the parent Container
     */
    protected void laidOut() {
<span class="pc bpc" id="L6986" title="1 of 2 branches missed.">        if (!isCellRenderer()) {</span>
<span class="fc" id="L6987">            CodenameOneImplementation ci = Display.impl;</span>
<span class="fc bfc" id="L6988" title="All 2 branches covered.">            if (ci.isEditingText()) {</span>
<span class="fc" id="L6989">                return;</span>
            }
<span class="fc" id="L6991">            int ivk = getInvisibleAreaUnderVKB();</span>

<span class="fc bfc" id="L6993" title="All 4 branches covered.">            if (isScrollableY() &amp;&amp; getScrollY() &gt; 0 &amp;&amp; getScrollY() + getHeight() &gt;</span>
<span class="pc bpc" id="L6994" title="1 of 2 branches missed.">                    getScrollDimension().getHeight() + ivk) {</span>
<span class="nc" id="L6995">                setScrollY(getScrollDimension().getHeight() - getHeight() + ivk);</span>
            }
<span class="pc bpc" id="L6997" title="3 of 4 branches missed.">            if (isScrollableX() &amp;&amp; getScrollX() &gt; 0 &amp;&amp; getScrollX() + getWidth() &gt;</span>
<span class="nc bnc" id="L6998" title="All 2 branches missed.">                    getScrollDimension().getWidth()) {</span>
<span class="nc" id="L6999">                setScrollX(getScrollDimension().getWidth() - getWidth());</span>
            }
<span class="pc bpc" id="L7001" title="1 of 4 branches missed.">            if (!isScrollableY() &amp;&amp; getScrollY() &gt; 0) {</span>
<span class="nc" id="L7002">                setScrollY(0);</span>
            }
<span class="pc bpc" id="L7004" title="2 of 4 branches missed.">            if (!isScrollableX() &amp;&amp; getScrollX() &gt; 0) {</span>
<span class="nc" id="L7005">                setScrollX(0);</span>
            }
<span class="fc" id="L7007">            updateNativeOverlay();</span>
        }
<span class="fc" id="L7009">    }</span>

    /**
     * Invoked to indicate that the component initialization is being reversed
     * since the component was detached from the container hierarchy. This allows
     * the component to deregister animators and cleanup after itself. This
     * method is the opposite of the initComponent() method.
     */
    protected void deinitialize() {
<span class="fc" id="L7018">    }</span>

    /**
     * Allows subclasses to bind functionality that relies on fully initialized and
     * &quot;ready for action&quot; component state
     */
    protected void initComponent() {
<span class="fc" id="L7025">    }</span>

    /**
     * Indicates if the component is in the initialized state, a component is initialized
     * when its initComponent() method was invoked. The initMethod is invoked before showing the
     * component to the user.
     *
     * @return true if the component is in the initialized state
     */
    protected boolean isInitialized() {
<span class="fc" id="L7035">        return initialized;</span>
    }

    /**
     * Indicates if the component is in the initialized state, a component is initialized
     * when its initComponent() method was invoked. The initMethod is invoked before showing the
     * component to the user.
     *
     * @param initialized Indicates if the component is in the initialized state
     */
    protected void setInitialized(boolean initialized) {
<span class="fc" id="L7046">        this.initialized = initialized;</span>
<span class="fc" id="L7047">    }</span>

    /**
     * Invoked to indicate a change in a propertyName of a Style
     *
     * &lt;p&gt;&lt;em&gt;NOTE&lt;/em&gt; By default this will trigger a call to {@link Container#revalidate() } on the parent
     * container, which is expensive.  You can disable this behavior by calling {@code CN.setProperty(&quot;Component.revalidateOnStyleChange&quot;, &quot;false&quot;)}.
     * The intention is to change this behavior so that the default is to &quot;not&quot; revalidate on style change, so we encourage you to
     * set this to &quot;false&quot; to ensure for future compatibility.&lt;/p&gt;
     *
     * @param propertyName the property name that was changed
     * @param source       The changed Style object
     */
    public void styleChanged(String propertyName, Style source) {
        //changing the Font, Padding, Margin may casue the size of the Component to Change
        //therefore we turn on the shouldCalcPreferredSize flag
<span class="fc bfc" id="L7063" title="All 2 branches covered.">        if ((!shouldCalcPreferredSize &amp;&amp;</span>
<span class="fc bfc" id="L7064" title="All 2 branches covered.">                source == getStyle()) &amp;&amp;</span>
<span class="pc bpc" id="L7065" title="1 of 2 branches missed.">                (propertyName.equals(Style.FONT) ||</span>
<span class="fc bfc" id="L7066" title="All 2 branches covered.">                        propertyName.equals(Style.MARGIN) ||</span>
<span class="fc bfc" id="L7067" title="All 2 branches covered.">                        propertyName.equals(Style.PADDING))) {</span>
<span class="fc" id="L7068">            setShouldCalcPreferredSize(true);</span>
<span class="fc" id="L7069">            Container parent = getParent();</span>
<span class="fc bfc" id="L7070" title="All 4 branches covered.">            if (parent != null &amp;&amp; parent.getComponentForm() != null) {</span>
<span class="pc bpc" id="L7071" title="1 of 2 branches missed.">                if (revalidateOnStyleChange) {</span>
<span class="fc" id="L7072">                    parent.revalidateLater();</span>
                }
            }
<span class="pc bpc" id="L7075" title="3 of 4 branches missed.">        } else if (propertyName.equals(Style.ELEVATION) &amp;&amp; source.getElevation() &gt; 0) {</span>
<span class="nc" id="L7076">            Container surface = findSurface();</span>
<span class="nc bnc" id="L7077" title="All 2 branches missed.">            if (surface != null) {</span>
<span class="nc" id="L7078">                surface.addElevatedComponent(this);</span>
            }
<span class="pc bpc" id="L7080" title="1 of 2 branches missed.">        } else if (propertyName.equals(Style.SURFACE)) {</span>
<span class="nc" id="L7081">            setSurface(source.isSurface());</span>
        }
<span class="fc" id="L7083">    }</span>

    /**
     * Allows us to determine which component will receive focus next when traversing
     * with the down key
     *
     * @return the next focus component
     */
    public Component getNextFocusDown() {
<span class="fc" id="L7092">        return nextFocusDown;</span>
    }

    /**
     * Allows us to determine which component will receive focus next when traversing
     * with the down key
     *
     * @param nextFocusDown the next focus component
     */
    public void setNextFocusDown(Component nextFocusDown) {
<span class="fc" id="L7102">        this.nextFocusDown = nextFocusDown;</span>
<span class="fc" id="L7103">    }</span>

    /**
     * Allows us to determine which component will receive focus next when traversing
     * with the up key.
     *
     * @return the nxt focus component
     */
    public Component getNextFocusUp() {
<span class="fc" id="L7112">        return nextFocusUp;</span>
    }

    /**
     * Allows us to determine which component will receive focus next when traversing
     * with the up key, this method doesn't affect the general focus behavior.
     *
     * @param nextFocusUp next focus component
     */
    public void setNextFocusUp(Component nextFocusUp) {
<span class="fc" id="L7122">        this.nextFocusUp = nextFocusUp;</span>
<span class="fc" id="L7123">    }</span>

    /**
     * Allows us to determine which component will receive focus next when traversing
     * with the left key.
     *
     * @return the next focus component
     */
    public Component getNextFocusLeft() {
<span class="fc" id="L7132">        return nextFocusLeft;</span>
    }

    /**
     * Allows us to determine which component will receive focus next when traversing
     * with the left key, this method doesn't affect the general focus behavior.
     *
     * @param nextFocusLeft the next focus component
     */
    public void setNextFocusLeft(Component nextFocusLeft) {
<span class="fc" id="L7142">        this.nextFocusLeft = nextFocusLeft;</span>
<span class="fc" id="L7143">    }</span>

    /**
     * Allows us to determine which component will receive focus next when traversing
     * with the right key
     *
     * @return the next focus component
     */
    public Component getNextFocusRight() {
<span class="fc" id="L7152">        return nextFocusRight;</span>
    }

    /**
     * Allows us to determine which component will receive focus next when traversing
     * with the right key
     *
     * @param nextFocusRight the next focus component
     */
    public void setNextFocusRight(Component nextFocusRight) {
<span class="fc" id="L7162">        this.nextFocusRight = nextFocusRight;</span>
<span class="fc" id="L7163">    }</span>

    /**
     * Indicates whether component is enabled or disabled thus allowing us to prevent
     * a component from receiving input events and indicate so visually
     *
     * @return true if enabled
     */
    public boolean isEnabled() {
<span class="fc" id="L7172">        return enabled;</span>
    }

    /**
     * Indicates whether component is enabled or disabled thus allowing us to prevent
     * a component from receiving input events and indicate so visually
     *
     * @param enabled true to enable false to disable
     */
    public void setEnabled(boolean enabled) {
<span class="fc bfc" id="L7182" title="All 2 branches covered.">        if (this.enabled == enabled) {</span>
<span class="fc" id="L7183">            return;</span>
        }
<span class="fc" id="L7185">        this.enabled = enabled;</span>
<span class="fc" id="L7186">        repaint();</span>
<span class="fc" id="L7187">    }</span>

    /**
     * Used to reduce coupling between the {@link TextArea} component and display/implementation
     * classes thus reduce the size of the hello world
     *
     * @param text text after editing is completed
     */
    void onEditComplete(String text) {
<span class="fc" id="L7196">    }</span>

    /**
     * A component name allows us to easily identify the component within a dynamic
     * UI.
     *
     * @return name of the component
     */
    public String getName() {
<span class="fc" id="L7205">        return name;</span>
    }

    /**
     * A component name allows us to easily identify the component within a dynamic
     * UI.
     *
     * @param name a name for the component
     */
    public void setName(String name) {
<span class="fc" id="L7215">        this.name = name;</span>
<span class="fc" id="L7216">    }</span>

    /**
     * Allows components to create a style of their own, this method binds the listener
     * to the style and installs a bg painter
     *
     * @param s style to initialize
     */
    protected void initCustomStyle(Style s) {
<span class="pc bpc" id="L7225" title="3 of 4 branches missed.">        if (initialized &amp;&amp; s.getElevation() &gt; 0) {</span>
<span class="nc" id="L7226">            registerElevatedInternal(this);</span>
        }
<span class="pc bpc" id="L7228" title="1 of 2 branches missed.">        if (initialized) {</span>
<span class="nc" id="L7229">            setSurface(s.isSurface());</span>
        }
<span class="fc" id="L7231">        s.addStyleListener(this);</span>
<span class="pc bpc" id="L7232" title="1 of 2 branches missed.">        if (s.getBgPainter() == null) {</span>
<span class="fc" id="L7233">            s.setBgPainter(new BGPainter());</span>
        }
<span class="fc" id="L7235">    }</span>

    /**
     * Allows components to create a style of their own, this method cleans up
     * state for the given style
     *
     * @param s style no longer used
     */
    protected void deinitializeCustomStyle(Style s) {
<span class="nc" id="L7244">        s.removeStyleListener(this);</span>
<span class="nc" id="L7245">    }</span>

    /**
     * Is the component a bidi RTL component
     *
     * @return true if the component is working in a right to left mode
     */
    public boolean isRTL() {
<span class="fc" id="L7253">        return rtl;</span>
    }

    /**
     * Is the component a bidi RTL component
     *
     * @param rtl true if the component should work in a right to left mode
     */
    public void setRTL(boolean rtl) {
<span class="fc" id="L7262">        this.rtl = rtl;</span>
<span class="fc" id="L7263">    }</span>

    /**
     * Elaborate components might not provide tactile feedback for all their areas (e.g. Lists)
     * this method defaults to returning the value of isTactileTouch
     *
     * @param x the x position
     * @param y the y position
     * @return True if the device should vibrate
     */
    protected boolean isTactileTouch(int x, int y) {
<span class="fc" id="L7274">        return isTactileTouch();</span>
    }

    /**
     * Indicates whether the component should &quot;trigger&quot; tactile touch when pressed by the user
     * in a touch screen UI.
     *
     * @return the tactileTouch
     */
    public boolean isTactileTouch() {
<span class="fc" id="L7284">        return tactileTouch;</span>
    }

    /**
     * Indicates whether the component should &quot;trigger&quot; tactile touch when pressed by the user
     * in a touch screen UI.
     *
     * @param tactileTouch true to trigger vibration when the component is pressed
     */
    public void setTactileTouch(boolean tactileTouch) {
<span class="fc" id="L7294">        this.tactileTouch = tactileTouch;</span>
<span class="fc" id="L7295">    }</span>

    /**
     * A component may expose mutable property names for a UI designer to manipulate, this
     * API is designed for usage internally by the GUI builder code
     *
     * @return the property names allowing mutation
     */
    public String[] getPropertyNames() {
<span class="fc" id="L7304">        return null;</span>
    }

    /**
     * Matches the property names method (see that method for further details).
     *
     * @return the types of the properties
     */
    public Class[] getPropertyTypes() {
<span class="fc" id="L7313">        return null;</span>
    }

    /**
     * This method is here to workaround an XMLVM array type bug where property types aren't
     * identified properly, it returns the names of the types using the following type names:
     * String,int,double,long,byte,short,char,String[],String[][],byte[],Image,Image[],Object[],ListModel,ListCellRenderer
     *
     * @return Array of type names
     */
    public String[] getPropertyTypeNames() {
<span class="fc" id="L7324">        return null;</span>
    }

    /**
     * Returns the current value of the property name, this method is used by the GUI builder
     *
     * @param name the name of the property
     * @return the value of said property
     */
    public Object getPropertyValue(String name) {
<span class="fc" id="L7334">        return null;</span>
    }

    /**
     * Sets a new value to the given property, returns an error message if failed
     * and null if successful. Notice that some builtin properties such as &quot;$designMode&quot; might be sent
     * to components to indicate application state.
     *
     * @param name  the name of the property
     * @param value new value for the property
     * @return error message or null
     */
    public String setPropertyValue(String name, Object value) {
<span class="fc" id="L7347">        return &quot;Unknown: &quot; + name;</span>
    }

    /**
     * Releases the paint lock image to allow paint to work as usual, see paintLock(boolean)
     * for details
     */
    public void paintLockRelease() {
<span class="fc" id="L7355">        paintLockImage = null;</span>
<span class="fc" id="L7356">    }</span>

    /**
     * This method locks the component so it will always paint the given image
     * instead of running through its paint logic. This is useful when running
     * transitions that might be quite expensive on the device. A lock should
     * be released using paintLockRelease(), it is implicitly released when
     * a component is deinitialized although a component doesn't need to be initialized
     * to be locked!&lt;br&gt;
     * If the component is not opaque null is always returned!
     * &lt;p&gt;Duplicate calls to this method won't produce duplicate locks, in case of
     * a soft lock the return value will always be null.
     *
     * @param hardLock indicates whether the lock uses a hard or a soft reference to the image
     * @return the image in case of a hard lock
     */
    public Image paintLock(boolean hardLock) {
<span class="pc bpc" id="L7373" title="1 of 2 branches missed.">        if (!paintLockEnableChecked) {</span>
<span class="fc" id="L7374">            paintLockEnableChecked = true;</span>
<span class="fc" id="L7375">            paintLockEnabled = Display.getInstance().getProperty(&quot;paintLockEnabled&quot;, &quot;true&quot;).equals(&quot;true&quot;);</span>
        }
<span class="pc bpc" id="L7377" title="2 of 4 branches missed.">        if (!paintLockEnabled || !Display.getInstance().areMutableImagesFast()) {</span>
<span class="nc" id="L7378">            return null;</span>
        }
<span class="pc bpc" id="L7380" title="1 of 2 branches missed.">        if ((getStyle().getBgTransparency() &amp; 0xff) != 0xff) {</span>
<span class="nc" id="L7381">            return null;</span>
        }
<span class="pc bpc" id="L7383" title="1 of 2 branches missed.">        if (paintLockImage == null) {</span>
<span class="fc" id="L7384">            paintLockImage = ImageFactory.createImage(this, getWidth(), getHeight(), 0);</span>
<span class="fc" id="L7385">            int x = getX();</span>
<span class="fc" id="L7386">            int y = getY();</span>
<span class="fc" id="L7387">            setX(0);</span>
<span class="fc" id="L7388">            setY(0);</span>
<span class="fc" id="L7389">            paintInternalImpl(((Image) paintLockImage).getGraphics(), false);</span>
<span class="fc" id="L7390">            setX(x);</span>
<span class="fc" id="L7391">            setY(y);</span>
<span class="pc bpc" id="L7392" title="1 of 2 branches missed.">            if (hardLock) {</span>
<span class="nc" id="L7393">                return (Image) paintLockImage;</span>
            } else {
<span class="fc" id="L7395">                paintLockImage = Display.getInstance().createSoftWeakRef(paintLockImage);</span>
            }
<span class="fc" id="L7397">        } else {</span>
<span class="nc bnc" id="L7398" title="All 2 branches missed.">            if (hardLock) {</span>
<span class="nc" id="L7399">                return (Image) paintLockImage;</span>
            }
        }
<span class="fc" id="L7402">        return null;</span>
    }

    /**
     * This is a callback method for the peer component class
     */
    void setLightweightMode(boolean l) {
<span class="fc" id="L7409">    }</span>

    /**
     * Indicates whether scrolling this component should jump to a specific location
     * in a grid
     *
     * @return the snapToGrid
     */
    public boolean isSnapToGrid() {
<span class="fc" id="L7418">        return snapToGrid;</span>
    }

    /**
     * Indicates whether scrolling this component should jump to a specific location
     * in a grid
     *
     * @param snapToGrid the snapToGrid to set
     * @deprecated this feature should work but it isn't maintained and isn't guaranteed to function properly.
     * There are issues covering this but at this time we can't dedicate resources to address them specifically:
     * &lt;a href=&quot;https://github.com/codenameone/CodenameOne/issues/2122&quot;&gt;#2122&lt;/a&gt;,
     * &lt;a href=&quot;https://github.com/codenameone/CodenameOne/issues/1966&quot;&gt;#1966&lt;/a&gt; &amp;amp;
     * &lt;a href=&quot;https://github.com/codenameone/CodenameOne/issues/1947&quot;&gt;#1947&lt;/a&gt;.
     */
    public void setSnapToGrid(boolean snapToGrid) {
<span class="fc" id="L7433">        this.snapToGrid = snapToGrid;</span>
<span class="fc" id="L7434">    }</span>

    /**
     * A component that might need side swipe such as the slider
     * could block it from being used for some other purpose when
     * on top of said component.
     */
    protected boolean shouldBlockSideSwipe() {
<span class="pc bpc" id="L7442" title="4 of 6 branches missed.">        return isScrollableX() || (parent != null &amp;&amp; parent.shouldBlockSideSwipe());</span>
    }

    /**
     * A component that might need side swipe such as the tabs
     * could block it from being used for some other purpose when
     * on top of said component.
     */
    protected boolean shouldBlockSideSwipeLeft() {
<span class="fc" id="L7451">        return false;</span>
    }

    /**
     * A component that might need side swipe such as the tabs
     * could block it from being used for some other purpose when
     * on top of said component.
     */
    protected boolean shouldBlockSideSwipeRight() {
<span class="fc" id="L7460">        return false;</span>
    }

    /**
     * A component that might need side swipe such as the slider
     * could block it from being used for some other purpose when
     * on top of said component.
     * &lt;p&gt;
     * This method is merely a public accessor for {@link #shouldBlockSideSwipe() }.
     *
     * @since 7.0
     */
    public final boolean blocksSideSwipe() {
<span class="fc" id="L7473">        return shouldBlockSideSwipe();</span>
    }

    /**
     * Makes the component effectively opaque by blending the backgrounds into an image in memory so the layer of underlying components
     * is only drawn once when this component is repainted. This does have a significant memory overhead.
     *
     * @return the flatten property
     */
    public boolean isFlatten() {
<span class="fc" id="L7483">        return flatten;</span>
    }

    /**
     * Makes the component effectively opaque by blending the backgrounds into an image in memory so the layer of underlying components
     * is only drawn once when this component is repainted. This does have a significant memory overhead.
     *
     * @param flatten the flatten value
     */
    public void setFlatten(boolean flatten) {
<span class="fc" id="L7493">        this.flatten = flatten;</span>
<span class="fc" id="L7494">    }</span>

    /**
     * Recommended length for the tensile, -1 for default
     *
     * @return Recommended length for the tensile, -1 for default
     */
    public int getTensileLength() {
<span class="fc" id="L7502">        return tensileLength;</span>
    }

    /**
     * Recommended length for the tensile, -1 for default
     *
     * @param tensileLength length for tensile drag
     */
    public void setTensileLength(int tensileLength) {
<span class="fc" id="L7511">        this.tensileLength = tensileLength;</span>
<span class="fc" id="L7512">    }</span>

    Label getHintLabelImpl() {
<span class="fc" id="L7515">        return null;</span>
    }

    void setHintLabelImpl(Label hintLabel) {
<span class="fc" id="L7519">    }</span>

    boolean shouldShowHint() {
<span class="fc" id="L7522">        return false;</span>
    }

    void paintHint(Graphics g) {
<span class="fc" id="L7526">        Label hintLabel = getHintLabelImpl();</span>
<span class="fc bfc" id="L7527" title="All 4 branches covered.">        if (hintLabel != null &amp;&amp; shouldShowHint()) {</span>
<span class="pc bpc" id="L7528" title="1 of 2 branches missed.">            switch (hintLabel.getVerticalAlignment()) {</span>
                case TOP:
<span class="nc" id="L7530">                    hintLabel.setHeight(hintLabel.getPreferredH());</span>
<span class="nc" id="L7531">                    hintLabel.setY(getY());</span>
<span class="nc" id="L7532">                    break;</span>
                default:
<span class="fc" id="L7534">                    hintLabel.setHeight(getHeight());</span>
<span class="fc" id="L7535">                    hintLabel.setY(getY());</span>
                    break;
            }
<span class="fc" id="L7538">            hintLabel.setX(getX());</span>
<span class="fc" id="L7539">            hintLabel.setWidth(getWidth());</span>
<span class="fc" id="L7540">            hintLabel.paint(g);</span>
        }
<span class="fc" id="L7542">    }</span>

    String getHint() {
<span class="fc" id="L7545">        Label hintLabel = getHintLabelImpl();</span>
<span class="pc bpc" id="L7546" title="1 of 2 branches missed.">        if (hintLabel != null) {</span>
<span class="fc" id="L7547">            return hintLabel.getText();</span>
        }
<span class="nc" id="L7549">        return null;</span>
    }

    /**
     * Returns the hint icon
     *
     * @return the hint icon
     */
    Image getHintIcon() {
<span class="fc" id="L7558">        Label hintLabel = getHintLabelImpl();</span>
<span class="fc bfc" id="L7559" title="All 2 branches covered.">        if (hintLabel != null) {</span>
<span class="fc" id="L7560">            return hintLabel.getIcon();</span>
        }
<span class="fc" id="L7562">        return null;</span>
    }

    /**
     * Sets the hint text and Icon, the hint text and icon are
     * displayed on the component when it is empty
     *
     * &lt;p&gt;The default UIID for the text hint is &quot;TextHint&quot;&lt;/p&gt;
     *
     * @param hint the hint text to display
     * @param icon the hint icon to display
     */
    void setHint(String hint, Image icon) {
<span class="fc" id="L7575">        Label hintLabel = getHintLabelImpl();</span>
<span class="fc bfc" id="L7576" title="All 2 branches covered.">        if (hintLabel == null) {</span>
<span class="fc" id="L7577">            hintLabel = new Label(hint);</span>
<span class="fc" id="L7578">            hintLabel.setUIID(&quot;TextHint&quot;);</span>
<span class="fc" id="L7579">            setHintLabelImpl(hintLabel);</span>
        } else {
<span class="fc" id="L7581">            hintLabel.setText(hint);</span>
        }
<span class="fc" id="L7583">        hintLabel.setIcon(icon);</span>
<span class="fc" id="L7584">    }</span>

    /**
     * This property is useful for blocking in z-order touch events, sometimes we might want to grab touch events in
     * a specific component without making it focusable.
     *
     * @return the grabsPointerEvents
     */
    public boolean isGrabsPointerEvents() {
<span class="fc" id="L7593">        return grabsPointerEvents;</span>
    }

    /**
     * This property is useful for blocking in z-order touch events, sometimes we might want to grab touch events in
     * a specific component without making it focusable.
     *
     * @param grabsPointerEvents the grabsPointerEvents to set
     */
    public void setGrabsPointerEvents(boolean grabsPointerEvents) {
<span class="fc" id="L7603">        this.grabsPointerEvents = grabsPointerEvents;</span>
<span class="fc" id="L7604">    }</span>

    /**
     * Indicates the decrement units for the scroll opacity
     *
     * @return the scrollOpacityChangeSpeed
     */
    public int getScrollOpacityChangeSpeed() {
<span class="fc" id="L7612">        return scrollOpacityChangeSpeed;</span>
    }

    /**
     * Indicates the decrement units for the scroll opacity
     *
     * @param scrollOpacityChangeSpeed the scrollOpacityChangeSpeed to set
     */
    public void setScrollOpacityChangeSpeed(int scrollOpacityChangeSpeed) {
<span class="fc" id="L7621">        this.scrollOpacityChangeSpeed = scrollOpacityChangeSpeed;</span>
<span class="fc" id="L7622">    }</span>

    /**
     * Grows or shrinks this component to its new preferred size, this method
     * essentially takes a component whose preferred size has changed and creates a &quot;growing&quot;
     * effect that lasts for the duration. Notice that some components (such as text areas)
     * don't report proper preferred size untill they are laid out once. Hence the first time
     * around a text area (or container containing a text area) will not produce the expected
     * effect. This can be solved by invoking revalidate before the call to this method only the
     * first time around!
     *
     * @param duration the duration in milliseconds for the grow/shrink animation
     */
    public void growShrink(int duration) {
<span class="fc" id="L7636">        Motion wMotion = Motion.createSplineMotion(getWidth(), getPreferredW(), duration);</span>
<span class="fc" id="L7637">        Motion hMotion = Motion.createSplineMotion(getHeight(), getPreferredH(), duration);</span>
<span class="fc" id="L7638">        wMotion.start();</span>
<span class="fc" id="L7639">        hMotion.start();</span>
<span class="fc" id="L7640">        setPreferredSize(new Dimension(getWidth(), getHeight()));</span>
        // we are using bgpainter just to save the cost of creating another class
<span class="fc" id="L7642">        getComponentForm().registerAnimated(new BGPainter(wMotion, hMotion));</span>
<span class="fc" id="L7643">        getComponentForm().revalidate();</span>
<span class="fc" id="L7644">    }</span>

    /**
     * Enable the tensile drag to work even when a component doesn't have a scroll showable (scrollable flag still needs to be set to true)
     *
     * @return the alwaysTensile
     */
    public boolean isAlwaysTensile() {
<span class="pc bpc" id="L7652" title="4 of 8 branches missed.">        return alwaysTensile &amp;&amp; !isScrollableX() || (refreshTask != null &amp;&amp; !InfiniteProgress.isDefaultMaterialDesignMode());</span>
    }

    /**
     * Enable the tensile drag to work even when a component doesn't have a scroll showable (scrollable flag still needs to be set to true)
     *
     * @param alwaysTensile the alwaysTensile to set
     */
    public void setAlwaysTensile(boolean alwaysTensile) {
<span class="fc" id="L7661">        this.alwaysTensile = alwaysTensile;</span>
<span class="fc" id="L7662">    }</span>

    /**
     * Indicates whether this component can be dragged in a drag and drop operation rather than scroll the parent
     *
     * @return the draggable state
     */
    public boolean isDraggable() {
<span class="fc" id="L7670">        return draggable;</span>
    }

    /**
     * Indicates whether this component can be dragged in a drag and drop operation rather than scroll the parent
     *
     * @param draggable the draggable to set
     */
    public void setDraggable(boolean draggable) {
<span class="fc" id="L7679">        this.draggable = draggable;</span>
<span class="fc" id="L7680">    }</span>

    /**
     * Indicates whether this component can receive dropped components into it, notice that when dropping on a component
     * or container the parents will be checked recursively to find a valid drop target
     *
     * @return the dropTarget state
     */
    public boolean isDropTarget() {
<span class="fc" id="L7689">        return dropTarget;</span>
    }

    /**
     * Indicates whether this component can receive dropped components into it, notice that when dropping on a component
     * or container the parents will be checked recursively to find a valid drop target
     *
     * @param dropTarget the dropTarget to set
     */
    public void setDropTarget(boolean dropTarget) {
<span class="fc" id="L7699">        this.dropTarget = dropTarget;</span>
<span class="fc" id="L7700">    }</span>

    /**
     * Searches the hierarchy of the component recursively to see if the given
     * Container is one of the parents of this component
     *
     * @param cnt a potential parent of this component
     * @return false if the container isn't one of our parent containers
     */
    public boolean isChildOf(Container cnt) {
<span class="fc bfc" id="L7710" title="All 2 branches covered.">        if (cnt == parent) {</span>
<span class="fc" id="L7711">            return true;</span>
        }
<span class="fc bfc" id="L7713" title="All 4 branches covered.">        return parent != null &amp;&amp; parent.isChildOf(cnt);</span>
    }

    /**
     * Indicates that this component and all its children should be hidden when the device is switched to portrait mode
     *
     * @return the hideInPortrait
     */
    public boolean isHideInPortrait() {
<span class="fc" id="L7722">        return hideInPortrait;</span>
    }

    /**
     * Indicates that this component and all its children should be hidden when the device is switched to portrait mode
     *
     * @param hideInPortrait set to true in order to hide when in portrait
     */
    public void setHideInPortrait(boolean hideInPortrait) {
<span class="fc" id="L7731">        this.hideInPortrait = hideInPortrait;</span>
<span class="fc" id="L7732">    }</span>

    /**
     * remove this component from the painting queue
     */
    protected void cancelRepaints() {
<span class="fc" id="L7738">        Display.impl.cancelRepaint(this);</span>
<span class="fc" id="L7739">    }</span>

    /**
     * Returns the names of the properties within this component that can be bound for persistence,
     * the order of these names mean that the first one will be the first bound
     *
     * @return a string array of property names or null
     * @deprecated this mapped to an older iteration of properties that is no longer used
     */
    public String[] getBindablePropertyNames() {
<span class="fc" id="L7749">        return null;</span>
    }

    /**
     * Returns the types of the properties that are bindable within this component
     *
     * @return the class for binding
     * @deprecated this mapped to an older iteration of properties that is no longer used
     */
    public Class[] getBindablePropertyTypes() {
<span class="fc" id="L7759">        return null;</span>
    }

    /**
     * Binds the given property name to the given bind target
     *
     * @param prop   the property name
     * @param target the target binder
     * @deprecated this mapped to an older iteration of properties that is no longer used
     */
    public void bindProperty(String prop, BindTarget target) {
<span class="fc" id="L7770">    }</span>

    /**
     * Removes a bind target from the given property name
     *
     * @param prop   the property names
     * @param target the target binder
     * @deprecated this mapped to an older iteration of properties that is no longer used
     */
    public void unbindProperty(String prop, BindTarget target) {
<span class="fc" id="L7780">    }</span>

    /**
     * Allows the binding code to extract the value of the property
     *
     * @param prop the property
     * @return the value for the property
     * @deprecated this mapped to an older iteration of properties that is no longer used
     */
    public Object getBoundPropertyValue(String prop) {
<span class="fc" id="L7790">        return null;</span>
    }

    /**
     * Sets the value of a bound property within this component, notice that this method MUST NOT fire
     * the property change event when invoked to prevent recursion!
     *
     * @param prop  the property whose value should be set
     * @param value the value
     * @deprecated this mapped to an older iteration of properties that is no longer used
     */
    public void setBoundPropertyValue(String prop, Object value) {
<span class="fc" id="L7802">    }</span>

    /**
     * Indicates the property within this component that should be bound to the cloud object
     *
     * @return the cloudBoundProperty
     * @deprecated this mapped to an older iteration of properties that is no longer used
     */
    public String getCloudBoundProperty() {
<span class="pc bpc" id="L7811" title="1 of 4 branches missed.">        if (noBind &amp;&amp; cloudBoundProperty == null) {</span>
<span class="fc" id="L7812">            return null;</span>
        }
<span class="pc bpc" id="L7814" title="1 of 2 branches missed.">        if (cloudBoundProperty == null) {</span>
<span class="nc" id="L7815">            String[] props = getBindablePropertyNames();</span>
<span class="nc bnc" id="L7816" title="All 4 branches missed.">            if (props != null &amp;&amp; props.length &gt; 0) {</span>
<span class="nc" id="L7817">                return props[0];</span>
            }
        }
<span class="fc" id="L7820">        return cloudBoundProperty;</span>
    }

    /**
     * Indicates the property within this component that should be bound to the cloud object
     *
     * @param cloudBoundProperty the cloudBoundProperty to set
     * @deprecated this mapped to an older iteration of properties that is no longer used
     */
    public void setCloudBoundProperty(String cloudBoundProperty) {
<span class="fc" id="L7830">        this.cloudBoundProperty = cloudBoundProperty;</span>
<span class="pc bpc" id="L7831" title="1 of 4 branches missed.">        if (cloudBoundProperty == null || this.cloudBoundProperty.length() == 0) {</span>
<span class="fc" id="L7832">            noBind = true;</span>
<span class="fc" id="L7833">            this.cloudBoundProperty = null;</span>
        }
<span class="fc" id="L7835">    }</span>

    /**
     * The destination property of the CloudObject
     *
     * @return the cloudDestinationProperty
     * @deprecated this mapped to an older iteration of properties that is no longer used
     */
    public String getCloudDestinationProperty() {
<span class="pc bpc" id="L7844" title="1 of 4 branches missed.">        if (cloudDestinationProperty == null || cloudDestinationProperty.length() == 0) {</span>
<span class="fc" id="L7845">            return getName();</span>
        }
<span class="fc" id="L7847">        return cloudDestinationProperty;</span>
    }

    /**
     * The destination property of the CloudObject
     *
     * @param cloudDestinationProperty the cloudDestinationProperty to set
     * @deprecated this mapped to an older iteration of properties that is no longer used
     */
    public void setCloudDestinationProperty(String cloudDestinationProperty) {
<span class="fc" id="L7857">        this.cloudDestinationProperty = cloudDestinationProperty;</span>
<span class="fc" id="L7858">    }</span>

    /**
     * Some components may optionally generate a state which can then be restored
     * using setCompnentState(). This method is used by the UIBuilder.
     *
     * @return the component state or null for undefined state.
     */
    public Object getComponentState() {
<span class="fc" id="L7867">        return null;</span>
    }

    /**
     * If getComponentState returned a value the setter can update the value and restore
     * the prior state.
     *
     * @param state the non-null state
     */
    public void setComponentState(Object state) {
<span class="fc" id="L7877">    }</span>

    /**
     * Makes the components preferred size equal 0 when hidden and restores it to the default size when not.
     * This method also optionally sets the margin to 0 so the component will be truly hidden. Notice that this might
     * not behave as expected with scrollable containers or layouts that ignore preferred size.
     *
     * @param b            true to hide the component and false to show it
     * @param changeMargin indicates margin should be set to 0
     */
    public void setHidden(boolean b, boolean changeMargin) {
<span class="fc bfc" id="L7888" title="All 2 branches covered.">        if (b) {</span>
<span class="fc bfc" id="L7889" title="All 2 branches covered.">            if (!sizeRequestedByUser) {</span>
<span class="pc bpc" id="L7890" title="1 of 2 branches missed.">                if (changeMargin) {</span>
<span class="fc" id="L7891">                    getAllStyles().cacheMargins(false); //if a margins cache already exists because the component is already hidden it would be kept else it would be created</span>
<span class="fc" id="L7892">                    getAllStyles().setMargin(0, 0, 0, 0);</span>
                }
<span class="fc" id="L7894">                setPreferredSize(new Dimension());</span>
            }
        } else {
<span class="fc" id="L7897">            setPreferredSize(null);</span>
<span class="pc bpc" id="L7898" title="1 of 2 branches missed.">            if (changeMargin) {</span>
<span class="fc" id="L7899">                getAllStyles().restoreCachedMargins(); //restore margins to the values they had before the component being hidden and flush the margins cache</span>
//                if(getUnselectedStyle().getMarginLeftNoRTL() == 0) {
//                    setUIID(getUIID());
//                }
            }
        }
<span class="fc" id="L7905">    }</span>

    /**
     * Returns true if the component was explicitly hidden by the user.  This method doesn't check
     * if the parent component is hidden, so it is possible that the component would be hidden from
     * the UI, but that this would still return true.  Use {@link #isHidden(boolean) } with {@literal true}
     * to check also if the parent is hidden.
     *
     * @return true if the component is hidden, notice that the hidden property and visible property have different meanings in the API!
     */
    public boolean isHidden() {
<span class="pc bpc" id="L7916" title="2 of 8 branches missed.">        return sizeRequestedByUser &amp;&amp; preferredSize != null &amp;&amp; preferredSize.getWidth() == 0 &amp;&amp; preferredSize.getHeight() == 0;</span>
    }

    /**
     * Makes the components preferred size equal 0 when hidden and restores it to the default size when not.
     * Also toggles the UIID to &quot;Container&quot; and back to allow padding/margin to be removed. Since the visible flag
     * just hides the component without &quot;removing&quot; the space it occupies this is the flag that can be used to truly
     * hide a component within the UI. Notice that this might
     * not behave as expected with scrollable containers or layouts that ignore preferred size.
     *
     * @param b true to hide the component and false to show it
     */
    public void setHidden(boolean b) {
<span class="fc" id="L7929">        setHidden(b, true);</span>
<span class="fc" id="L7930">    }</span>

    /**
     * Checks if the component is hidden. If {@literal checkParent} is {@literal true}, this
     * also checks to see if the parent is hidden, and will return true if either this component
     * is hidden, or the parent is hidden.
     *
     * @param checkParent True to check if parent is hidden also.
     * @return Returns true if the component is hidden.
     * @since 7.0
     */
    public boolean isHidden(boolean checkParent) {
<span class="pc bpc" id="L7942" title="1 of 2 branches missed.">        if (isHidden()) {</span>
<span class="nc" id="L7943">            return true;</span>
        }
<span class="pc bpc" id="L7945" title="1 of 4 branches missed.">        if (checkParent &amp;&amp; parent != null) {</span>
<span class="fc" id="L7946">            return parent.isHidden(true);</span>
        }
<span class="fc" id="L7948">        return false;</span>
    }

    /**
     * Manually announces text to native accessibility services, associating the announcement
     * with this component when possible. Screen readers normally announce a component
     * automatically when it gains focus; this helper is for additional announcements that
     * should occur outside of focus changes.
     *
     * @param text the message to announce
     */
    public void announceForAccessibility(String text) {
<span class="fc" id="L7960">        Display.getInstance().announceForAccessibility(this, text);</span>
<span class="fc" id="L7961">    }</span>

    /**
     * Returns the text that describes this component to assistive technologies.
     * If no text was set explicitly, this method attempts to derive a
     * description from the component's label or content.
     *
     * @return accessibility description or {@code null} if none
     */
    public String getAccessibilityText() {
<span class="fc bfc" id="L7971" title="All 2 branches covered.">        if (accessibilityText != null) {</span>
<span class="fc" id="L7972">            return accessibilityText;</span>
        }
<span class="fc bfc" id="L7974" title="All 2 branches covered.">        if (componentLabel != null) {</span>
<span class="fc" id="L7975">            String t = componentLabel.getText();</span>
<span class="pc bpc" id="L7976" title="2 of 4 branches missed.">            if (t != null &amp;&amp; t.length() &gt; 0) {</span>
<span class="fc" id="L7977">                return t;</span>
            }
        }
<span class="fc bfc" id="L7980" title="All 2 branches covered.">        if (this instanceof TextHolder) {</span>
<span class="fc" id="L7981">            String t = ((TextHolder) this).getText();</span>
<span class="fc bfc" id="L7982" title="All 4 branches covered.">            if (t != null &amp;&amp; t.length() &gt; 0) {</span>
<span class="fc" id="L7983">                return t;</span>
            }
        }
<span class="fc" id="L7986">        return null;</span>
    }

    /**
     * Sets the text that describes this component to assistive technologies.
     * When the component gains focus, this text will be announced
     * automatically.
     *
     * @param text accessibility description
     */
    public void setAccessibilityText(String text) {
<span class="fc" id="L7997">        this.accessibilityText = text;</span>
<span class="fc" id="L7998">    }</span>

    /**
     * @return the tooltip
     */
    public String getTooltip() {
<span class="fc" id="L8004">        return tooltip;</span>
    }

    /**
     * @param tooltip the tooltip to set
     */
    public void setTooltip(String tooltip) {
<span class="fc" id="L8011">        this.tooltip = tooltip;</span>
<span class="fc" id="L8012">    }</span>

<span class="fc" id="L8014">    class AnimationTransitionPainter implements Painter {</span>
        int alpha;
        Style originalStyle;
        Style destStyle;
        Painter original;
        Painter dest;

        public void paint(Graphics g, Rectangle rect) {
<span class="fc" id="L8022">            int oAlpha = g.getAlpha();</span>
<span class="pc bpc" id="L8023" title="1 of 2 branches missed.">            if (alpha == 0) {</span>
<span class="fc" id="L8024">                unSelectedStyle = originalStyle;</span>
<span class="fc" id="L8025">                original.paint(g, rect);</span>
<span class="fc" id="L8026">                return;</span>
            }
<span class="nc bnc" id="L8028" title="All 2 branches missed.">            if (alpha == 255) {</span>
<span class="nc" id="L8029">                unSelectedStyle = destStyle;</span>
<span class="nc" id="L8030">                dest.paint(g, rect);</span>
<span class="nc" id="L8031">                unSelectedStyle = originalStyle;</span>
<span class="nc" id="L8032">                return;</span>
            }
<span class="nc" id="L8034">            int opa = unSelectedStyle.getBgTransparency() &amp; 0xff;</span>
<span class="nc" id="L8035">            unSelectedStyle.setBgTransparency(255 - alpha);</span>
<span class="nc" id="L8036">            g.setAlpha(255 - alpha);</span>
<span class="nc" id="L8037">            original.paint(g, rect);</span>
<span class="nc" id="L8038">            unSelectedStyle.setBgTransparency(opa);</span>
<span class="nc" id="L8039">            unSelectedStyle = destStyle;</span>
<span class="nc" id="L8040">            opa = unSelectedStyle.getBgTransparency() &amp; 0xff;</span>
<span class="nc" id="L8041">            g.setAlpha(alpha);</span>
<span class="nc" id="L8042">            unSelectedStyle.setBgTransparency(alpha);</span>
<span class="nc" id="L8043">            dest.paint(g, rect);</span>
<span class="nc" id="L8044">            unSelectedStyle.setBgTransparency(opa);</span>
<span class="nc" id="L8045">            unSelectedStyle = originalStyle;</span>
<span class="nc" id="L8046">            g.setAlpha(oAlpha);</span>
<span class="nc" id="L8047">        }</span>
    }

    class BGPainter implements Painter, Animation {
        Image radialCache;
        CodenameOneImplementation impl;
        private Motion wMotion, hMotion;
        private Form previousTint;
        private Painter painter;
        private Style constantStyle;

<span class="fc" id="L8058">        public BGPainter(Motion wMotion, Motion hMotion) {</span>
<span class="fc" id="L8059">            this.wMotion = wMotion;</span>
<span class="fc" id="L8060">            this.hMotion = hMotion;</span>
<span class="fc" id="L8061">            impl = Display.impl;</span>
<span class="fc" id="L8062">        }</span>

<span class="fc" id="L8064">        public BGPainter() {</span>
<span class="fc" id="L8065">            impl = Display.impl;</span>
<span class="fc" id="L8066">        }</span>

<span class="fc" id="L8068">        public BGPainter(Style s) {</span>
<span class="fc" id="L8069">            constantStyle = s;</span>
<span class="fc" id="L8070">            impl = Display.impl;</span>
<span class="fc" id="L8071">        }</span>

<span class="fc" id="L8073">        public BGPainter(Form parent, Painter p) {</span>
<span class="fc" id="L8074">            this.painter = p;</span>
<span class="fc" id="L8075">            impl = Display.impl;</span>
<span class="fc" id="L8076">        }</span>

        public Form getPreviousForm() {
<span class="fc" id="L8079">            return previousTint;</span>
        }

        public void setPreviousForm(Form previous) {
<span class="fc" id="L8083">            previousTint = previous;</span>
<span class="fc" id="L8084">        }</span>

        public void paint(Graphics g, Rectangle rect) {
<span class="fc bfc" id="L8087" title="All 2 branches covered.">            if (painter != null) {</span>
<span class="pc bpc" id="L8088" title="1 of 2 branches missed.">                if (previousTint != null) {</span>
<span class="fc" id="L8089">                    previousTint.paint(g);</span>
                }
            } else {
                Style s;
<span class="fc bfc" id="L8093" title="All 2 branches covered.">                if (constantStyle != null) {</span>
<span class="fc" id="L8094">                    s = constantStyle;</span>
                } else {
<span class="fc" id="L8096">                    s = getStyle();</span>
                }
<span class="fc" id="L8098">                int x = rect.getX() + g.getTranslateX();</span>
<span class="fc" id="L8099">                int y = rect.getY() + g.getTranslateY();</span>
<span class="fc" id="L8100">                int width = rect.getSize().getWidth();</span>
<span class="fc" id="L8101">                int height = rect.getSize().getHeight();</span>
<span class="fc" id="L8102">                Image img = s.getBgImage();</span>
<span class="pc bpc" id="L8103" title="1 of 4 branches missed.">                if (img != null &amp;&amp; img.requiresDrawImage()) {</span>
                    // damn no native painting...
<span class="nc" id="L8105">                    int oldX = x;</span>
<span class="nc" id="L8106">                    int oldY = y;</span>
<span class="nc" id="L8107">                    x = rect.getX();</span>
<span class="nc" id="L8108">                    y = rect.getY();</span>
<span class="nc" id="L8109">                    int iW = img.getWidth();</span>
<span class="nc" id="L8110">                    int iH = img.getHeight();</span>
<span class="nc bnc" id="L8111" title="All 20 branches missed.">                    switch (s.getBackgroundType()) {</span>
                        case Style.BACKGROUND_IMAGE_SCALED:
<span class="nc bnc" id="L8113" title="All 2 branches missed.">                            if (Display.impl.isScaledImageDrawingSupported()) {</span>
<span class="nc" id="L8114">                                g.drawImage(img, x, y, width, height);</span>
                            } else {
<span class="nc bnc" id="L8116" title="All 4 branches missed.">                                if (iW != width || iH != height) {</span>
<span class="nc" id="L8117">                                    img = img.scaled(width, height);</span>
<span class="nc" id="L8118">                                    s.setBgImage(img, true);</span>
                                }
<span class="nc" id="L8120">                                g.drawImage(img, x, y);</span>
                            }
<span class="nc" id="L8122">                            return;</span>
                        case Style.BACKGROUND_IMAGE_SCALED_FILL:
<span class="nc" id="L8124">                            float r = Math.max(((float) width) / ((float) iW), ((float) height) / ((float) iH));</span>
<span class="nc" id="L8125">                            int bwidth = (int) (((float) iW) * r);</span>
<span class="nc" id="L8126">                            int bheight = (int) (((float) iH) * r);</span>
<span class="nc bnc" id="L8127" title="All 2 branches missed.">                            if (Display.impl.isScaledImageDrawingSupported()) {</span>
<span class="nc" id="L8128">                                g.drawImage(img, x + (width - bwidth) / 2, y + (height - bheight) / 2, bwidth, bheight);</span>
                            } else {
<span class="nc bnc" id="L8130" title="All 4 branches missed.">                                if (iW != bwidth || iH != bheight) {</span>
<span class="nc" id="L8131">                                    img = img.scaled(bwidth, bheight);</span>
<span class="nc" id="L8132">                                    s.setBgImage(img, true);</span>
                                }
<span class="nc" id="L8134">                                g.drawImage(img, x + (width - bwidth) / 2, y + (height - bheight) / 2);</span>
                            }
<span class="nc" id="L8136">                            return;</span>
                        case Style.BACKGROUND_IMAGE_SCALED_FIT:
<span class="nc bnc" id="L8138" title="All 2 branches missed.">                            if (s.getBgTransparency() != 0) {</span>
<span class="nc" id="L8139">                                g.setColor(s.getBgColor());</span>
<span class="nc" id="L8140">                                g.fillRect(x, y, width, height, s.getBgTransparency());</span>
                            }
<span class="nc" id="L8142">                            float r2 = Math.min(((float) width) / ((float) iW), ((float) height) / ((float) iH));</span>
<span class="nc" id="L8143">                            int awidth = (int) (((float) iW) * r2);</span>
<span class="nc" id="L8144">                            int aheight = (int) (((float) iH) * r2);</span>
<span class="nc bnc" id="L8145" title="All 2 branches missed.">                            if (Display.impl.isScaledImageDrawingSupported()) {</span>
<span class="nc" id="L8146">                                g.drawImage(img, x + (width - awidth) / 2, y + (height - aheight) / 2, awidth, aheight);</span>
                            } else {
<span class="nc bnc" id="L8148" title="All 4 branches missed.">                                if (iW != awidth || iH != aheight) {</span>
<span class="nc" id="L8149">                                    img = img.scaled(awidth, aheight);</span>
<span class="nc" id="L8150">                                    s.setBgImage(img, true);</span>
                                }
<span class="nc" id="L8152">                                g.drawImage(img, x + (width - awidth) / 2, y + (height - aheight) / 2, awidth, aheight);</span>
                            }
<span class="nc" id="L8154">                            return;</span>
                        case Style.BACKGROUND_IMAGE_TILE_BOTH:
<span class="nc" id="L8156">                            g.tileImage(img, x, y, width, height);</span>
<span class="nc" id="L8157">                            return;</span>
                        case Style.BACKGROUND_IMAGE_TILE_HORIZONTAL_ALIGN_TOP:
<span class="nc" id="L8159">                            g.setColor(s.getBgColor());</span>
<span class="nc" id="L8160">                            g.fillRect(x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L8161">                            g.tileImage(img, x, y, width, iH);</span>
<span class="nc" id="L8162">                            return;</span>
                        case Style.BACKGROUND_IMAGE_TILE_HORIZONTAL_ALIGN_CENTER:
<span class="nc" id="L8164">                            g.setColor(s.getBgColor());</span>
<span class="nc" id="L8165">                            g.fillRect(x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L8166">                            g.tileImage(img, x, y + (height / 2 - iH / 2), width, iH);</span>
<span class="nc" id="L8167">                            return;</span>
                        case Style.BACKGROUND_IMAGE_TILE_HORIZONTAL_ALIGN_BOTTOM:
<span class="nc" id="L8169">                            g.setColor(s.getBgColor());</span>
<span class="nc" id="L8170">                            g.fillRect(x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L8171">                            g.tileImage(img, x, y + (height - iH), width, iH);</span>
<span class="nc" id="L8172">                            return;</span>
                        case Style.BACKGROUND_IMAGE_TILE_VERTICAL_ALIGN_LEFT:
<span class="nc" id="L8174">                            g.setColor(s.getBgColor());</span>
<span class="nc" id="L8175">                            g.fillRect(x, y, width, height, s.getBgTransparency());</span>
<span class="nc bnc" id="L8176" title="All 2 branches missed.">                            for (int yPos = 0; yPos &lt;= height; yPos += iH) {</span>
<span class="nc" id="L8177">                                g.drawImage(img, x, y + yPos);</span>
                            }
<span class="nc" id="L8179">                            return;</span>
                        case Style.BACKGROUND_IMAGE_TILE_VERTICAL_ALIGN_CENTER:
<span class="nc" id="L8181">                            g.setColor(s.getBgColor());</span>
<span class="nc" id="L8182">                            g.fillRect(x, y, width, height, s.getBgTransparency());</span>
<span class="nc bnc" id="L8183" title="All 2 branches missed.">                            for (int yPos = 0; yPos &lt;= height; yPos += iH) {</span>
<span class="nc" id="L8184">                                g.drawImage(img, x + (width / 2 - iW / 2), y + yPos);</span>
                            }
<span class="nc" id="L8186">                            return;</span>
                        case Style.BACKGROUND_IMAGE_TILE_VERTICAL_ALIGN_RIGHT:
<span class="nc" id="L8188">                            g.setColor(s.getBgColor());</span>
<span class="nc" id="L8189">                            g.fillRect(x, y, width, height, s.getBgTransparency());</span>
<span class="nc bnc" id="L8190" title="All 2 branches missed.">                            for (int yPos = 0; yPos &lt;= height; yPos += iH) {</span>
<span class="nc" id="L8191">                                g.drawImage(img, x + width - iW, y + yPos);</span>
                            }
<span class="nc" id="L8193">                            return;</span>
                        case Style.BACKGROUND_IMAGE_ALIGNED_TOP:
<span class="nc" id="L8195">                            g.setColor(s.getBgColor());</span>
<span class="nc" id="L8196">                            g.fillRect(x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L8197">                            g.drawImage(img, x + (width / 2 - iW / 2), y);</span>
<span class="nc" id="L8198">                            return;</span>
                        case Style.BACKGROUND_IMAGE_ALIGNED_BOTTOM:
<span class="nc" id="L8200">                            g.setColor(s.getBgColor());</span>
<span class="nc" id="L8201">                            g.fillRect(x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L8202">                            g.drawImage(img, x + (width / 2 - iW / 2), y + (height - iH));</span>
<span class="nc" id="L8203">                            return;</span>
                        case Style.BACKGROUND_IMAGE_ALIGNED_LEFT:
<span class="nc" id="L8205">                            g.setColor(s.getBgColor());</span>
<span class="nc" id="L8206">                            g.fillRect(x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L8207">                            g.drawImage(img, x, y + (height / 2 - iH / 2));</span>
<span class="nc" id="L8208">                            return;</span>
                        case Style.BACKGROUND_IMAGE_ALIGNED_RIGHT:
<span class="nc" id="L8210">                            g.setColor(s.getBgColor());</span>
<span class="nc" id="L8211">                            g.fillRect(x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L8212">                            g.drawImage(img, x + width - iW, y + (height / 2 - iH / 2));</span>
<span class="nc" id="L8213">                            return;</span>
                        case Style.BACKGROUND_IMAGE_ALIGNED_CENTER:
<span class="nc" id="L8215">                            g.setColor(s.getBgColor());</span>
<span class="nc" id="L8216">                            g.fillRect(x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L8217">                            g.drawImage(img, x + (width / 2 - iW / 2), y + (height / 2 - iH / 2));</span>
<span class="nc" id="L8218">                            return;</span>
                        case Style.BACKGROUND_IMAGE_ALIGNED_TOP_LEFT:
<span class="nc" id="L8220">                            g.setColor(s.getBgColor());</span>
<span class="nc" id="L8221">                            g.fillRect(x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L8222">                            g.drawImage(img, x, y);</span>
<span class="nc" id="L8223">                            return;</span>
                        case Style.BACKGROUND_IMAGE_ALIGNED_TOP_RIGHT:
<span class="nc" id="L8225">                            g.setColor(s.getBgColor());</span>
<span class="nc" id="L8226">                            g.fillRect(x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L8227">                            g.drawImage(img, x + width - iW, y);</span>
<span class="nc" id="L8228">                            return;</span>
                        case Style.BACKGROUND_IMAGE_ALIGNED_BOTTOM_LEFT:
<span class="nc" id="L8230">                            g.setColor(s.getBgColor());</span>
<span class="nc" id="L8231">                            g.fillRect(x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L8232">                            g.drawImage(img, x, y + (height - iH));</span>
<span class="nc" id="L8233">                            return;</span>
                        case Style.BACKGROUND_IMAGE_ALIGNED_BOTTOM_RIGHT:
<span class="nc" id="L8235">                            g.setColor(s.getBgColor());</span>
<span class="nc" id="L8236">                            g.fillRect(x, y, width, height, s.getBgTransparency());</span>
<span class="nc" id="L8237">                            g.drawImage(img, x + width - iW, y + (height - iH));</span>
<span class="nc" id="L8238">                            return;</span>
                    }
<span class="nc" id="L8240">                    x = oldX;</span>
<span class="nc" id="L8241">                    y = oldY;</span>
                }

<span class="fc" id="L8244">                impl.paintComponentBackground(g.getGraphics(), x, y, width, height, s);</span>
            }
<span class="fc" id="L8246">        }</span>

        public boolean animate() {
<span class="pc bpc" id="L8249" title="2 of 4 branches missed.">            if (wMotion.isFinished() &amp;&amp; hMotion.isFinished()) {</span>
<span class="fc" id="L8250">                getComponentForm().deregisterAnimated(this);</span>
<span class="fc" id="L8251">                setPreferredSize(null);</span>
<span class="fc" id="L8252">                getComponentForm().revalidate();</span>
<span class="fc" id="L8253">                return false;</span>
            }
<span class="nc" id="L8255">            setPreferredSize(new Dimension(wMotion.getValue(), hMotion.getValue()));</span>
<span class="nc" id="L8256">            getComponentForm().revalidate();</span>
<span class="nc" id="L8257">            return false;</span>
        }

        public void paint(Graphics g) {
<span class="nc" id="L8261">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>