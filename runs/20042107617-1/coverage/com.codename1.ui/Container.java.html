<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Container.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codenameone-core-unittests</a> &gt; <a href="index.source.html" class="el_package">com.codename1.ui</a> &gt; <span class="el_source">Container.java</span></div><h1>Container.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores
 * CA 94065 USA or visit www.oracle.com if you need additional information or
 * have any questions.
 */
package com.codename1.ui;

import com.codename1.impl.CodenameOneImplementation;
import com.codename1.ui.animations.ComponentAnimation;
import com.codename1.ui.animations.Motion;
import com.codename1.ui.animations.Transition;
import com.codename1.ui.geom.Dimension;
import com.codename1.ui.geom.Rectangle;
import com.codename1.ui.layouts.BorderLayout;
import com.codename1.ui.layouts.BoxLayout;
import com.codename1.ui.layouts.FlowLayout;
import com.codename1.ui.layouts.LayeredLayout;
import com.codename1.ui.layouts.Layout;
import com.codename1.ui.plaf.LookAndFeel;
import com.codename1.ui.plaf.Style;
import com.codename1.ui.plaf.UIManager;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Vector;

/**
 * &lt;p&gt;A composite pattern with {@link Component}, allows nesting and arranging multiple
 * components using a pluggable layout manager architecture. Containers can be nested
 * one within the other to form elaborate UI's. By default Containers use {@link com.codename1.ui.layouts.FlowLayout}
 * which isn't ideal for most use cases.&lt;/p&gt;
 * &lt;img src=&quot;https://www.codenameone.com/img/developer-guide/component-uml.png&quot; alt=&quot;Component/Container Relationship Diagram&quot; /&gt;
 * &lt;p&gt;
 * Components within the Container &lt;b&gt;MUST&lt;/b&gt; be arranged using a layout manager! &lt;br&gt;
 * This allows the UI to adapt to different resolutions, DPI, orientation changes etc. seamlessly. Invoking any
 * bounds setting method will produce unpredictable results. To learn about layout managers check out the
 * &lt;a href=&quot;https://www.codenameone.com/manual/basics.html#_layout_managers&quot;&gt;relevant section in the developer guide&lt;/a&gt;.
 * &lt;/p&gt;
 * &lt;p&gt;
 * A container doesn't implicitly reflow its elements and in that regard follows the direction of AWT/Swing. As
 * a result the layout can be animated to create a flowing effect for UI changes. This also provides improved
 * performance as a bonus. See this sample of {@code Container} animation:
 * &lt;/p&gt;
 * &lt;script src=&quot;https://gist.github.com/codenameone/38c076760e309c066126.js&quot;&gt;&lt;/script&gt;
 *
 * &lt;p&gt;
 * Many components within Codename One (e.g. {@link com.codename1.ui.tree.Tree},
 * {@link com.codename1.ui.table.Table},
 * {@link com.codename1.components.MultiButton} etc.) derive from Container instead of Component. This allows
 * such components to provide very rich functionality by building on top of the existing functionality.
 * Container also provides the lead component functionality that allows treating an entire Container hierarchy
 * as a single component. This is discussed in depth within the &lt;a href=&quot;https://www.codenameone.com/manual/misc-features.html#_lead_component&quot;&gt;developer guide&lt;/a&gt;.
 * &lt;/p&gt;
 *
 * @author Chen Fishbein
 * @see com.codename1.ui.layouts
 * @see Component
 */
public class Container extends Component implements Iterable&lt;Component&gt; {
<span class="fc" id="L81">    static boolean enableLayoutOnPaint = true;</span>
    /**
     * Workaround for the behavior of the sidemenu bar on iOS etc. which translates aggressively,
     * this is visible with the table component where the lines slide out of place
     */
    static int sidemenuBarTranslation;
<span class="fc" id="L87">    static boolean blockOverdraw = false;</span>
    boolean scrollableX;
    boolean scrollableY;
    /**
     * A set used in {@link #paintElevatedPane(Graphics)} to gather all of the elevated descendent components
     * of this container.
     */
    ArrayList&lt;Component&gt; _tmpRenderingElevatedComponents;
    // A 2nd flag for enabling layout on paint.  In order for layoutOnPaint to occur,
    // both the enableLayoutOnPaint and allowEnableLayoutOnPaint flags must be true.
    // This flag can be set on any Container (e.g. form), and will cause it to be propagated
    // down to its children.  So you can set this at the form level, in order to enable this behaviour
    // for the whole form.
<span class="fc" id="L100">    private boolean allowEnableLayoutOnPaint = false;</span>
    private Component leadComponent;
    private Layout layout;
<span class="fc" id="L103">    private final java.util.ArrayList&lt;Component&gt; components = new java.util.ArrayList&lt;Component&gt;();</span>
    /**
     * A queue that keeps track of changes to the children while an animation is in progress.
     *
     * @see #getChildrenAsList(boolean)
     * @see #iterator(boolean)
     * @see #insertComponentAt(int, java.lang.Object, com.codename1.ui.Component)
     * @see #removeComponentImpl(com.codename1.ui.Component)
     */
<span class="fc" id="L112">    private final java.util.ArrayList&lt;QueuedChange&gt; changeQueue = new java.util.ArrayList&lt;QueuedChange&gt;();</span>
<span class="fc" id="L113">    private boolean shouldLayout = true;</span>
    private java.util.Vector cmpTransitions;
<span class="fc" id="L115">    private int scrollIncrement = 20;</span>
<span class="fc" id="L116">    private boolean blockFocus = false;</span>
    private boolean dontRecurseContainer;
    private UIManager uiManager;
    private boolean surface;
    private boolean revalidatePending;
    /**
     * Set to keep track of elevated components to render against this surface.
     */
    private HashSet&lt;Component&gt; elevatedComponents;
    /**
     * Index variable used to assign indices to components within the same elevation level.
     */
    private int nextElevationComponentIndex;
    /**
     * Flag to
     */
    private boolean safeArea;
    /**
     * Indicates that this container is a &quot;safe area&quot; root.
     */
    private boolean safeAreaRoot;
    private TmpInsets tmpInsets;
    private int doLayoutDepth;
    private TmpInsets calcTmpInsets;
    private int calcPreferredSizeDepth;

    /**
     * Constructs a new Container with a new layout manager and UIID
     *
     * @param layout the specified layout manager
     * @param uiid   the uiid of the container
     */
    public Container(Layout layout, String uiid) {
<span class="fc" id="L149">        super();</span>
<span class="fc" id="L150">        setUIID(uiid);</span>
<span class="fc" id="L151">        this.layout = layout;</span>
<span class="fc" id="L152">        setFocusable(false);</span>
<span class="fc" id="L153">    }</span>

    /**
     * Constructs a new Container with a new layout manager.
     *
     * @param layout the specified layout manager
     */
    public Container(Layout layout) {
<span class="fc" id="L161">        this(layout, &quot;Container&quot;);</span>
<span class="fc" id="L162">    }</span>


    /**
     * Constructs a new Container, with a {@link FlowLayout}.
     */
    public Container() {
<span class="fc" id="L169">        this(new FlowLayout());</span>
<span class="fc" id="L170">    }</span>

    /**
     * Short-hand for enclosing a component within a Container
     *
     * @param l    the layout
     * @param cmp  the component to enclose
     * @param cons the constraint for the component
     * @return a newly created container containing the given component
     */
    public static Container encloseIn(Layout l, Component cmp, Object cons) {
<span class="fc" id="L181">        Container cnt = new Container(l);</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">        if (cons instanceof Component) {</span>
            // this got sent to the wong method by dumb compiler...
<span class="fc" id="L184">            return cnt.add(cmp).add((Component) cons);</span>
        }
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        if (cons != null) {</span>
<span class="fc" id="L187">            cnt.addComponent(cons, cmp);</span>
        } else {
<span class="nc" id="L189">            cnt.addComponent(cmp);</span>
        }
<span class="fc" id="L191">        return cnt;</span>
    }

    /**
     * Short-hand for enclosing multiple components in a container typically a box layout
     *
     * @param l   the layout
     * @param cmp the components to enclose
     * @return a newly created container containing the given components
     */
    public static Container encloseIn(Layout l, Component... cmp) {
<span class="fc" id="L202">        Container cnt = new Container(l);</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">        for (Component c : cmp) {</span>
<span class="fc" id="L204">            cnt.addComponent(c);</span>
        }
<span class="fc" id="L206">        return cnt;</span>
    }

    /**
     * {@inheritDoc}
     */
    protected void initLaf(UIManager uim) {
<span class="fc bfc" id="L213" title="All 4 branches covered.">        if (uim == getUIManager() &amp;&amp; isInitialized()) {</span>
<span class="fc" id="L214">            return;</span>
        }
<span class="fc" id="L216">        super.initLaf(uim);</span>
<span class="fc" id="L217">        LookAndFeel laf = uim.getLookAndFeel();</span>
<span class="fc" id="L218">        setSmoothScrolling(laf.isDefaultSmoothScrolling());</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">        if (components != null) {</span>
<span class="fc" id="L220">            int count = getComponentCount();</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">            for (int i = 0; i &lt; count; i++) {</span>
<span class="fc" id="L222">                Component c = getComponentAt(i);</span>
<span class="fc" id="L223">                c.initLaf(uim);</span>
            }
        }

<span class="fc" id="L227">    }</span>

    /**
     * {@inheritDoc}
     */
    public UIManager getUIManager() {
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">        if (uiManager != null) {</span>
<span class="nc" id="L234">            return uiManager;</span>
        }
<span class="fc" id="L236">        return super.getUIManager();</span>
    }

    /**
     * Allows replacing the UIManager in a component hierarchy to update the look and feel
     * only to a specific hierarchy
     *
     * @param uiManager UIManager instance
     */
    public void setUIManager(UIManager uiManager) {
<span class="nc" id="L246">        this.uiManager = uiManager;</span>
<span class="nc" id="L247">    }</span>

    /**
     * An atomic operation that wraps the current component in a Container with
     * a layered layout.  This prevents us from having to initialize and deinitialize
     * all of the components in a sub-tree because we want to re-root it.  In particular
     * Form.getLayeredPane() re-roots the entire content pane the first time it is
     * called on a form.  If the form contains native peers there is a flicker which
     * is quite annoying.  Providing a way to do this atomically results in a better
     * user experience.
     *
     * @return The Container that is the new parent of this component.
     */
    Container wrapInLayeredPane() {
<span class="fc" id="L261">        final Container oldParent = getParent();</span>
<span class="fc" id="L262">        final Container newParent = new Container(new LayeredLayout());</span>
<span class="pc bpc" id="L263" title="2 of 4 branches missed.">        final Layout parentLayout = oldParent != null &amp;&amp; oldParent.layout != null ? oldParent.layout : null;</span>
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">        final Object constraint = parentLayout != null ? parentLayout.getComponentConstraint(this) : null;</span>
<span class="fc" id="L265">        newParent.setParent(oldParent);</span>
<span class="fc" id="L266">        newParent.components.add(this);</span>

<span class="fc" id="L268">        final Runnable r = new Runnable() {</span>
            public void run() {
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">                if (parentLayout != null) {</span>
<span class="fc" id="L271">                    parentLayout.removeLayoutComponent(Container.this);</span>
<span class="fc" id="L272">                    parentLayout.addLayoutComponent(constraint, newParent, oldParent);</span>
                }

<span class="fc" id="L275">                newParent.initComponentImpl();</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">                if (oldParent != null) {</span>
<span class="fc" id="L277">                    int cmpIndex = -1;</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">                    for (int i = 0; i &lt; oldParent.getComponentCount(); i++) {</span>
<span class="fc" id="L279">                        Component c = oldParent.getComponentAt(i);</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">                        if (c.equals(Container.this)) {</span>
<span class="fc" id="L281">                            cmpIndex = i;</span>
<span class="fc" id="L282">                            break;</span>
                        }
                    }
                    //int cmpIndex = oldParent.getComponentIndex(Container.this);  &lt;---  WTF... this always returns -1!!
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">                    if (cmpIndex == -1) {</span>
<span class="nc" id="L287">                        throw new RuntimeException(&quot;WTF we have parent but no index!!!!&quot;);</span>
                    }
<span class="fc" id="L289">                    oldParent.components.set(cmpIndex, newParent);</span>
                }

<span class="fc" id="L292">                Container.this.setParent(newParent);</span>

<span class="fc" id="L294">                newParent.revalidate();</span>
<span class="fc" id="L295">            }</span>
        };
<span class="fc" id="L297">        AnimationManager a = getAnimationManager();</span>
<span class="pc bpc" id="L298" title="2 of 4 branches missed.">        if (a != null &amp;&amp; a.isAnimating()) {</span>

<span class="nc" id="L300">            a.addAnimation(new ComponentAnimation() {</span>
                @Override
                public boolean isInProgress() {
<span class="nc" id="L303">                    return false;</span>
                }

                @Override
                protected void updateState() {
<span class="nc" id="L308">                    r.run();</span>
<span class="nc" id="L309">                }</span>
            });
<span class="nc" id="L311">            return newParent;</span>
        } else {
<span class="fc" id="L313">            r.run();</span>
<span class="fc" id="L314">            return newParent;</span>
        }

    }

    /**
     * Checks if this container acts as a Material Design surface.  &quot;Surface&quot; containers render drop-shadows for their
     * elevated descendents.
     *
     * @return True if this container is a surface.
     * @since 8.0
     */
    public boolean isSurface() {
<span class="fc" id="L327">        return surface;</span>
    }

    /**
     * Enables or disables &quot;surface&quot; features for this container.  If {@literal surface} is true, then the container
     * will act as a surface.  As such, it will paint the drop-shadows for elevated descendents.
     *
     * @param surface True to set this container as a surface.
     * @see Style#getElevation()
     * @see Component#paintShadows(Graphics, int, int)
     * @since 8.0
     */
    void setSurface(boolean surface) {
<span class="fc bfc" id="L340" title="All 2 branches covered.">        if (surface != this.surface) {</span>
<span class="fc" id="L341">            this.surface = surface;</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">            if (!surface) {</span>
                // This is not a surface anymore.  We need to take all of the
                // elevated components that currently project against this surface
                // and reevaluate which surface they should project onto
<span class="nc bnc" id="L346" title="All 4 branches missed.">                if (elevatedComponents != null &amp;&amp; !elevatedComponents.isEmpty()) {</span>
<span class="nc" id="L347">                    ArrayList&lt;Component&gt; toProcess = new ArrayList&lt;Component&gt;(elevatedComponents);</span>
<span class="nc" id="L348">                    elevatedComponents.clear();</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">                    for (Component elevated : toProcess) {</span>
<span class="nc" id="L350">                        elevated.registerElevatedInternal(elevated);</span>
<span class="nc" id="L351">                    }</span>
<span class="nc" id="L352">                }</span>
            } else {
                // We are now a surface.  See if there are any projections against parent the parent
                // surface that this should intercept
<span class="fc" id="L356">                Container parentSurface = findSurface();</span>
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">                if (parentSurface != null) {</span>
<span class="nc bnc" id="L358" title="All 4 branches missed.">                    if (parentSurface.elevatedComponents != null &amp;&amp; !parentSurface.elevatedComponents.isEmpty()) {</span>
<span class="nc" id="L359">                        ArrayList&lt;Component&gt; toProcess = new ArrayList&lt;Component&gt;(parentSurface.elevatedComponents);</span>

<span class="nc bnc" id="L361" title="All 2 branches missed.">                        for (Component elevated : toProcess) {</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">                            if (contains(elevated)) {</span>
                                // This component is actually inside us, so it should project on
                                // us now.
<span class="nc" id="L365">                                elevated.registerElevatedInternal(elevated);</span>
                            }
<span class="nc" id="L367">                        }</span>
                    }
                }

            }
        }

<span class="fc" id="L374">    }</span>

    /**
     * Simpler version of addComponent that allows chaining the calls for shorter syntax
     *
     * @param cmp the component to add
     * @return this for call chaining
     */
    public Container add(Component cmp) {
<span class="fc" id="L383">        addComponent(cmp);</span>
<span class="fc" id="L384">        return this;</span>
    }

    /**
     * Identical to add(x).add(y) only with a shorter syntax
     *
     * @param cmps the other components to add
     * @return this for call chaining
     */
    public Container addAll(Component... cmps) {
<span class="fc bfc" id="L394" title="All 2 branches covered.">        for (Component c : cmps) {</span>
<span class="fc" id="L395">            addComponent(c);</span>
        }
<span class="fc" id="L397">        return this;</span>
    }

    /**
     * Simpler version of addComponent that allows chaining the calls for shorter syntax
     *
     * @param constraint the layout constraint if applicable
     * @param cmp        the component to add
     * @return this for call chaining
     */
    public Container add(Object constraint, Component cmp) {
<span class="fc" id="L408">        addComponent(constraint, cmp);</span>
<span class="fc" id="L409">        return this;</span>
    }

    /**
     * Simpler version of addComponent that allows chaining the calls for shorter syntax
     *
     * @param label a string that will be wrapped as a label, this is equivalent to calling add(new Label(l))
     * @return this for call chaining
     */
    public Container add(String label) {
<span class="nc" id="L419">        return add(new Label(label));</span>
    }

    /**
     * Simpler version of addComponent that allows chaining the calls for shorter syntax
     *
     * @param img an image that will be wrapped as a label, this is equivalent to calling add(new Label(l))
     * @return this for call chaining
     */
    public Container add(Image img) {
<span class="nc" id="L429">        return add(new Label(img));</span>
    }

    /**
     * Simpler version of addComponent that allows chaining the calls for shorter syntax
     *
     * @param constraint the layout constraint if applicable
     * @param label      a component that will be wrapped as a label, this is equivalent to calling add(new Label(l))
     * @return this for call chaining
     */
    public Container add(Object constraint, String label) {
<span class="nc" id="L440">        return add(constraint, new Label(label));</span>
    }

    /**
     * Simpler version of addComponent that allows chaining the calls for shorter syntax
     *
     * @param constraint the layout constraint if applicable
     * @param img        an image that will be wrapped as a label, this is equivalent to calling add(new Label(l))
     * @return this for call chaining
     */
    public Container add(Object constraint, Image img) {
<span class="nc" id="L451">        return add(constraint, new Label(img));</span>
    }

    void focusGainedInternal() {
<span class="fc" id="L455">        super.focusGainedInternal();</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">        if (leadComponent != null) {</span>
<span class="fc" id="L457">            setFocusLead(true);</span>
        }
<span class="fc" id="L459">    }</span>

    void focusLostInternal() {
<span class="fc" id="L462">        super.focusLostInternal();</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">        if (leadComponent != null) {</span>
<span class="fc" id="L464">            setFocusLead(false);</span>
        }
<span class="fc" id="L466">    }</span>

    /**
     * Returns the lead component for this hierarchy if such a component is defined
     *
     * @return the lead component
     */
    public Component getLeadComponent() {

<span class="fc bfc" id="L475" title="All 2 branches covered.">        if (leadComponent != null) {</span>
<span class="fc" id="L476">            return leadComponent;</span>
        }
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">        if (isBlockLead()) {</span>
<span class="nc" id="L479">            return null;</span>
        }
<span class="fc bfc" id="L481" title="All 2 branches covered.">        if (hasLead) {</span>
<span class="fc" id="L482">            return super.getLeadComponent();</span>
        }
<span class="fc" id="L484">        return null;</span>
    }

    /**
     * Sets the lead component for this container, a lead component takes over the entire
     * component hierarchy and receives all the events for the container hierarchy.
     *
     * @param lead component that takes over the hierarchy
     */
    public void setLeadComponent(Component lead) {
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">        if (lead == leadComponent) {</span>
<span class="nc" id="L495">            return;</span>
        }
<span class="fc" id="L497">        leadComponent = lead;</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">        if (lead == null) {</span>
            // clear the lead component from the hierarchy

<span class="pc bpc" id="L501" title="3 of 6 branches missed.">            if (!isBlockLead() &amp;&amp; getParent() != null &amp;&amp; getParent().hasLead) {</span>
                // hasLead should still be true because of parent lead

            } else {
<span class="fc" id="L505">                setFocusable(false);</span>
<span class="fc" id="L506">                hasLead = false;</span>
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">                if (isInitialized()) {</span>
<span class="fc" id="L508">                    enableFocusAndDeinitLead(this);</span>
                }
            }

        } else {
<span class="fc bfc" id="L513" title="All 2 branches covered.">            if (isInitialized()) {</span>
<span class="fc" id="L514">                initLead();</span>
            }
        }
<span class="fc" id="L517">    }</span>

    /**
     * Returns the lead container thats handling the leading, this is useful for
     * a container hierarchy where the parent container might not be the leader
     *
     * @return the lead component
     */
    public Container getLeadParent() {

<span class="fc bfc" id="L527" title="All 2 branches covered.">        if (leadComponent != null) {</span>
<span class="fc" id="L528">            return this;</span>
        }
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">        if (isBlockLead()) {</span>
<span class="nc" id="L531">            return null;</span>
        }
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">        if (hasLead) {</span>
<span class="nc" id="L534">            return getParent().getLeadParent();</span>
        }
<span class="fc" id="L536">        return null;</span>
    }

    private void initLead() {
<span class="fc" id="L540">        disableFocusAndInitLead(this);</span>
<span class="fc" id="L541">        setFocusable(true);</span>
<span class="pc bpc" id="L542" title="3 of 4 branches missed.">        hasLead = leadComponent != null || !isBlockLead();</span>
<span class="fc" id="L543">    }</span>

    /**
     * {@inheritDoc}
     */
    public void keyPressed(int k) {
<span class="nc bnc" id="L549" title="All 2 branches missed.">        if (leadComponent != null) {</span>
<span class="nc" id="L550">            leadComponent.keyPressed(k);</span>
<span class="nc" id="L551">            repaint();</span>
        }
<span class="nc" id="L553">    }</span>

    /**
     * {@inheritDoc}
     */
    public void keyReleased(int k) {
<span class="nc bnc" id="L559" title="All 2 branches missed.">        if (leadComponent != null) {</span>
<span class="nc" id="L560">            leadComponent.keyReleased(k);</span>
<span class="nc" id="L561">            repaint();</span>
        }
<span class="nc" id="L563">    }</span>

    private void disableFocusAndInitLead(Container c) {
<span class="fc bfc" id="L566" title="All 2 branches covered.">        for (int iter = 0; iter &lt; c.getComponentCount(); iter++) {</span>
<span class="fc" id="L567">            Component cu = c.getComponentAt(iter);</span>
<span class="fc" id="L568">            boolean isContainer = (cu instanceof Container);</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">            if (!cu.isBlockLead()) {</span>
<span class="fc" id="L570">                cu.setFocusable(false);</span>
            }
<span class="fc bfc" id="L572" title="All 2 branches covered.">            if (isContainer) {</span>
<span class="pc bpc" id="L573" title="1 of 4 branches missed.">                cu.hasLead = ((Container) cu).leadComponent != null || !cu.isBlockLead();</span>
            } else {
<span class="fc bfc" id="L575" title="All 2 branches covered.">                cu.hasLead = !cu.isBlockLead();</span>
            }
<span class="pc bpc" id="L577" title="1 of 4 branches missed.">            if (isContainer &amp;&amp; cu.hasLead) {</span>
<span class="fc" id="L578">                disableFocusAndInitLead((Container) cu);</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">                if (((Container) cu).leadComponent != null) {</span>
<span class="fc" id="L580">                    cu.setFocusable(true);</span>
                }

            }

        }
<span class="fc" id="L586">    }</span>

    private void enableFocusAndDeinitLead(Container c) {
<span class="fc bfc" id="L589" title="All 2 branches covered.">        for (int iter = 0; iter &lt; c.getComponentCount(); iter++) {</span>
<span class="fc" id="L590">            Component cu = c.getComponentAt(iter);</span>
<span class="fc" id="L591">            boolean isContainer = (cu instanceof Container);</span>
<span class="pc bpc" id="L592" title="1 of 2 branches missed.">            if (isContainer) {</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">                cu.hasLead = ((Container) cu).leadComponent != null;</span>
            } else {
<span class="fc" id="L595">                cu.hasLead = false;</span>
            }
<span class="pc bpc" id="L597" title="3 of 4 branches missed.">            if (isContainer &amp;&amp; !cu.hasLead) {</span>
<span class="nc" id="L598">                enableFocusAndDeinitLead((Container) cu);</span>
            }
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">            if (!cu.hasLead) {</span>
<span class="fc" id="L601">                cu.resetFocusable();</span>
            }
        }
<span class="fc" id="L604">    }</span>

    /**
     * Returns the layout manager responsible for arranging this container.
     *
     * @return the container layout manager
     */
    public Layout getLayout() {
<span class="fc" id="L612">        return layout;</span>
    }

    /**
     * Sets the layout manager responsible for arranging this container
     *
     * @param layout the specified layout manager
     */
    public void setLayout(Layout layout) {
<span class="fc bfc" id="L621" title="All 2 branches covered.">        if (layout.isConstraintTracking()) {</span>
<span class="pc bpc" id="L622" title="1 of 2 branches missed.">            for (int iter = 0; iter &lt; getComponentCount(); iter++) {</span>
<span class="nc" id="L623">                Component c = getComponentAt(iter);</span>
<span class="nc" id="L624">                Object cons = this.layout.getComponentConstraint(c);</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">                if (cons != null) {</span>
<span class="nc" id="L626">                    layout.addLayoutComponent(cons, c, this);</span>
                }
            }
        }
<span class="fc" id="L630">        this.layout = layout;</span>
<span class="fc bfc" id="L631" title="All 4 branches covered.">        if (layout instanceof BorderLayout &amp;&amp; isScrollable()) {</span>
<span class="fc" id="L632">            setScrollable(false);</span>
        }
<span class="fc" id="L634">    }</span>

    /**
     * Returns the actual layout of this container.  For most components this just
     * wraps {@link #getLayout()}, but some classes (e.g. Form) don't return their
     * *actual* layout.  In such cases, this method will return the component's *actual*
     * layout.
     *
     * @return
     */
    final Layout getActualLayout() {
<span class="fc" id="L645">        return layout;</span>
    }

    /**
     * Same as setShouldCalcPreferredSize(true) but made accessible for
     * layout managers
     */
    public void invalidate() {
<span class="fc" id="L653">        setShouldCalcPreferredSize(true);</span>
<span class="fc" id="L654">    }</span>

    /**
     * Flags this container to preform layout
     *
     * @param layout
     */
    protected void setShouldLayout(boolean layout) {
<span class="fc bfc" id="L662" title="All 2 branches covered.">        if (!shouldCalcScrollSize) {</span>
<span class="fc" id="L663">            this.shouldCalcScrollSize = layout;</span>
        }
<span class="fc bfc" id="L665" title="All 2 branches covered.">        if (shouldLayout != layout) {</span>
<span class="fc" id="L666">            shouldLayout = layout;</span>
<span class="fc" id="L667">            shouldCalcPreferredSize = layout;</span>
<span class="fc" id="L668">            shouldCalcScrollSize = layout;</span>
<span class="fc" id="L669">            int componentCount = components.size();</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">            for (int iter = 0; iter &lt; componentCount; iter++) {</span>
<span class="fc" id="L671">                Component cmp = components.get(iter);</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">                if (cmp instanceof Container) {</span>
<span class="fc" id="L673">                    cmp.setShouldCalcPreferredSize(shouldCalcPreferredSize);</span>
                }
            }
<span class="fc" id="L676">            Container parent = getParent();</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">            if (parent != null) {</span>
<span class="fc" id="L678">                parent.setShouldLayout(layout);</span>
            }
        }
<span class="fc" id="L681">    }</span>

    /**
     * {@inheritDoc}
     */
    public void setShouldCalcPreferredSize(boolean shouldCalcPreferredSize) {
        // minor optimization preventing repeated invokations to setShouldCalcPreferredSize
<span class="fc bfc" id="L688" title="All 8 branches covered.">        if (shouldCalcPreferredSize &amp;&amp; this.shouldLayout &amp;&amp; this.shouldCalcPreferredSize &amp;&amp; !isInitialized()) {</span>
<span class="fc" id="L689">            Container p = getParent();</span>
<span class="fc bfc" id="L690" title="All 6 branches covered.">            if (p != null &amp;&amp; p.shouldLayout &amp;&amp; p.shouldCalcPreferredSize) {</span>
<span class="fc" id="L691">                return;</span>
            }
        }
<span class="fc" id="L694">        super.setShouldCalcPreferredSize(shouldCalcPreferredSize);</span>
<span class="fc" id="L695">        shouldLayout = shouldCalcPreferredSize;</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">        if (shouldLayout) {</span>
<span class="fc" id="L697">            int componentCount = components.size();</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">            for (int iter = 0; iter &lt; componentCount; iter++) {</span>
<span class="fc" id="L699">                Component cmp = components.get(iter);</span>
<span class="fc bfc" id="L700" title="All 2 branches covered.">                if (cmp instanceof Container) {</span>
<span class="fc" id="L701">                    cmp.setShouldCalcPreferredSize(shouldCalcPreferredSize);</span>
                }
            }
        }
<span class="fc" id="L705">    }</span>

    /**
     * Returns the width for layout manager purposes, this takes scrolling
     * into consideration unlike the getWidth method.
     *
     * @return the layout width
     */
    public int getLayoutWidth() {
<span class="fc bfc" id="L714" title="All 2 branches covered.">        if (scrollableX) {</span>
<span class="fc" id="L715">            return Math.max(getWidth(), getPreferredW());</span>
        } else {
<span class="fc" id="L717">            Container parent = getScrollableParentX();</span>
<span class="pc bpc" id="L718" title="1 of 4 branches missed.">            if (parent != null &amp;&amp; parent.scrollableX) {</span>
<span class="nc" id="L719">                return Math.max(getWidth(), getPreferredW());</span>
            }
<span class="fc" id="L721">            int width = getWidth();</span>
<span class="fc bfc" id="L722" title="All 2 branches covered.">            if (width &lt;= 0) {</span>
<span class="fc" id="L723">                return getPreferredW();</span>
            }
<span class="fc" id="L725">            return width;</span>
        }
    }

    /**
     * Returns the height for layout manager purposes, this takes scrolling
     * into consideration unlike the getHeight method.
     *
     * @return the layout height
     */
    public int getLayoutHeight() {
<span class="fc bfc" id="L736" title="All 2 branches covered.">        if (scrollableY) {</span>
<span class="fc" id="L737">            return Math.max(getHeight(), getPreferredH());</span>
        } else {
<span class="fc" id="L739">            Container parent = getScrollableParentY();</span>
<span class="fc bfc" id="L740" title="All 4 branches covered.">            if (parent != null &amp;&amp; parent.scrollableY) {</span>
<span class="fc" id="L741">                return Math.max(getHeight(), getPreferredH());</span>
            }
<span class="fc" id="L743">            int height = getHeight();</span>
<span class="fc bfc" id="L744" title="All 2 branches covered.">            if (height &lt;= 1) {</span>
<span class="fc" id="L745">                return getPreferredH();</span>
            }
<span class="fc" id="L747">            return height;</span>
        }
    }

    /**
     * Invokes apply/setRTL recursively on all the children components of this container
     *
     * @param rtl right to left bidi indication
     * @see Component#setRTL(boolean)
     */
    public void applyRTL(boolean rtl) {
<span class="nc" id="L758">        setRTL(rtl);</span>
<span class="nc" id="L759">        int c = getComponentCount();</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">        for (int iter = 0; iter &lt; c; iter++) {</span>
<span class="nc" id="L761">            Component current = getComponentAt(iter);</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">            if (current instanceof Container) {</span>
<span class="nc" id="L763">                ((Container) current).applyRTL(rtl);</span>
            } else {
<span class="nc" id="L765">                current.setRTL(rtl);</span>
            }
        }
<span class="nc" id="L768">    }</span>

    /**
     * Returns a parent container that is scrollableX or null if no parent is
     * scrollable.
     * &lt;p&gt;
     * NOTE:  This is a utility method that is designed for the getLayoutWidth()
     * method, which is why it obeys the constrainHeightWhenScrollable() attribute.
     *
     * @return a parent container that is scrollable or null if no parent is
     * scrollable.
     */
    private Container getScrollableParentX() {
<span class="fc" id="L781">        Container parent = getParent();</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">        while (parent != null) {</span>
<span class="pc bpc" id="L783" title="3 of 4 branches missed.">            if (parent.scrollableX &amp;&amp; !parent.constrainWidthWhenScrollable()) {</span>
<span class="nc" id="L784">                return parent;</span>
            }
<span class="fc bfc" id="L786" title="All 2 branches covered.">            if (parent.hasFixedPreferredSize()) {</span>
<span class="fc" id="L787">                return parent;</span>
            }
<span class="fc" id="L789">            parent = parent.getParent();</span>
        }
<span class="fc" id="L791">        return null;</span>
    }

    /**
     * Returns a parent container that is scrollableY or null if no parent is
     * scrollable.
     * &lt;p&gt;
     * NOTE:  This is a utility method that is designed for the getLayoutHeight()
     * method, which is why it obeys the constrainHeightWhenScrollable() attribute.
     *
     * @return a parent container that is scrollable or null if no parent is
     * scrollable.
     */
    private Container getScrollableParentY() {
<span class="fc" id="L805">        Container parent = getParent();</span>
<span class="fc bfc" id="L806" title="All 2 branches covered.">        while (parent != null) {</span>
<span class="pc bpc" id="L807" title="1 of 4 branches missed.">            if (parent.scrollableY &amp;&amp; !parent.constrainHeightWhenScrollable()) {</span>
<span class="fc" id="L808">                return parent;</span>
            }
<span class="fc bfc" id="L810" title="All 2 branches covered.">            if (parent.hasFixedPreferredSize()) {</span>
<span class="fc" id="L811">                return parent;</span>
            }
<span class="fc" id="L813">            parent = parent.getParent();</span>
        }
<span class="fc" id="L815">        return null;</span>
    }

    /**
     * Indicates that children's widths should be calculated as if this component weren't
     * scrollable-X, even when the component is scrollable X.  Normally, when a component
     * is figuring out its layout width, it will walk up the UI hierarchy to find the
     * first scrollable container.  If there is a scrollable container, then the component
     * will try to grow as big as it wants.  If there are no scrollable containers found,
     * it will constrain itself to the space available.   In some cases, we may want the children
     * of a component to lay themselves out conservatively though because it wants to use its
     * scrollability for other features.
     *
     * @return True if children should calculate their layout widgets as if the component
     * weren't scrollable.
     * @since 7.0
     */
    protected boolean constrainWidthWhenScrollable() {
<span class="nc" id="L833">        return false;</span>
    }

    /**
     * Indicates that children's widths should be calculated as if this component weren't
     * scrollable-X, even when the component is scrollable Y.  Normally, when a component
     * is figuring out its layout width, it will walk up the UI hierarchy to find the
     * first scrollable container.  If there is a scrollable container, then the component
     * will try to grow as big as it wants.  If there are no scrollable containers found,
     * it will constrain itself to the space available.   In some cases, we may want the children
     * of a component to lay themselves out conservatively though because it wants to use its
     * scrollability for other features.
     *
     * @return True if children should calculate their layout widgets as if the component
     * weren't scrollable.
     * @since 7.0
     */
    protected boolean constrainHeightWhenScrollable() {
<span class="fc" id="L851">        return false;</span>
    }

    /**
     * Adds a Component to the Container
     *
     * @param cmp the component to be added
     */
    public void addComponent(Component cmp) {
<span class="fc" id="L860">        layout.addLayoutComponent(null, cmp, this);</span>
<span class="fc" id="L861">        insertComponentAt(Integer.MAX_VALUE, null, cmp);</span>
<span class="fc" id="L862">    }</span>

    /**
     * Adds a Component to the Container
     *
     * @param constraints this method is useful when the Layout requires a constraint
     *                    such as the BorderLayout.
     *                    In this case you need to specify an additional data when you add a Component,
     *                    such as &quot;CENTER&quot;, &quot;NORTH&quot;...
     * @param cmp         component to add
     */
    public void addComponent(final Object constraints, final Component cmp) {
<span class="fc" id="L874">        layout.addLayoutComponent(constraints, cmp, this);</span>
<span class="fc" id="L875">        insertComponentAt(Integer.MAX_VALUE, null, cmp);</span>
<span class="fc" id="L876">    }</span>

    /**
     * Adds a Component to the Container
     *
     * @param index       location to insert the Component
     * @param constraints this method is useful when the Layout requires a constraint
     *                    such as the BorderLayout.
     *                    In this case you need to specify an additional data when you add a Component,
     *                    such as &quot;CENTER&quot;, &quot;NORTH&quot;...
     * @param cmp         component to add
     */
    public void addComponent(int index, Object constraints, Component cmp) {
<span class="nc" id="L889">        insertComponentAt(index, constraints, cmp);</span>
<span class="nc" id="L890">    }</span>

    void insertComponentAt(final int index, final Object constraint, final Component cmp) {
<span class="fc" id="L893">        final AnimationManager a = getAnimationManager();</span>
<span class="fc bfc" id="L894" title="All 4 branches covered.">        if (a != null &amp;&amp; a.isAnimating()) {</span>
            // pretend like the component was already added
<span class="pc bpc" id="L896" title="1 of 2 branches missed.">            if (cmp.getParent() != null) {</span>
<span class="nc" id="L897">                throw new IllegalArgumentException(&quot;Component is already contained in Container: &quot; + cmp.getParent());</span>
            }
<span class="fc" id="L899">            cmp.setParent(this);</span>

<span class="fc" id="L901">            final QueuedInsertion insertion = new QueuedInsertion(index, constraint, cmp);</span>
<span class="fc" id="L902">            changeQueue.add(insertion);</span>
<span class="fc" id="L903">            a.addAnimation(new ComponentAnimation() {</span>
                private boolean alreadyAdded;

                @Override
                public boolean isInProgress() {
<span class="nc" id="L908">                    return false;</span>
                }

                @Override
                protected void updateState() {
<span class="pc bpc" id="L913" title="1 of 2 branches missed.">                    if (!alreadyAdded) {</span>
                        try {
<span class="fc" id="L915">                            alreadyAdded = true;</span>
<span class="fc" id="L916">                            cmp.setParent(null);</span>
<span class="pc bpc" id="L917" title="1 of 2 branches missed.">                            if (constraint != null) {</span>
<span class="nc" id="L918">                                layout.addLayoutComponent(constraint, cmp, Container.this);</span>
                            }
<span class="fc" id="L920">                            insertComponentAtImpl(index, cmp);</span>
                        } finally {
<span class="fc" id="L922">                            changeQueue.remove(insertion);</span>
                        }
<span class="fc" id="L924">                        revalidateLater();</span>
                    }
<span class="fc" id="L926">                }</span>

                @Override
                public void flush() {
<span class="fc" id="L930">                    updateState();</span>
<span class="fc" id="L931">                }</span>
            });
<span class="fc" id="L933">        } else {</span>
<span class="pc bpc" id="L934" title="1 of 2 branches missed.">            if (constraint != null) {</span>
<span class="nc" id="L935">                layout.addLayoutComponent(constraint, cmp, this);</span>
            }
<span class="fc" id="L937">            insertComponentAtImpl(index, cmp);</span>
        }
<span class="fc" id="L939">    }</span>

    void insertComponentAtImpl(int index, final Component cmp) {
<span class="fc bfc" id="L942" title="All 2 branches covered.">        if (index == Integer.MAX_VALUE) {</span>
<span class="fc" id="L943">            index = components.size();</span>
        }
<span class="pc bpc" id="L945" title="1 of 2 branches missed.">        if (cmp.getParent() != null) {</span>
<span class="nc" id="L946">            throw new IllegalArgumentException(&quot;Component is already contained in Container: &quot; + cmp.getParent());</span>
        }
<span class="fc bfc" id="L948" title="All 2 branches covered.">        if (cmp instanceof Form) {</span>
<span class="fc" id="L949">            cmp.setVisible(true);</span>
<span class="fc" id="L950">            cmp.setPreferredSize(null);</span>
        }
<span class="fc" id="L952">        UIManager manager = getUIManager();</span>
<span class="pc bpc" id="L953" title="1 of 2 branches missed.">        boolean refreshLaf = manager != cmp.getUIManager();</span>
<span class="fc" id="L954">        cmp.setParent(this);</span>
<span class="pc bpc" id="L955" title="1 of 2 branches missed.">        if (refreshLaf) {</span>
<span class="nc" id="L956">            Display.getInstance().callSerially(new Runnable() {</span>
                public void run() {
<span class="nc" id="L958">                    cmp.refreshTheme(false);</span>
<span class="nc" id="L959">                }</span>
            });
        }
<span class="fc" id="L962">        components.add(index, cmp);</span>
<span class="fc bfc" id="L963" title="All 4 branches covered.">        if (layout instanceof BorderLayout &amp;&amp; !BorderLayout.OVERLAY.equals(layout.getComponentConstraint(cmp))) {</span>
            // Make sure overlay component is always on top
<span class="fc" id="L965">            Component overlay = ((BorderLayout) layout).getOverlay();</span>
<span class="pc bpc" id="L966" title="1 of 2 branches missed.">            if (overlay != null) {</span>
<span class="nc" id="L967">                components.remove(overlay);</span>
<span class="nc" id="L968">                components.add(index, overlay);</span>
            }
        }
<span class="fc" id="L971">        setShouldCalcPreferredSize(true);</span>
<span class="fc bfc" id="L972" title="All 2 branches covered.">        if (isInitialized()) {</span>
<span class="fc" id="L973">            cmp.initComponentImpl();</span>
        }
<span class="fc" id="L975">    }</span>

    /**
     * This method adds the Component at a specific index location in the Container
     * Components array.
     *
     * @param index location to insert the Component
     * @param cmp   the Component to add
     * @throws ArrayIndexOutOfBoundsException if index is out of bounds
     * @throws IllegalArgumentException       if Component is already contained or
     *                                        the cmp is a Form Component
     */
    public void addComponent(int index, Component cmp) {
<span class="fc" id="L988">        insertComponentAt(index, null, cmp);</span>
<span class="fc" id="L989">    }</span>

    /**
     * This method replaces the current Component with the next Component.
     * Current Component must be contained in this Container.
     * This method returns when transition has finished.
     *
     * @param current a Component to remove from the Container
     * @param next    a Component that replaces the current Component
     * @param t       a Transition between the add and removal of the Components
     *                a Transition can be null
     */
    public void replaceAndWait(final Component current, final Component next, final Transition t) {
<span class="nc" id="L1002">        replaceComponents(current, next, t, true, false, null, 0, 0, true);</span>
<span class="nc" id="L1003">    }</span>

    /**
     * This method replaces the current Component with the next Component.
     * Current Component must be contained in this Container.
     * This method returns when transition has finished.
     *
     * @param current              a Component to remove from the Container
     * @param next                 a Component that replaces the current Component
     * @param t                    a Transition between the add and removal of the Components
     *                             a Transition can be null
     * @param layoutAnimationSpeed the speed of the layout animation after replace  is completed
     */
    public void replaceAndWait(final Component current, final Component next, final Transition t, int layoutAnimationSpeed) {
<span class="nc" id="L1017">        enableLayoutOnPaint = false;</span>
<span class="nc" id="L1018">        replaceComponents(current, next, t, true, false, null, 0, layoutAnimationSpeed, true);</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">        if (layoutAnimationSpeed &gt; 0) {</span>
<span class="nc" id="L1020">            animateLayoutAndWait(layoutAnimationSpeed);</span>
        }
<span class="nc" id="L1022">        dontRecurseContainer = false;</span>
<span class="nc" id="L1023">        enableLayoutOnPaint = true;</span>
<span class="nc" id="L1024">    }</span>

    /**
     * This method replaces the current Component with the next Component
     *
     * @param current   a Component to remove from the Container
     * @param next      a Component that replaces the current Component
     * @param t         a Transition between the add and removal of the Components
     *                  a Transition can be null
     * @param onFinish  invoked when the replace operation is completed, may be null
     * @param growSpeed after replace is completed the component can gradually grow/shrink to fill up
     *                  available room, set this to 0 for immediate growth or any larger number for gradual animation. -1 indicates
     *                  a special case where no validation occurs
     */
    public void replace(final Component current, final Component next, final Transition t, Runnable onFinish, int growSpeed) {
<span class="nc" id="L1039">        replaceComponents(current, next, t, false, false, onFinish, growSpeed, 0, true);</span>
<span class="nc" id="L1040">    }</span>

    /**
     * This method replaces the current Component with the next Component.
     * Current Component must be contained in this Container.
     * This method returns when transition has finished.
     *
     * @param current    a Component to remove from the Container
     * @param next       a Component that replaces the current Component
     * @param t          a Transition between the add and removal of the Components
     *                   a Transition can be null
     * @param dropEvents indicates if the display should drop all events
     *                   while this Component replacing is happening
     */
    public void replaceAndWait(final Component current, final Component next,
                               final Transition t, boolean dropEvents) {
<span class="nc" id="L1056">        replaceComponents(current, next, t, true, dropEvents, null, 0, 0, true);</span>
<span class="nc" id="L1057">    }</span>

    /**
     * This method replaces the current Component with the next Component.
     * Current Component must be contained in this Container.
     * This method return immediately.
     *
     * @param current a Component to remove from the Container
     * @param next    a Component that replaces the current Component
     * @param t       a Transition between the add and removal of the Components
     *                a Transition can be null
     */
    public void replace(final Component current, final Component next, final Transition t) {
<span class="fc" id="L1070">        replaceComponents(current, next, t, false, false, null, 0, 0, true);</span>
<span class="fc" id="L1071">    }</span>

    /**
     * This method creates an animation component that replaces the current Component with the next Component.
     * Current Component must be contained in this Container.
     * This method return immediately.
     *
     * @param current a Component to remove from the Container
     * @param next    a Component that replaces the current Component
     * @param t       a Transition between the add and removal of the Components
     *                a Transition can be null
     * @return animation component that can be queued
     */
    public ComponentAnimation createReplaceTransition(Component current, Component next, Transition t) {
<span class="nc" id="L1085">        return replaceComponents(current, next, t, false, false, null, 0, 0, false);</span>
    }

    private ComponentAnimation replaceComponents(final Component current, final Component next,
                                                 final Transition t, boolean wait, boolean dropEvents, Runnable onFinish, int growSpeed, int layoutAnimationSpeed,
                                                 boolean addAnimtion) {
<span class="pc bpc" id="L1091" title="1 of 2 branches missed.">        if (!contains(current)) {</span>
<span class="nc" id="L1092">            throw new IllegalArgumentException(&quot;Component &quot; + current + &quot; is not contained in this Container&quot;);</span>
        }
<span class="pc bpc" id="L1094" title="1 of 6 branches missed.">        if (t == null || !isVisible() || getComponentForm() == null) {</span>
<span class="fc" id="L1095">            next.setX(current.getX());</span>
<span class="fc" id="L1096">            next.setY(current.getY());</span>
<span class="fc" id="L1097">            next.setWidth(current.getWidth());</span>
<span class="fc" id="L1098">            next.setHeight(current.getHeight());</span>
<span class="fc" id="L1099">            replace(current, next, false);</span>
<span class="fc" id="L1100">            return null;</span>
        }

<span class="fc" id="L1103">        setScrollX(0);</span>
<span class="fc" id="L1104">        setScrollY(0);</span>

<span class="fc" id="L1106">        next.setX(current.getX());</span>
<span class="fc" id="L1107">        next.setY(current.getY());</span>
<span class="fc" id="L1108">        next.setWidth(current.getWidth());</span>
<span class="fc" id="L1109">        next.setHeight(current.getHeight());</span>
<span class="fc" id="L1110">        next.setParent(this);</span>
<span class="pc bpc" id="L1111" title="1 of 2 branches missed.">        if (next instanceof Container) {</span>
<span class="nc" id="L1112">            ((Container) next).layoutContainer();</span>
        }

<span class="fc" id="L1115">        final TransitionAnimation anim = new TransitionAnimation(this, current, next, t);</span>
<span class="fc" id="L1116">        anim.growSpeed = growSpeed;</span>
<span class="fc" id="L1117">        anim.layoutAnimationSpeed = layoutAnimationSpeed;</span>

        // register the transition animation
        /*getComponentForm().registerAnimatedInternal(anim);
        //wait until animation has finished
        if (wait) {
            Display.getInstance().invokeAndBlock(anim, dropEvents);
        }*/
<span class="pc bpc" id="L1125" title="1 of 2 branches missed.">        if (addAnimtion) {</span>
<span class="pc bpc" id="L1126" title="1 of 2 branches missed.">            if (wait) {</span>
<span class="nc" id="L1127">                getAnimationManager().addAnimationAndBlock(anim);</span>
            } else {
<span class="pc bpc" id="L1129" title="1 of 2 branches missed.">                if (onFinish != null) {</span>
<span class="nc" id="L1130">                    getAnimationManager().addUIMutation(this, anim, onFinish);</span>
                } else {
<span class="fc" id="L1132">                    getAnimationManager().addUIMutation(this, anim);</span>
                }
            }
        }
<span class="fc" id="L1136">        return anim;</span>
    }

    private boolean isParentOf(Component c) {
<span class="fc" id="L1140">        c = c.getParent();</span>
<span class="pc bpc" id="L1141" title="1 of 4 branches missed.">        if (c == null || c instanceof Form) {</span>
<span class="fc" id="L1142">            return false;</span>
        }
<span class="pc bpc" id="L1144" title="2 of 4 branches missed.">        return (c == this) || isParentOf(c);</span>
    }

    void onParentPositionChange() {
<span class="fc" id="L1148">        int cmpCount = getComponentCount();</span>
<span class="fc bfc" id="L1149" title="All 2 branches covered.">        for (int iter = 0; iter &lt; cmpCount; iter++) {</span>
<span class="fc" id="L1150">            Component c = getComponentAt(iter);</span>
<span class="fc" id="L1151">            c.onParentPositionChange();</span>
        }
<span class="fc" id="L1153">    }</span>

    @Override
    boolean onOrientationChange() {
<span class="fc" id="L1157">        boolean v = super.onOrientationChange();</span>
<span class="fc" id="L1158">        int cmpCount = getComponentCount();</span>
<span class="fc bfc" id="L1159" title="All 2 branches covered.">        for (int iter = 0; iter &lt; cmpCount; iter++) {</span>
<span class="fc" id="L1160">            Component c = getComponentAt(iter);</span>
<span class="pc bpc" id="L1161" title="2 of 4 branches missed.">            v = c.onOrientationChange() || v;</span>
        }
<span class="fc" id="L1163">        return v;</span>
    }

    private boolean requestFocusChild(boolean avoidRepaint) {
<span class="nc" id="L1167">        int cmpCount = getComponentCount();</span>
<span class="nc bnc" id="L1168" title="All 2 branches missed.">        for (int iter = 0; iter &lt; cmpCount; iter++) {</span>
<span class="nc" id="L1169">            Component c = getComponentAt(iter);</span>
<span class="nc bnc" id="L1170" title="All 2 branches missed.">            if (c.isFocusable()) {</span>
<span class="nc bnc" id="L1171" title="All 2 branches missed.">                if (avoidRepaint) {</span>
<span class="nc" id="L1172">                    getComponentForm().setFocusedInternal(c);</span>
                } else {
<span class="nc" id="L1174">                    c.requestFocus();</span>
                }
<span class="nc" id="L1176">                return true;</span>
            }
<span class="nc bnc" id="L1178" title="All 4 branches missed.">            if (c instanceof Container &amp;&amp; ((Container) c).requestFocusChild(avoidRepaint)) {</span>
<span class="nc" id="L1179">                return true;</span>
            }
        }
<span class="nc" id="L1182">        return false;</span>
    }

    private void cancelRepaintsRecursively(Component c, CodenameOneImplementation l) {
<span class="fc bfc" id="L1186" title="All 2 branches covered.">        if (c instanceof Container) {</span>
<span class="fc" id="L1187">            Container cnt = (Container) c;</span>
<span class="fc" id="L1188">            int count = cnt.getComponentCount();</span>
<span class="fc bfc" id="L1189" title="All 2 branches covered.">            for (int i = 0; i &lt; count; i++) {</span>
<span class="fc" id="L1190">                cancelRepaintsRecursively(cnt.getComponentAt(i), l);</span>
            }
        }
<span class="fc" id="L1193">        l.cancelRepaint(c);</span>
<span class="fc" id="L1194">    }</span>

    private void cancelRepaintsRecursively(Component c) {
<span class="fc" id="L1197">        cancelRepaintsRecursively(c, Display.impl);</span>
<span class="fc" id="L1198">    }</span>

    void replace(final Component current, final Component next, boolean avoidRepaint) {
<span class="fc" id="L1201">        int index = components.indexOf(current);</span>
<span class="fc" id="L1202">        boolean currentFocused = false;</span>
<span class="fc bfc" id="L1203" title="All 2 branches covered.">        if (current.getComponentForm() != null) {</span>
<span class="fc" id="L1204">            Component currentF = current.getComponentForm().getFocused();</span>
<span class="fc bfc" id="L1205" title="All 2 branches covered.">            currentFocused = currentF == current;</span>
<span class="pc bpc" id="L1206" title="1 of 8 branches missed.">            if (!currentFocused &amp;&amp; current instanceof Container &amp;&amp; currentF != null &amp;&amp; ((Container) current).isParentOf(currentF)) {</span>
<span class="nc" id="L1207">                currentFocused = true;</span>
            }
        }
<span class="fc" id="L1210">        Object constraint = layout.getComponentConstraint(current);</span>
<span class="fc bfc" id="L1211" title="All 2 branches covered.">        if (constraint != null) {</span>
<span class="fc" id="L1212">            removeComponentImplNoAnimationSafety(current);</span>
<span class="fc" id="L1213">            layout.addLayoutComponent(constraint, next, Container.this);</span>
        } else {
<span class="fc" id="L1215">            removeComponentImplNoAnimationSafety(current);</span>
        }
<span class="fc" id="L1217">        cancelRepaintsRecursively(current);</span>
<span class="fc" id="L1218">        next.setParent(null);</span>
<span class="pc bpc" id="L1219" title="1 of 2 branches missed.">        if (index &lt; 0) {</span>
<span class="nc" id="L1220">            index = 0;</span>
        }
<span class="fc" id="L1222">        insertComponentAtImpl(index, next);</span>
<span class="fc bfc" id="L1223" title="All 2 branches covered.">        if (currentFocused) {</span>
<span class="pc bpc" id="L1224" title="1 of 2 branches missed.">            if (next.isFocusable()) {</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">                if (avoidRepaint) {</span>
<span class="nc" id="L1226">                    getComponentForm().setFocusedInternal(next);</span>
                } else {
<span class="nc" id="L1228">                    next.requestFocus();</span>
                }
            } else {
<span class="pc bpc" id="L1231" title="1 of 2 branches missed.">                if (next instanceof Container) {</span>
<span class="nc" id="L1232">                    ((Container) next).requestFocusChild(avoidRepaint);</span>
                }
            }
        }
<span class="fc" id="L1236">    }</span>

    /**
     * {@inheritDoc}
     */
    void initComponentImpl() {
<span class="fc bfc" id="L1242" title="All 2 branches covered.">        if (!isInitialized()) {</span>
<span class="fc" id="L1243">            super.initComponentImpl();</span>
        }
<span class="fc" id="L1245">        Container p = getParent();</span>
<span class="fc bfc" id="L1246" title="All 2 branches covered.">        if (p != null) {</span>
<span class="fc" id="L1247">            allowEnableLayoutOnPaint = p.allowEnableLayoutOnPaint;</span>
        }
<span class="fc" id="L1249">        int componentCount = components.size();</span>
<span class="fc bfc" id="L1250" title="All 2 branches covered.">        for (int iter = 0; iter &lt; componentCount; iter++) {</span>
<span class="fc" id="L1251">            Component cmp = components.get(iter);</span>
<span class="fc" id="L1252">            cmp.initComponentImpl();</span>
        }
<span class="fc bfc" id="L1254" title="All 2 branches covered.">        if (leadComponent != null) {</span>
<span class="fc" id="L1255">            initLead();</span>
        }
<span class="fc" id="L1257">    }</span>

    /**
     * {@inheritDoc}
     */
    public boolean isEnabled() {
        // Normally a container shouldn't be a lead component but this happens
        // in the GUI builder and this block can cause an infinite recursion
        // without the second condition
<span class="pc bpc" id="L1266" title="1 of 4 branches missed.">        if (leadComponent != null &amp;&amp; leadComponent != this) {</span>
<span class="fc" id="L1267">            return leadComponent.isEnabled();</span>
        }
<span class="fc" id="L1269">        return super.isEnabled();</span>
    }

    /**
     * This method will recursively set all the Container chidrens to be
     * enabled/disabled.
     * If the Container is disabled and a child Component changed it's state to
     * be enabled, the child Component will be treated as an enabled Component.
     *
     * @param enabled
     */
    public void setEnabled(boolean enabled) {
<span class="fc" id="L1281">        super.setEnabled(enabled);</span>
<span class="fc" id="L1282">        int count = getComponentCount();</span>
<span class="fc bfc" id="L1283" title="All 2 branches covered.">        for (int i = 0; i &lt; count; i++) {</span>
<span class="fc" id="L1284">            Component c = getComponentAt(i);</span>
<span class="fc" id="L1285">            c.setEnabled(enabled);</span>
        }
<span class="fc" id="L1287">    }</span>

    /**
     * removes a Component from the Container, notice that removed component might still have
     * a pending repaint in the queue that won't be removed. Calling form.repaint() will workaround
     * such an issue.
     *
     * @param cmp the removed component
     */
    public void removeComponent(Component cmp) {
<span class="fc" id="L1297">        removeComponentImpl(cmp);</span>
<span class="fc" id="L1298">    }</span>

    /**
     * Changes the component index of a child component without revalidating or animating. This is useful
     * for complex animations or z-order manipulation but might collide with ongoing animations hence the
     * package protected nature.
     *
     * @param cmp      The component to be moved
     * @param location The new component index
     */
    void setComponentIndex(Component cmp, int location) {
<span class="nc bnc" id="L1309" title="All 2 branches missed.">        if (location &lt; components.size()) {</span>
<span class="nc" id="L1310">            components.remove(cmp);</span>
<span class="nc" id="L1311">            components.add(location, cmp);</span>
        }
<span class="nc" id="L1313">    }</span>

    void removeComponentImpl(final Component cmp) {
<span class="fc" id="L1316">        final AnimationManager a = getAnimationManager();</span>
<span class="fc bfc" id="L1317" title="All 4 branches covered.">        if (a != null &amp;&amp; a.isAnimating()) {</span>
            // pretend like the component was already removed
<span class="fc" id="L1319">            layout.removeLayoutComponent(cmp);</span>
<span class="fc" id="L1320">            cmp.setParent(null);</span>
<span class="fc" id="L1321">            final QueuedRemoval removed = new QueuedRemoval(cmp);</span>
<span class="fc" id="L1322">            changeQueue.add(removed);</span>
<span class="fc" id="L1323">            a.addAnimation(new ComponentAnimation() {</span>
                private boolean alreadyRemoved;

                @Override
                public boolean isInProgress() {
<span class="fc" id="L1328">                    return false;</span>
                }

                @Override
                protected void updateState() {
<span class="pc bpc" id="L1333" title="1 of 2 branches missed.">                    if (!alreadyRemoved) {</span>
                        try {
<span class="fc" id="L1335">                            alreadyRemoved = true;</span>
<span class="fc" id="L1336">                            removeComponentImplNoAnimationSafety(cmp);</span>
                        } finally {
<span class="fc" id="L1338">                            changeQueue.remove(removed);</span>
                        }
<span class="fc" id="L1340">                        revalidateLater();</span>
                    }
<span class="fc" id="L1342">                }</span>

                @Override
                public void flush() {
<span class="fc" id="L1346">                    updateAnimationState();</span>
<span class="fc" id="L1347">                }</span>
            });
<span class="fc" id="L1349">        } else {</span>
<span class="fc" id="L1350">            removeComponentImplNoAnimationSafety(cmp);</span>
        }
<span class="fc" id="L1352">    }</span>

    /**
     * removes a Component from the Container
     *
     * @param cmp the removed component
     */
    void removeComponentImplNoAnimationSafety(Component cmp) {
<span class="fc" id="L1360">        Form parentForm = getComponentForm();</span>
<span class="fc" id="L1361">        layout.removeLayoutComponent(cmp);</span>

        // the deinitizlize contract expects the component to be in a container but if this is a part of an animation
        // it might have been removed already to prevent conflict with remove operations
<span class="fc" id="L1365">        cmp.setParent(this);</span>
<span class="fc" id="L1366">        cmp.deinitializeImpl();</span>
<span class="fc" id="L1367">        components.remove(cmp);</span>
<span class="fc" id="L1368">        cmp.setParent(null);</span>
<span class="fc bfc" id="L1369" title="All 2 branches covered.">        if (parentForm != null) {</span>
<span class="fc bfc" id="L1370" title="All 6 branches covered.">            if (parentForm.getFocused() == cmp || cmp instanceof Container &amp;&amp; ((Container) cmp).contains(parentForm.getFocused())) {</span>
<span class="fc" id="L1371">                parentForm.setFocusedInternal(null);</span>
            }
<span class="fc" id="L1373">            Component dragged = parentForm.getDraggedComponent();</span>
<span class="pc bpc" id="L1374" title="1 of 2 branches missed.">            if (dragged == cmp) {</span>
<span class="nc" id="L1375">                parentForm.setDraggedComponent(null);</span>
            }
<span class="fc bfc" id="L1377" title="All 2 branches covered.">            if (cmp.isSmoothScrolling()) {</span>
<span class="fc" id="L1378">                parentForm.deregisterAnimatedInternal(cmp);</span>
            }
        }
<span class="fc" id="L1381">        cmp.cancelRepaints();</span>
<span class="pc bpc" id="L1382" title="1 of 2 branches missed.">        if (cmp instanceof Form) {</span>
<span class="nc" id="L1383">            cmp.setVisible(false);</span>
        }
<span class="fc" id="L1385">        setShouldCalcPreferredSize(true);</span>
<span class="fc" id="L1386">        Display.impl.componentRemoved(cmp);</span>
<span class="fc" id="L1387">    }</span>

    /**
     * remove this component and it's children from the painting queue
     */
    protected void cancelRepaints() {
<span class="fc" id="L1393">        super.cancelRepaints();</span>
<span class="fc bfc" id="L1394" title="All 2 branches covered.">        for (int i = 0; i &lt; getComponentCount(); i++) {</span>
<span class="fc" id="L1395">            Component c = getComponentAt(i);</span>
<span class="fc" id="L1396">            c.cancelRepaints();</span>
        }
<span class="fc" id="L1398">    }</span>

    /**
     * Cleansup the initialization flags in the hierachy
     */
    void deinitializeImpl() {
<span class="fc" id="L1404">        super.deinitializeImpl();</span>
<span class="fc" id="L1405">        int componentCount = components.size();</span>
<span class="fc bfc" id="L1406" title="All 2 branches covered.">        for (int iter = 0; iter &lt; componentCount; iter++) {</span>
<span class="fc" id="L1407">            Component cmp = components.get(iter);</span>
<span class="fc" id="L1408">            cmp.deinitializeImpl();</span>
        }
<span class="fc" id="L1410">        flushReplace();</span>
<span class="fc" id="L1411">    }</span>

    /**
     * Flushes ongoing replace operations to prevent two concurrent replace operations from colliding.
     * If there is no ongoing replace nothing will occur
     *
     * @deprecated this method is no longer used in the new animation framework
     */
    public void flushReplace() {
        /*if (cmpTransitions != null) {
            int size = cmpTransitions.size();
            for (int iter = 0; iter &lt; size; iter++) {
                ((Anim) cmpTransitions.elementAt(iter)).destroy();
            }
            cmpTransitions.removeAllElements();
            cmpTransitions = null;
        }*/
<span class="fc" id="L1428">    }</span>

    /**
     * remove all Components from container, notice that removed component might still have
     * a pending repaint in the queue that won't be removed. Calling form.repaint() will workaround
     * such an issue. Notice that this method doesn't recurse and only removes from
     * the current container.
     */
    public void removeAll() {
<span class="fc" id="L1437">        Form parentForm = getComponentForm();</span>
<span class="fc bfc" id="L1438" title="All 2 branches covered.">        if (parentForm != null) {</span>
<span class="fc" id="L1439">            Component focus = parentForm.getFocused();</span>
<span class="fc bfc" id="L1440" title="All 4 branches covered.">            if (focus != null &amp;&amp; contains(focus)) {</span>
<span class="fc" id="L1441">                parentForm.setFocused(null);</span>
            }
        }

        // prevents concurrent modification exception
        Component[] arr;
<span class="fc" id="L1447">        boolean includeQueued = true; // Setting this true because when would you ever want removeAll() to NOT remove queued components</span>
<span class="pc bpc" id="L1448" title="1 of 2 branches missed.">        if (includeQueued) {</span>
<span class="fc" id="L1449">            java.util.List&lt;Component&gt; l = getChildrenAsList(includeQueued);</span>
<span class="fc" id="L1450">            arr = new Component[l.size()];</span>
<span class="fc" id="L1451">            l.toArray(arr);</span>
<span class="fc" id="L1452">        } else {</span>
<span class="nc" id="L1453">            arr = new Component[components.size()];</span>
<span class="nc" id="L1454">            components.toArray(arr);</span>
        }

<span class="fc" id="L1457">        int componentCount = arr.length;</span>
<span class="fc bfc" id="L1458" title="All 2 branches covered.">        for (int iter = 0; iter &lt; componentCount; iter++) {</span>
<span class="fc" id="L1459">            Component cmp = arr[iter];</span>
<span class="fc" id="L1460">            removeComponent(cmp);</span>
        }
<span class="fc" id="L1462">        resetScroll();</span>
<span class="fc" id="L1463">    }</span>

    /**
     * Revalidates the container in a way that doesn't conflict with
     * running animations.  If you simply call {@link #revalidate() }
     * on a container while an animation is in progress, it will produce
     * paint artifacts as it will insert frames in the animation with
     * the container at its final position.  Using this method, it will
     * wait until running animations are complete before it revalidates.
     *
     * @since 6.0
     */
    public void revalidateWithAnimationSafety() {
<span class="fc bfc" id="L1476" title="All 2 branches covered.">        if (revalidatePending) {</span>
<span class="fc" id="L1477">            return;</span>
        }
<span class="fc" id="L1479">        revalidatePending = true;</span>
<span class="fc" id="L1480">        AnimationManager mgr = getAnimationManager();</span>
<span class="pc bpc" id="L1481" title="1 of 2 branches missed.">        if (mgr == null) {</span>
<span class="nc" id="L1482">            revalidatePending = false;</span>
<span class="nc" id="L1483">            revalidate();</span>
<span class="nc" id="L1484">            return;</span>
        }
<span class="fc bfc" id="L1486" title="All 2 branches covered.">        if (mgr.isAnimating()) {</span>
<span class="fc" id="L1487">            mgr.flushAnimation(new Runnable() {</span>
                @Override
                public void run() {
<span class="nc" id="L1490">                    revalidatePending = false;</span>
<span class="nc" id="L1491">                    revalidate();</span>
<span class="nc" id="L1492">                }</span>

            });
        } else {
<span class="fc" id="L1496">            revalidatePending = false;</span>
<span class="fc" id="L1497">            revalidate();</span>
        }
<span class="fc" id="L1499">    }</span>

    void revalidateWithAnimationSafetyInternal(final boolean fromRoot) {
<span class="pc bpc" id="L1502" title="1 of 2 branches missed.">        if (revalidatePending) {</span>
<span class="nc" id="L1503">            return;</span>
        }
<span class="fc" id="L1505">        revalidatePending = true;</span>
<span class="fc" id="L1506">        AnimationManager mgr = getAnimationManager();</span>
<span class="fc bfc" id="L1507" title="All 2 branches covered.">        if (mgr == null) {</span>
<span class="fc" id="L1508">            revalidatePending = false;</span>
<span class="fc" id="L1509">            revalidateInternal(fromRoot);</span>
<span class="fc" id="L1510">            return;</span>
        }
<span class="fc bfc" id="L1512" title="All 2 branches covered.">        if (mgr.isAnimating()) {</span>
<span class="fc" id="L1513">            mgr.flushAnimation(new Runnable() {</span>
                @Override
                public void run() {
<span class="nc" id="L1516">                    revalidatePending = false;</span>
<span class="nc" id="L1517">                    revalidateInternal(fromRoot);</span>
<span class="nc" id="L1518">                }</span>

            });
        } else {
<span class="fc" id="L1522">            revalidatePending = false;</span>
<span class="fc" id="L1523">            revalidateInternal(fromRoot);</span>
        }
<span class="fc" id="L1525">    }</span>

    /**
     * Re-layout the container, this is useful when we modify the container hierarchy and
     * need to redo the layout
     */
    public void revalidate() {
<span class="fc" id="L1532">        revalidateInternal(true);</span>
<span class="fc" id="L1533">    }</span>

    /**
     * Internal revalidate method.  Takes parameter {@literal fromRoot} that
     * allows you to disable the default behaviour of revalidating the form.
     *
     * @param fromRoot
     */
    void revalidateInternal(boolean fromRoot) {
<span class="fc" id="L1542">        setShouldCalcPreferredSize(true);</span>
<span class="fc" id="L1543">        Form root = getComponentForm();</span>

<span class="fc bfc" id="L1545" title="All 4 branches covered.">        if (root != null &amp;&amp; root != this) {</span>
<span class="fc" id="L1546">            root.removeFromRevalidateQueue(this);</span>
<span class="pc bpc" id="L1547" title="1 of 4 branches missed.">            if (fromRoot &amp;&amp; root.revalidateFromRoot) {</span>
<span class="fc" id="L1548">                root.layoutContainer();</span>
<span class="fc" id="L1549">                root.repaint();</span>

                // for complex hierarchies
<span class="pc bpc" id="L1552" title="1 of 2 branches missed.">                if (getParent() != null) {</span>
<span class="fc" id="L1553">                    getParent().shouldLayout = true;</span>
<span class="fc" id="L1554">                    getParent().layoutContainer();</span>
                } else {
<span class="nc" id="L1556">                    layoutContainer();</span>
                }
            } else {
<span class="fc" id="L1559">                layoutContainer();</span>
<span class="fc" id="L1560">                repaint();</span>
            }
        } else {
<span class="fc" id="L1563">            layoutContainer();</span>
<span class="fc" id="L1564">            repaint();</span>
        }
<span class="fc" id="L1566">    }</span>

    /**
     * Revalidates the container before the next paint cycle.  Prefer this
     * method to {@link #revalidate() } and {@link #revalidateWithAnimationSafety() }
     * if you don't need the revalidate (layout and repaint) to happen immediately,
     * but you *do* want it to happen before the next paint.  This is can be far more
     * efficient as it will squash the revalidation calls into the minimal set
     * of containers that require revalidation, so that the system doesn't end up
     * revalidating the same container multiple times between paints.
     */
    public void revalidateLater() {
<span class="fc" id="L1578">        Form root = getComponentForm();</span>
<span class="fc bfc" id="L1579" title="All 2 branches covered.">        if (root != null) {</span>
<span class="fc" id="L1580">            root.revalidateLater(this);</span>
        }

<span class="fc" id="L1583">    }</span>

    /**
     * A more powerful form of revalidate that recursively lays out the full hierarchy
     */
    public void forceRevalidate() {
<span class="fc" id="L1589">        forceRevalidateImpl();</span>
<span class="fc" id="L1590">        revalidate();</span>
<span class="fc" id="L1591">    }</span>

    private void forceRevalidateImpl() {
<span class="fc" id="L1594">        setShouldCalcPreferredSize(true);</span>
<span class="fc" id="L1595">        int c = getComponentCount();</span>
<span class="fc bfc" id="L1596" title="All 2 branches covered.">        for (int iter = 0; iter &lt; c; iter++) {</span>
<span class="fc" id="L1597">            Component cmp = getComponentAt(iter);</span>
<span class="fc bfc" id="L1598" title="All 2 branches covered.">            if (cmp instanceof Container) {</span>
<span class="fc" id="L1599">                ((Container) cmp).forceRevalidateImpl();</span>
            } else {
<span class="fc" id="L1601">                cmp.setShouldCalcPreferredSize(true);</span>
            }
        }
<span class="fc" id="L1604">    }</span>

    /**
     * {@inheritDoc}
     */
    public void clearClientProperties() {
<span class="nc" id="L1610">        super.clearClientProperties();</span>
<span class="nc" id="L1611">        int c = getComponentCount();</span>
<span class="nc bnc" id="L1612" title="All 2 branches missed.">        for (int iter = 0; iter &lt; c; iter++) {</span>
<span class="nc" id="L1613">            Component cmp = getComponentAt(iter);</span>
<span class="nc" id="L1614">            cmp.clearClientProperties();</span>
        }
<span class="nc" id="L1616">    }</span>

    private void paintContainerChildrenForAnimation(Container cnt, Graphics g) {
<span class="nc" id="L1619">        int ourX = getAbsoluteX();</span>
<span class="nc" id="L1620">        int ourY = getAbsoluteY();</span>
<span class="nc" id="L1621">        int cc = cnt.getComponentCount();</span>
<span class="nc bnc" id="L1622" title="All 2 branches missed.">        for (int iter = 0; iter &lt; cc; iter++) {</span>
<span class="nc" id="L1623">            Component cmp = cnt.getComponentAt(iter);</span>
<span class="nc bnc" id="L1624" title="All 2 branches missed.">            if (cmp.getClass() == Container.class) {</span>
<span class="nc" id="L1625">                paintContainerChildrenForAnimation((Container) cmp, g);</span>
<span class="nc" id="L1626">                continue;</span>
            }
<span class="nc" id="L1628">            int abx = cmp.getAbsoluteX();</span>
<span class="nc" id="L1629">            int aby = cmp.getAbsoluteY();</span>
<span class="nc" id="L1630">            int oldX = cmp.getX();</span>
<span class="nc" id="L1631">            int oldY = cmp.getY();</span>
<span class="nc" id="L1632">            cmp.setParent(this);</span>
<span class="nc" id="L1633">            cmp.setX(abx - ourX);</span>
<span class="nc" id="L1634">            cmp.setY(aby - ourY);</span>
<span class="nc" id="L1635">            cmp.paintInternal(g, false);</span>
<span class="nc" id="L1636">            cmp.setParent(cnt);</span>
<span class="nc" id="L1637">            cmp.setX(oldX);</span>
<span class="nc" id="L1638">            cmp.setY(oldY);</span>
        }
<span class="nc" id="L1640">    }</span>

    /**
     * Invoked internally to indicate if child components are hiding this container
     * thus removing the need to invoke its own paint methods
     *
     * @return true if child components are obscuring this component
     */
    boolean isObscuredByChildren() {
<span class="pc bpc" id="L1649" title="1 of 2 branches missed.">        if (!blockOverdraw) {</span>
<span class="fc" id="L1650">            return false;</span>
        }
<span class="nc bnc" id="L1652" title="All 2 branches missed.">        if (!getLayout().obscuresPotential(this)) {</span>
<span class="nc" id="L1653">            return false;</span>
        }
<span class="nc" id="L1655">        Style s = getStyle();</span>
<span class="nc bnc" id="L1656" title="All 8 branches missed.">        if (s.getPaddingTop() != 0 || s.getPaddingLeftNoRTL() != 0 || s.getPaddingRightNoRTL() != 0 || s.getPaddingBottom() != 0) {</span>
<span class="nc" id="L1657">            return false;</span>
        }

<span class="nc" id="L1660">        int size = components.size();</span>
<span class="nc bnc" id="L1661" title="All 2 branches missed.">        for (int iter = 0; iter &lt; size; iter++) {</span>
<span class="nc" id="L1662">            Component cmp = components.get(iter);</span>
<span class="nc" id="L1663">            s = cmp.getStyle();</span>
<span class="nc bnc" id="L1664" title="All 4 branches missed.">            if (cmp.getWidth() == 0 || cmp.getHeight() == 0) {</span>
<span class="nc" id="L1665">                continue;</span>
            }
            // need to think of a better way, this means we invoke the same logic recurisvely again and again by a factor of depth. Not good...
<span class="nc bnc" id="L1668" title="All 2 branches missed.">            if (cmp instanceof Container) {</span>
<span class="nc bnc" id="L1669" title="All 2 branches missed.">                if (!((Container) cmp).getLayout().obscuresPotential(this)) {</span>
<span class="nc" id="L1670">                    return false;</span>
                }
<span class="nc bnc" id="L1672" title="All 10 branches missed.">                if (s.getOpacity() != 0xff || s.getMarginTop() != 0 || s.getMarginLeftNoRTL() != 0 || s.getMarginRightNoRTL() != 0 || s.getMarginBottom() != 0) {</span>
<span class="nc" id="L1673">                    return false;</span>
                }
<span class="nc bnc" id="L1675" title="All 4 branches missed.">                if ((s.getBgTransparency() &amp; 0xff) != 0xff &amp;&amp; !((Container) cmp).isObscuredByChildren()) {</span>
<span class="nc" id="L1676">                    return false;</span>
                }
            } else {
<span class="nc bnc" id="L1679" title="All 12 branches missed.">                if ((s.getBgTransparency() &amp; 0xff) != 0xff || s.getOpacity() != 0xff || s.getMarginTop() != 0 || s.getMarginLeftNoRTL() != 0 || s.getMarginRightNoRTL() != 0 || s.getMarginBottom() != 0) {</span>
<span class="nc" id="L1680">                    return false;</span>
                }
            }
        }

<span class="nc" id="L1685">        return true;</span>
    }

    /**
     * Efficiently finds the first child component that is visible in the specified
     * bounds.
     * &lt;p&gt;This is only really helpful if the child components are sorted
     * in some way so that we can quickly (with a binary search) find the first
     * visible component.  E.g. In BoxLayout.Y_AXIS, the components are arranged
     * vertically in order of their index so we can use a binary search to find
     * the first visible element.  For most other layout managers we can't as easily
     * do a sort like this.&lt;/p&gt;
     *
     * &lt;p&gt;If the layout manager doesn't allow for a binary search, then this will
     * just return 0 (meaning that you need to scan the children from the beginning
     * to find visible children).&lt;/p&gt;
     *
     * &lt;p&gt;After you obtain this value, use the {@link #calculateLastPaintableOffset(int, int, int, int, int) } method
     * to get the end of the visible region.&lt;/p&gt;
     *
     * &lt;p&gt;The motivation for this is to try to improve performance in places where the container
     * has many (say 2500) children, and most of them aren't actually visible.&lt;/p&gt;
     *
     * @param clipX1 Left bounds of region to check.  (0,0) is the top left corner of this component.
     * @param clipY1 Top bounds of region to check.  (0,0) is top left corner of this component.
     * @param clipX2 Right bounds of region to check.  (0,0) is top left corner of this component.
     * @param clipY2 Bottom bounds of region to check.  (0,0) is top left corner of this component.
     * @return The index within the &quot;components&quot; array where the first child that intersects the provided
     * clip occurs, or -1 if there is no &quot;fast&quot; way to find it.  If there was a fast way to do it, but no visible
     * components were found, then this will return components.size().
     * @see #calculateLastPaintableOffset(int, int, int, int, int)
     */
    private int calculateFirstPaintableOffset(int clipX1, int clipY1, int clipX2, int clipY2) {
<span class="fc" id="L1718">        int len = components.size();</span>
<span class="fc" id="L1719">        Layout l = getLayout();</span>
<span class="fc bfc" id="L1720" title="All 2 branches covered.">        if (l.getClass() == BoxLayout.class) {</span>
<span class="pc bpc" id="L1721" title="1 of 2 branches missed.">            if (((BoxLayout) l).getAxis() == BoxLayout.Y_AXIS) {</span>
                // Use a binary search to find the first visible
<span class="fc" id="L1723">                int startPos = binarySearchFirstIntersectionY(clipY1, clipY2, 0, len);</span>
<span class="pc bpc" id="L1724" title="1 of 2 branches missed.">                if (startPos &gt;= 0) {</span>
<span class="fc" id="L1725">                    return startPos;</span>
                } else {
<span class="nc" id="L1727">                    return len;</span>
                }

            }
        }
<span class="fc" id="L1732">        return -1;</span>
    }

    /**
     * Gets the index of the &quot;last&quot; child component that intersects the given rectangle.  This is
     * only helpful if the components are sorted (e.g. with BoxLayout.Y_AXIS).  If they aren't
     * sorted then this will just return components.size()-1.
     *
     * @param pos    The starting position to search.  It is assumed that this starting
     *               position is in the visible region.
     * @param clipX1 The left bounds of the region to search.  (0,0) is the top left corner of the container.
     * @param clipY1 The top bounds of the region to search. (0,0) is the top left corner of the container.
     * @param clipX2 The right bounds of the region to search. (0,0) is the top left corner of the container.
     * @param clipY2 The bottom bounds of the region to search. (0,0) is the top left corner of the container.
     * @return The index of the last visible component in this container - or components.size()-1
     */
    private int calculateLastPaintableOffset(int pos, int clipX1, int clipY1, int clipX2, int clipY2) {
<span class="fc" id="L1749">        final int len = components.size();</span>
<span class="pc bpc" id="L1750" title="1 of 2 branches missed.">        if (pos &gt;= len - 1) {</span>
            // Start position is after the last index, so we didn't
            // even find an end offset.
            // Let's return one less than pos to indicate this
<span class="nc" id="L1754">            return len - 1;</span>
        }
<span class="fc" id="L1756">        final Layout l = getLayout();</span>
<span class="pc bpc" id="L1757" title="1 of 2 branches missed.">        if (l.getClass() == BoxLayout.class) {</span>
<span class="pc bpc" id="L1758" title="1 of 2 branches missed.">            if (((BoxLayout) l).getAxis() == BoxLayout.Y_AXIS) {</span>
                // Use a binary search to find the first visible
                //Component c = components.get(++pos);
<span class="fc" id="L1761">                Component c = null;</span>
<span class="fc" id="L1762">                int cy1 = -1;</span>
<span class="fc" id="L1763">                final int end = len - 1;</span>
<span class="fc" id="L1764">                pos++; // This should still be a valid index because</span>
                // we previously checked to see if it was &gt;= len-1
                do {
<span class="fc" id="L1767">                    c = components.get(pos);</span>
<span class="fc" id="L1768">                    cy1 = c.getBounds().getY();</span>
<span class="pc bpc" id="L1769" title="1 of 4 branches missed.">                } while (++pos &lt;= end &amp;&amp; cy1 &lt;= clipY2);</span>
<span class="fc" id="L1770">                return pos - 1;</span>
            }
        }
<span class="nc" id="L1773">        return len - 1;</span>
    }

    /**
     * Performs a binary search within the children of the container to find components
     * that intersect the given range on the y-axis.  &lt;b&gt;This should only be used
     * if it is known that the child components are sorted by their y coordinates
     * in ascending order.  Otherwise you'll get undefined results.&lt;/b&gt;
     *
     * @param y1    The lower y-bound of the region to search.  (0,0) is top-left corner of container.
     * @param y2    The upper y-bound of the region to search.  (0,0) is top-left corner of container.
     * @param start The lower &quot;index&quot; to search.
     * @param end   The upper &quot;index&quot; to search.
     * @return The index within the components array of the first child component
     * that intersects the given region.  Or -1 if none is found.
     */
    private int binarySearchFirstIntersectionY(int y1, int y2, int start, int end) {
<span class="pc bpc" id="L1790" title="1 of 2 branches missed.">        if (start &gt;= end) {</span>
<span class="nc" id="L1791">            return -1;</span>
        }
<span class="fc" id="L1793">        int pos = (start + end) / 2;</span>
<span class="fc" id="L1794">        Component c = components.get(pos);</span>
<span class="fc" id="L1795">        Rectangle bounds = c.getBounds();</span>
<span class="fc" id="L1796">        int cy1 = bounds.getY();</span>

<span class="fc" id="L1798">        int cy2 = bounds.getY() + bounds.getHeight();</span>
<span class="pc bpc" id="L1799" title="10 of 12 branches missed.">        if ((cy1 &gt;= y1 &amp;&amp; cy1 &lt;= y2) || (cy2 &gt;= y1 &amp;&amp; cy2 &lt;= y2) || (cy1 &lt;= y1 &amp;&amp; cy2 &gt;= y2)) {</span>
            // We have a hit let's roll backward until we find the first visible
<span class="pc bpc" id="L1801" title="1 of 4 branches missed.">            while (pos &gt; start &amp;&amp; cy1 &gt; y1) {</span>
<span class="fc" id="L1802">                c = components.get(--pos);</span>
<span class="fc" id="L1803">                cy1 = c.getBounds().getY();</span>
            }
<span class="fc" id="L1805">            return pos;</span>
<span class="nc bnc" id="L1806" title="All 2 branches missed.">        } else if (cy1 &gt; y2) {</span>
<span class="nc" id="L1807">            return binarySearchFirstIntersectionY(y1, y2, start, pos);</span>
        } else {
<span class="nc" id="L1809">            return binarySearchFirstIntersectionY(y1, y2, pos + 1, end);</span>
        }
    }

    /**
     * Activates enableLayoutOnPaint behaviour for this container. This is package private because
     * this flag is more complicated than a simple setter.  When the container is initialized
     * it will take on the value of its parent, so it only makes sense to call this method on the
     * top-level container, like a Form.  Form overrides this method and makes it public.
     *
     * &lt;p&gt;Development Note:  enableLayoutOnPaint causes the container to be laid out whenever paint()
     * is called.  This has been part of codename one since the beginning (initial commit to google code), but
     * this taxes rendering performance fairly seriously in some of the complex layouts, and it isn't clear
     * why it was ever necessary.  Perhaps it was to help in an edge case that is no longer relevant.&lt;/p&gt;
     *
     * &lt;p&gt;We are adding this additionally flag which defaults to false to try to gain performance, and just in
     * case the edge case still exists, developers are able to &quot;enable&quot; it again on a form-by-form basis.&lt;/p&gt;
     *
     * @param allow Whether to allow enable layout on paint.
     * @see #enableLayoutOnPaint
     * @since 7.0
     */
    void setAllowEnableLayoutOnPaint(boolean allow) {
<span class="fc" id="L1832">        allowEnableLayoutOnPaint = allow;</span>
<span class="fc" id="L1833">    }</span>

    /**
     * Registers a component with this surface as an elevated component.
     *
     * @param cmp
     */
    void addElevatedComponent(Component cmp) {
<span class="nc bnc" id="L1841" title="All 2 branches missed.">        if (elevatedComponents == null) elevatedComponents = new HashSet&lt;Component&gt;();</span>
<span class="nc" id="L1842">        elevatedComponents.add(cmp);</span>
<span class="nc" id="L1843">    }</span>

    /**
     * Unregisters a component with this surface as an elevated components.
     *
     * @param cmp
     */
    void removeElevatedComponent(Component cmp) {
<span class="nc bnc" id="L1851" title="All 2 branches missed.">        if (elevatedComponents == null) return;</span>
<span class="nc" id="L1852">        elevatedComponents.remove(cmp);</span>
<span class="nc" id="L1853">    }</span>

    /**
     * Paints the all of the elevated components in this surface.
     *
     * @param g
     */
    void paintElevatedPane(Graphics g) {
<span class="nc" id="L1861">        nextElevationComponentIndex = 0;</span>
<span class="nc" id="L1862">        paintElevatedPane(g, false, -1, -1, -1, -1, -1, -1, false);</span>
<span class="nc" id="L1863">    }</span>

    /**
     * Paints the elevated pane for a surface.
     *
     * @param g                                THe graphics context
     * @param useIntersection                  Enable intersection checking.  This is used when trying to paint components above and below other components,
     *                                         as it checks the intersection for painting.
     * @param intersectionX                    IntersectionX in abs screen coords.
     * @param intersectionY                    The intersectonY in abs screen coords
     * @param intersectionWidth                THe intersection width in abs screen coords
     * @param intersectionHeight               The intersection height in abs screen coords
     * @param elevationThreshold               The elevation threshold used when useIntersection is true. If above is true, then this threshold is used to paint
     *                                         only the components on the same elevation level and higher.
     * @param elevationComponentIndexThreshold The elevation component index threshold used when useIntersection is true.  This is used to differentiate the
     *                                         z-index of components in the same elevation level.
     * @param above                            Indicate whether to render components above or below the thresholds specified by elevationThreshold and elevationComponentIndexThreshold.  Only used if useIntersection is true.
     */
    void paintElevatedPane(Graphics g, final boolean useIntersection, int intersectionX, int intersectionY, int intersectionWidth, int intersectionHeight, int elevationThreshold, int elevationComponentIndexThreshold, boolean above) {
<span class="nc" id="L1882">        CodenameOneImplementation impl = Display.impl;</span>
<span class="nc" id="L1883">        int absX = getAbsoluteX();</span>
<span class="nc" id="L1884">        int absY = getAbsoluteY();</span>

<span class="nc" id="L1886">        g.translate(-absX, -absY);</span>

<span class="nc bnc" id="L1888" title="All 4 branches missed.">        if (elevatedComponents != null &amp;&amp; !elevatedComponents.isEmpty()) {</span>
<span class="nc bnc" id="L1889" title="All 2 branches missed.">            if (_tmpRenderingElevatedComponents == null)</span>
<span class="nc" id="L1890">                _tmpRenderingElevatedComponents = new ArrayList&lt;Component&gt;(elevatedComponents);</span>
            else {
<span class="nc" id="L1892">                _tmpRenderingElevatedComponents.clear();</span>
<span class="nc" id="L1893">                _tmpRenderingElevatedComponents.addAll(elevatedComponents);</span>
            }
<span class="nc" id="L1895">            Collections.sort(_tmpRenderingElevatedComponents, new Comparator&lt;Component&gt;() {</span>

                public int compare(Component o1, Component o2) {
<span class="nc" id="L1898">                    int e1 = o1.getStyle().getElevation();</span>
<span class="nc" id="L1899">                    int e2 = o2.getStyle().getElevation();</span>
<span class="nc bnc" id="L1900" title="All 2 branches missed.">                    if (e1 &lt; e2) return -1;</span>
<span class="nc bnc" id="L1901" title="All 2 branches missed.">                    else if (e1 &gt; e2) return 1;</span>
                    else {
<span class="nc" id="L1903">                        return o1.renderedElevationComponentIndex - o2.renderedElevationComponentIndex;</span>
                    }
                }
            });
<span class="nc bnc" id="L1907" title="All 2 branches missed.">            for (Component child : _tmpRenderingElevatedComponents) {</span>
<span class="nc" id="L1908">                int relativeX = child.getRelativeX(this) + child.getScrollX();</span>
<span class="nc" id="L1909">                int relativeY = child.getRelativeY(this) + child.getScrollY();</span>
<span class="nc" id="L1910">                int clipX = g.getClipX();</span>
<span class="nc" id="L1911">                int clipW = g.getClipWidth();</span>
<span class="nc" id="L1912">                int shadowX = relativeX + child.calculateShadowOffsetX();</span>
<span class="nc" id="L1913">                int shadowW = child.calculateShadowWidth();</span>
<span class="nc bnc" id="L1914" title="All 4 branches missed.">                if (shadowX + shadowW &lt;= clipX || shadowX &gt;= clipX + clipW) continue;</span>
<span class="nc" id="L1915">                int clipY = g.getClipY();</span>
<span class="nc" id="L1916">                int clipH = g.getClipHeight();</span>
<span class="nc" id="L1917">                int shadowY = relativeY + child.calculateShadowOffsetY();</span>
<span class="nc" id="L1918">                int shadowH = child.calculateShadowHeight();</span>
<span class="nc bnc" id="L1919" title="All 4 branches missed.">                if (shadowY + shadowH &lt;= clipY || shadowY &gt;= clipY + clipH) continue;</span>


<span class="nc bnc" id="L1922" title="All 4 branches missed.">                if (!useIntersection || Rectangle.intersects(child.getAbsoluteX() + child.getScrollX() + child.calculateShadowOffsetX(),</span>
<span class="nc" id="L1923">                        child.getAbsoluteY() + child.getScrollY() + child.calculateShadowOffsetY(),</span>
<span class="nc" id="L1924">                        child.calculateShadowWidth(),</span>
<span class="nc" id="L1925">                        child.calculateShadowHeight(),</span>
                        intersectionX, intersectionY, intersectionWidth, intersectionHeight)
                ) {
<span class="nc bnc" id="L1928" title="All 2 branches missed.">                    if (!useIntersection) {</span>
<span class="nc" id="L1929">                        child.renderedElevation = child.getStyle().getElevation();</span>
<span class="nc" id="L1930">                        child.renderedElevationComponentIndex = nextElevationComponentIndex++;</span>
                    }
<span class="nc bnc" id="L1932" title="All 20 branches missed.">                    if (!useIntersection || elevationThreshold &lt; 0 ||</span>
                            (above &amp;&amp; (elevationThreshold &lt; child.renderedElevation || elevationThreshold == child.renderedElevation &amp;&amp; elevationComponentIndexThreshold &lt; child.renderedElevationComponentIndex)) ||
                            (!above &amp;&amp; (elevationThreshold &gt; child.renderedElevation || elevationThreshold == child.renderedElevation &amp;&amp; elevationComponentIndexThreshold &gt; child.renderedElevationComponentIndex))) {
<span class="nc" id="L1935">                        g.translate(absX, absY);</span>
<span class="nc" id="L1936">                        child.paintShadows(impl.getComponentScreenGraphics(this, g), child.getRelativeX(this), child.getRelativeY(this));</span>
<span class="nc" id="L1937">                        g.translate(-absX, -absY);</span>
<span class="nc" id="L1938">                        int tx = child.getParent().getRelativeX(this) + child.getScrollX();</span>
<span class="nc" id="L1939">                        int ty = child.getParent().getRelativeY(this) + child.getScrollY();</span>
<span class="nc" id="L1940">                        g.translate(tx, ty);</span>

<span class="nc" id="L1942">                        child.paintInternal(impl.getComponentScreenGraphics(this, g), false);</span>
<span class="nc" id="L1943">                        g.translate(-tx, -ty);</span>
                    }

                }


<span class="nc" id="L1949">                Container cnt = child.getParent();</span>
<span class="nc" id="L1950">                Component currCmp = child;</span>
<span class="nc" id="L1951">                boolean foundOverlap = false;</span>

                // We need to paint all components that should be &quot;on top&quot; of the elevated component
                // also.
                paintOnTopLoop:
<span class="nc bnc" id="L1956" title="All 4 branches missed.">                while (cnt != this &amp;&amp; cnt != null) {</span>
<span class="nc" id="L1957">                    Layout cntLayout = cnt.getLayout();</span>
<span class="nc bnc" id="L1958" title="All 4 branches missed.">                    if (!foundOverlap &amp;&amp; cntLayout.isOverlapSupported()) foundOverlap = true;</span>
<span class="nc bnc" id="L1959" title="All 2 branches missed.">                    if (foundOverlap) {</span>
<span class="nc" id="L1960">                        int currCmpIndex = cnt.getComponentIndex(currCmp);</span>
<span class="nc bnc" id="L1961" title="All 2 branches missed.">                        if (currCmpIndex &gt;= 0) {</span>
<span class="nc" id="L1962">                            int count = cnt.getComponentCount();</span>
<span class="nc bnc" id="L1963" title="All 2 branches missed.">                            for (int i = currCmpIndex + 1; i &lt; count; i++) {</span>
<span class="nc" id="L1964">                                Component cntChild = cnt.getComponentAt(i);</span>
<span class="nc bnc" id="L1965" title="All 2 branches missed.">                                if (elevatedComponents.contains(cntChild)) {</span>
                                    // if this component is itself an elevated component
                                    // then it, and all of its subsequent
<span class="nc" id="L1968">                                    break paintOnTopLoop;</span>
                                }
<span class="nc bnc" id="L1970" title="All 4 branches missed.">                                if (!useIntersection || Rectangle.intersects(cntChild.getAbsoluteX() + cntChild.getScrollX(), cntChild.getAbsoluteY() + cntChild.getScrollY(), cntChild.getWidth(), cntChild.getHeight(),</span>
                                        intersectionX, intersectionY, intersectionWidth, intersectionHeight)
                                ) {
<span class="nc bnc" id="L1973" title="All 2 branches missed.">                                    if (!useIntersection) {</span>
<span class="nc" id="L1974">                                        cntChild.renderedElevation = child.renderedElevation;</span>
<span class="nc" id="L1975">                                        cntChild.renderedElevationComponentIndex = nextElevationComponentIndex++;</span>
                                    }
<span class="nc bnc" id="L1977" title="All 20 branches missed.">                                    if (!useIntersection || elevationThreshold &lt; 0 ||</span>
                                            (above &amp;&amp; (elevationThreshold &lt; cntChild.renderedElevation || elevationThreshold == cntChild.renderedElevation &amp;&amp; elevationComponentIndexThreshold &lt; cntChild.renderedElevationComponentIndex)) ||
                                            (!above &amp;&amp; (elevationThreshold &gt; cntChild.renderedElevation || elevationThreshold == cntChild.renderedElevation &amp;&amp; elevationComponentIndexThreshold &gt; cntChild.renderedElevationComponentIndex))) {
<span class="nc" id="L1980">                                        int tx = cntChild.getParent().getRelativeX(this) + cntChild.getParent().getScrollX();</span>
<span class="nc" id="L1981">                                        int ty = cntChild.getParent().getRelativeY(this) + cntChild.getParent().getScrollY();</span>
<span class="nc" id="L1982">                                        g.translate(tx, ty);</span>

<span class="nc" id="L1984">                                        cntChild.paintInternal(impl.getComponentScreenGraphics(this, g), false);</span>

<span class="nc" id="L1986">                                        g.translate(-tx, -ty);</span>
                                    }
                                }
                            }
                        }
                    }
<span class="nc" id="L1992">                    currCmp = cnt;</span>
<span class="nc" id="L1993">                    cnt = cnt.getParent();</span>


<span class="nc" id="L1996">                }</span>

<span class="nc" id="L1998">            }</span>
        }
<span class="nc" id="L2000">        g.translate(absX, absY);</span>

<span class="nc" id="L2002">    }</span>

    /**
     * This is used to &quot;tag&quot; components in this surface that should be rendered in the elevated pane.
     * This just sets or unsets the {@link Component#doNotPaint} flag so that rendering of the non-elevated
     * pane can proceed without rendering elevated components.
     *
     * @param shouldPaintInElevatedPane True if we are setting the doNotPaint flag.  False if we are unsetting it.
     */
    void markComponentsToBePaintedInElevatedPane(boolean shouldPaintInElevatedPane) {
<span class="nc bnc" id="L2012" title="All 4 branches missed.">        if (elevatedComponents != null &amp;&amp; !elevatedComponents.isEmpty()) {</span>
<span class="nc bnc" id="L2013" title="All 2 branches missed.">            for (Component child : elevatedComponents) {</span>
<span class="nc" id="L2014">                child.doNotPaint = shouldPaintInElevatedPane;</span>
<span class="nc" id="L2015">                Container cnt = child.getParent();</span>
<span class="nc" id="L2016">                Component currCmp = child;</span>
<span class="nc" id="L2017">                boolean foundOverlap = false;</span>

                // We need to paint all components that should be &quot;on top&quot; of the elevated component
                // also.
                paintOnTopLoop:
<span class="nc bnc" id="L2022" title="All 4 branches missed.">                while (cnt != this &amp;&amp; cnt != null) {</span>
<span class="nc" id="L2023">                    Layout cntLayout = cnt.getLayout();</span>
<span class="nc bnc" id="L2024" title="All 4 branches missed.">                    if (!foundOverlap &amp;&amp; cntLayout.isOverlapSupported()) foundOverlap = true;</span>
<span class="nc bnc" id="L2025" title="All 2 branches missed.">                    if (foundOverlap) {</span>
<span class="nc" id="L2026">                        int currCmpIndex = cnt.getComponentIndex(currCmp);</span>
<span class="nc bnc" id="L2027" title="All 2 branches missed.">                        if (currCmpIndex &gt;= 0) {</span>
<span class="nc" id="L2028">                            int count = cnt.getComponentCount();</span>
<span class="nc bnc" id="L2029" title="All 2 branches missed.">                            for (int i = currCmpIndex + 1; i &lt; count; i++) {</span>
<span class="nc" id="L2030">                                Component cntChild = cnt.getComponentAt(i);</span>
<span class="nc bnc" id="L2031" title="All 2 branches missed.">                                if (elevatedComponents.contains(cntChild)) {</span>
                                    // if this component is itself an elevated component
                                    // then it, and all of its subsequent
<span class="nc" id="L2034">                                    break paintOnTopLoop;</span>
                                }
<span class="nc" id="L2036">                                child.doNotPaint = shouldPaintInElevatedPane;</span>

                            }
                        }
                    }
<span class="nc" id="L2041">                    currCmp = cnt;</span>
<span class="nc" id="L2042">                    cnt = cnt.getParent();</span>

<span class="nc" id="L2044">                }</span>

<span class="nc" id="L2046">            }</span>
        }
<span class="nc" id="L2048">    }</span>

    /**
     * {@inheritDoc}
     */
    public void paint(Graphics g) {
        // Q: Why two flags for enableLayoutOnPaint?
        // A: enableLayoutOnPaint is managed internally, and it enabled/renabled
        //    in CN1 code during certain performance-sensitive periods.
        //    allowEnableLayoutOnPaint is a flag controlled by the developer so that
        //    they can enable/disable this behaviour at form level via the setAllowEnableLayoutOnPaint(boolean)
        //    method.  See javadocs for Form.setAllowEnableOnPaint(boolean) for historical background
        //    this feature.
<span class="pc bpc" id="L2061" title="3 of 4 branches missed.">        if (allowEnableLayoutOnPaint &amp;&amp; enableLayoutOnPaint) {</span>
<span class="nc" id="L2062">            layoutContainer();</span>
        }
<span class="fc" id="L2064">        g.translate(getX(), getY());</span>

<span class="fc" id="L2066">        int size = components.size();</span>
<span class="fc" id="L2067">        int startIter = 0;</span>
<span class="fc bfc" id="L2068" title="All 2 branches covered.">        if (size &gt;= 30) {</span>
<span class="fc" id="L2069">            int clipX1 = g.getClipX();</span>
<span class="fc" id="L2070">            int clipX2 = g.getClipX() + g.getClipWidth();</span>
<span class="fc" id="L2071">            int clipY1 = g.getClipY();</span>
<span class="fc" id="L2072">            int clipY2 = g.getClipY() + g.getClipHeight();</span>
<span class="fc" id="L2073">            startIter = calculateFirstPaintableOffset(clipX1, clipY1, clipX2, clipY2);</span>
<span class="fc bfc" id="L2074" title="All 2 branches covered.">            if (startIter &lt; 0) {</span>
                // There was no efficient way to calculate the offset
<span class="fc" id="L2076">                startIter = 0;</span>
<span class="pc bpc" id="L2077" title="1 of 2 branches missed.">            } else if (startIter &lt; size) {</span>
                // There was an efficient way to calculate the offset so we
                // will continue this approach
<span class="fc" id="L2080">                size = calculateLastPaintableOffset(startIter, clipX1, clipY1, clipX2, clipY2) + 1;</span>
            }
        }

<span class="pc bpc" id="L2084" title="5 of 6 branches missed.">        if (isSurface() &amp;&amp; elevatedComponents != null &amp;&amp; !elevatedComponents.isEmpty()) {</span>
            // We need to mark all of the elevated components so that they don't render the first time around
<span class="nc" id="L2086">            markComponentsToBePaintedInElevatedPane(true);</span>

        }

<span class="fc" id="L2090">        CodenameOneImplementation impl = Display.impl;</span>
<span class="fc bfc" id="L2091" title="All 2 branches covered.">        if (dontRecurseContainer) {</span>
<span class="fc bfc" id="L2092" title="All 2 branches covered.">            for (int iter = startIter; iter &lt; size; iter++) {</span>
<span class="fc" id="L2093">                Component cmp = components.get(iter);</span>
<span class="pc bpc" id="L2094" title="1 of 2 branches missed.">                if (cmp.getClass() == Container.class) {</span>
<span class="nc" id="L2095">                    paintContainerChildrenForAnimation((Container) cmp, g);</span>
                } else {
<span class="fc" id="L2097">                    cmp.paintInternal(impl.getComponentScreenGraphics(this, g), false);</span>
                }
            }
        } else {
<span class="fc bfc" id="L2101" title="All 2 branches covered.">            for (int iter = startIter; iter &lt; size; iter++) {</span>
<span class="fc" id="L2102">                Component cmp = components.get(iter);</span>
<span class="fc" id="L2103">                cmp.paintInternal(impl.getComponentScreenGraphics(this, g), false);</span>
            }
        }

<span class="pc bpc" id="L2107" title="5 of 6 branches missed.">        if (isSurface() &amp;&amp; elevatedComponents != null &amp;&amp; !elevatedComponents.isEmpty()) {</span>
<span class="nc" id="L2108">            markComponentsToBePaintedInElevatedPane(false);</span>
<span class="nc" id="L2109">            paintElevatedPane(g);</span>
        }

<span class="fc" id="L2112">        int tx = g.getTranslateX();</span>
<span class="fc" id="L2113">        int ty = g.getTranslateY();</span>
<span class="fc" id="L2114">        g.translate(-tx, -ty);</span>
<span class="pc bpc" id="L2115" title="1 of 2 branches missed.">        if (sidemenuBarTranslation &gt; 0) {</span>
<span class="nc" id="L2116">            g.translate(sidemenuBarTranslation, 0);</span>
<span class="nc" id="L2117">            paintGlass(g);</span>
<span class="nc" id="L2118">            paintTensile(g);</span>
<span class="nc" id="L2119">            g.translate(-sidemenuBarTranslation, 0);</span>
        } else {
<span class="fc" id="L2121">            paintGlass(g);</span>
<span class="fc" id="L2122">            paintTensile(g);</span>
        }
<span class="fc" id="L2124">        g.translate(tx, ty);</span>
<span class="fc" id="L2125">        g.translate(-getX(), -getY());</span>
<span class="fc" id="L2126">    }</span>

    /**
     * This method can be overriden by a component to draw on top of itself or its children
     * after the component or the children finished drawing in a similar way to the glass
     * pane but more refined per component
     *
     * @param g the graphics context
     */
    protected void paintGlass(Graphics g) {
<span class="fc" id="L2136">    }</span>

    void paintGlassImpl(Graphics g) {
<span class="fc" id="L2139">        super.paintGlassImpl(g);</span>
<span class="fc" id="L2140">        paintGlass(g);</span>
<span class="fc" id="L2141">    }</span>

    void paintIntersecting(Graphics g, Component cmp, int x, int y, int w, int h, boolean above, int elevation) {

<span class="pc bpc" id="L2145" title="1 of 4 branches missed.">        if (layout.isOverlapSupported() &amp;&amp; cmp.getParent() == this) {</span>
<span class="fc" id="L2146">            int indexOfComponent = components.indexOf(cmp);</span>

            int startIndex;
            int endIndex;

<span class="fc bfc" id="L2151" title="All 2 branches covered.">            if (above) {</span>
<span class="fc" id="L2152">                startIndex = indexOfComponent + 1;</span>
<span class="fc" id="L2153">                endIndex = components.size();</span>
            } else {
<span class="fc" id="L2155">                startIndex = 0;</span>
<span class="fc" id="L2156">                endIndex = indexOfComponent;</span>
            }

<span class="fc bfc" id="L2159" title="All 2 branches covered.">            for (int i = startIndex; i &lt; endIndex; i++) {</span>
<span class="fc" id="L2160">                Component cmp2 = components.get(i);</span>
<span class="pc bpc" id="L2161" title="1 of 2 branches missed.">                if (cmp2.renderedElevation != elevation) continue;</span>
<span class="fc bfc" id="L2162" title="All 2 branches covered.">                if (Rectangle.intersects(x, y, w, h,</span>
<span class="fc" id="L2163">                        cmp2.getAbsoluteX() + cmp2.getScrollX(),</span>
<span class="fc" id="L2164">                        cmp2.getAbsoluteY() + cmp2.getScrollY(),</span>
<span class="fc" id="L2165">                        cmp2.getBounds().getSize().getWidth(),</span>
<span class="fc" id="L2166">                        cmp2.getBounds().getSize().getHeight())) {</span>
<span class="fc" id="L2167">                    cmp2.paintInternal(g, false);</span>
                }
            }
        }
<span class="fc" id="L2171">    }</span>

    /**
     * Performs the layout of the container if a layout is necessary
     */
    public void layoutContainer() {
        //will compute the container + components and will layout the components.
<span class="fc bfc" id="L2178" title="All 2 branches covered.">        if (shouldLayout) {</span>
<span class="fc" id="L2179">            shouldLayout = false;</span>
<span class="fc" id="L2180">            doLayout();</span>
        }
<span class="fc" id="L2182">    }</span>

    private boolean hasScrollableYParentInternal() {
<span class="nc bnc" id="L2185" title="All 2 branches missed.">        if (getParent() == null) {</span>
<span class="nc" id="L2186">            return false;</span>
        }
<span class="nc bnc" id="L2188" title="All 2 branches missed.">        if (getParent().scrollableYFlag()) {</span>
<span class="nc" id="L2189">            return true;</span>
        }
<span class="nc" id="L2191">        return getParent().hasScrollableYParentInternal();</span>
    }

    private boolean hasScrollableXParentInternal() {
<span class="nc bnc" id="L2195" title="All 2 branches missed.">        if (getParent() == null) {</span>
<span class="nc" id="L2196">            return false;</span>
        }
<span class="nc bnc" id="L2198" title="All 2 branches missed.">        if (getParent().scrollableXFlag()) {</span>
<span class="nc" id="L2199">            return true;</span>
        }
<span class="nc" id="L2201">        return getParent().hasScrollableXParentInternal();</span>
    }

    /**
     * Checks if this container is a &quot;safe area&quot;.  A &quot;safe area&quot; is a container whose
     * contents will always be displayed inside the device's &quot;safe display area&quot;.
     * &lt;p&gt;This feature was added primarily for the iPhone X which covers some parts of
     * the screen and would cover or interfere with any content drawn in those regions. In particular,
     * the notch, the rounded corners, and the task bar cover portions of the screen.&lt;/p&gt;
     *
     * &lt;p&gt;A container that is a safe area will automatically add appropriate padding
     * on layout so that its children will be rendered completely in the safe area of
     * the screen.  This only applies if the container has no scrollable parents.  If a
     * &quot;safe&quot; container has scrollable parents, then it is assumed that the user can
     * just scroll it into a safe area.&lt;/p&gt;
     *
     * @return True if this container is a safe area.
     * @see #setSafeArea(boolean)
     * @see Form#getSafeArea()
     * @since 7.0
     */
    public boolean isSafeArea() {
<span class="nc" id="L2223">        return this.safeArea;</span>
    }

    /**
     * Marks this container as a &quot;safe area&quot;, meaning that it will automatically supply
     * sufficient padding as necessary for its children to be laid out inside the
     * safe area of the screen.
     *
     * &lt;p&gt;This was primarily added for the iPhone X which covers portions of the screen
     * and may interfere with components that are rendered there.&lt;/p&gt;
     *
     * &lt;p&gt;The &quot;safe&quot; area is calculated against a &quot;safe area root&quot;'s bounds, which is
     * the parent form by default.  In some cases it may be helpful to make the root
     * a sub-container, such as if you need to lay a component out off-screen.  See
     * {@link #setSafeAreaRoot(boolean)} for more details.&lt;/p&gt;
     *
     * @param safeArea True to make this container a safe area.
     * @see Form#getSafeArea()
     * @see #isSafeArea()
     * @see #setSafeAreaRoot(boolean)
     * @since 7.0
     */
    public void setSafeArea(boolean safeArea) {
<span class="fc" id="L2246">        this.safeArea = safeArea;</span>
<span class="fc" id="L2247">    }</span>

    /**
     * Checks if this container is a safe area root.  A safe area root is a container
     * against whose bounds, safe area margins are calculated for child components.
     *
     * &lt;p&gt;Forms are safe area roots by default.&lt;/p&gt;
     *
     * @return
     * @see #setSafeAreaRoot(boolean)
     * @since 7.0
     */
    public boolean isSafeAreaRoot() {
<span class="nc" id="L2260">        return safeAreaRoot;</span>
    }

    /**
     * Gets the Safe area &quot;root&quot; container for this container.  This method will walk
     * up the component hierarchy until is finds a Container with {@link #isSafeAreaRoot() } true.
     *
     * &lt;p&gt;Forms are safe area roots by default, but it is possible to mark other containers
     * as safe area roots.&lt;/p&gt;
     *
     * &lt;p&gt;A safe area root is a container from which safe area margins are applied when
     * calculating the safe areas of child components.  Setting a root can facilitate the
     * layout of a container's children before it appears on the screen.&lt;/p&gt;
     *
     * @return
     * @since 7.0
     */
    public Container getSafeAreaRoot() {
<span class="fc bfc" id="L2278" title="All 2 branches covered.">        if (safeAreaRoot) {</span>
<span class="fc" id="L2279">            return this;</span>
        }
<span class="fc" id="L2281">        Container parent = getParent();</span>
<span class="fc bfc" id="L2282" title="All 2 branches covered.">        if (parent != null) {</span>
<span class="fc" id="L2283">            return parent.getSafeAreaRoot();</span>
        }
<span class="fc" id="L2285">        return null;</span>
    }

    /**
     * Set whether this container is a safe area root.   A safe area root is a container
     * against whose bounds, safe area margins are calculated for child components.
     *
     * &lt;p&gt;&lt;strong&gt;Safe Area root vs Safe Area&lt;/strong&gt;&lt;/p&gt;
     *
     * &lt;p&gt;A Safe Area root is not actually a safe area.  It will lay out its children
     * normally, without any adjustments to padding to accommodate the display safe area.  They
     * are rather &lt;em&gt;used&lt;/em&gt; by safe area child containers to calculate safe area margins,
     * according to if the safe area root container spanned the entire screen&lt;/p&gt;
     *
     * &lt;p&gt;In most cases you don't need to explicitly set a safe area root, since Forms are
     * marked as roots by default.  However, there are edge cases where components may be
     * initially laid out off-screen (in which safe areas are not applied), but are transitioned
     * in.  Once on the screen, the safe margins would be applied which may cause an abrupt
     * re-layout at the moment that the safe margins are applied.  This edge case occurs in,
     * for example, a side menu bar which is rendered off-screen.  By making the side menu bar
     * container a &quot;root&quot; itself, the safe areas will be applied to the layout, even when
     * the menu is off-screen.  Then there is no &quot;jerk&quot; when it transitions in.&lt;/p&gt;
     *
     * @param root True to make this a root.  False to make it &quot;not&quot; a root.
     * @see #isSafeAreaRoot()
     * @since 7.0
     */
    public void setSafeAreaRoot(boolean root) {
<span class="fc" id="L2313">        this.safeAreaRoot = root;</span>
<span class="fc" id="L2314">    }</span>

    /**
     * Checks to see if this container or any of its parents are safe areas.
     *
     * @param checkParents True to check parents too.  False to just check this container.
     * @return
     */
    private boolean isSafeAreaInternal(boolean checkParents) {
<span class="pc bpc" id="L2323" title="1 of 2 branches missed.">        if (safeArea) {</span>
<span class="nc" id="L2324">            return true;</span>
        }
<span class="pc bpc" id="L2326" title="1 of 2 branches missed.">        if (checkParents) {</span>
<span class="fc" id="L2327">            Container parent = getParent();</span>
<span class="fc bfc" id="L2328" title="All 2 branches covered.">            if (parent != null) {</span>
<span class="fc" id="L2329">                return parent.isSafeAreaInternal(true);</span>
            }
        }
<span class="fc" id="L2332">        return false;</span>
    }

    /**
     * For iPhone X primarily.  This will check if the current bounds goes outside the
     * safe area.  If so, it will add padding to make the contents fit the safe area.
     */
    private boolean snapToSafeAreaInternal() {
<span class="pc bpc" id="L2340" title="1 of 2 branches missed.">        if (isHidden()) {</span>
<span class="nc" id="L2341">            return false;</span>
        }
<span class="fc" id="L2343">        Container safeAreaRoot = getSafeAreaRoot();</span>
<span class="fc bfc" id="L2344" title="All 2 branches covered.">        if (safeAreaRoot == null) {</span>
<span class="fc" id="L2345">            return false;</span>
        }
<span class="fc" id="L2347">        Rectangle rect = Display.impl.getDisplaySafeArea(new Rectangle());</span>
<span class="fc" id="L2348">        int safeLeftMargin = rect.getX();</span>
<span class="fc" id="L2349">        int safeRightMargin = CN.getDisplayWidth() - rect.getWidth() - rect.getX();</span>
<span class="fc" id="L2350">        int safeTopMargin = rect.getY();</span>
<span class="fc" id="L2351">        int safeBottomMargin = CN.getDisplayHeight() - rect.getHeight() - rect.getY();</span>
<span class="pc bpc" id="L2352" title="4 of 8 branches missed.">        if (safeLeftMargin == 0 &amp;&amp; safeRightMargin == 0 &amp;&amp; safeBottomMargin == 0 &amp;&amp; safeTopMargin == 0) {</span>
<span class="fc" id="L2353">            return false;</span>
        }
<span class="nc" id="L2355">        rect.setWidth(Math.max(0, safeAreaRoot.getWidth() - safeLeftMargin - safeRightMargin));</span>
<span class="nc" id="L2356">        rect.setHeight(Math.max(0, safeAreaRoot.getHeight() - safeTopMargin - safeBottomMargin));</span>
<span class="nc bnc" id="L2357" title="All 4 branches missed.">        if (rect.getWidth() == 0 || rect.getHeight() == 0) {</span>
<span class="nc" id="L2358">            return false;</span>
        }
<span class="nc" id="L2360">        Rectangle safeArea = rect;</span>
        //Form f = getComponentForm();
        //if (f == null) {
        //    return false;
        //}

        //Rectangle safeArea = f.getSafeArea();

        //if (safeArea.getX() == 0 &amp;&amp; safeArea.getY() == 0 &amp;&amp; safeArea.getWidth() == CN.getDisplayWidth() &amp;&amp; safeArea.getHeight() == CN.getDisplayHeight()) {
        //    return false;
        //}
<span class="nc" id="L2371">        Style style = getStyle();</span>
<span class="nc" id="L2372">        int safeX1 = safeArea.getX();</span>
<span class="nc" id="L2373">        int safeX2 = safeArea.getWidth() + safeX1;</span>
<span class="nc" id="L2374">        int safeY1 = safeArea.getY();</span>
<span class="nc" id="L2375">        int safeY2 = safeArea.getHeight() + safeY1;</span>


<span class="nc" id="L2378">        int paddingLeft = style.getPaddingLeftNoRTL();</span>
<span class="nc" id="L2379">        int paddingRight = style.getPaddingRightNoRTL();</span>
<span class="nc" id="L2380">        int paddingTop = style.getPaddingTop();</span>
<span class="nc" id="L2381">        int paddingBottom = style.getPaddingBottom();</span>


<span class="nc" id="L2384">        int newPaddingTop = paddingTop;</span>
<span class="nc" id="L2385">        int newPaddingBottom = paddingBottom;</span>
<span class="nc" id="L2386">        int newPaddingLeft = paddingLeft;</span>
<span class="nc" id="L2387">        int newPaddingRight = paddingRight;</span>


<span class="nc" id="L2390">        int absX = getAbsoluteX() - safeAreaRoot.getAbsoluteX();</span>
<span class="nc" id="L2391">        int w = getWidth();</span>
<span class="nc" id="L2392">        int absX2 = absX + w;</span>

<span class="nc bnc" id="L2394" title="All 2 branches missed.">        if (absX &gt;= 0) {</span>
<span class="nc bnc" id="L2395" title="All 2 branches missed.">            if (absX + paddingLeft &lt; safeX1) {</span>
<span class="nc" id="L2396">                newPaddingLeft = safeX1 - absX;</span>
            }
        }
<span class="nc bnc" id="L2399" title="All 2 branches missed.">        if (absX2 &lt;= safeAreaRoot.getWidth()) {</span>
<span class="nc bnc" id="L2400" title="All 2 branches missed.">            if (absX2 - paddingRight &gt; safeX2) {</span>
<span class="nc" id="L2401">                newPaddingRight = absX2 - safeX2;</span>
            }
        }

<span class="nc" id="L2405">        int absY = getAbsoluteY() - safeAreaRoot.getAbsoluteY();</span>
<span class="nc" id="L2406">        int h = getHeight();</span>
<span class="nc" id="L2407">        int absY2 = absY + h;</span>


<span class="nc bnc" id="L2410" title="All 2 branches missed.">        if (absY &gt;= 0) {</span>
<span class="nc bnc" id="L2411" title="All 2 branches missed.">            if (absY + paddingTop &lt; safeY1) {</span>
<span class="nc" id="L2412">                newPaddingTop = safeY1 - absY;</span>
            }
        }
<span class="nc bnc" id="L2415" title="All 2 branches missed.">        if (absY2 &lt;= safeAreaRoot.getHeight()) {</span>
<span class="nc bnc" id="L2416" title="All 2 branches missed.">            if (absY2 - paddingBottom &gt; safeY2) {</span>
<span class="nc" id="L2417">                newPaddingBottom = absY2 - safeY2;</span>
            }
        }

<span class="nc" id="L2421">        boolean changed = false;</span>
<span class="nc bnc" id="L2422" title="All 4 branches missed.">        if (newPaddingTop != paddingTop || newPaddingBottom != paddingBottom) {</span>
<span class="nc bnc" id="L2423" title="All 2 branches missed.">            if (!hasScrollableYParentInternal()) {</span>
<span class="nc" id="L2424">                changed = true;</span>

<span class="nc bnc" id="L2426" title="All 2 branches missed.">                if (newPaddingTop != paddingTop) {</span>
<span class="nc" id="L2427">                    style.setPaddingUnitTop(Style.UNIT_TYPE_PIXELS);</span>
<span class="nc" id="L2428">                    style.setPaddingTop(newPaddingTop);</span>
                }
<span class="nc bnc" id="L2430" title="All 2 branches missed.">                if (newPaddingBottom != paddingBottom) {</span>
<span class="nc" id="L2431">                    style.setPaddingUnitBottom(Style.UNIT_TYPE_PIXELS);</span>
<span class="nc" id="L2432">                    style.setPaddingBottom(newPaddingBottom);</span>
                }

            }
        }

<span class="nc bnc" id="L2438" title="All 4 branches missed.">        if (newPaddingLeft != paddingLeft || newPaddingRight != paddingRight) {</span>
<span class="nc bnc" id="L2439" title="All 2 branches missed.">            if (!hasScrollableXParentInternal()) {</span>
<span class="nc" id="L2440">                changed = true;</span>

<span class="nc bnc" id="L2442" title="All 2 branches missed.">                if (newPaddingLeft != paddingLeft) {</span>
<span class="nc" id="L2443">                    style.setPaddingUnitLeft(Style.UNIT_TYPE_PIXELS);</span>
<span class="nc" id="L2444">                    style.setPaddingLeft(newPaddingLeft);</span>
                }
<span class="nc bnc" id="L2446" title="All 2 branches missed.">                if (newPaddingRight != paddingRight) {</span>
<span class="nc" id="L2447">                    style.setPaddingUnitRight(Style.UNIT_TYPE_PIXELS);</span>
<span class="nc" id="L2448">                    style.setPaddingRight(newPaddingRight);</span>
                }


            }
        }
<span class="nc" id="L2454">        return changed;</span>

    }

    void doLayout() {
<span class="fc" id="L2459">        doLayoutDepth++;</span>
<span class="fc" id="L2460">        boolean restoreBounds = false;</span>
<span class="pc bpc" id="L2461" title="1 of 4 branches missed.">        if (safeArea &amp;&amp; doLayoutDepth == 1) {</span>
            // If this container is marked as a safe area
            // then we may need to add padding to make it *safe*
<span class="fc" id="L2464">            Container parent = getParent();</span>
<span class="pc bpc" id="L2465" title="1 of 4 branches missed.">            if (parent == null || !parent.isSafeAreaInternal(true)) {</span>
                // For efficiency, we check if the parent is a safe area.
                // If so, we don't need to worry because it has already
                // added appropriate padding.
<span class="fc bfc" id="L2469" title="All 2 branches covered.">                if (tmpInsets == null) {</span>
<span class="fc" id="L2470">                    tmpInsets = new TmpInsets();</span>
                }
<span class="fc" id="L2472">                Style s = getStyle();</span>
<span class="fc" id="L2473">                tmpInsets.set(s);</span>
<span class="fc" id="L2474">                restoreBounds = snapToSafeAreaInternal();</span>
            }
        }
<span class="fc" id="L2477">        layout.layoutContainer(this);</span>
<span class="fc" id="L2478">        int count = getComponentCount();</span>
<span class="fc bfc" id="L2479" title="All 2 branches covered.">        for (int i = 0; i &lt; count; i++) {</span>
<span class="fc" id="L2480">            Component c = getComponentAt(i);</span>
<span class="fc bfc" id="L2481" title="All 2 branches covered.">            if (c instanceof Container) {</span>
<span class="fc" id="L2482">                ((Container) c).layoutContainer();</span>
            } else {
<span class="fc" id="L2484">                c.laidOut();</span>
            }
        }
<span class="pc bpc" id="L2487" title="3 of 4 branches missed.">        if (restoreBounds &amp;&amp; tmpInsets != null) {</span>
<span class="nc" id="L2488">            tmpInsets.restore(getStyle());</span>
        }
<span class="fc" id="L2490">        laidOut();</span>
<span class="fc bfc" id="L2491" title="All 2 branches covered.">        if (Form.activePeerCount &gt; 0) {</span>
<span class="fc" id="L2492">            onParentPositionChange();</span>
        }
<span class="fc" id="L2494">        doLayoutDepth--;</span>

<span class="fc" id="L2496">    }</span>

    /**
     * Returns the number of components
     *
     * @return the Component count
     */
    public int getComponentCount() {
<span class="fc" id="L2504">        return components.size();</span>
    }

    /**
     * Returns the Component at a given index
     *
     * @param index of the Component you wish to get
     * @return a Component
     * @throws ArrayIndexOutOfBoundsException if an invalid index was given.
     */
    public Component getComponentAt(
            int index) {
<span class="fc" id="L2516">        return components.get(index);</span>
    }

    /**
     * Returns the Component index in the Container
     *
     * @param cmp the component to search for
     * @return the Component index in the Container or -1 if not found
     */
    public int getComponentIndex(Component cmp) {
<span class="fc" id="L2526">        int count = getComponentCount();</span>
<span class="pc bpc" id="L2527" title="1 of 2 branches missed.">        for (int i = 0; i &lt;</span>
<span class="fc" id="L2528">                count; i++) {</span>
<span class="fc" id="L2529">            Component c = getComponentAt(i);</span>
<span class="fc bfc" id="L2530" title="All 2 branches covered.">            if (c.equals(cmp)) {</span>
<span class="fc" id="L2531">                return i;</span>
            }
        }
<span class="nc" id="L2534">        return -1;</span>
    }

    /**
     * Returns true if the given component is within the hierarchy of this container
     *
     * @param cmp a Component to check
     * @return true if this Component contains in this Container
     */
    public boolean contains(Component cmp) {
<span class="fc bfc" id="L2544" title="All 2 branches covered.">        if (cmp == null) {</span>
<span class="fc" id="L2545">            return false;</span>
        }
<span class="fc" id="L2547">        cmp = cmp.getParent();</span>
<span class="fc bfc" id="L2548" title="All 2 branches covered.">        while (cmp != null) {</span>
<span class="fc bfc" id="L2549" title="All 2 branches covered.">            if (cmp == this) {</span>
<span class="fc" id="L2550">                return true;</span>
            }
<span class="fc" id="L2552">            cmp = cmp.getParent();</span>
        }
<span class="fc" id="L2554">        return false;</span>
    }

    /**
     * Makes sure the component is visible in the scroll if this container is
     * scrollable
     *
     * @param c the component that will be scrolling for visibility
     */
    public void scrollComponentToVisible(final Component c) {
<span class="fc bfc" id="L2564" title="All 2 branches covered.">        if (isScrollable()) {</span>
<span class="pc bpc" id="L2565" title="1 of 2 branches missed.">            if (c != null) {</span>
<span class="fc" id="L2566">                Rectangle r = c.getVisibleBounds();</span>
<span class="pc bpc" id="L2567" title="1 of 2 branches missed.">                if (c.getParent() != null) {</span>
                    // special case for the first component to allow the user to scroll all the
                    // way to the top
<span class="fc" id="L2570">                    Form f = getComponentForm();</span>
<span class="pc bpc" id="L2571" title="3 of 4 branches missed.">                    if (f != null &amp;&amp; f.getInvisibleAreaUnderVKB() == 0 &amp;&amp;</span>
<span class="nc bnc" id="L2572" title="All 2 branches missed.">                            f.findFirstFocusable() == c) {</span>
                        // support this use case only if the component doesn't explicitly declare visible bounds
<span class="nc bnc" id="L2574" title="All 4 branches missed.">                        if (r == c.getBounds() &amp;&amp; !Display.getInstance().isTouchScreenDevice()) {</span>
<span class="nc" id="L2575">                            scrollRectToVisible(new Rectangle(0, 0,</span>
<span class="nc" id="L2576">                                    c.getX() + Math.min(c.getWidth(), getWidth()),</span>
<span class="nc" id="L2577">                                    c.getY() + Math.min(c.getHeight(), getHeight())), this);</span>
<span class="nc" id="L2578">                            return;</span>
                        }
                    }
                }
<span class="fc" id="L2582">                boolean moveToVisible = true;</span>
<span class="fc" id="L2583">                Dimension size = r.getSize();</span>
<span class="pc bpc" id="L2584" title="1 of 2 branches missed.">                boolean large = size.getHeight() &gt; getHeight() ||</span>
<span class="pc bpc" id="L2585" title="1 of 2 branches missed.">                        size.getWidth() &gt; getWidth();</span>
<span class="pc bpc" id="L2586" title="1 of 2 branches missed.">                if (large) {</span>
<span class="nc" id="L2587">                    int x = getScrollX();</span>
<span class="nc" id="L2588">                    int y = getScrollY();</span>
<span class="nc" id="L2589">                    int w = getWidth();</span>
<span class="nc" id="L2590">                    int h = getHeight();</span>
<span class="nc bnc" id="L2591" title="All 4 branches missed.">                    boolean visible = contains(c) &amp;&amp; Rectangle.intersects(c.getAbsoluteX(),</span>
<span class="nc" id="L2592">                            c.getAbsoluteY(),</span>
<span class="nc" id="L2593">                            c.getWidth(),</span>
<span class="nc" id="L2594">                            c.getHeight(),</span>
<span class="nc" id="L2595">                            getAbsoluteX() + x,</span>
<span class="nc" id="L2596">                            getAbsoluteY() + y,</span>
                            w,
                            h);
                    //if this is a big component no need to scroll to the begining if it's
                    //partially visible
<span class="nc bnc" id="L2601" title="All 2 branches missed.">                    moveToVisible = !visible;</span>
                }
<span class="pc bpc" id="L2603" title="1 of 2 branches missed.">                if (moveToVisible) {</span>
<span class="fc" id="L2604">                    scrollRectToVisible(r.getX(), r.getY(),</span>
<span class="fc" id="L2605">                            Math.min(r.getSize().getWidth(), getWidth()),</span>
<span class="fc" id="L2606">                            Math.min(r.getSize().getHeight(), getHeight()), c);</span>
                }
            }
        }
<span class="fc" id="L2610">    }</span>

    /**
     * This method scrolls the Container if Scrollable towards the given
     * Component based on the given direction.
     *
     * @param direction is the direction of the navigation (Display.GAME_UP,
     *                  Display.GAME_DOWN, ...)
     * @param next      the Component to move the scroll towards.
     * @return true if next Component is now visible.
     */
    boolean moveScrollTowards(int direction, Component next) {
<span class="nc bnc" id="L2622" title="All 2 branches missed.">        if (isScrollable()) {</span>
<span class="nc" id="L2623">            Component current = null;</span>
<span class="nc" id="L2624">            Form f = getComponentForm();</span>
<span class="nc" id="L2625">            current = f.getFocused();</span>

<span class="nc" id="L2627">            boolean cyclic = f.isCyclicFocus();</span>
<span class="nc" id="L2628">            f.setCyclicFocus(false);</span>
<span class="nc" id="L2629">            boolean edge = false;</span>
<span class="nc" id="L2630">            boolean currentLarge = false;</span>
<span class="nc" id="L2631">            boolean scrollOutOfBounds = false;</span>

<span class="nc" id="L2633">            int x = getScrollX();</span>
<span class="nc" id="L2634">            int y = getScrollY();</span>
<span class="nc" id="L2635">            int w = getWidth();</span>
<span class="nc" id="L2636">            int h = getHeight();</span>

<span class="nc bnc" id="L2638" title="All 5 branches missed.">            switch (direction) {</span>
                case Display.GAME_UP:
<span class="nc bnc" id="L2640" title="All 4 branches missed.">                    if (!cyclic &amp;&amp; getScrollY() == 0) {</span>
<span class="nc" id="L2641">                        return true;</span>
                    }
<span class="nc" id="L2643">                    y = getScrollY() - scrollIncrement;</span>
<span class="nc bnc" id="L2644" title="All 2 branches missed.">                    edge = f.findNextFocusUp() == null;</span>
<span class="nc bnc" id="L2645" title="All 4 branches missed.">                    currentLarge = (current != null &amp;&amp; current.getVisibleBounds().getSize().getHeight() &gt; getHeight());</span>
<span class="nc bnc" id="L2646" title="All 2 branches missed.">                    scrollOutOfBounds = y &lt; 0;</span>
<span class="nc bnc" id="L2647" title="All 2 branches missed.">                    if (scrollOutOfBounds) {</span>
<span class="nc" id="L2648">                        y = 0;</span>
                    }
                    break;
                case Display.GAME_DOWN:
<span class="nc" id="L2652">                    y = getScrollY() + scrollIncrement;</span>
<span class="nc bnc" id="L2653" title="All 2 branches missed.">                    edge = f.findNextFocusDown() == null;</span>
<span class="nc bnc" id="L2654" title="All 4 branches missed.">                    currentLarge = (current != null &amp;&amp; current.getVisibleBounds().getSize().getHeight() &gt; getHeight());</span>
<span class="nc bnc" id="L2655" title="All 2 branches missed.">                    scrollOutOfBounds = y &gt; getScrollDimension().getHeight() - getHeight();</span>
<span class="nc bnc" id="L2656" title="All 2 branches missed.">                    if (scrollOutOfBounds) {</span>
<span class="nc" id="L2657">                        y = getScrollDimension().getHeight() - getHeight();</span>
                    }
                    break;
                case Display.GAME_RIGHT:
<span class="nc" id="L2661">                    x = getScrollX() + scrollIncrement;</span>
<span class="nc bnc" id="L2662" title="All 2 branches missed.">                    edge = f.findNextFocusRight() == null;</span>
<span class="nc bnc" id="L2663" title="All 4 branches missed.">                    currentLarge = (current != null &amp;&amp; current.getVisibleBounds().getSize().getWidth() &gt; getWidth());</span>
<span class="nc bnc" id="L2664" title="All 2 branches missed.">                    scrollOutOfBounds = x &gt; getScrollDimension().getWidth() - getWidth();</span>
<span class="nc bnc" id="L2665" title="All 2 branches missed.">                    if (scrollOutOfBounds) {</span>
<span class="nc" id="L2666">                        x = getScrollDimension().getWidth() - getWidth();</span>
                    }
                    break;
                case Display.GAME_LEFT:
<span class="nc" id="L2670">                    x = getScrollX() - scrollIncrement;</span>
<span class="nc bnc" id="L2671" title="All 2 branches missed.">                    edge = f.findNextFocusLeft() == null;</span>
<span class="nc bnc" id="L2672" title="All 4 branches missed.">                    currentLarge = (current != null &amp;&amp; current.getVisibleBounds().getSize().getWidth() &gt; getWidth());</span>
<span class="nc bnc" id="L2673" title="All 2 branches missed.">                    scrollOutOfBounds = x &lt; 0;</span>
<span class="nc bnc" id="L2674" title="All 2 branches missed.">                    if (scrollOutOfBounds) {</span>
<span class="nc" id="L2675">                        x = 0;</span>
                    }
                    break;
            }
<span class="nc" id="L2679">            f.setCyclicFocus(cyclic);</span>
            //if the Form doesn't contain a focusable Component simply move the
            //viewport by pixels
<span class="nc bnc" id="L2682" title="All 4 branches missed.">            if (next == null || next == this) {</span>
<span class="nc" id="L2683">                scrollRectToVisible(x, y, w, h, this);</span>
<span class="nc" id="L2684">                return false;</span>
            }
            //if we are on the edge and this is a non cyclic Form.
<span class="nc bnc" id="L2687" title="All 6 branches missed.">            if (!cyclic &amp;&amp; direction == Display.GAME_DOWN &amp;&amp; edge) {</span>
<span class="nc" id="L2688">                scrollRectToVisible(x, y, w, h, this);</span>
<span class="nc" id="L2689">                return false;</span>
            }

<span class="nc bnc" id="L2692" title="All 4 branches missed.">            boolean nextIntersects = contains(next) &amp;&amp; Rectangle.intersects(next.getAbsoluteX(),</span>
<span class="nc" id="L2693">                    next.getAbsoluteY(),</span>
<span class="nc" id="L2694">                    next.getWidth(),</span>
<span class="nc" id="L2695">                    next.getHeight(),</span>
<span class="nc" id="L2696">                    getAbsoluteX() + x,</span>
<span class="nc" id="L2697">                    getAbsoluteY() + y,</span>
                    w,
                    h);

<span class="nc bnc" id="L2701" title="All 8 branches missed.">            if ((nextIntersects &amp;&amp; !currentLarge &amp;&amp; !edge) || (Rectangle.contains(</span>
<span class="nc" id="L2702">                    getAbsoluteX() + getScrollX(),</span>
<span class="nc" id="L2703">                    getAbsoluteY() + getScrollY(),</span>
                    w,
                    h,
<span class="nc" id="L2706">                    next.getAbsoluteX(),</span>
<span class="nc" id="L2707">                    next.getAbsoluteY(),</span>
<span class="nc" id="L2708">                    next.getWidth(),</span>
<span class="nc" id="L2709">                    next.getHeight()))) {</span>
                //scrollComponentToVisible(next);
<span class="nc" id="L2711">                return true;</span>
            } else {
<span class="nc bnc" id="L2713" title="All 2 branches missed.">                if (!scrollOutOfBounds) {</span>
<span class="nc" id="L2714">                    scrollRectToVisible(x, y, w, h, this);</span>
                    //if after moving the scroll the current focus is out of the
                    //view port and the next focus is in the view port move
                    //the focus
<span class="nc bnc" id="L2718" title="All 4 branches missed.">                    return nextIntersects &amp;&amp; !Rectangle.intersects(current.getAbsoluteX(),</span>
<span class="nc" id="L2719">                            current.getAbsoluteY(),</span>
<span class="nc" id="L2720">                            current.getWidth(),</span>
<span class="nc" id="L2721">                            current.getHeight(),</span>
<span class="nc" id="L2722">                            getAbsoluteX() + x,</span>
<span class="nc" id="L2723">                            getAbsoluteY() + y,</span>
                            w,
                            h);
                } else {
                    //scrollComponentToVisible(next);
<span class="nc" id="L2728">                    return true;</span>
                }
            }

        }


<span class="nc" id="L2735">        return true;</span>
    }

    private int distanceToComponent(Component c, int x, int y) {
<span class="nc" id="L2739">        int cx = c.getX();</span>
<span class="nc bnc" id="L2740" title="All 2 branches missed.">        if (x &gt; cx) {</span>
<span class="nc" id="L2741">            cx += c.getWidth();</span>
<span class="nc bnc" id="L2742" title="All 2 branches missed.">            if (cx &gt; x) {</span>
<span class="nc" id="L2743">                cx = x;</span>
            }
        }
<span class="nc" id="L2746">        int cy = c.getY();</span>
<span class="nc bnc" id="L2747" title="All 2 branches missed.">        if (y &gt; cy) {</span>
<span class="nc" id="L2748">            cy += c.getHeight();</span>
<span class="nc bnc" id="L2749" title="All 2 branches missed.">            if (cy &gt; y) {</span>
<span class="nc" id="L2750">                cy = y;</span>
            }
        }
<span class="nc" id="L2753">        x = Math.abs(cx - x);</span>
<span class="nc" id="L2754">        y = Math.abs(cy - y);</span>
<span class="nc" id="L2755">        return (int) Math.sqrt(x * x + y * y);</span>
    }

    /**
     * Very useful for touch events or drop events that need approximation more than accuracy
     *
     * @param x location in container relative coordinates
     * @param y location in container relative coordinates
     * @return the closest component in the container or null if no component is in the container
     */
    public Component getClosestComponentTo(int x, int y) {
<span class="nc" id="L2766">        int count = getComponentCount();</span>
<span class="nc bnc" id="L2767" title="All 2 branches missed.">        if (count == 0) {</span>
<span class="nc" id="L2768">            return null;</span>
        }
<span class="nc" id="L2770">        Component closest = getComponentAt(0);</span>
<span class="nc bnc" id="L2771" title="All 2 branches missed.">        if (closest.contains(x, y)) {</span>
<span class="nc" id="L2772">            return closest;</span>
        }
<span class="nc" id="L2774">        int distance = distanceToComponent(closest, x, y);</span>
<span class="nc bnc" id="L2775" title="All 2 branches missed.">        for (int iter = 1; iter &lt; count; iter++) {</span>
<span class="nc" id="L2776">            Component current = getComponentAt(iter);</span>
<span class="nc bnc" id="L2777" title="All 2 branches missed.">            if (current.contains(x, y)) {</span>
<span class="nc" id="L2778">                return current;</span>
            }
<span class="nc" id="L2780">            int cd = distanceToComponent(current, x, y);</span>
<span class="nc bnc" id="L2781" title="All 2 branches missed.">            if (cd &lt; distance) {</span>
<span class="nc" id="L2782">                closest = current;</span>
<span class="nc" id="L2783">                distance = cd;</span>
            }
        }
<span class="nc" id="L2786">        return closest;</span>
    }

    /**
     * Returns the top-most component that responds to pointer events at absolute
     * coordinate {@literal (x, y)}.  This may return {@literal null} if there are
     * no components at this coordinate that respond to pointer events.
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method is stricter than {@link #getComponentAt(int, int) }
     * about which component is returned.  Whereas {@link #getComponentAt(int, int) } will return
     * {@literal this } when there are no matches, as long as it contains {@literal (x, y)}, {@link #getResponderAt(int, int) }
     * will return null in this case.  {@link #getComponentAt(int, int) } may also return components
     * that are not visible or are not enabled.  In generaly, if you are trying to retrieve a component
     * that responds to pointer events, you should use this method over {@link #getComponentAt(int, int) } unless
     * you have a good reason and really know what you are doing.&lt;/p&gt;
     *
     * @param x Absolute x-coordinate.
     * @param y Absolute y-coordinate.
     * @return Top-most component that responds to pointer events at given coordinate.  May be {@literal null}.
     * @see Component#respondsToPointerEvents()
     */
    public Component getResponderAt(int x, int y) {
<span class="nc bnc" id="L2808" title="All 4 branches missed.">        if (!isVisible() || !contains(x, y)) {</span>
<span class="nc" id="L2809">            return null;</span>
        }
<span class="nc" id="L2811">        int startIter = 0;</span>
<span class="nc" id="L2812">        int count = getComponentCount();</span>
<span class="nc bnc" id="L2813" title="All 2 branches missed.">        if (count &gt; 30) {</span>
<span class="nc" id="L2814">            int relx = x - getAbsoluteX();</span>
<span class="nc" id="L2815">            int rely = y - getAbsoluteY();</span>

<span class="nc" id="L2817">            startIter = calculateFirstPaintableOffset(relx, rely, relx, rely);</span>
<span class="nc bnc" id="L2818" title="All 2 branches missed.">            if (startIter &lt; 0) {</span>
                // There was no efficient way to calculate the first paintable offset
                // start counting from 0
<span class="nc" id="L2821">                startIter = 0;</span>
<span class="nc bnc" id="L2822" title="All 2 branches missed.">            } else if (startIter &lt; count) {</span>
                // We found a start offset using an efficient method
                // Find an appropriate end offset.
<span class="nc" id="L2825">                count = calculateLastPaintableOffset(startIter, relx, rely, relx, rely) + 1;</span>
            }
        }
<span class="nc bnc" id="L2828" title="All 2 branches missed.">        for (int i = count - 1; i &gt;= startIter; i--) {</span>
<span class="nc" id="L2829">            Component cmp = getComponentAt(i);</span>
<span class="nc bnc" id="L2830" title="All 2 branches missed.">            if (cmp.contains(x, y)) {</span>
<span class="nc bnc" id="L2831" title="All 4 branches missed.">                if (!cmp.isBlockLead() &amp;&amp; cmp instanceof Container) {</span>
<span class="nc" id="L2832">                    cmp = ((Container) cmp).getResponderAt(x, y);</span>
                }
<span class="nc bnc" id="L2834" title="All 4 branches missed.">                if (cmp != null &amp;&amp; cmp.respondsToPointerEvents()) {</span>
<span class="nc" id="L2835">                    return cmp;</span>
                }
            }
        }
<span class="nc bnc" id="L2839" title="All 2 branches missed.">        if (respondsToPointerEvents()) {</span>
<span class="nc" id="L2840">            return this;</span>
        }
<span class="nc" id="L2842">        return null;</span>
    }

    /**
     * Returns a Component at coordinate {@literal (x, y)}.
     *
     * &lt;p&gt;&lt;strong&gt;WARNING:&lt;/strong&gt;  This method may return components that are disabled,
     * or invisible, or that do not respond to pointer events.  If you are looking for the
     * top-most component that responds to pointer events, you should use {@link #getResponderAt(int, int) }
     * as it is guaranteed to return a component with {@link Component#respondsToPointerEvents() } {@literal true};
     * or {@literal null} if none is found at the coordinate.&lt;/p&gt;
     *
     * @param x absolute screen location
     * @param y absolute screen location
     * @return a Component if found, null otherwise
     * @see Component#contains
     * @see #getResponderAt(int, int)
     */
    public Component getComponentAt(int x, int y) {
<span class="fc bfc" id="L2861" title="All 4 branches covered.">        if (!contains(x, y) || !isVisible()) {</span>
<span class="fc" id="L2862">            return this;</span>
        }
<span class="fc" id="L2864">        int startIter = 0;</span>
<span class="fc" id="L2865">        int count = getComponentCount();</span>
<span class="pc bpc" id="L2866" title="1 of 2 branches missed.">        if (count &gt; 30) {</span>
<span class="nc" id="L2867">            int relx = x - getAbsoluteX();</span>
<span class="nc" id="L2868">            int rely = y - getAbsoluteY();</span>

<span class="nc" id="L2870">            startIter = calculateFirstPaintableOffset(relx, rely, relx, rely);</span>
<span class="nc bnc" id="L2871" title="All 2 branches missed.">            if (startIter &lt; 0) {</span>
                // There was no efficient way to calculate the first paintable offset
                // start counting from 0
<span class="nc" id="L2874">                startIter = 0;</span>
<span class="nc bnc" id="L2875" title="All 2 branches missed.">            } else if (startIter &lt; count) {</span>
                // We found a start offset using an efficient method
                // Find an appropriate end offset.
<span class="nc" id="L2878">                count = calculateLastPaintableOffset(startIter, relx, rely, relx, rely) + 1;</span>
            }
        }
<span class="fc" id="L2881">        boolean overlaps = getActualLayout().isOverlapSupported();</span>
<span class="fc" id="L2882">        Component component = null;</span>
<span class="fc" id="L2883">        Component top = null;</span>

<span class="fc bfc" id="L2885" title="All 2 branches covered.">        for (int i = count - 1; i &gt;= startIter; i--) {</span>
<span class="fc" id="L2886">            Component cmp = getComponentAt(i);</span>
<span class="fc bfc" id="L2887" title="All 4 branches covered.">            if (cmp.contains(x, y) &amp;&amp; cmp.isVisible()) {</span>
<span class="fc" id="L2888">                component = cmp;</span>
<span class="fc" id="L2889">                boolean isPotentialCandidate = cmp.respondsToPointerEvents();</span>
<span class="fc bfc" id="L2890" title="All 2 branches covered.">                if (cmp instanceof Container) {</span>
<span class="fc" id="L2891">                    Component c = ((Container) cmp).getComponentAt(x, y);</span>
<span class="pc bpc" id="L2892" title="1 of 2 branches missed.">                    if (c != null) {</span>
<span class="pc bpc" id="L2893" title="1 of 2 branches missed.">                        if (top == null) {</span>
<span class="fc bfc" id="L2894" title="All 4 branches covered.">                            if (c.respondsToPointerEvents() || !(c instanceof Container)) {</span>
<span class="fc" id="L2895">                                top = c;</span>
                            }
                        }
<span class="fc bfc" id="L2898" title="All 2 branches covered.">                        if (c != cmp) {</span>
<span class="fc" id="L2899">                            Component tmp = c;</span>
<span class="fc bfc" id="L2900" title="All 2 branches covered.">                            if (cmp.isFocusable()) {</span>
<span class="fc" id="L2901">                                isPotentialCandidate = true;</span>
<span class="fc" id="L2902">                                boolean found = false;</span>
<span class="pc bpc" id="L2903" title="1 of 4 branches missed.">                                while (tmp != cmp &amp;&amp; tmp != null) {</span>
<span class="fc bfc" id="L2904" title="All 2 branches covered.">                                    if (tmp.isFocusable()) {</span>
                                        // We found a focusable child
                                        // so we will use that.
<span class="fc" id="L2907">                                        c = tmp;</span>
<span class="fc" id="L2908">                                        found = true;</span>
<span class="fc" id="L2909">                                        break;</span>
                                    }
<span class="fc" id="L2911">                                    tmp = tmp.getParent();</span>
                                }
<span class="fc bfc" id="L2913" title="All 2 branches covered.">                                if (!found) {</span>
                                    // Since the container is focusable
                                    // and none of its children are focusable
                                    // we will prefer to take the container over
                                    // its children here.
<span class="fc" id="L2918">                                    c = cmp;</span>
                                }

<span class="fc bfc" id="L2921" title="All 2 branches covered.">                            } else if (cmp.respondsToPointerEvents()) {</span>
<span class="fc" id="L2922">                                isPotentialCandidate = true;</span>
<span class="pc bpc" id="L2923" title="1 of 4 branches missed.">                                while (tmp != cmp &amp;&amp; tmp != null) {</span>
<span class="fc bfc" id="L2924" title="All 2 branches covered.">                                    if (tmp.respondsToPointerEvents()) {</span>
                                        // We found a child that also responds to
                                        // pointer events so we will use that.
<span class="fc" id="L2927">                                        c = tmp;</span>
<span class="fc" id="L2928">                                        break;</span>
                                    }
<span class="fc" id="L2930">                                    tmp = tmp.getParent();</span>
                                }


                            } else {
                                // In this last case, the parent doesn't respond to pointer events
                                // so all we want to know is if any of the children respond to pointer events
                                // so we know if it will be eligible to be returned in the case of an overlapping
                                // layout.
<span class="pc bpc" id="L2939" title="1 of 4 branches missed.">                                while (tmp != cmp &amp;&amp; tmp != null) {</span>
<span class="fc bfc" id="L2940" title="All 2 branches covered.">                                    if (tmp.respondsToPointerEvents()) {</span>
<span class="fc" id="L2941">                                        isPotentialCandidate = true;</span>

<span class="fc" id="L2943">                                        break;</span>
                                    }
<span class="fc" id="L2945">                                    tmp = tmp.getParent();</span>
                                }
                            }
<span class="fc" id="L2948">                            component = c;</span>

<span class="fc" id="L2950">                        }</span>

                    } else {
                        // No children found here
<span class="nc bnc" id="L2954" title="All 4 branches missed.">                        if (top == null &amp;&amp; cmp.respondsToPointerEvents()) {</span>
<span class="nc" id="L2955">                            top = cmp;</span>
                        }
                    }
<span class="fc" id="L2958">                } else {</span>
<span class="pc bpc" id="L2959" title="1 of 2 branches missed.">                    if (top == null) {</span>
<span class="fc" id="L2960">                        top = cmp;</span>
                    }
                }
<span class="fc bfc" id="L2963" title="All 2 branches covered.">                if (!overlaps) {</span>

<span class="fc" id="L2965">                    return component;</span>

                } else {
<span class="fc bfc" id="L2968" title="All 2 branches covered.">                    if (isPotentialCandidate) {</span>
<span class="fc" id="L2969">                        return component;</span>
                    }

                }

            }
        }
<span class="pc bpc" id="L2976" title="2 of 6 branches missed.">        if (component == null || (!component.respondsToPointerEvents() &amp;&amp; top != null)) {</span>
<span class="pc bpc" id="L2977" title="1 of 2 branches missed.">            if (top != null) {</span>
<span class="nc" id="L2978">                return top;</span>
            }
        }

<span class="fc bfc" id="L2982" title="All 2 branches covered.">        if (component != null) {</span>
<span class="fc" id="L2983">            return component;</span>
        }
<span class="fc" id="L2985">        return this;</span>
    }

    /**
     * Recursively searches the container hierarchy for a drop target
     *
     * @param x position in which we are searching for a drop target
     * @param y position in which we are searching for a drop target
     * @return a drop target or null if no drop target could be found at the x/y position
     */
    public Component findDropTargetAt(int x, int y) {
<span class="fc" id="L2996">        int count = getComponentCount();</span>
<span class="fc bfc" id="L2997" title="All 2 branches covered.">        for (int i = count - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L2998">            Component cmp = getComponentAt(i);</span>
<span class="fc bfc" id="L2999" title="All 2 branches covered.">            if (cmp.contains(x, y)) {</span>
<span class="fc bfc" id="L3000" title="All 2 branches covered.">                if (cmp.isDropTarget()) {</span>
<span class="fc" id="L3001">                    return cmp;</span>
                }
<span class="fc bfc" id="L3003" title="All 2 branches covered.">                if (cmp instanceof Container) {</span>
<span class="fc" id="L3004">                    Component component = ((Container) cmp).findDropTargetAt(x, y);</span>
<span class="fc bfc" id="L3005" title="All 2 branches covered.">                    if (component != null) {</span>
<span class="fc" id="L3006">                        return component;</span>
                    }
                }
            }
        }
<span class="fc" id="L3011">        return null;</span>
    }

    /**
     * {@inheritDoc}
     */
    public void pointerPressed(int x, int y) {
<span class="fc" id="L3018">        Component leadParent = LeadUtil.leadParentImpl(this);</span>
<span class="fc" id="L3019">        leadParent.clearDrag();</span>
<span class="fc" id="L3020">        leadParent.setDragActivated(false);</span>
<span class="fc" id="L3021">        Component cmp = getComponentAt(x, y);</span>
<span class="pc bpc" id="L3022" title="1 of 2 branches missed.">        if (cmp == this) {</span>
<span class="fc" id="L3023">            super.pointerPressed(x, y);</span>
<span class="fc" id="L3024">            return;</span>
        }
<span class="nc bnc" id="L3026" title="All 2 branches missed.">        if (cmp != null) {</span>
            //give priority to focusable components contained in the Container
<span class="nc bnc" id="L3028" title="All 4 branches missed.">            if (cmp.isFocusable() || cmp.isGrabsPointerEvents()) {</span>
<span class="nc" id="L3029">                cmp.pointerPressed(x, y);</span>
<span class="nc" id="L3030">                return;</span>
            }
<span class="nc bnc" id="L3032" title="All 4 branches missed.">            if (isFocusable() || isGrabsPointerEvents()) {</span>
<span class="nc" id="L3033">                super.pointerPressed(x, y);</span>
<span class="nc" id="L3034">                return;</span>
            }
<span class="nc" id="L3036">            cmp.pointerPressed(x, y);</span>
        }
<span class="nc" id="L3038">    }</span>

    /**
     * {@inheritDoc}
     */
    protected Dimension calcPreferredSize() {
<span class="fc" id="L3044">        calcPreferredSizeDepth++;</span>
<span class="fc" id="L3045">        boolean restoreBounds = false;</span>
<span class="pc bpc" id="L3046" title="1 of 8 branches missed.">        if (safeArea &amp;&amp; getWidth() &gt; 0 &amp;&amp; getHeight() &gt; 0 &amp;&amp; calcPreferredSizeDepth == 1) {</span>
            // If this container is marked as a safe area
            // then we may need to add padding to make it *safe*
<span class="fc" id="L3049">            Container parent = getParent();</span>
<span class="pc bpc" id="L3050" title="2 of 4 branches missed.">            if (parent == null || !parent.isSafeAreaInternal(true)) {</span>
                // For efficiency, we check if the parent is a safe area.
                // If so, we don't need to worry because it has already
                // added appropriate padding.
<span class="fc bfc" id="L3054" title="All 2 branches covered.">                if (calcTmpInsets == null) {</span>
<span class="fc" id="L3055">                    calcTmpInsets = new TmpInsets();</span>
                }
<span class="fc" id="L3057">                Style s = getStyle();</span>
<span class="fc" id="L3058">                calcTmpInsets.set(s);</span>
<span class="fc" id="L3059">                restoreBounds = snapToSafeAreaInternal();</span>
            }
        }

<span class="fc" id="L3063">        Dimension d = layout.getPreferredSize(this);</span>
<span class="fc" id="L3064">        Style style = getStyle();</span>
<span class="pc bpc" id="L3065" title="1 of 6 branches missed.">        if (style.getBorder() != null &amp;&amp; d.getWidth() != 0 &amp;&amp; d.getHeight() != 0) {</span>
<span class="fc" id="L3066">            d.setWidth(Math.max(style.getBorder().getMinimumWidth(), d.getWidth()));</span>
<span class="fc" id="L3067">            d.setHeight(Math.max(style.getBorder().getMinimumHeight(), d.getHeight()));</span>
        }
<span class="pc bpc" id="L3069" title="3 of 4 branches missed.">        if (UIManager.getInstance().getLookAndFeel().isBackgroundImageDetermineSize() &amp;&amp; style.getBgImage() != null) {</span>
<span class="nc" id="L3070">            d.setWidth(Math.max(style.getBgImage().getWidth(), d.getWidth()));</span>
<span class="nc" id="L3071">            d.setHeight(Math.max(style.getBgImage().getHeight(), d.getHeight()));</span>
        }
<span class="pc bpc" id="L3073" title="3 of 4 branches missed.">        if (restoreBounds &amp;&amp; calcTmpInsets != null) {</span>
<span class="nc" id="L3074">            calcTmpInsets.restore(getStyle());</span>
        }
<span class="fc" id="L3076">        calcPreferredSizeDepth--;</span>
<span class="fc" id="L3077">        return d;</span>
    }

    /**
     * {@inheritDoc}
     */
    protected String paramString() {
<span class="nc" id="L3084">        String className = layout.getClass().getName();</span>
<span class="nc" id="L3085">        String layoutStr = className.substring(className.lastIndexOf('.') + 1);</span>
<span class="nc" id="L3086">        return super.paramString() + &quot;, layout = &quot; + layoutStr +</span>
                &quot;, scrollableX = &quot; + scrollableX +
                &quot;, scrollableY = &quot; + scrollableY +
<span class="nc" id="L3089">                &quot;, components = &quot; + getComponentsNames();</span>
    }

    /**
     * Return the container components objects as list of Strings
     *
     * @return the container components objects as list of Strings
     */
    private String getComponentsNames() {
<span class="nc" id="L3098">        String ret = &quot;[&quot;;</span>
<span class="nc" id="L3099">        int componentCount = components.size();</span>
<span class="nc bnc" id="L3100" title="All 2 branches missed.">        for (int iter = 0; iter &lt; componentCount; iter++) {</span>
<span class="nc" id="L3101">            Component cmp = components.get(iter);</span>
<span class="nc" id="L3102">            String className = cmp.getClass().getName();</span>
<span class="nc" id="L3103">            ret += className.substring(className.lastIndexOf('.') + 1) + &quot;, &quot;;</span>
        }
<span class="nc bnc" id="L3105" title="All 2 branches missed.">        if (ret.length() &gt; 1) {</span>
<span class="nc" id="L3106">            ret = ret.substring(0, ret.length() - 2);</span>
        }
<span class="nc" id="L3108">        ret = ret + &quot;]&quot;;</span>
<span class="nc" id="L3109">        return ret;</span>
    }

    /**
     * {@inheritDoc}
     */
    public void refreshTheme(boolean merge) {
<span class="fc" id="L3116">        super.refreshTheme(merge);</span>
<span class="fc" id="L3117">        int componentCount = components.size();</span>
<span class="fc bfc" id="L3118" title="All 2 branches covered.">        for (int iter = 0; iter &lt; componentCount; iter++) {</span>
<span class="fc" id="L3119">            Component cmp = components.get(iter);</span>
<span class="fc" id="L3120">            cmp.refreshTheme(merge);</span>
        }
<span class="fc" id="L3122">    }</span>

    boolean scrollableXFlag() {
<span class="fc" id="L3125">        return scrollableX;</span>
    }

    boolean scrollableYFlag() {
<span class="fc" id="L3129">        return scrollableY;</span>
    }

    /**
     * {@inheritDoc}
     */
    public boolean isScrollableX() {
<span class="fc bfc" id="L3136" title="All 4 branches covered.">        return scrollableX &amp;&amp; (getScrollDimension().getWidth() + getStyle().getHorizontalPadding() &gt; getWidth());</span>
    }

    /**
     * Sets whether the component should/could scroll on the X axis
     *
     * @param scrollableX whether the component should/could scroll on the X axis
     */
    public void setScrollableX(boolean scrollableX) {
<span class="fc bfc" id="L3145" title="All 2 branches covered.">        if (layout instanceof BorderLayout) {</span>
<span class="fc" id="L3146">            this.scrollableX = false;</span>
        } else {
<span class="fc" id="L3148">            this.scrollableX = scrollableX;</span>
        }
<span class="fc" id="L3150">    }</span>

    /**
     * {@inheritDoc}
     */
    public boolean isScrollableY() {
<span class="fc" id="L3156">        Form f = getComponentForm();</span>
<span class="fc" id="L3157">        int v = 0;</span>
<span class="fc bfc" id="L3158" title="All 2 branches covered.">        if (f != null) {</span>
<span class="fc" id="L3159">            v = f.getInvisibleAreaUnderVKB();</span>
        }
<span class="fc bfc" id="L3161" title="All 6 branches covered.">        return scrollableY &amp;&amp; (getScrollDimension().getHeight() + getStyle().getVerticalPadding() &gt; getHeight() - v || isAlwaysTensile());</span>
    }

    /**
     * Sets whether the component should/could scroll on the Y axis
     *
     * @param scrollableY whether the component should/could scroll on the Y axis
     */
    public void setScrollableY(boolean scrollableY) {
<span class="fc bfc" id="L3170" title="All 2 branches covered.">        if (layout instanceof BorderLayout) {</span>
<span class="fc" id="L3171">            this.scrollableY = false;</span>
        } else {
<span class="fc" id="L3173">            this.scrollableY = scrollableY;</span>
        }
<span class="fc" id="L3175">    }</span>

    /**
     * {@inheritDoc}
     */
    public int getSideGap() {
        // isScrollableY() in the base method is very expensive since it triggers getScrollDimension before the layout is complete!
<span class="fc bfc" id="L3182" title="All 2 branches covered.">        if (scrollSize == null) {</span>
<span class="fc bfc" id="L3183" title="All 4 branches covered.">            if (scrollableY &amp;&amp; isScrollVisible()) {</span>
<span class="fc" id="L3184">                return getUIManager().getLookAndFeel().getVerticalScrollWidth();</span>
            }
        } else {
<span class="fc" id="L3187">            return super.getSideGap();</span>
        }
<span class="fc" id="L3189">        return 0;</span>
    }

    /**
     * {@inheritDoc}
     */
    public int getBottomGap() {
        // isScrollableY() in the base method is very expensive since it triggers getScrollDimension before the layout is complete!
<span class="pc bpc" id="L3197" title="1 of 4 branches missed.">        if (scrollableX &amp;&amp; isScrollVisible()) {</span>
<span class="nc" id="L3198">            return getUIManager().getLookAndFeel().getHorizontalScrollHeight();</span>
        }
<span class="fc" id="L3200">        return 0;</span>
    }

    /**
     * The equivalent of calling both setScrollableY and setScrollableX
     *
     * @param scrollable whether the component should/could scroll on the
     *                   X and Y axis
     * @deprecated use setScrollableX and setScrollableY instead. This method is deprecated since it breeds confusion and is often misunderstood.
     */
    public void setScrollable(boolean scrollable) {
<span class="fc" id="L3211">        setScrollableX(scrollable);</span>
<span class="fc" id="L3212">        setScrollableY(scrollable);</span>
<span class="fc" id="L3213">    }</span>

    /**
     * {@inheritDoc}
     */
    public void setCellRenderer(boolean cellRenderer) {
<span class="pc bpc" id="L3219" title="1 of 2 branches missed.">        if (isCellRenderer() != cellRenderer) {</span>
<span class="fc" id="L3220">            super.setCellRenderer(cellRenderer);</span>
<span class="fc" id="L3221">            int size = getComponentCount();</span>
<span class="fc bfc" id="L3222" title="All 2 branches covered.">            for (int iter = 0; iter &lt;</span>
<span class="fc" id="L3223">                    size; iter++) {</span>
<span class="fc" id="L3224">                getComponentAt(iter).setCellRenderer(cellRenderer);</span>
            }
        }
<span class="fc" id="L3227">    }</span>

    /**
     * Gets the Container scroll increment
     *
     * @return the scroll increment in pixels.
     */
    public int getScrollIncrement() {
<span class="nc" id="L3235">        return scrollIncrement;</span>
    }

    /**
     * Determines the scroll increment size of this Container.
     * This value is in use when the current foucs element within this Container
     * is larger than this Container size.
     *
     * @param scrollIncrement the size in pixels.
     */
    public void setScrollIncrement(int scrollIncrement) {
<span class="nc" id="L3246">        this.scrollIncrement = scrollIncrement;</span>
<span class="nc" id="L3247">    }</span>

    /**
     * Finds the first focusable Component on this Container
     *
     * @return a focusable Component or null if not exists;
     */
    public Component findFirstFocusable() {
<span class="fc" id="L3255">        int size = getComponentCount();</span>

<span class="fc bfc" id="L3257" title="All 2 branches covered.">        for (int iter = 0; iter &lt; size; iter++) {</span>
<span class="fc" id="L3258">            Component current = getComponentAt(iter);</span>
<span class="pc bpc" id="L3259" title="1 of 2 branches missed.">            if (current.isVisible()) {</span>
<span class="fc bfc" id="L3260" title="All 2 branches covered.">                if (current.isFocusable()) {</span>
<span class="fc" id="L3261">                    return current;</span>
                }
<span class="pc bpc" id="L3263" title="1 of 6 branches missed.">                if (current instanceof Container &amp;&amp; !((Container) current).isBlockFocus() &amp;&amp; current.getLeadComponent() == null) {</span>
<span class="fc" id="L3264">                    Component cmp = ((Container) current).findFirstFocusable();</span>
<span class="fc bfc" id="L3265" title="All 2 branches covered.">                    if (cmp != null) {</span>
<span class="fc" id="L3266">                        return cmp;</span>
                    }
                }
            }
        }
<span class="fc" id="L3271">        return null;</span>
    }

    /**
     * Recusively focuses components for the lead component functionality
     */
    private void setFocusLead(boolean f) {
<span class="fc" id="L3278">        int count = getComponentCount();</span>
<span class="fc bfc" id="L3279" title="All 2 branches covered.">        for (int i = 0; i &lt; count; i++) {</span>
<span class="fc" id="L3280">            Component c = getComponentAt(i);</span>
<span class="fc bfc" id="L3281" title="All 2 branches covered.">            if (c instanceof Container) {</span>
<span class="fc" id="L3282">                ((Container) c).setFocusLead(f);</span>
            }
<span class="fc" id="L3284">            c.setFocus(f);</span>
<span class="fc bfc" id="L3285" title="All 2 branches covered.">            if (f) {</span>
<span class="fc" id="L3286">                c.fireFocusGained();</span>
            } else {
<span class="fc" id="L3288">                c.fireFocusLost();</span>
            }
        }
<span class="fc" id="L3291">    }</span>

    /**
     * {@inheritDoc}
     */
    protected void dragInitiated() {
<span class="fc" id="L3297">        super.dragInitiated();</span>
<span class="pc bpc" id="L3298" title="1 of 2 branches missed.">        if (leadComponent != null) {</span>
<span class="fc" id="L3299">            leadComponent.dragInitiated();</span>
        }
<span class="fc" id="L3301">    }</span>

    /**
     * {@inheritDoc}
     */
    protected void fireClicked() {
<span class="nc bnc" id="L3307" title="All 2 branches missed.">        if (leadComponent != null) {</span>
<span class="nc" id="L3308">            leadComponent.fireClicked();</span>
        } else {
<span class="nc" id="L3310">            super.fireClicked();</span>
        }
<span class="nc" id="L3312">    }</span>

    /**
     * {@inheritDoc}
     */
    protected boolean isSelectableInteraction() {
<span class="fc bfc" id="L3318" title="All 2 branches covered.">        if (leadComponent != null) {</span>
<span class="fc" id="L3319">            return leadComponent.isSelectableInteraction();</span>
        } else {
<span class="fc" id="L3321">            return super.isSelectableInteraction();</span>
        }
    }

    /**
     * This is a callback method for the peer component class
     */
    void setLightweightMode(boolean l) {
<span class="fc" id="L3329">        int size = getComponentCount();</span>
<span class="fc bfc" id="L3330" title="All 2 branches covered.">        for (int iter = 0; iter &lt; size; iter++) {</span>
<span class="fc" id="L3331">            getComponentAt(iter).setLightweightMode(l);</span>
        }
<span class="fc" id="L3333">    }</span>

    /**
     * {@inheritDoc}
     */
    protected int getGridPosY() {
<span class="nc" id="L3339">        int scroll = getScrollY();</span>
<span class="nc" id="L3340">        int size = getComponentCount();</span>
<span class="nc" id="L3341">        int bestRow = 0;</span>
<span class="nc bnc" id="L3342" title="All 2 branches missed.">        for (int iter = 0; iter &lt; size; iter++) {</span>
<span class="nc" id="L3343">            Component c = getComponentAt(iter);</span>
<span class="nc" id="L3344">            int y = c.getY();</span>
<span class="nc bnc" id="L3345" title="All 2 branches missed.">            if (Math.abs(scroll - y) &lt; Math.abs(scroll - bestRow)) {</span>
<span class="nc" id="L3346">                bestRow = y;</span>
            }
        }
<span class="nc bnc" id="L3349" title="All 2 branches missed.">        if (Math.abs(scroll - bestRow) &gt; 2) {</span>
<span class="nc" id="L3350">            return bestRow;</span>
        }
<span class="nc" id="L3352">        return scroll;</span>
    }

    /**
     * Returns false for the special case where a container has an opaque/flattened child that
     * occupies its entire face
     */
    private boolean shouldPaintContainerBackground() {
<span class="pc bpc" id="L3360" title="1 of 2 branches missed.">        return !isObscuredByChildren();</span>
    }

    /**
     * {@inheritDoc}
     */
    public void paintComponentBackground(Graphics g) {
<span class="pc bpc" id="L3367" title="1 of 2 branches missed.">        if (isFlatten()) {</span>
<span class="nc" id="L3368">            super.paintBackgrounds(g);</span>
<span class="nc" id="L3369">            return;</span>
        }

<span class="pc bpc" id="L3372" title="1 of 2 branches missed.">        if (shouldPaintContainerBackground()) {</span>
<span class="fc" id="L3373">            super.paintComponentBackground(g);</span>
        }
<span class="fc" id="L3375">    }</span>

    @Override
    protected void paintBackground(Graphics g) {
<span class="fc" id="L3379">        super.paintBackground(g);</span>
<span class="fc" id="L3380">    }</span>

    @Override
    protected void paintBorderBackground(Graphics g) {
<span class="nc" id="L3384">        super.paintBorderBackground(g);</span>
<span class="nc" id="L3385">    }</span>

    /**
     * {@inheritDoc}
     */
    protected int getGridPosX() {
<span class="nc" id="L3391">        int scroll = getScrollX();</span>
<span class="nc" id="L3392">        int size = getComponentCount();</span>
<span class="nc" id="L3393">        int bestCol = 0;</span>
<span class="nc bnc" id="L3394" title="All 2 branches missed.">        for (int iter = 0; iter &lt; size; iter++) {</span>
<span class="nc" id="L3395">            Component c = getComponentAt(iter);</span>
<span class="nc" id="L3396">            int x = c.getX();</span>
<span class="nc bnc" id="L3397" title="All 2 branches missed.">            if (Math.abs(scroll - x) &lt; Math.abs(scroll - bestCol)) {</span>
<span class="nc" id="L3398">                bestCol = x;</span>
            }
        }
<span class="nc bnc" id="L3401" title="All 2 branches missed.">        if (Math.abs(scroll - bestCol) &gt; 2) {</span>
<span class="nc" id="L3402">            return bestCol;</span>
        }
<span class="nc" id="L3404">        return scroll;</span>
    }

    /**
     * Returns true if focus is blocked for this Container
     *
     * @return
     */
    boolean isBlockFocus() {
<span class="fc" id="L3413">        return blockFocus;</span>
    }

    /**
     * This method blocks all children from getting focus
     *
     * @param blockFocus
     */
    void setBlockFocus(boolean blockFocus) {
<span class="fc" id="L3422">        this.blockFocus = blockFocus;</span>
<span class="fc" id="L3423">    }</span>

    /**
     * Animates a pending hierarchy of components into place, this effectively replaces revalidate with
     * a more visual form of animation. This method waits until the operation is completed before returning
     *
     * @param duration the duration in milliseconds for the animation
     */
    public void animateHierarchyAndWait(final int duration) {
<span class="nc" id="L3432">        animateHierarchy(duration, true, 255, true);</span>
<span class="nc" id="L3433">    }</span>

    /**
     * Animates a pending hierarchy of components into place, this effectively replaces revalidate with
     * a more visual form of animation.
     *
     * @param duration the duration in milliseconds for the animation
     * @return the animation object that should be added to the animation manager
     */
    public ComponentAnimation createAnimateHierarchy(final int duration) {
<span class="nc" id="L3443">        return animateHierarchy(duration, false, 255, false);</span>
    }

    /**
     * Animates a pending hierarchy of components into place, this effectively replaces revalidate with
     * a more visual form of animation
     *
     * @param duration the duration in milliseconds for the animation
     */
    public void animateHierarchy(final int duration) {
<span class="fc" id="L3453">        animateHierarchy(duration, false, 255, true);</span>
<span class="fc" id="L3454">    }</span>

    /**
     * Animates a pending hierarchy of components into place, this effectively replaces revalidate with
     * a more visual form of animation. This method waits until the operation is completed before returning
     *
     * @param duration        the duration in milliseconds for the animation
     * @param startingOpacity the initial opacity to give to the animated components
     */
    public void animateHierarchyFadeAndWait(final int duration, int startingOpacity) {
<span class="nc" id="L3464">        animateHierarchy(duration, true, startingOpacity, true);</span>
<span class="nc" id="L3465">    }</span>

    /**
     * Animates a pending hierarchy of components into place, this effectively replaces revalidate with
     * a more visual form of animation.
     *
     * @param duration        the duration in milliseconds for the animation
     * @param startingOpacity the initial opacity to give to the animated components
     * @return the animation object that should be added to the animation manager
     */
    public ComponentAnimation createAnimateHierarchyFade(final int duration, int startingOpacity) {
<span class="nc" id="L3476">        return animateHierarchy(duration, false, startingOpacity, false);</span>
    }

    /**
     * Animates a pending hierarchy of components into place, this effectively replaces revalidate with
     * a more visual form of animation
     *
     * @param duration        the duration in milliseconds for the animation
     * @param startingOpacity the initial opacity to give to the animated components
     */
    public void animateHierarchyFade(final int duration, int startingOpacity) {
<span class="nc" id="L3487">        animateHierarchy(duration, false, startingOpacity, true);</span>
<span class="nc" id="L3488">    }</span>

    /**
     * Animates a pending layout into place, this effectively replaces revalidate with a more visual form of animation. This method
     * waits until the operation is completed before returning
     *
     * @param duration        the duration in milliseconds for the animation
     * @param startingOpacity the initial opacity to give to the animated components
     */
    public void animateLayoutFadeAndWait(final int duration, int startingOpacity) {
<span class="nc" id="L3498">        animateLayout(duration, true, startingOpacity, true);</span>
<span class="nc" id="L3499">    }</span>

    /**
     * Animates a pending layout into place, this effectively replaces revalidate with a more visual form of animation. This method
     * waits until the operation is completed before returning
     *
     * @param duration        the duration in milliseconds for the animation
     * @param startingOpacity the initial opacity to give to the animated components
     * @return the animation object that should be added to the animation manager
     * @deprecated this was added by mistake!
     */
    public ComponentAnimation createAnimateLayoutFadeAndWait(final int duration, int startingOpacity) {
<span class="nc" id="L3511">        return null;</span>
    }

    /**
     * Animates a pending layout into place, this effectively replaces revalidate with a more visual form of animation
     *
     * @param duration        the duration in milliseconds for the animation
     * @param startingOpacity the initial opacity to give to the animated components
     */
    public void animateLayoutFade(final int duration, int startingOpacity) {
<span class="nc" id="L3521">        animateLayout(duration, false, startingOpacity, true);</span>
<span class="nc" id="L3522">    }</span>

    /**
     * Animates a pending layout into place, this effectively replaces revalidate with a more visual form of animation
     *
     * @param duration        the duration in milliseconds for the animation
     * @param startingOpacity the initial opacity to give to the animated components
     * @return the animation object that should be added to the animation manager
     */
    public ComponentAnimation createAnimateLayoutFade(final int duration, int startingOpacity) {
<span class="nc" id="L3532">        return animateLayout(duration, false, startingOpacity, false);</span>
    }

    /**
     * Animates a pending layout into place, this effectively replaces revalidate with a more visual form of animation. This method
     * waits until the operation is completed before returning
     *
     * @param duration the duration in milliseconds for the animation
     */
    public void animateLayoutAndWait(final int duration) {
<span class="nc" id="L3542">        animateLayout(duration, true, 255, true);</span>
<span class="nc" id="L3543">    }</span>

    /**
     * &lt;p&gt;
     * Animates a pending layout into place, this effectively replaces revalidate with a more visual form of animation&lt;br&gt;
     * See:
     * &lt;/p&gt;
     *
     * &lt;script src=&quot;https://gist.github.com/codenameone/38c076760e309c066126.js&quot;&gt;&lt;/script&gt;
     *
     * @param duration the duration in milliseconds for the animation
     */
    public void animateLayout(final int duration) {
<span class="fc" id="L3556">        animateLayout(duration, false, 255, true);</span>
<span class="fc" id="L3557">    }</span>

    /**
     * Updates the tab indices in this container recursively. This method is used internally by
     * layout managers when calculating the traversal order of components in a form.
     *
     * @param offset The starting tab index.
     * @return The ending tab index (+1)
     * @deprecated For internal use only.
     */
    public int updateTabIndices(int offset) {
<span class="fc" id="L3568">        Container parent = this;</span>
<span class="fc" id="L3569">        Layout l = parent.getActualLayout();</span>
<span class="pc bpc" id="L3570" title="1 of 2 branches missed.">        if (l.overridesTabIndices(parent)) {</span>
<span class="fc" id="L3571">            return l.updateTabIndices(parent, offset);</span>
        }

<span class="nc" id="L3574">        int len = parent.getComponentCount();</span>
<span class="nc" id="L3575">        int idx = offset;</span>
<span class="nc bnc" id="L3576" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L3577">            Component c = parent.getComponentAt(i);</span>
<span class="nc" id="L3578">            int prefIdx = c.getPreferredTabIndex();</span>
<span class="nc bnc" id="L3579" title="All 2 branches missed.">            if (prefIdx == 0) {</span>
<span class="nc" id="L3580">                c.setTabIndex(idx++);</span>
            } else {
<span class="nc" id="L3582">                c.setTabIndex(prefIdx);</span>
            }
<span class="nc bnc" id="L3584" title="All 2 branches missed.">            if (c instanceof Container) {</span>
<span class="nc" id="L3585">                idx = ((Container) c).updateTabIndices(idx);</span>
            }
        }
<span class="nc" id="L3588">        return idx;</span>
    }

    /**
     * &lt;p&gt;
     * Animates a pending layout into place, this effectively replaces revalidate with a more visual form of animation&lt;br&gt;
     * See:
     * &lt;/p&gt;
     *
     * &lt;script src=&quot;https://gist.github.com/codenameone/38c076760e309c066126.js&quot;&gt;&lt;/script&gt;
     *
     * @param duration the duration in milliseconds for the animation
     * @return the animation object that should be added to the animation manager
     */
    public ComponentAnimation createAnimateLayout(final int duration) {
<span class="fc" id="L3603">        return animateLayout(duration, false, 255, false);</span>
    }

    /**
     * {@inheritDoc}
     */
    public void drop(Component dragged, int x, int y) {
<span class="nc" id="L3610">        int i = getComponentIndex(dragged);</span>
<span class="nc bnc" id="L3611" title="All 2 branches missed.">        if (i &gt; -1) {</span>
<span class="nc" id="L3612">            Component dest = getComponentAt(x, y);</span>
<span class="nc bnc" id="L3613" title="All 2 branches missed.">            if (dest != dragged) {</span>
<span class="nc" id="L3614">                int destIndex = getComponentIndex(dest);</span>
<span class="nc bnc" id="L3615" title="All 4 branches missed.">                if (destIndex &gt; -1 &amp;&amp; destIndex != i) {</span>
<span class="nc" id="L3616">                    setComponentIndex(dragged, destIndex);</span>
                }
            }
<span class="nc" id="L3619">            animateLayout(400);</span>
<span class="nc" id="L3620">        } else {</span>
<span class="nc" id="L3621">            Container oldParent = dragged.getParent();</span>
<span class="nc bnc" id="L3622" title="All 2 branches missed.">            if (oldParent != null) {</span>
<span class="nc" id="L3623">                oldParent.removeComponent(dragged);</span>
            }
<span class="nc" id="L3625">            Component pos = getComponentAt(x, y);</span>
<span class="nc" id="L3626">            i = getComponentIndex(pos);</span>
<span class="nc bnc" id="L3627" title="All 2 branches missed.">            if (i &gt; -1) {</span>
<span class="nc" id="L3628">                addComponent(i, dragged);</span>
            } else {
<span class="nc" id="L3630">                addComponent(dragged);</span>
            }
<span class="nc" id="L3632">            getComponentForm().animateHierarchy(400);</span>
        }
<span class="nc" id="L3634">    }</span>

    /**
     * Creates a motion object for animation, allows subclasses to replace the motion type
     * used in animations (currently defaults to ease-in).
     *
     * @param start       start value
     * @param destination destination value
     * @param duration    duration of animation
     * @return motion object
     */
    protected Motion createAnimateMotion(int start, int destination, int duration) {
<span class="fc" id="L3646">        return Motion.createEaseInMotion(start, destination, duration);</span>
    }

    private Motion createAndStartAnimateMotion(int start, int destination, int duration) {
<span class="fc" id="L3650">        Motion m = createAnimateMotion(start, destination, duration);</span>
<span class="fc" id="L3651">        m.start();</span>
<span class="fc" id="L3652">        return m;</span>
    }

    private void findComponentsInHierachy(Vector vec) {
<span class="fc" id="L3656">        int cc = getComponentCount();</span>
<span class="fc bfc" id="L3657" title="All 2 branches covered.">        for (int iter = 0; iter &lt; cc; iter++) {</span>
<span class="fc" id="L3658">            Component c = getComponentAt(iter);</span>
<span class="fc" id="L3659">            vec.addElement(c);</span>
<span class="pc bpc" id="L3660" title="1 of 2 branches missed.">            if (c.getClass() == Container.class) {</span>
<span class="nc" id="L3661">                ((Container) c).findComponentsInHierachy(vec);</span>
            }
        }
<span class="fc" id="L3664">    }</span>

    /**
     * Morph is similar to the replace functionality where a component might be replaced with
     * a component that isn't within the container. However, unlike the replace functionality which
     * uses a transition and assumes the position of the component (and is hence quite flexible) morph
     * can move and resize the component. E.g. after entering text into a text field and pressing submit
     * it can &quot;morph&quot; into a chat bubble located in a different part of the screen.&lt;br&gt;
     * It is the responsibility of the caller to remove the source component (if desired) and revalidate the
     * container when the animation completes.
     *
     * @param source       source component assumed to be within this container or one of its children
     * @param destination  the destination component
     * @param duration     the time the morph operation should take
     * @param onCompletion invoked when the morphing completes
     */
    public void morph(Component source, Component destination, int duration, Runnable onCompletion) {
<span class="nc" id="L3681">        morph(source, destination, duration, false, onCompletion);</span>
<span class="nc" id="L3682">    }</span>

    /**
     * Morph is similar to the replace functionality where a component might be replaced with
     * a component that isn't within the container. However, unlike the replace functionality which
     * uses a transition and assumes the position of the component (and is hence quite flexible) morph
     * can move and resize the component. E.g. after entering text into a text field and pressing submit
     * it can &quot;morph&quot; into a chat bubble located in a different part of the screen.&lt;br&gt;
     * It is the responsibility of the caller to remove the source component (if desired) and revalidate the
     * container when the animation completes.
     *
     * @param source      source component assumed to be within this container or one of its children
     * @param destination the destination component
     * @param duration    the time the morph operation should take
     */
    public void morphAndWait(Component source, Component destination, int duration) {
<span class="fc" id="L3698">        morph(source, destination, duration, true, null);</span>
<span class="fc" id="L3699">    }</span>

    private void morph(Component source, Component destination, int duration, boolean wait, Runnable onCompletion) {
<span class="fc" id="L3702">        setShouldCalcPreferredSize(true);</span>
<span class="fc" id="L3703">        enableLayoutOnPaint = false;</span>
<span class="fc" id="L3704">        dontRecurseContainer = true;</span>
<span class="fc" id="L3705">        int deltaX = getAbsoluteX();</span>
<span class="fc" id="L3706">        int deltaY = getAbsoluteY();</span>
<span class="fc" id="L3707">        int sourceX = source.getAbsoluteX() - deltaX;</span>
<span class="fc" id="L3708">        int destX = destination.getAbsoluteX() - deltaX;</span>
<span class="fc" id="L3709">        int sourceY = source.getAbsoluteY() - deltaY;</span>
<span class="fc" id="L3710">        int destY = destination.getAbsoluteY() - deltaY;</span>
<span class="fc" id="L3711">        final Motion[] xMotions = new Motion[]{</span>
<span class="fc" id="L3712">                createAndStartAnimateMotion(sourceX, destX, duration),</span>
<span class="fc" id="L3713">                createAndStartAnimateMotion(sourceX, destX, duration)</span>
        };
<span class="fc" id="L3715">        final Motion[] yMotions = new Motion[]{</span>
<span class="fc" id="L3716">                createAndStartAnimateMotion(sourceY, destY, duration),</span>
<span class="fc" id="L3717">                createAndStartAnimateMotion(sourceY, destY, duration)</span>
        };
<span class="fc" id="L3719">        final Motion[] wMotions = new Motion[]{</span>
<span class="fc" id="L3720">                createAndStartAnimateMotion(source.getWidth(), destination.getWidth(), duration),</span>
<span class="fc" id="L3721">                createAndStartAnimateMotion(source.getWidth(), destination.getWidth(), duration)</span>
        };
<span class="fc" id="L3723">        final Motion[] hMotions = new Motion[]{</span>
<span class="fc" id="L3724">                createAndStartAnimateMotion(source.getHeight(), destination.getHeight(), duration),</span>
<span class="fc" id="L3725">                createAndStartAnimateMotion(source.getHeight(), destination.getHeight(), duration)</span>
        };
<span class="fc" id="L3727">        MorphAnimation a = new MorphAnimation(this, duration, new Motion[][]{</span>
                xMotions, yMotions, wMotions, hMotions
        });
<span class="fc" id="L3730">        a.opacity = new Motion[]{</span>
<span class="fc" id="L3731">                createAndStartAnimateMotion(255, 0, duration),</span>
<span class="fc" id="L3732">                createAndStartAnimateMotion(0, 255, duration)</span>
        };
<span class="fc" id="L3734">        a.animatedComponents = new Vector();</span>
<span class="fc" id="L3735">        a.animatedComponents.addElement(source);</span>
<span class="fc" id="L3736">        a.animatedComponents.addElement(destination);</span>
<span class="fc" id="L3737">        a.dontRevalidate = true;</span>
<span class="fc" id="L3738">        a.scrollTo = destination;</span>

<span class="pc bpc" id="L3740" title="1 of 2 branches missed.">        if (wait) {</span>
<span class="fc" id="L3741">            getAnimationManager().addAnimationAndBlock(a);</span>
        } else {
<span class="nc bnc" id="L3743" title="All 2 branches missed.">            if (onCompletion != null) {</span>
<span class="nc" id="L3744">                getAnimationManager().addAnimation(a, onCompletion);</span>
            } else {
<span class="nc" id="L3746">                getAnimationManager().addAnimation(a);</span>
            }
        }
<span class="fc" id="L3749">    }</span>

    /**
     * Animates a pending layout into place, this effectively replaces revalidate with a more visual form of animation
     *
     * @param duration the duration in milliseconds for the animation
     */
    private ComponentAnimation animateHierarchy(final int duration, boolean wait, int opacity, boolean add) {
<span class="fc" id="L3757">        setShouldCalcPreferredSize(true);</span>
<span class="fc" id="L3758">        enableLayoutOnPaint = false;</span>
<span class="fc" id="L3759">        dontRecurseContainer = true;</span>
<span class="fc" id="L3760">        Vector comps = new Vector();</span>
<span class="fc" id="L3761">        findComponentsInHierachy(comps);</span>
<span class="fc" id="L3762">        final int componentCount = comps.size();</span>
<span class="fc" id="L3763">        int[] beforeX = new int[componentCount];</span>
<span class="fc" id="L3764">        int[] beforeY = new int[componentCount];</span>
<span class="fc" id="L3765">        int[] beforeW = new int[componentCount];</span>
<span class="fc" id="L3766">        int[] beforeH = new int[componentCount];</span>
<span class="fc" id="L3767">        final Motion[] xMotions = new Motion[componentCount];</span>
<span class="fc" id="L3768">        final Motion[] yMotions = new Motion[componentCount];</span>
<span class="fc" id="L3769">        final Motion[] wMotions = new Motion[componentCount];</span>
<span class="fc" id="L3770">        final Motion[] hMotions = new Motion[componentCount];</span>
<span class="fc bfc" id="L3771" title="All 2 branches covered.">        for (int iter = 0; iter &lt; componentCount; iter++) {</span>
<span class="fc" id="L3772">            Component current = (Component) comps.elementAt(iter);</span>
<span class="fc" id="L3773">            beforeX[iter] = current.getX();</span>
<span class="fc" id="L3774">            beforeY[iter] = current.getY();</span>
<span class="fc" id="L3775">            beforeW[iter] = current.getWidth();</span>
<span class="fc" id="L3776">            beforeH[iter] = current.getHeight();</span>
        }
<span class="fc" id="L3778">        layoutContainer();</span>
<span class="fc bfc" id="L3779" title="All 2 branches covered.">        for (int iter = 0; iter &lt; componentCount; iter++) {</span>
<span class="fc" id="L3780">            Component current = (Component) comps.elementAt(iter);</span>
<span class="fc" id="L3781">            xMotions[iter] = createAnimateMotion(beforeX[iter], current.getX(), duration);</span>
<span class="fc" id="L3782">            yMotions[iter] = createAnimateMotion(beforeY[iter], current.getY(), duration);</span>
<span class="fc" id="L3783">            wMotions[iter] = createAnimateMotion(beforeW[iter], current.getWidth(), duration);</span>
<span class="fc" id="L3784">            hMotions[iter] = createAnimateMotion(beforeH[iter], current.getHeight(), duration);</span>
<span class="fc" id="L3785">            xMotions[iter].start();</span>
<span class="fc" id="L3786">            yMotions[iter].start();</span>
<span class="fc" id="L3787">            wMotions[iter].start();</span>
<span class="fc" id="L3788">            hMotions[iter].start();</span>
<span class="fc" id="L3789">            current.setX(beforeX[iter]);</span>
<span class="fc" id="L3790">            current.setY(beforeY[iter]);</span>
<span class="fc" id="L3791">            current.setWidth(beforeW[iter]);</span>
<span class="fc" id="L3792">            current.setHeight(beforeH[iter]);</span>
        }
<span class="fc" id="L3794">        MorphAnimation a = new MorphAnimation(this, duration, new Motion[][]{</span>
                xMotions, yMotions, wMotions, hMotions
        });
<span class="fc" id="L3797">        setAnimOpacity(opacity, 255, a, componentCount, duration);</span>
<span class="fc" id="L3798">        a.animatedComponents = comps;</span>
<span class="pc bpc" id="L3799" title="1 of 2 branches missed.">        if (add) {</span>
<span class="pc bpc" id="L3800" title="1 of 2 branches missed.">            if (wait) {</span>
<span class="nc" id="L3801">                getAnimationManager().addAnimationAndBlock(a);</span>
            } else {
<span class="fc" id="L3803">                getAnimationManager().addAnimation(a);</span>
            }
        }
<span class="fc" id="L3806">        return a;</span>
    }

    /**
     * &lt;p&gt;This method is the exact reverse of animateLayout, when completed it leaves the container in
     * an invalid state. It is useful to invoke this in order to remove a component, transition to a
     * different form or provide some other interaction. E.g.:&lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/codenameone/ba6fdc5f841b083e13e9.js&quot;&gt;&lt;/script&gt;
     *
     * @param duration the duration of the animation
     * @param opacity  the opacity to which the layout will reach, allows fading out the components
     * @param callback if not null will be invoked when unlayouting is complete
     */
    public void animateUnlayout(final int duration, int opacity, Runnable callback) {
<span class="fc" id="L3820">        animateUnlayout(duration, false, opacity, callback, true);</span>
<span class="fc" id="L3821">    }</span>

    /**
     * &lt;p&gt;This method is the exact reverse of animateLayoutAndWait, when completed it leaves the container in
     * an invalid state. It is useful to invoke this in order to remove a component, transition to a
     * different form or provide some other interaction. E.g.:&lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/codenameone/ba6fdc5f841b083e13e9.js&quot;&gt;&lt;/script&gt;
     *
     * @param duration the duration of the animation
     * @param opacity  the opacity to which the layout will reach, allows fading out the components
     */
    public void animateUnlayoutAndWait(final int duration, int opacity) {
<span class="nc" id="L3833">        animateUnlayout(duration, true, opacity, null, true);</span>
<span class="nc" id="L3834">    }</span>

    /**
     * &lt;p&gt;This method is the exact reverse of createAnimateLayout, when animation is completed it leaves the container in
     * an invalid state. It is useful to invoke this in order to remove a component, transition to a
     * different form or provide some other interaction. E.g.:&lt;/p&gt;
     *
     * @param duration the duration of the animation
     * @param opacity  the opacity to which the layout will reach, allows fading out the components
     * @return the animation object that should be added to the animation manager
     */
    public ComponentAnimation createAnimateUnlayout(int duration, int opacity, Runnable callback) {
<span class="fc" id="L3846">        return animateUnlayout(duration, false, opacity, callback, false);</span>
    }

    /**
     * Animates a pending layout into place, this effectively replaces revalidate with a more visual form of animation
     *
     * @param duration the duration in milliseconds for the animation
     */
    private ComponentAnimation animateUnlayout(final int duration, boolean wait, int opacity, Runnable callback, boolean add) {
<span class="fc" id="L3855">        setShouldCalcPreferredSize(true);</span>
<span class="fc" id="L3856">        enableLayoutOnPaint = false;</span>
<span class="fc" id="L3857">        final int componentCount = getComponentCount();</span>
<span class="fc" id="L3858">        int[] beforeX = new int[componentCount];</span>
<span class="fc" id="L3859">        int[] beforeY = new int[componentCount];</span>
<span class="fc" id="L3860">        int[] beforeW = new int[componentCount];</span>
<span class="fc" id="L3861">        int[] beforeH = new int[componentCount];</span>
<span class="fc" id="L3862">        final Motion[] xMotions = new Motion[componentCount];</span>
<span class="fc" id="L3863">        final Motion[] yMotions = new Motion[componentCount];</span>
<span class="fc" id="L3864">        final Motion[] wMotions = new Motion[componentCount];</span>
<span class="fc" id="L3865">        final Motion[] hMotions = new Motion[componentCount];</span>
<span class="fc bfc" id="L3866" title="All 2 branches covered.">        for (int iter = 0; iter &lt; componentCount; iter++) {</span>
<span class="fc" id="L3867">            Component current = getComponentAt(iter);</span>
<span class="fc" id="L3868">            beforeX[iter] = current.getX();</span>
<span class="fc" id="L3869">            beforeY[iter] = current.getY();</span>
<span class="fc" id="L3870">            beforeW[iter] = current.getWidth();</span>
<span class="fc" id="L3871">            beforeH[iter] = current.getHeight();</span>
        }
<span class="fc" id="L3873">        layoutContainer();</span>
<span class="fc bfc" id="L3874" title="All 2 branches covered.">        for (int iter = 0; iter &lt; componentCount; iter++) {</span>
<span class="fc" id="L3875">            Component current = getComponentAt(iter);</span>
<span class="fc" id="L3876">            xMotions[iter] = createAnimateMotion(current.getX(), beforeX[iter], duration);</span>
<span class="fc" id="L3877">            yMotions[iter] = createAnimateMotion(current.getY(), beforeY[iter], duration);</span>
<span class="fc" id="L3878">            wMotions[iter] = createAnimateMotion(current.getWidth(), beforeW[iter], duration);</span>
<span class="fc" id="L3879">            hMotions[iter] = createAnimateMotion(current.getHeight(), beforeH[iter], duration);</span>
<span class="fc" id="L3880">            xMotions[iter].start();</span>
<span class="fc" id="L3881">            yMotions[iter].start();</span>
<span class="fc" id="L3882">            wMotions[iter].start();</span>
<span class="fc" id="L3883">            hMotions[iter].start();</span>
        }
<span class="fc" id="L3885">        MorphAnimation a = new MorphAnimation(this, duration, new Motion[][]{</span>
                xMotions, yMotions, wMotions, hMotions
        });
<span class="fc" id="L3888">        setAnimOpacity(255, opacity, a, componentCount, duration);</span>
<span class="fc" id="L3889">        a.dontRevalidate = true;</span>
<span class="fc bfc" id="L3890" title="All 2 branches covered.">        if (add) {</span>
<span class="pc bpc" id="L3891" title="1 of 2 branches missed.">            if (wait) {</span>
<span class="nc" id="L3892">                getAnimationManager().addAnimationAndBlock(a);</span>
            } else {
<span class="pc bpc" id="L3894" title="1 of 2 branches missed.">                if (callback != null) {</span>
<span class="fc" id="L3895">                    getAnimationManager().addUIMutation(this, a, callback);</span>
                } else {
<span class="nc" id="L3897">                    getAnimationManager().addUIMutation(this, a);</span>
                }
            }
        }
<span class="fc" id="L3901">        return a;</span>
    }

    /**
     * Animates a pending layout into place, this effectively replaces revalidate with a more visual form of animation
     *
     * @param duration the duration in milliseconds for the animation
     */
    private ComponentAnimation animateLayout(final int duration, boolean wait, int opacity, boolean addAnimation) {
        // this happens for some reason
<span class="fc" id="L3911">        Form f = getComponentForm();</span>
<span class="fc bfc" id="L3912" title="All 2 branches covered.">        if (f == null) {</span>
<span class="fc" id="L3913">            return null;</span>
        }
<span class="fc" id="L3915">        setShouldCalcPreferredSize(true);</span>
<span class="fc" id="L3916">        enableLayoutOnPaint = false;</span>
<span class="fc" id="L3917">        final int componentCount = getComponentCount();</span>
<span class="fc" id="L3918">        int[] beforeX = new int[componentCount];</span>
<span class="fc" id="L3919">        int[] beforeY = new int[componentCount];</span>
<span class="fc" id="L3920">        int[] beforeW = new int[componentCount];</span>
<span class="fc" id="L3921">        int[] beforeH = new int[componentCount];</span>
<span class="fc" id="L3922">        final Motion[] xMotions = new Motion[componentCount];</span>
<span class="fc" id="L3923">        final Motion[] yMotions = new Motion[componentCount];</span>
<span class="fc" id="L3924">        final Motion[] wMotions = new Motion[componentCount];</span>
<span class="fc" id="L3925">        final Motion[] hMotions = new Motion[componentCount];</span>
<span class="fc bfc" id="L3926" title="All 2 branches covered.">        for (int iter = 0; iter &lt; componentCount; iter++) {</span>
<span class="fc" id="L3927">            Component current = getComponentAt(iter);</span>
<span class="fc" id="L3928">            beforeX[iter] = current.getX();</span>
<span class="fc" id="L3929">            beforeY[iter] = current.getY();</span>
<span class="fc" id="L3930">            beforeW[iter] = current.getWidth();</span>
<span class="fc" id="L3931">            beforeH[iter] = current.getHeight();</span>
        }
<span class="fc" id="L3933">        layoutContainer();</span>
<span class="fc bfc" id="L3934" title="All 2 branches covered.">        for (int iter = 0; iter &lt; componentCount; iter++) {</span>
<span class="fc" id="L3935">            Component current = getComponentAt(iter);</span>
<span class="fc" id="L3936">            xMotions[iter] = createAnimateMotion(beforeX[iter], current.getX(), duration);</span>
<span class="fc" id="L3937">            yMotions[iter] = createAnimateMotion(beforeY[iter], current.getY(), duration);</span>
<span class="fc" id="L3938">            wMotions[iter] = createAnimateMotion(beforeW[iter], current.getWidth(), duration);</span>
<span class="fc" id="L3939">            hMotions[iter] = createAnimateMotion(beforeH[iter], current.getHeight(), duration);</span>
<span class="fc" id="L3940">            xMotions[iter].start();</span>
<span class="fc" id="L3941">            yMotions[iter].start();</span>
<span class="fc" id="L3942">            wMotions[iter].start();</span>
<span class="fc" id="L3943">            hMotions[iter].start();</span>
<span class="fc" id="L3944">            current.setX(beforeX[iter]);</span>
<span class="fc" id="L3945">            current.setY(beforeY[iter]);</span>
<span class="fc" id="L3946">            current.setWidth(beforeW[iter]);</span>
<span class="fc" id="L3947">            current.setHeight(beforeH[iter]);</span>
        }
<span class="fc" id="L3949">        MorphAnimation a = new MorphAnimation(this, duration, new Motion[][]{</span>
                xMotions, yMotions, wMotions, hMotions
        });
<span class="fc" id="L3952">        setAnimOpacity(opacity, 255, a, componentCount, duration);</span>
<span class="fc bfc" id="L3953" title="All 2 branches covered.">        if (addAnimation) {</span>
<span class="pc bpc" id="L3954" title="1 of 2 branches missed.">            if (wait) {</span>
<span class="nc" id="L3955">                getAnimationManager().addAnimationAndBlock(a);</span>
            } else {
<span class="fc" id="L3957">                getAnimationManager().addUIMutation(this, a);</span>
            }
        } else {
<span class="fc" id="L3960">            a.dontRevalidate = true;</span>
        }
<span class="fc" id="L3962">        return a;</span>
    }

    private void setAnimOpacity(int source, int dest, MorphAnimation a, int componentCount, int duration) {
<span class="pc bpc" id="L3966" title="1 of 2 branches missed.">        if (source != dest) {</span>
<span class="nc" id="L3967">            a.opacity = new Motion[componentCount];</span>
<span class="nc bnc" id="L3968" title="All 2 branches missed.">            for (int iter = 0; iter &lt; componentCount; iter++) {</span>
<span class="nc" id="L3969">                a.opacity[iter] = createAndStartAnimateMotion(source, dest, duration);</span>
            }
        }
<span class="fc" id="L3972">    }</span>

    /**
     * Gets the child components of this Container as a List.  Using {@literal true} as the
     * argument provides a way to obtain all of the children, including children whose full
     * addition is pending while an animation is in progress.
     *
     * &lt;p&gt;&lt;strong&gt;Animation Discussion&lt;/strong&gt;: If children are added or removed from a Container
     * while its containing Form has an animation in progress, the insertion/deletion isn't complete
     * until after the animation is finished.  Most methods to interact with a container's children
     * won't see these pending changes until that time.  E.g.:&lt;/p&gt;
     *
     * &lt;p&gt;{@code
     * // Assume an animation is in progress on the form containing cnt.
     * Label lbl = new Label(&quot;Test&quot;);
     * int len = cnt.getComponentCount(); // 0
     * cnt.addComponent(lbl);
     * int lenAfter = cnt.getComponentCount(); // 0
     * cnt.contains(lbl);  // true
     * cnt.getChildrenAsList(true).size(); // 1
     * cnt.getChildrenAsList(false).size(); // 0
     * &lt;p&gt;
     * Button btn = new Button(&quot;Press me&quot;);
     * cnt.addComponent(btn);
     * cnt.getComponentCount(); // 0
     * cnt.getChildrenAsList(true).size(); // 2
     * cnt.removeComponent(btn);
     * cnt.getComponentCount(); // 0
     * cnt.getChildrenAsList(true).size(); // 1
     * &lt;p&gt;
     * }&lt;/p&gt;
     *
     * @param includeQueued True to reflect queued inserts and removals while an animation is in progress.
     * @return A list including all of the children of this container.
     * @see #iterator(boolean)
     */
    public java.util.List&lt;Component&gt; getChildrenAsList(boolean includeQueued) {
<span class="pc bpc" id="L4009" title="1 of 2 branches missed.">        if (includeQueued) {</span>
<span class="fc" id="L4010">            java.util.ArrayList&lt;Component&gt; out = new java.util.ArrayList&lt;Component&gt;();</span>
<span class="fc" id="L4011">            out.addAll(components);</span>
<span class="pc bpc" id="L4012" title="1 of 2 branches missed.">            if (changeQueue != null) {</span>
<span class="pc bpc" id="L4013" title="1 of 2 branches missed.">                for (QueuedChange change : changeQueue) {</span>
<span class="nc bnc" id="L4014" title="All 3 branches missed.">                    switch (change.type) {</span>
                        case QueuedChange.TYPE_INSERT:
<span class="nc" id="L4016">                            QueuedInsertion insert = (QueuedInsertion) change;</span>
<span class="nc" id="L4017">                            int index = insert.index;</span>
<span class="nc bnc" id="L4018" title="All 2 branches missed.">                            if (insert.index == Integer.MAX_VALUE) {</span>
<span class="nc" id="L4019">                                index = out.size();</span>
                            }
<span class="nc" id="L4021">                            out.add(index, change.component);</span>
<span class="nc" id="L4022">                            break;</span>
                        case QueuedChange.TYPE_REMOVE:
<span class="nc" id="L4024">                            out.remove(change.component);</span>
                            break;
                    }
<span class="nc" id="L4027">                }</span>
            }
<span class="fc" id="L4029">            return out;</span>
        } else {
<span class="nc" id="L4031">            java.util.ArrayList&lt;Component&gt; out = new java.util.ArrayList&lt;Component&gt;();</span>
<span class="nc" id="L4032">            out.addAll(components);</span>
<span class="nc" id="L4033">            return out;</span>
        }
    }

    /**
     * Obtains an iterator that iterates over the children of this container.  If argument is true,
     * then the iteratator will include queued insertions/deletions while an animation is in progress.
     *
     * @param includeQueued True to include queued component insertions and removals while animation is in progress.
     * @return An iterator that iterates over the children of this component.
     * @see #iterator()
     * @see #getChildrenAsList(boolean)
     */
    public Iterator&lt;Component&gt; iterator(boolean includeQueued) {
<span class="nc bnc" id="L4047" title="All 2 branches missed.">        if (includeQueued) {</span>
<span class="nc" id="L4048">            return getChildrenAsList(includeQueued).iterator();</span>
        } else {
<span class="nc" id="L4050">            return iterator();</span>
        }
    }

    /**
     * Part of the Iterable interface allowing us to do a for-each loop on Container
     *
     * @return the iterator of the components
     */
    public Iterator&lt;Component&gt; iterator() {
<span class="fc" id="L4060">        return components.iterator();</span>
    }

    /**
     * Encapsulates a change to the container's children.  Used to keep track of
     * queued inserts and removes that occur while an animation is in progress.
     */
    private static class QueuedChange {
        /**
         * For {@link #type} to indicate an insertion.
         */
        static final int TYPE_INSERT = 0;
        /**
         * For {@link #type} to indicate a removal.
         */
        static final int TYPE_REMOVE = 1;
        /**
         * The component that was inserted or removed.
         */
        private final Component component;
        /**
         * The type of change.  Either {@link #TYPE_INSERT} or {@link #TYPE_REMOVE}
         */
        private final int type;

        /**
         * Creates a new queued change.
         *
         * @param type Either {@link #TYPE_INSERT} or {@link #TYPE_REMOVE}
         * @param cmp  The component that was inserted or removed.
         */
<span class="fc" id="L4091">        QueuedChange(int type, Component cmp) {</span>
<span class="fc" id="L4092">            this.type = type;</span>
<span class="fc" id="L4093">            this.component = cmp;</span>
<span class="fc" id="L4094">        }</span>
    }

    /**
     * Encapsulates a child component insertion that occurs during an animation.
     */
    private static class QueuedInsertion extends QueuedChange {
        /**
         * The component constraint of the component that was inserted.
         */
        private final Object constraint;

        /**
         * The index where the component should be inserted.
         */
        private final int index;

        /**
         * Creates a new queued insertion.
         *
         * @param index      The index where the component is inserted.
         * @param constraint The constraint.
         * @param cmp        The component that was inserted.
         */
        QueuedInsertion(int index, Object constraint, Component cmp) {
<span class="fc" id="L4119">            super(TYPE_INSERT, cmp);</span>
<span class="fc" id="L4120">            this.index = index;</span>
<span class="fc" id="L4121">            this.constraint = constraint;</span>
<span class="fc" id="L4122">        }</span>
    }

    /**
     * Encapsulates the removal of a component from the children while an animation
     * is in progress.
     */
    private static class QueuedRemoval extends QueuedChange {
        QueuedRemoval(Component cmp) {
<span class="fc" id="L4131">            super(TYPE_REMOVE, cmp);</span>
<span class="fc" id="L4132">        }</span>
    }

    /**
     * Lays out the container
     */

    private static class TmpInsets {
        float top, left, bottom, right;
        byte topUnit, leftUnit, bottomUnit, rightUnit;

        @Override
        public String toString() {
<span class="nc" id="L4145">            return top + &quot;,&quot; + right + &quot;,&quot; + bottom + &quot;,&quot; + left;</span>
        }

        private void set(Style style) {
            //boolean suppressEvents = style.isSuppressChangeEvents();
            //style.setSuppressChangeEvents(true);
<span class="fc" id="L4151">            top = style.getPaddingFloatValue(false, TOP);</span>
<span class="fc" id="L4152">            left = style.getPaddingFloatValue(false, LEFT);</span>
<span class="fc" id="L4153">            bottom = style.getPaddingFloatValue(false, BOTTOM);</span>
<span class="fc" id="L4154">            right = style.getPaddingFloatValue(false, RIGHT);</span>
<span class="fc" id="L4155">            byte[] units = style.getPaddingUnit();</span>
<span class="fc bfc" id="L4156" title="All 2 branches covered.">            if (units != null) {</span>
<span class="fc" id="L4157">                topUnit = units[TOP];</span>
<span class="fc" id="L4158">                leftUnit = units[LEFT];</span>
<span class="fc" id="L4159">                bottomUnit = units[BOTTOM];</span>
<span class="fc" id="L4160">                rightUnit = units[RIGHT];</span>
            } else {
<span class="fc" id="L4162">                topUnit = leftUnit = bottomUnit = rightUnit = Style.UNIT_TYPE_PIXELS;</span>
            }
            //style.setSuppressChangeEvents(suppressEvents);
<span class="fc" id="L4165">        }</span>

        private void restore(Style style) {
<span class="nc" id="L4168">            boolean suppressEvents = style.isSuppressChangeEvents();</span>
<span class="nc" id="L4169">            style.setSuppressChangeEvents(true);</span>
<span class="nc" id="L4170">            style.setPadding(TOP, top, true);</span>
<span class="nc" id="L4171">            style.setPadding(LEFT, left, true);</span>
<span class="nc" id="L4172">            style.setPadding(BOTTOM, bottom, true);</span>
<span class="nc" id="L4173">            style.setPadding(RIGHT, right, true);</span>
<span class="nc" id="L4174">            byte[] units = style.getPaddingUnit();</span>
<span class="nc bnc" id="L4175" title="All 2 branches missed.">            if (units != null) {</span>
<span class="nc" id="L4176">                units[TOP] = topUnit;</span>
<span class="nc" id="L4177">                units[BOTTOM] = bottomUnit;</span>
<span class="nc" id="L4178">                units[LEFT] = leftUnit;</span>
<span class="nc" id="L4179">                units[RIGHT] = rightUnit;</span>
            } else {
<span class="nc" id="L4181">                style.setPaddingUnit(topUnit, leftUnit, bottomUnit, rightUnit);</span>
            }
<span class="nc" id="L4183">            style.setSuppressChangeEvents(suppressEvents);</span>
<span class="nc" id="L4184">        }</span>

    }

    static class TransitionAnimation extends ComponentAnimation {
        int growSpeed;
        int layoutAnimationSpeed;
        Vector animatedComponents;
        Motion[] opacity;
        boolean dontRevalidate;
        private final Transition t;
        private final Container thisContainer;
<span class="fc" id="L4196">        private boolean started = false;</span>
<span class="fc" id="L4197">        private boolean inProgress = true;</span>
        private final Component current;
        private final Component next;
        private final Form parent;
        private boolean destroyed;

<span class="fc" id="L4203">        TransitionAnimation(Container thisContainer, Component current, Component next, Transition t) {</span>
<span class="fc" id="L4204">            this.t = t;</span>
<span class="fc" id="L4205">            this.next = next;</span>
<span class="fc" id="L4206">            this.current = current;</span>
<span class="fc" id="L4207">            this.thisContainer = thisContainer;</span>
<span class="fc" id="L4208">            this.parent = thisContainer.getComponentForm();</span>
<span class="fc" id="L4209">        }</span>

        public boolean isInProgress() {
<span class="nc" id="L4212">            return inProgress;</span>
        }

        public void updateState() {
<span class="nc bnc" id="L4216" title="All 2 branches missed.">            if (destroyed) {</span>
<span class="nc" id="L4217">                return;</span>
            }
<span class="nc bnc" id="L4219" title="All 2 branches missed.">            if (!started) {</span>
<span class="nc" id="L4220">                t.init(current, next);</span>
<span class="nc bnc" id="L4221" title="All 2 branches missed.">                if (current != null) {</span>
<span class="nc" id="L4222">                    current.setLightweightMode(true);</span>
                }
<span class="nc bnc" id="L4224" title="All 2 branches missed.">                if (next != null) {</span>
<span class="nc" id="L4225">                    next.setLightweightMode(true);</span>
                }
<span class="nc" id="L4227">                t.initTransition();</span>
<span class="nc" id="L4228">                started = true;</span>
<span class="nc bnc" id="L4229" title="All 2 branches missed.">                if (thisContainer.cmpTransitions == null) {</span>
<span class="nc" id="L4230">                    thisContainer.cmpTransitions = new Vector();</span>
                }
<span class="nc" id="L4232">                thisContainer.cmpTransitions.addElement(this);</span>
            }
<span class="nc" id="L4234">            inProgress = t.animate();</span>
<span class="nc bnc" id="L4235" title="All 2 branches missed.">            if (!inProgress) {</span>
<span class="nc" id="L4236">                thisContainer.cmpTransitions.removeElement(this);</span>
<span class="nc" id="L4237">                destroy();</span>
<span class="nc" id="L4238">                thisContainer.repaint();</span>
            } else {
<span class="nc" id="L4240">                Display.getInstance().repaint(t);</span>
            }
<span class="nc" id="L4242">        }</span>

        @Override
        public void flush() {
<span class="nc" id="L4246">            destroy();</span>
<span class="nc" id="L4247">        }</span>

        public void destroy() {
<span class="nc bnc" id="L4250" title="All 2 branches missed.">            if (destroyed) {</span>
<span class="nc" id="L4251">                return;</span>
            }
<span class="nc" id="L4253">            destroyed = true;</span>
<span class="nc" id="L4254">            next.setParent(null);</span>
<span class="nc bnc" id="L4255" title="All 4 branches missed.">            thisContainer.replace(current, next, growSpeed &gt; 0 || layoutAnimationSpeed &gt; 0);</span>
            //release the events blocking
<span class="nc" id="L4257">            t.cleanup();</span>
<span class="nc bnc" id="L4258" title="All 2 branches missed.">            if (current != null) {</span>
<span class="nc" id="L4259">                current.setLightweightMode(false);</span>
            }
<span class="nc bnc" id="L4261" title="All 2 branches missed.">            if (next != null) {</span>
<span class="nc" id="L4262">                next.setLightweightMode(false);</span>
            }
<span class="nc bnc" id="L4264" title="All 6 branches missed.">            if (thisContainer.cmpTransitions != null &amp;&amp; thisContainer.cmpTransitions.size() == 0 &amp;&amp; growSpeed &gt; -1) {</span>
<span class="nc bnc" id="L4265" title="All 2 branches missed.">                if (growSpeed &gt; 0) {</span>
<span class="nc" id="L4266">                    current.growShrink(growSpeed);</span>
                } else {
<span class="nc bnc" id="L4268" title="All 4 branches missed.">                    if (layoutAnimationSpeed &lt;= 0 &amp;&amp; !dontRevalidate) {</span>
<span class="nc bnc" id="L4269" title="All 2 branches missed.">                        if (parent != null) {</span>
<span class="nc" id="L4270">                            parent.revalidate();</span>
                        }
                    }
                }
            }
<span class="nc" id="L4275">            inProgress = false;</span>
<span class="nc" id="L4276">        }</span>
    }

    static class MorphAnimation extends ComponentAnimation {
        Runnable onFinish;
        int growSpeed;
        int layoutAnimationSpeed;
        Vector animatedComponents;
        Motion[] opacity;
        boolean dontRevalidate;
        private final long startTime;
        private int duration;
        private Transition t;
        private final Container thisContainer;
<span class="fc" id="L4290">        private boolean finished = false;</span>
        private final Motion[][] motions;
        private Component scrollTo;

<span class="fc" id="L4294">        public MorphAnimation(Container thisContainer, int duration, Motion[][] motions) {</span>
<span class="fc" id="L4295">            startTime = System.currentTimeMillis();</span>
<span class="fc" id="L4296">            this.duration = duration;</span>
<span class="pc bpc" id="L4297" title="1 of 2 branches missed.">            if (Motion.isSlowMotion()) {</span>
<span class="nc" id="L4298">                this.duration *= 50;</span>
            }
<span class="fc" id="L4300">            this.thisContainer = thisContainer;</span>
<span class="fc" id="L4301">            this.motions = motions;</span>
<span class="fc" id="L4302">        }</span>

        @Override
        public boolean isInProgress() {
<span class="fc bfc" id="L4306" title="All 2 branches covered.">            return !finished;</span>
        }

        @Override
        public void flush() {
<span class="fc bfc" id="L4311" title="All 2 branches covered.">            for (Motion[] mm : motions) {</span>
<span class="fc bfc" id="L4312" title="All 2 branches covered.">                for (Motion m : mm) {</span>
<span class="pc bpc" id="L4313" title="1 of 2 branches missed.">                    if (m != null) {</span>
<span class="fc" id="L4314">                        m.finish();</span>
                    }
                }
            }
<span class="fc" id="L4318">            updateState();</span>
<span class="fc" id="L4319">        }</span>

        @Override
        protected void updateState() {
<span class="fc bfc" id="L4323" title="All 2 branches covered.">            if (animatedComponents != null) {</span>
<span class="fc" id="L4324">                int componentCount = animatedComponents.size();</span>
<span class="fc bfc" id="L4325" title="All 2 branches covered.">                for (int iter = 0; iter &lt; componentCount; iter++) {</span>
<span class="fc" id="L4326">                    Component currentCmp = (Component) animatedComponents.elementAt(iter);</span>

<span class="fc" id="L4328">                    currentCmp.setX(motions[0][iter].getValue());</span>
<span class="fc" id="L4329">                    currentCmp.setY(motions[1][iter].getValue());</span>
<span class="fc" id="L4330">                    currentCmp.setWidth(motions[2][iter].getValue());</span>
<span class="fc" id="L4331">                    currentCmp.setHeight(motions[3][iter].getValue());</span>
<span class="pc bpc" id="L4332" title="1 of 4 branches missed.">                    if (opacity != null &amp;&amp; iter &lt; opacity.length) {</span>
<span class="fc" id="L4333">                        currentCmp.getStyle().setOpacity(opacity[iter].getValue(), false);</span>
                    }
                }
<span class="fc" id="L4336">            } else {</span>
<span class="fc" id="L4337">                int componentCount = thisContainer.getComponentCount();</span>
<span class="pc bpc" id="L4338" title="1 of 2 branches missed.">                if (motions != null) {</span>
<span class="fc" id="L4339">                    componentCount = Math.min(motions[0].length, componentCount);</span>
                }
<span class="fc bfc" id="L4341" title="All 2 branches covered.">                for (int iter = 0; iter &lt; componentCount; iter++) {</span>
<span class="fc" id="L4342">                    Component currentCmp = thisContainer.getComponentAt(iter);</span>

                    // this might happen if a container was replaced during animation
<span class="pc bpc" id="L4345" title="1 of 2 branches missed.">                    if (currentCmp == null) {</span>
<span class="nc" id="L4346">                        continue;</span>
                    }
<span class="fc" id="L4348">                    currentCmp.setX(motions[0][iter].getValue());</span>
<span class="fc" id="L4349">                    currentCmp.setY(motions[1][iter].getValue());</span>
<span class="fc" id="L4350">                    currentCmp.setWidth(motions[2][iter].getValue());</span>
<span class="fc" id="L4351">                    currentCmp.setHeight(motions[3][iter].getValue());</span>
<span class="pc bpc" id="L4352" title="3 of 4 branches missed.">                    if (opacity != null &amp;&amp; iter &lt; opacity.length) {</span>
<span class="nc" id="L4353">                        currentCmp.getStyle().setOpacity(opacity[iter].getValue(), false);</span>
                    }
                }
            }
<span class="fc bfc" id="L4357" title="All 2 branches covered.">            if (scrollTo != null) {</span>
<span class="fc" id="L4358">                boolean s = thisContainer.isSmoothScrolling();</span>
<span class="fc" id="L4359">                thisContainer.setSmoothScrolling(false);</span>
<span class="fc" id="L4360">                thisContainer.scrollComponentToVisible(scrollTo);</span>
<span class="fc" id="L4361">                thisContainer.setSmoothScrolling(s);</span>
            }
<span class="fc" id="L4363">            thisContainer.repaint();</span>
<span class="fc bfc" id="L4364" title="All 2 branches covered.">            if (System.currentTimeMillis() - startTime &gt;= duration) {</span>
<span class="fc" id="L4365">                enableLayoutOnPaint = true;</span>
<span class="fc" id="L4366">                thisContainer.dontRecurseContainer = false;</span>
<span class="fc" id="L4367">                Form f = thisContainer.getComponentForm();</span>
<span class="fc" id="L4368">                finished = true;</span>
<span class="pc bpc" id="L4369" title="1 of 2 branches missed.">                if (f == null) {</span>
<span class="nc" id="L4370">                    return;</span>
                }
<span class="fc bfc" id="L4372" title="All 2 branches covered.">                if (!dontRevalidate) {</span>
<span class="fc" id="L4373">                    f.revalidate();</span>
                }
            }
<span class="fc" id="L4376">        }</span>

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>