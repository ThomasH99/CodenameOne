<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Form.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codenameone-core-unittests</a> &gt; <a href="index.source.html" class="el_package">com.codename1.ui</a> &gt; <span class="el_source">Form.java</span></div><h1>Form.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores
 * CA 94065 USA or visit www.oracle.com if you need additional information or
 * have any questions.
 */
package com.codename1.ui;

import com.codename1.impl.CodenameOneImplementation;
import com.codename1.io.Log;
import com.codename1.ui.ComponentSelector.Filter;
import com.codename1.ui.animations.Animation;
import com.codename1.ui.animations.Motion;
import com.codename1.ui.animations.Transition;
import com.codename1.ui.events.ActionEvent;
import com.codename1.ui.events.ActionListener;
import com.codename1.ui.geom.Dimension;
import com.codename1.ui.geom.Rectangle;
import com.codename1.ui.layouts.BorderLayout;
import com.codename1.ui.layouts.FlowLayout;
import com.codename1.ui.layouts.LayeredLayout;
import com.codename1.ui.layouts.Layout;
import com.codename1.ui.list.ListCellRenderer;
import com.codename1.ui.plaf.LookAndFeel;
import com.codename1.ui.plaf.Style;
import com.codename1.ui.plaf.UIManager;
import com.codename1.ui.util.EventDispatcher;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Set;

/**
 * &lt;p&gt; Top level component that serves as the root for the UI, this {@link Container}
 * subclass works in concert with the {@link Toolbar} to create menus. By default a
 * forms main content area (the content pane) is scrollable on the Y axis and has a {@link com.codename1.ui.layouts.FlowLayout} as is the default.&lt;/p&gt;
 *
 * &lt;p&gt;Form contains a title bar area which in newer application is replaced by the {@link Toolbar}.
 * Calling {@link #add(com.codename1.ui.Component)} or all similar methods  on the {@code Form}
 * delegates to the contentPane so calling {@code form.add(cmp)} is equivalent to
 * {@code form.getContentPane().add(cmp)}. Normally this shouldn't matter, however in some cases such as
 * animation we need to use the content pane directly e.g. {@code form.getContentPane().animateLayout(200)}
 * will work whereas {@code form.animateLayout(200)} will fail. &lt;/p&gt;
 *
 * @author Chen Fishbein
 */
public class Form extends Container {
    private static final String Z_INDEX_PROP = &quot;cn1$_zIndex&quot;;
    static int activePeerCount;
    static Motion rippleMotion;
    static Component rippleComponent;
    static int rippleX;
    static int rippleY;
    /**
     * Used by the combo box to block some default Codename One behaviors
     */
    static boolean comboLock;
    private final Container contentPane;
    /**
     * Rectangle storing the safe area on the form.
     */
<span class="fc" id="L85">    private final Rectangle safeArea = new Rectangle();</span>
    /**
     * Indicates whether lists and containers should scroll only via focus and thus &quot;jump&quot; when
     * moving to a larger component as was the case in older versions of Codename One.
     */
    protected boolean focusScrolling;
<span class="fc" id="L91">    Container titleArea = new Container(new BorderLayout());</span>
    /**
     * Indicates that this form should be tinted when painted
     */
    boolean tint;
    EventDispatcher showListener;
    int initialPressX;
    int initialPressY;
    /**
     * A flag that enables/disables the behaviour that revalidate() on any container
     * will trigger a revalidate() in its parent form.  Not sure why we do this
     * but this flag turns off this behaviour.  Hopefully we can default this
     * to &quot;Off&quot; eventually.
     * &lt;p&gt;
     * Used in {@link Container#revalidate() }.
     */
<span class="fc" id="L107">    boolean revalidateFromRoot = &quot;true&quot;.equals(CN.getProperty(&quot;Form.revalidateFromRoot&quot;, &quot;true&quot;));</span>
    private Command sourceCommand;
    private boolean globalAnimationLock;
    private Painter glassPane;
    private Container layeredPane;
    private Container formLayeredPane;
<span class="fc" id="L113">    private Label title = new Label(&quot;&quot;, &quot;Title&quot;);</span>
    private MenuBar menuBar;
    private Component dragged;
    private boolean enableCursors;
    private TextSelection textSelection;
    private ArrayList&lt;Component&gt; componentsAwaitingRelease;
    private VirtualInputDevice currentInputDevice;
<span class="fc" id="L120">    private final AnimationManager animMananger = new AnimationManager(this);</span>
    /**
     * Contains a list of components that would like to animate their state
     */
    private ArrayList&lt;Animation&gt; internalAnimatableComponents;
    /**
     * Contains a list of components that would like to animate their state
     */
    private ArrayList&lt;Animation&gt; animatableComponents;
    //private FormSwitcher formSwitcher;
    private Component focused;
    private ArrayList&lt;Component&gt; mediaComponents;
    private boolean bottomPaddingMode;
    /**
     * This member allows us to define an animation that will draw the transition for
     * entering this form. A transition is an animation that would occur when
     * switching from one form to another.
     */
    private Transition transitionInAnimator;
    /**
     * This member allows us to define an animation that will draw the transition for
     * exiting this form. A transition is an animation that would occur when
     * switching from one form to another.
     */
    private Transition transitionOutAnimator;
    /**
     * a listener that is invoked when a command is clicked allowing multiple commands
     * to be handled by a single block
     */
    private EventDispatcher commandListener;
    /**
     * Relevant for modal forms where the previous form should be rendered underneath
     */
    private Form previousForm;
    /**
     * Default color for the screen tint when a dialog or a menu is shown
     */
    private int tintColor;
    /**
     * Listeners for key release events
     */
    private HashMap&lt;Integer, ArrayList&lt;ActionListener&gt;&gt; keyListeners;
    /**
     * Listeners for game key release events
     */
    private HashMap&lt;Integer, ArrayList&lt;ActionListener&gt;&gt; gameKeyListeners;
    /**
     * Indicates whether focus should cycle within the form
     */
<span class="fc" id="L169">    private boolean cyclicFocus = true;</span>
    private int tactileTouchDuration;
    private EventDispatcher orientationListener;
    private EventDispatcher sizeChangedListener;
    private EventDispatcher pasteListener;
    private UIManager uiManager;
    private Component stickyDrag;
    private boolean dragStopFlag;
    private Toolbar toolbar;
    /**
     * A text component that will receive focus and start editing immediately as the form is shown
     */
    private TextArea editOnShow;
    /**
     * A queue of containers that are scheduled to be revalidated before the next
     * paint.  Use {@link Container#revalidateLater() } to add to this queue.  The
     * queue the queue is flushed in {@link #flushRevalidateQueue() }
     */
<span class="fc" id="L187">    private final Set&lt;Container&gt; pendingRevalidateQueue = new HashSet&lt;Container&gt;();</span>
    /**
     * A temporary container used in {@link #flushRevalidateQueue() } for the list
     * of containers that are being revalidated.  This should not be used outside
     * of {@link #flushRevalidateQueue() }
     */
<span class="fc" id="L193">    private final ArrayList&lt;Container&gt; revalidateQueue = new ArrayList&lt;Container&gt;();</span>
<span class="fc" id="L194">    private int overrideInvisibleAreaUnderVKB = -1;</span>
    /**
     * A flag indicating if the safe area may be dirty, and needs to be recaculated.
     *
     * @see #getSafeArea()
     */
<span class="fc" id="L200">    private boolean safeAreaDirty = true;</span>
    private boolean pointerPressedAgainDuringDrag;
    private Component pressedCmp;
<span class="fc" id="L203">    private final Rectangle pressedCmpAbsBounds = new Rectangle();</span>
    private Object currentPointerPress;
    private boolean inInternalPaint;

    /**
     * Default constructor creates a simple form
     */
    public Form() {
<span class="fc" id="L211">        this(new FlowLayout());</span>
<span class="fc" id="L212">    }</span>

    /**
     * Constructor that accepts a layout
     *
     * @param contentPaneLayout the layout for the content pane
     */
    public Form(Layout contentPaneLayout) {
<span class="fc" id="L220">        super(new BorderLayout());</span>
<span class="fc" id="L221">        setSafeAreaRoot(true);</span>
<span class="fc" id="L222">        contentPane = new Container(contentPaneLayout);</span>
<span class="fc" id="L223">        setUIID(&quot;Form&quot;);</span>
        // forms/dialogs are not visible by default
<span class="fc" id="L225">        setVisible(false);</span>
<span class="fc" id="L226">        Style formStyle = getStyle();</span>
<span class="fc" id="L227">        Display d = Display.getInstance();</span>
<span class="fc" id="L228">        int w = d.getDisplayWidth() - (formStyle.getHorizontalMargins());</span>
<span class="fc" id="L229">        int h = d.getDisplayHeight() - (formStyle.getVerticalMargins());</span>

<span class="fc" id="L231">        setWidth(w);</span>
<span class="fc" id="L232">        setHeight(h);</span>
<span class="fc" id="L233">        setPreferredSize(new Dimension(w, h));</span>
<span class="fc" id="L234">        super.setAlwaysTensile(false);</span>

<span class="fc" id="L236">        title.setEndsWith3Points(false);</span>
<span class="fc" id="L237">        titleArea.addComponent(BorderLayout.CENTER, title);</span>
<span class="fc" id="L238">        titleArea.setUIID(&quot;TitleArea&quot;);</span>
<span class="fc" id="L239">        addComponentToForm(BorderLayout.NORTH, titleArea);</span>
<span class="fc" id="L240">        addComponentToForm(BorderLayout.CENTER, contentPane);</span>

<span class="fc" id="L242">        initAdPadding(d);</span>

<span class="fc" id="L244">        contentPane.setUIID(&quot;ContentPane&quot;);</span>
<span class="fc" id="L245">        contentPane.setScrollableY(true);</span>

<span class="pc bpc" id="L247" title="2 of 4 branches missed.">        if (title.getText() != null &amp;&amp; title.shouldTickerStart()) {</span>
<span class="nc" id="L248">            title.startTicker(getUIManager().getLookAndFeel().getTickerSpeed(), true);</span>
        }

<span class="fc" id="L251">        initTitleBarStatus();</span>

        // hardcoded, anything else is just pointless...
<span class="fc" id="L254">        formStyle.setBgTransparency(0xFF);</span>

<span class="fc" id="L256">        initGlobalToolbar();</span>
<span class="fc" id="L257">    }</span>

    /**
     * Sets the title after invoking the constructor
     *
     * @param title the form title
     */
    public Form(String title) {
<span class="fc" id="L265">        this();</span>
<span class="fc" id="L266">        setTitle(title);</span>
//        this.title.setText(title);
<span class="fc" id="L268">    }</span>

    /**
     * Sets the title after invoking the constructor
     *
     * @param title             the form title
     * @param contentPaneLayout the layout for the content pane
     */
    public Form(String title, Layout contentPaneLayout) {
<span class="fc" id="L277">        this(contentPaneLayout);</span>
<span class="fc" id="L278">        setTitle(title);</span>
<span class="fc" id="L279">    }</span>

    static int getInvisibleAreaUnderVKB(Form f) {
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">        if (f == null) {</span>
<span class="nc" id="L283">            return 0;</span>
        }
<span class="fc" id="L285">        return f.getInvisibleAreaUnderVKB();</span>
    }

    /**
     * &lt;p&gt;Enabling &quot;layoutOnPaint&quot; behaviour.  Setting this flag to true will cause
     * this form and all of its containers to lay themselves out whenever they are painted.
     * This carries a performance penalty.&lt;/p&gt;
     *
     * &lt;p&gt;Historical Note: &quot;layoutOnPaint&quot; behaviour has been &quot;on&quot; since the original commit
     * to Google code in 2012, but it isn't clear, now, why it was necessary.  It was likely
     * to fix an edge case in certain layouts that is no longer relevant.  As of 7.0, we are
     * disabling this behaviour by default because it carries such performance penalties, but allowing
     * developers to opt-in to it using this method.&lt;/p&gt;
     *
     * @param allow Whether to allow layoutOnPaint behaviour in this this form and it's containers.
     * @since 7.0&lt;/ p&gt;
     */
    @Override
    public void setAllowEnableLayoutOnPaint(boolean allow) {
<span class="fc" id="L304">        super.setAllowEnableLayoutOnPaint(allow);</span>
<span class="fc" id="L305">    }</span>

    /**
     * Adds a listener to be notified when the user has initiated a paste event.  This will primarily
     * occur only on desktop devices which allow the user to initiate a paste outside
     * the UI of the app itself, either using a key code (Command/Ctrl V), or a menu (Edit &amp;gt; Paste).
     *
     * &lt;p&gt;The event will be fired after the paste action has updated the clipboard contents, so you can
     * access the clipboard contents via {@link Display#getPasteDataFromClipboard() }.&lt;/p&gt;
     *
     * @param l Listener registered to receive paste events.
     * @since 7.0
     */
    public void addPasteListener(ActionListener l) {
<span class="nc bnc" id="L319" title="All 2 branches missed.">        if (pasteListener == null) {</span>
<span class="nc" id="L320">            pasteListener = new EventDispatcher();</span>
        }
<span class="nc" id="L322">        pasteListener.addListener(l);</span>
<span class="nc" id="L323">    }</span>

    /**
     * Removes listener from being notified when the user has initiated a paste event.
     *
     * @param l Listener to unregister to receive paste events.
     * @see #addPasteListener(com.codename1.ui.events.ActionListener)
     * @since 7.0
     */
    public void removePasteListener(ActionListener l) {
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if (pasteListener == null) {</span>
<span class="nc" id="L334">            return;</span>
        }
<span class="nc" id="L336">        pasteListener.removeListener(l);</span>
<span class="nc" id="L337">    }</span>

    /**
     * Adds a container to the revalidation queue to be revalidated before the next
     * paint.
     *
     * @param cnt The container to schedule for revalidation
     */
    void revalidateLater(Container cnt) {
<span class="fc bfc" id="L346" title="All 2 branches covered.">        if (!pendingRevalidateQueue.contains(cnt)) {</span>
            // It doesn't need to be in queue more than once.
<span class="fc" id="L348">            Iterator&lt;Container&gt; it = pendingRevalidateQueue.iterator();</span>

            // Iterate through the existing queue to make sure that this container
            // isn't already scheduled to be revalidated.
<span class="fc bfc" id="L352" title="All 2 branches covered.">            while (it.hasNext()) {</span>
<span class="fc" id="L353">                Container existing = it.next();</span>
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">                if (existing.contains(cnt)) {</span>
                    // cnt is already in a container that is scheduled for revalidation
                    // we don't need to add it.
<span class="nc" id="L357">                    return;</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">                } else if (cnt.contains(existing)) {</span>
                    // cnt is the parent of this container.  Remove the existing container
                    // as it will be covered by a revalidate of cnt
<span class="nc" id="L361">                    it.remove();</span>
                }

<span class="fc" id="L364">            }</span>
<span class="fc" id="L365">            pendingRevalidateQueue.add(cnt);</span>
        }
<span class="fc" id="L367">    }</span>

    /**
     * Removes a container from the revalidation queue.  This is called from
     * {@link Container#revalidate() }.
     *
     * @param cnt The container to remove from the queue.
     */
    void removeFromRevalidateQueue(Container cnt) {
<span class="fc" id="L376">        pendingRevalidateQueue.remove(cnt);</span>
<span class="fc" id="L377">    }</span>

    void flushRevalidateQueue() {

<span class="fc bfc" id="L381" title="All 2 branches covered.">        if (!pendingRevalidateQueue.isEmpty()) {</span>
<span class="fc" id="L382">            revalidateQueue.addAll(pendingRevalidateQueue);</span>
<span class="fc" id="L383">            pendingRevalidateQueue.clear();</span>
<span class="fc" id="L384">            int len = revalidateQueue.size();</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L386">                Container cnt = revalidateQueue.get(i);</span>
<span class="fc" id="L387">                cnt.revalidateWithAnimationSafetyInternal(false);</span>
            }
<span class="fc" id="L389">            revalidateQueue.clear();</span>

        }
<span class="fc" id="L392">    }</span>

    /**
     * Fires a paste event to the paste listeners.  For internal use.
     *
     * @param l The paste event.  Includes no useful data currently.
     * @see #addPasteListener(com.codename1.ui.events.ActionListener)
     * @see #removePasteListener(com.codename1.ui.events.ActionListener)
     * @since 7.0
     */
    public void dispatchPaste(ActionEvent l) {
<span class="nc bnc" id="L403" title="All 2 branches missed.">        if (pasteListener != null) {</span>
<span class="nc" id="L404">            pasteListener.fireActionEvent(l);</span>
        }
<span class="nc" id="L406">    }</span>

    /**
     * Gets TextSelection support for this form.
     *
     * @return The text selection support for this form.
     * @since 7.0
     */
    public TextSelection getTextSelection() {
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">        if (textSelection == null) {</span>
<span class="fc" id="L416">            textSelection = new TextSelection(getContentPane());</span>
        }
<span class="fc" id="L418">        return textSelection;</span>
    }

    /**
     * Checks if custom cursors are enabled on this form.  They are turned off by default since
     * they incur some overhead.
     *
     * @return True if cursors are enabled on this form.
     * @see #setEnableCursors(boolean)
     * @see Component#setCursor(int)
     */
    public boolean isEnableCursors() {
<span class="nc" id="L430">        return enableCursors;</span>
    }

    /**
     * Enable or disable custom cursors on this form.  They are turned off by default since they incur some overhead.
     *
     * @param e True to enable cursors.  False to disable them.
     * @see Component#setCursor(int)
     */
    public void setEnableCursors(boolean e) {
<span class="fc" id="L440">        this.enableCursors = e;</span>
<span class="fc" id="L441">    }</span>

    /**
     * Gets the source command that was used to navigate to this form.  This can be used
     * to pass context information to the form.
     *
     * @return The source command.
     * @since 7.0
     */
    public Command getSourceCommand() {
<span class="nc" id="L451">        return sourceCommand;</span>
    }

    /**
     * Sets the source command that was used to navigate to this form.  This can be used
     * to pass context information to the form.
     *
     * @param sourceCommand The source command.
     * @since 7.0
     */
    public void setSourceCommand(Command sourceCommand) {
<span class="nc" id="L462">        this.sourceCommand = sourceCommand;</span>
<span class="nc" id="L463">    }</span>

    /**
     * Returns the current virtual input device in the form.
     *
     * @return The current input device in the form.
     * @see #setCurrentInputDevice(com.codename1.ui.VirtualInputDevice)
     */
    public VirtualInputDevice getCurrentInputDevice() {
<span class="fc" id="L472">        return currentInputDevice;</span>
    }

    /**
     * Sets the current virtual input device for the form.  This will execute the {@link VirtualInputDevice#close() }
     * method of the current input device, and then set {@literal device} as the new current input device.
     *
     * &lt;p&gt;Some examples of virtual input devices are the Picker widget and the virtual keyboard.&lt;/p&gt;
     *
     * @param device
     * @throws Exception
     */
    public void setCurrentInputDevice(VirtualInputDevice device) throws Exception {
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">        if (currentInputDevice != null) {</span>
<span class="nc" id="L486">            currentInputDevice.close();</span>
        }
<span class="fc" id="L488">        currentInputDevice = device;</span>
<span class="fc" id="L489">    }</span>

    /**
     * Allows subclasses to disable the global toolbar for a specific form by overriding this method
     */
    protected void initGlobalToolbar() {
<span class="fc bfc" id="L495" title="All 2 branches covered.">        if (Toolbar.isGlobalToolbar()) {</span>
<span class="fc" id="L496">            setToolbar(new Toolbar());</span>
        }
<span class="fc" id="L498">    }</span>

    /**
     * Overrides the invisible area under the virtual keyboard with a given value.  This is used by lightweight components
     * to simulate the virtual keyboard, so that they will respect {@link #setFormBottomPaddingEditingMode(boolean)}.
     *
     * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; This setting is generally for internal use only, and should only be used if you know what you are doing.
     * After setting this value to a non-negative value, it will override the &quot;real&quot; area under the VKB if the read VKB is shown.
     * &lt;/p&gt;
     *
     * &lt;p&gt;To reset this after the lightweight component is hidden, set the value to {@literal -1}.&lt;/p&gt;
     *
     * @param invisibleAreaUnderVKB The area hidden by the VKB in pixels.
     * @since 8.0
     */
    public void setOverrideInvisibleAreaUnderVKB(int invisibleAreaUnderVKB) {
<span class="nc" id="L514">        overrideInvisibleAreaUnderVKB = invisibleAreaUnderVKB;</span>
<span class="nc" id="L515">    }</span>

    /**
     * In some virtual keyboard implementations (notably iOS) this value is used to determine the height of
     * the virtual keyboard
     *
     * @return height in pixels of the virtual keyboard
     * @see #setOverrideInvisibleAreaUnderVKB(int)
     */
    public int getInvisibleAreaUnderVKB() {
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">        if (bottomPaddingMode) {</span>
<span class="nc" id="L526">            return 0;</span>
        }
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">        if (overrideInvisibleAreaUnderVKB &gt;= 0) {</span>
<span class="nc" id="L529">            return overrideInvisibleAreaUnderVKB;</span>
        }
<span class="fc" id="L531">        return Display.impl.getInvisibleAreaUnderVKB();</span>
    }

    /**
     * Returns the animation manager instance responsible for this form, this can be used to track/queue
     * animations
     *
     * @return the animation manager
     */
    public AnimationManager getAnimationManager() {
<span class="fc" id="L541">        return animMananger;</span>
    }

    /**
     * Toggles the way the virtual keyboard behaves, enabling this mode shrinks the screen but makes editing
     * possible when working with text fields that aren't in a scrollable container.
     *
     * @return true when this mode is enabled
     */
    public boolean isFormBottomPaddingEditingMode() {
<span class="nc" id="L551">        return bottomPaddingMode;</span>
    }

    /**
     * Toggles the way the virtual keyboard behaves, enabling this mode shrinks the screen but makes editing
     * possible when working with text fields that aren't in a scrollable container.
     *
     * @param b true to enable false to disable
     */
    public void setFormBottomPaddingEditingMode(boolean b) {
<span class="nc" id="L561">        bottomPaddingMode = b;</span>
<span class="nc" id="L562">    }</span>

    /**
     * This method returns a rectangle defining the &quot;safe&quot; area of the display, which excludes
     * areas on the screen that are covered by notches, task bars, rounded corners, etc.
     *
     * &lt;p&gt;This feature was primarily added to deal with the task bar on the iPhone X, which
     * is displayed on the screen near the bottom edge, and can interfere with components
     * that are laid out at the bottom of the screen.&lt;/p&gt;
     *
     * &lt;p&gt;Most platforms will simply return a Rectangle with bounds (0, 0, displayWidth, displayHeight).  iPhone X
     * will return a rectangle that excludes the notch, and task bar regions.&lt;/p&gt;
     *
     * @return The safe area on which to draw.
     * @see CodenameOneImplementation#getDisplaySafeArea(com.codename1.ui.geom.Rectangle)
     * @see Container#setSafeArea(boolean)
     * @see Container#isSafeArea()
     * @since 7.0
     */
    public Rectangle getSafeArea() {
<span class="nc bnc" id="L582" title="All 2 branches missed.">        if (safeAreaDirty) {</span>
<span class="nc" id="L583">            Display.impl.getDisplaySafeArea(safeArea);</span>
            //safeAreaDirty = false;
        }
<span class="nc" id="L586">        return safeArea;</span>
    }

    void initAdPadding(Display d) {
        // this is injected automatically by the implementation in case of ads
<span class="fc" id="L591">        String adPaddingBottom = d.getProperty(&quot;adPaddingBottom&quot;, null);</span>
<span class="pc bpc" id="L592" title="3 of 4 branches missed.">        if (adPaddingBottom != null &amp;&amp; adPaddingBottom.length() &gt; 0) {</span>
<span class="nc" id="L593">            Container pad = new Container();</span>
<span class="nc" id="L594">            int dim = Integer.parseInt(adPaddingBottom);</span>
<span class="nc" id="L595">            dim = d.convertToPixels(dim, true);</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">            if (Display.getInstance().isTablet()) {</span>
<span class="nc" id="L597">                dim *= 2;</span>
            }
<span class="nc" id="L599">            pad.setPreferredSize(new Dimension(dim, dim));</span>
<span class="nc" id="L600">            addComponentToForm(BorderLayout.SOUTH, pad);</span>
        }
<span class="fc" id="L602">    }</span>

    /**
     * This method returns the value of the theme constant {@code paintsTitleBarBool} and it is
     * invoked internally in the code. You can override this method to toggle the appearance of the status
     * bar on a per-form basis
     *
     * @return the value of the {@code paintsTitleBarBool} theme constant
     */
    protected boolean shouldPaintStatusBar() {
<span class="fc" id="L612">        return getUIManager().isThemeConstant(&quot;paintsTitleBarBool&quot;, false);</span>
    }

    /**
     * Subclasses can override this method to control the creation of the status bar component.
     * Notice that this method will only be invoked if the paintsTitleBarBool theme constant is true
     * which it is on iOS by default
     *
     * @return a Component that represents the status bar if the OS requires status bar spacing
     */
    protected Component createStatusBar() {
<span class="nc bnc" id="L623" title="All 2 branches missed.">        if (getUIManager().isThemeConstant(&quot;statusBarScrollsUpBool&quot;, true)) {</span>
<span class="nc" id="L624">            Button bar = new Button();</span>
<span class="nc" id="L625">            bar.setShowEvenIfBlank(true);</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">            if (getUIManager().isThemeConstant(&quot;landscapeTitleUiidBool&quot;, false)) {</span>
<span class="nc" id="L627">                bar.setUIID(&quot;StatusBar&quot;, &quot;StatusBarLandscape&quot;);</span>
            } else {
<span class="nc" id="L629">                bar.setUIID(&quot;StatusBar&quot;);</span>
            }
<span class="nc" id="L631">            bar.addActionListener(new ActionListener() {</span>

                public void actionPerformed(ActionEvent evt) {
<span class="nc" id="L634">                    Component c = findScrollableChild(getContentPane());</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L636">                        c.scrollRectToVisible(new Rectangle(0, 0, 10, 10), c);</span>
                    }
<span class="nc" id="L638">                }</span>
            });
<span class="nc" id="L640">            return bar;</span>
        } else {
<span class="nc" id="L642">            Container bar = new Container();</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">            if (getUIManager().isThemeConstant(&quot;landscapeTitleUiidBool&quot;, false)) {</span>
<span class="nc" id="L644">                bar.setUIID(&quot;StatusBar&quot;, &quot;StatusBarLandscape&quot;);</span>
            } else {
<span class="nc" id="L646">                bar.setUIID(&quot;StatusBar&quot;);</span>
            }
<span class="nc" id="L648">            return bar;</span>
        }
    }

    /**
     * Here so dialogs can disable this
     */
    void initTitleBarStatus() {
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">        if (shouldPaintStatusBar()) {</span>
            // check if its already added:
<span class="nc bnc" id="L658" title="All 2 branches missed.">            if (((BorderLayout) titleArea.getLayout()).getNorth() == null) {</span>
<span class="nc" id="L659">                titleArea.addComponent(BorderLayout.NORTH, createStatusBar());</span>
<span class="nc" id="L660">                titleArea.revalidateLater();</span>
            }
        }
<span class="fc" id="L663">    }</span>

    Component findScrollableChild(Container c) {
<span class="nc bnc" id="L666" title="All 2 branches missed.">        if (c.isScrollableY()) {</span>
<span class="nc" id="L667">            return c;</span>
        }
<span class="nc" id="L669">        int count = c.getComponentCount();</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">        for (int iter = 0; iter &lt; count; iter++) {</span>
<span class="nc" id="L671">            Component comp = c.getComponentAt(iter);</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">            if (comp.isScrollableY()) {</span>
<span class="nc" id="L673">                return comp;</span>
            }
<span class="nc bnc" id="L675" title="All 2 branches missed.">            if (comp instanceof Container) {</span>
<span class="nc" id="L676">                Component chld = findScrollableChild((Container) comp);</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">                if (chld != null) {</span>
<span class="nc" id="L678">                    return chld;</span>
                }
            }
        }
<span class="nc" id="L682">        return null;</span>
    }

    /**
     * {@inheritDoc}
     */
    public boolean isAlwaysTensile() {
<span class="nc" id="L689">        return getContentPane().isAlwaysTensile();</span>
    }

    /**
     * {@inheritDoc}
     */
    public void setAlwaysTensile(boolean alwaysTensile) {
<span class="nc" id="L696">        getContentPane().setAlwaysTensile(alwaysTensile);</span>
<span class="nc" id="L697">    }</span>

    /**
     * Allows grabbing a flag that is used by convention to indicate that you are running an exclusive animation.
     * This is used by some code to prevent collision between optional animation
     *
     * @return whether the lock was acquired or not
     * @deprecated this is effectively invalidated by the newer animation framework
     */
    public boolean grabAnimationLock() {
<span class="nc bnc" id="L707" title="All 2 branches missed.">        if (globalAnimationLock) {</span>
<span class="nc" id="L708">            return false;</span>
        }
<span class="nc" id="L710">        globalAnimationLock = true;</span>
<span class="nc" id="L711">        return true;</span>
    }

    /**
     * Invoke this to release the animation lock that was grabbed in grabAnimationLock
     *
     * @deprecated this is effectively invalidated by the newer animation framework
     */
    public void releaseAnimationLock() {
<span class="nc" id="L720">        globalAnimationLock = false;</span>
<span class="nc" id="L721">    }</span>

    /**
     * Returns the component on this form that is currently being edited, or null
     * if no component is currently being edited.
     *
     * @return The currently edited component on this form.
     * @see Component#isEditing()
     */
    public Component findCurrentlyEditingComponent() {
<span class="fc" id="L731">        return ComponentSelector.select(&quot;*&quot;, this).filter(new Filter() {</span>


            public boolean filter(Component c) {
<span class="fc" id="L735">                return c.isEditing();</span>
            }

<span class="fc" id="L738">        }).asComponent();</span>
    }

    /**
     * Title area manipulation might break with future changes to Codename One and might
     * damage themeing/functionality of the Codename One application in some platforms
     *
     * @return the container containing the title
     * @deprecated this method was exposed to allow some hacks, you are advised not to use it.
     * There are some alternatives such as command behavior (thru Display or the theme constants)
     */
    public Container getTitleArea() {
<span class="fc bfc" id="L750" title="All 4 branches covered.">        if (toolbar != null &amp;&amp; toolbar.getParent() != null) {</span>
<span class="fc" id="L751">            return toolbar;</span>
        }
<span class="fc" id="L753">        return titleArea;</span>
    }

    public UIManager getUIManager() {
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">        if (uiManager != null) {</span>
<span class="nc" id="L758">            return uiManager;</span>
        } else {
<span class="fc" id="L760">            return UIManager.getInstance();</span>
        }
    }

    public void setUIManager(UIManager uiManager) {
<span class="nc" id="L765">        this.uiManager = uiManager;</span>
<span class="nc" id="L766">        refreshTheme(false);</span>
<span class="nc" id="L767">    }</span>

    /**
     * This listener would be invoked when show is completed
     *
     * @param l listener
     */
    public void addShowListener(ActionListener l) {
<span class="pc bpc" id="L775" title="1 of 2 branches missed.">        if (showListener == null) {</span>
<span class="fc" id="L776">            showListener = new EventDispatcher();</span>
        }
<span class="fc" id="L778">        showListener.addListener(l);</span>
<span class="fc" id="L779">    }</span>

    /**
     * Removes the show listener
     *
     * @param l the listener
     */
    public void removeShowListener(ActionListener l) {
<span class="nc bnc" id="L787" title="All 2 branches missed.">        if (showListener == null) {</span>
<span class="nc" id="L788">            return;</span>
        }
<span class="nc" id="L790">        showListener.removeListener(l);</span>
<span class="nc" id="L791">    }</span>

    /**
     * Removes all Show Listeners from this Form
     */
    public void removeAllShowListeners() {
<span class="nc bnc" id="L797" title="All 2 branches missed.">        if (showListener != null) {</span>
<span class="nc" id="L798">            showListener.getListenerCollection().clear();</span>
<span class="nc" id="L799">            showListener = null;</span>
        }
<span class="nc" id="L801">    }</span>

    /**
     * This listener is invoked when device orientation changes on devices that support orientation change
     *
     * @param l listener
     */
    public void addOrientationListener(ActionListener l) {
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">        if (orientationListener == null) {</span>
<span class="fc" id="L810">            orientationListener = new EventDispatcher();</span>
        }
<span class="fc" id="L812">        orientationListener.addListener(l);</span>
<span class="fc" id="L813">    }</span>

    /**
     * This listener is invoked when device orientation changes on devices that support orientation change
     *
     * @param l the listener
     */
    public void removeOrientationListener(ActionListener l) {
<span class="nc bnc" id="L821" title="All 2 branches missed.">        if (orientationListener == null) {</span>
<span class="nc" id="L822">            return;</span>
        }
<span class="nc" id="L824">        orientationListener.removeListener(l);</span>
<span class="nc" id="L825">    }</span>

    /**
     * This listener is invoked when device size is changed
     *
     * @param l listener
     */
    public void addSizeChangedListener(ActionListener l) {
<span class="pc bpc" id="L833" title="1 of 2 branches missed.">        if (sizeChangedListener == null) {</span>
<span class="fc" id="L834">            sizeChangedListener = new EventDispatcher();</span>
        }
<span class="fc" id="L836">        sizeChangedListener.addListener(l);</span>
<span class="fc" id="L837">    }</span>

    /**
     * Remove SizeChangedListener
     *
     * @param l the listener
     */
    public void removeSizeChangedListener(ActionListener l) {
<span class="nc bnc" id="L845" title="All 2 branches missed.">        if (sizeChangedListener == null) {</span>
<span class="nc" id="L846">            return;</span>
        }
<span class="nc" id="L848">        sizeChangedListener.removeListener(l);</span>
<span class="nc" id="L849">    }</span>

    /**
     * This method is only invoked when the underlying canvas for the form is hidden
     * this method isn't called for form based events and is generally usable for
     * suspend/resume based behavior
     */
    protected void hideNotify() {
<span class="nc" id="L857">        setVisible(false);</span>
<span class="nc" id="L858">    }</span>

    /**
     * This method is only invoked when the underlying canvas for the form is shown
     * this method isn't called for form based events and is generally usable for
     * suspend/resume based behavior
     */
    protected void showNotify() {
<span class="nc" id="L866">        setVisible(true);</span>
<span class="nc" id="L867">    }</span>

    /**
     * This method is only invoked when the underlying canvas for the form gets
     * a size changed event.
     * This method will trigger a relayout of the Form.
     * This method will get the callback only if this Form is the Current Form
     *
     * @param w the new width of the Form
     * @param h the new height of the Form
     */
    protected void sizeChanged(int w, int h) {
<span class="fc" id="L879">    }</span>

    /**
     * Causes the display safe area to be recalculated the next time the form list laid out.
     *
     * @see #getSafeArea()
     * @since 7.0
     */
    public void setSafeAreaChanged() {
<span class="nc" id="L888">        safeAreaDirty = true;</span>
<span class="nc" id="L889">    }</span>

    /**
     * This method is only invoked when the underlying canvas for the form gets
     * a size changed event.
     * This method will trigger a relayout of the Form.
     * This method will get the callback only if this Form is the Current Form
     *
     * @param w the new width of the Form
     * @param h the new height of the Form
     */
    void sizeChangedInternal(int w, int h) {
<span class="fc" id="L901">        int oldWidth = getWidth();</span>
<span class="fc" id="L902">        int oldHeight = getHeight();</span>
<span class="fc" id="L903">        sizeChanged(w, h);</span>
<span class="fc" id="L904">        Style formStyle = getStyle();</span>
<span class="fc" id="L905">        w = w - (formStyle.getHorizontalMargins());</span>
<span class="fc" id="L906">        h = h - (formStyle.getVerticalMargins());</span>
<span class="fc" id="L907">        setSize(new Dimension(w, h));</span>
<span class="fc" id="L908">        setShouldCalcPreferredSize(true);</span>
<span class="fc" id="L909">        safeAreaDirty = true;</span>
<span class="fc" id="L910">        doLayout();</span>
<span class="fc" id="L911">        focused = getFocused();</span>
<span class="fc bfc" id="L912" title="All 2 branches covered.">        if (focused != null) {</span>
<span class="fc" id="L913">            Component.setDisableSmoothScrolling(true);</span>
<span class="fc" id="L914">            scrollComponentToVisible(focused);</span>
<span class="fc" id="L915">            Component.setDisableSmoothScrolling(false);</span>
        }

<span class="pc bpc" id="L918" title="2 of 4 branches missed.">        if (oldWidth != w &amp;&amp; oldHeight != h) {</span>
<span class="fc bfc" id="L919" title="All 2 branches covered.">            if (orientationListener != null) {</span>
<span class="fc" id="L920">                orientationListener.fireActionEvent(new ActionEvent(this, ActionEvent.Type.OrientationChange));</span>
            }
<span class="fc" id="L922">            boolean a = getContentPane().onOrientationChange();</span>
<span class="pc bpc" id="L923" title="1 of 2 branches missed.">            if (getToolbar() != null) {</span>
<span class="nc bnc" id="L924" title="All 4 branches missed.">                if (getToolbar().onOrientationChange() || a) {</span>
<span class="nc" id="L925">                    forceRevalidate();</span>
                }
            } else {
<span class="pc bpc" id="L928" title="1 of 2 branches missed.">                if (a) {</span>
<span class="nc" id="L929">                    forceRevalidate();</span>
                }
            }
        }
<span class="fc bfc" id="L933" title="All 2 branches covered.">        if (sizeChangedListener != null) {</span>
<span class="fc" id="L934">            sizeChangedListener.fireActionEvent(new ActionEvent(this, ActionEvent.Type.SizeChange, w, h));</span>
        }

<span class="fc" id="L937">        repaint();</span>
<span class="fc" id="L938">        revalidate();</span>
<span class="fc" id="L939">    }</span>

    /**
     * Indicates if the section within the X/Y area is a &quot;drag region&quot; where
     * we expect people to drag and never actually &quot;press&quot; in which case we
     * can instantly start dragging making perceived performance faster. This
     * is invoked by the implementation code to optimize drag start behavior
     *
     * @param x x location for the touch
     * @param y y location for the touch
     * @return true if the touch is in a region specifically designated as a &quot;drag region&quot;
     * @deprecated this method was replaced by getDragRegionStatus
     */
    public boolean isDragRegion(int x, int y) {
<span class="nc bnc" id="L953" title="All 2 branches missed.">        if (getMenuBar().isDragRegion(x, y)) {</span>
<span class="nc" id="L954">            return true;</span>
        }
<span class="nc bnc" id="L956" title="All 4 branches missed.">        if (formLayeredPane != null &amp;&amp; formLayeredPane.isDragRegion(x, y)) {</span>
<span class="nc" id="L957">            return true;</span>
        }
<span class="nc" id="L959">        Container actual = getActualPane();</span>
<span class="nc" id="L960">        Component c = actual.getComponentAt(x, y);</span>
<span class="nc bnc" id="L961" title="All 4 branches missed.">        while (c != null &amp;&amp; c.isIgnorePointerEvents()) {</span>
<span class="nc" id="L962">            c = c.getParent();</span>
        }
<span class="nc bnc" id="L964" title="All 4 branches missed.">        return c != null &amp;&amp; c.isDragRegion(x, y);</span>
    }

    /**
     * Indicates if the section within the X/Y area is a &quot;drag region&quot; where
     * we expect people to drag or press in which case we
     * can instantly start dragging making perceived performance faster. This
     * is invoked by the implementation code to optimize drag start behavior
     *
     * @param x x location for the touch
     * @param y y location for the touch
     * @return one of the DRAG_REGION_* values
     */
    public int getDragRegionStatus(int x, int y) {
<span class="nc" id="L978">        int menuBarDrag = getMenuBar().getDragRegionStatus(x, y);</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">        if (menuBarDrag != DRAG_REGION_NOT_DRAGGABLE) {</span>
<span class="nc" id="L980">            return menuBarDrag;</span>
        }
<span class="nc bnc" id="L982" title="All 2 branches missed.">        int formLayeredPaneDrag = formLayeredPane != null ?</span>
<span class="nc" id="L983">                formLayeredPane.getDragRegionStatus(x, y) :</span>
                DRAG_REGION_NOT_DRAGGABLE;
<span class="nc bnc" id="L985" title="All 2 branches missed.">        if (formLayeredPaneDrag != DRAG_REGION_NOT_DRAGGABLE) {</span>
<span class="nc" id="L986">            return formLayeredPaneDrag;</span>
        }
<span class="nc" id="L988">        Container actual = getActualPane();</span>

        // no idea how this can happen
<span class="nc bnc" id="L991" title="All 2 branches missed.">        if (actual != null) {</span>
<span class="nc" id="L992">            Component c = actual.getComponentAt(x, y);</span>
<span class="nc bnc" id="L993" title="All 4 branches missed.">            while (c != null &amp;&amp; c.isIgnorePointerEvents()) {</span>
<span class="nc" id="L994">                c = c.getParent();</span>
            }
<span class="nc bnc" id="L996" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc" id="L997">                return c.getDragRegionStatus(x, y);</span>
            }
<span class="nc bnc" id="L999" title="All 2 branches missed.">            if (isScrollable()) {</span>
<span class="nc" id="L1000">                return DRAG_REGION_LIKELY_DRAG_Y;</span>
            }
        }
<span class="nc" id="L1003">        return DRAG_REGION_NOT_DRAGGABLE;</span>
    }

    /**
     * This method can be overriden by a component to draw on top of itself or its children
     * after the component or the children finished drawing in a similar way to the glass
     * pane but more refined per component
     *
     * @param g the graphics context
     */
    void paintGlassImpl(Graphics g) {
<span class="pc bpc" id="L1014" title="1 of 2 branches missed.">        if (getParent() != null) {</span>
<span class="nc" id="L1015">            super.paintGlassImpl(g);</span>
<span class="nc" id="L1016">            return;</span>
        }
<span class="fc bfc" id="L1018" title="All 2 branches covered.">        if (glassPane != null) {</span>
<span class="fc" id="L1019">            int tx = g.getTranslateX();</span>
<span class="fc" id="L1020">            int ty = g.getTranslateY();</span>
<span class="fc" id="L1021">            g.translate(-tx, -ty);</span>
<span class="fc" id="L1022">            glassPane.paint(g, getBounds());</span>
<span class="fc" id="L1023">            g.translate(tx, ty);</span>
        }
<span class="fc" id="L1025">        paintGlass(g);</span>
<span class="pc bpc" id="L1026" title="3 of 4 branches missed.">        if (dragged != null &amp;&amp; dragged.isDragAndDropInitialized()) {</span>
<span class="nc" id="L1027">            int[] c = g.getClip();</span>
<span class="nc" id="L1028">            g.setClip(0, 0, getWidth(), getHeight());</span>
<span class="nc" id="L1029">            dragged.drawDraggedImage(g);</span>
<span class="nc" id="L1030">            g.setClip(c);</span>
        }
<span class="fc" id="L1032">    }</span>

    /**
     * &lt;p&gt;Allows a developer that doesn't derive from the form to draw on top of the
     * form regardless of underlying changes or animations. This is useful for
     * watermarks or special effects (such as tinting) it is also useful for generic
     * drawing of validation errors etc... A glass pane is generally
     * transparent or translucent and allows the the UI below to be seen.&lt;/p&gt;
     * &lt;p&gt;
     * The example shows a glasspane running on top of a field to show a validation hint,
     * notice that for real world usage you should probably look into {@link com.codename1.ui.validation.Validator}
     * &lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/codenameone/f5b83373088600b19610.js&quot;&gt;&lt;/script&gt;
     * &lt;img src=&quot;https://www.codenameone.com/img/developer-guide/graphics-glasspane.png&quot; alt=&quot;Sample of glasspane&quot; /&gt;
     *
     * @return the instance of the glass pane for this form
     * @see com.codename1.ui.painter.PainterChain#installGlassPane(Form, com.codename1.ui.Painter)
     */
    public Painter getGlassPane() {
<span class="fc" id="L1051">        return glassPane;</span>
    }

    /**
     * &lt;p&gt;Allows a developer that doesn't derive from the form to draw on top of the
     * form regardless of underlying changes or animations. This is useful for
     * watermarks or special effects (such as tinting) it is also useful for generic
     * drawing of validation errors etc... A glass pane is generally
     * transparent or translucent and allows the the UI below to be seen.&lt;/p&gt;
     * &lt;p&gt;
     * The example shows a glasspane running on top of a field to show a validation hint,
     * notice that for real world usage you should probably look into {@link com.codename1.ui.validation.Validator}
     * &lt;/p&gt;
     * &lt;script src=&quot;https://gist.github.com/codenameone/f5b83373088600b19610.js&quot;&gt;&lt;/script&gt;
     * &lt;img src=&quot;https://www.codenameone.com/img/developer-guide/graphics-glasspane.png&quot; alt=&quot;Sample of glasspane&quot; /&gt;
     *
     * @param glassPane a new glass pane to install. It is generally recommended to
     *                  use a painter chain if more than one painter is required.
     */
    public void setGlassPane(Painter glassPane) {
<span class="fc" id="L1071">        this.glassPane = glassPane;</span>
<span class="fc" id="L1072">        repaint();</span>
<span class="fc" id="L1073">    }</span>

    /**
     * Allows modifying the title attributes beyond style (e.g. setting icon/alignment etc.)
     *
     * @return the component representing the title for the form
     */
    public Label getTitleComponent() {
<span class="fc" id="L1081">        return title;</span>
    }

    /**
     * Allows replacing the title with a different title component, thus allowing
     * developers to create more elaborate title objects.
     *
     * @param title new title component
     */
    public void setTitleComponent(Label title) {
<span class="nc" id="L1091">        titleArea.replace(this.title, title, false);</span>
<span class="nc" id="L1092">        this.title = title;</span>
<span class="nc" id="L1093">    }</span>

    /**
     * Allows replacing the title with a different title component, thus allowing
     * developers to create more elaborate title objects. This version of the
     * method allows special effects for title replacement such as transitions
     * for title entering
     *
     * @param title new title component
     * @param t     transition for title replacement
     */
    public void setTitleComponent(Label title, Transition t) {
<span class="fc" id="L1105">        titleArea.replace(this.title, title, t);</span>
<span class="fc" id="L1106">        this.title = title;</span>
<span class="fc" id="L1107">    }</span>

    /**
     * Add a key listener to the given keycode for a callback when the key is released
     *
     * @param keyCode  code on which to send the event
     * @param listener listener to invoke when the key code released.
     */
    public void addKeyListener(int keyCode, ActionListener listener) {
<span class="pc bpc" id="L1116" title="1 of 2 branches missed.">        if (keyListeners == null) {</span>
<span class="fc" id="L1117">            keyListeners = new HashMap&lt;Integer, ArrayList&lt;ActionListener&gt;&gt;();</span>
        }
<span class="fc" id="L1119">        addKeyListener(keyCode, listener, keyListeners);</span>
<span class="fc" id="L1120">    }</span>

    /**
     * Removes a key listener from the given keycode
     *
     * @param keyCode  code on which the event is sent
     * @param listener listener instance to remove
     */
    public void removeKeyListener(int keyCode, ActionListener listener) {
<span class="pc bpc" id="L1129" title="1 of 2 branches missed.">        if (keyListeners == null) {</span>
<span class="nc" id="L1130">            return;</span>
        }
<span class="fc" id="L1132">        removeKeyListener(keyCode, listener, keyListeners);</span>
<span class="fc" id="L1133">    }</span>

    /**
     * Removes a game key listener from the given game keycode
     *
     * @param keyCode  code on which the event is sent
     * @param listener listener instance to remove
     */
    public void removeGameKeyListener(int keyCode, ActionListener listener) {
<span class="nc bnc" id="L1142" title="All 2 branches missed.">        if (gameKeyListeners == null) {</span>
<span class="nc" id="L1143">            return;</span>
        }
<span class="nc" id="L1145">        removeKeyListener(keyCode, listener, gameKeyListeners);</span>
<span class="nc" id="L1146">    }</span>

    private void addKeyListener(int keyCode, ActionListener listener, HashMap&lt;Integer, ArrayList&lt;ActionListener&gt;&gt; keyListeners) {
<span class="pc bpc" id="L1149" title="1 of 2 branches missed.">        if (keyListeners == null) {</span>
<span class="nc" id="L1150">            keyListeners = new HashMap&lt;Integer, ArrayList&lt;ActionListener&gt;&gt;();</span>
        }
<span class="fc" id="L1152">        Integer code = Integer.valueOf(keyCode);</span>
<span class="fc" id="L1153">        ArrayList&lt;ActionListener&gt; vec = keyListeners.get(code);</span>
<span class="pc bpc" id="L1154" title="1 of 2 branches missed.">        if (vec == null) {</span>
<span class="fc" id="L1155">            vec = new ArrayList&lt;ActionListener&gt;();</span>
<span class="fc" id="L1156">            vec.add(listener);</span>
<span class="fc" id="L1157">            keyListeners.put(code, vec);</span>
<span class="fc" id="L1158">            return;</span>
        }
<span class="nc bnc" id="L1160" title="All 2 branches missed.">        if (!vec.contains(listener)) {</span>
<span class="nc" id="L1161">            vec.add(listener);</span>
        }
<span class="nc" id="L1163">    }</span>

    private void removeKeyListener(int keyCode, ActionListener listener, HashMap&lt;Integer, ArrayList&lt;ActionListener&gt;&gt; keyListeners) {
<span class="pc bpc" id="L1166" title="1 of 2 branches missed.">        if (keyListeners == null) {</span>
<span class="nc" id="L1167">            return;</span>
        }
<span class="fc" id="L1169">        Integer code = Integer.valueOf(keyCode);</span>
<span class="fc" id="L1170">        ArrayList&lt;ActionListener&gt; vec = keyListeners.get(code);</span>
<span class="pc bpc" id="L1171" title="1 of 2 branches missed.">        if (vec == null) {</span>
<span class="nc" id="L1172">            return;</span>
        }
<span class="fc" id="L1174">        vec.remove(listener);</span>
<span class="pc bpc" id="L1175" title="1 of 2 branches missed.">        if (vec.size() == 0) {</span>
<span class="fc" id="L1176">            keyListeners.remove(code);</span>
        }
<span class="fc" id="L1178">    }</span>

    /**
     * Add a game key listener to the given gamekey for a callback when the
     * key is released
     *
     * @param keyCode  code on which to send the event
     * @param listener listener to invoke when the key code released.
     */
    public void addGameKeyListener(int keyCode, ActionListener listener) {
<span class="nc bnc" id="L1188" title="All 2 branches missed.">        if (gameKeyListeners == null) {</span>
<span class="nc" id="L1189">            gameKeyListeners = new HashMap&lt;Integer, ArrayList&lt;ActionListener&gt;&gt;();</span>
        }
<span class="nc" id="L1191">        addKeyListener(keyCode, listener, gameKeyListeners);</span>
<span class="nc" id="L1192">    }</span>

    /**
     * Returns the number of buttons on the menu bar for use with getSoftButton()
     *
     * @return the number of softbuttons
     */
    public int getSoftButtonCount() {
<span class="fc" id="L1200">        return menuBar.getSoftButtons().length;</span>
    }

    /**
     * Returns the button representing the softbutton, this allows modifying softbutton
     * attributes and behavior programmatically rather than by using the command API.
     * Notice that this API behavior is fragile since the button mapped to a particular
     * offset might change based on the command API
     *
     * @param offset the offest of the softbutton
     * @return a button that can be manipulated
     */
    public Button getSoftButton(int offset) {
<span class="fc" id="L1213">        return menuBar.getSoftButtons()[offset];</span>
    }

    /**
     * Returns the style of the menu
     *
     * @return the style of the menu
     */
    public Style getMenuStyle() {
<span class="nc" id="L1222">        return menuBar.getMenuStyle();</span>
    }

    /**
     * Returns the style of the title
     *
     * @return the style of the title
     */
    public Style getTitleStyle() {
<span class="nc" id="L1231">        return title.getStyle();</span>
    }

    /**
     * Sets the style of the title programmatically
     *
     * @param s new style
     * @deprecated this method doesn't take into consideration multiple styles
     */
    public void setTitleStyle(Style s) {
<span class="nc" id="L1241">        title.setUnselectedStyle(s);</span>
<span class="nc" id="L1242">    }</span>

    /**
     * Allows the display to skip the menu dialog if that is the current form
     */
    Form getPreviousForm() {
<span class="fc" id="L1248">        return previousForm;</span>
    }

    void setPreviousForm(Form previousForm) {
<span class="nc" id="L1252">        this.previousForm = previousForm;</span>
<span class="nc" id="L1253">    }</span>

    /**
     * {@inheritDoc}
     */
    protected void initLaf(UIManager uim) {
<span class="fc" id="L1259">        super.initLaf(uim);</span>
<span class="fc" id="L1260">        LookAndFeel laf = uim.getLookAndFeel();</span>
<span class="fc" id="L1261">        transitionOutAnimator = laf.getDefaultFormTransitionOut();</span>
<span class="fc" id="L1262">        transitionInAnimator = laf.getDefaultFormTransitionIn();</span>
<span class="fc" id="L1263">        focusScrolling = laf.isFocusScrolling();</span>
<span class="fc bfc" id="L1264" title="All 4 branches covered.">        if (menuBar == null || !menuBar.getClass().equals(laf.getMenuBarClass())) {</span>
            try {
<span class="fc" id="L1266">                menuBar = (MenuBar) laf.getMenuBarClass().newInstance();</span>
<span class="nc" id="L1267">            } catch (Exception ex) {</span>
<span class="nc" id="L1268">                Log.e(ex);</span>
<span class="nc" id="L1269">                menuBar = new MenuBar();</span>
<span class="fc" id="L1270">            }</span>
<span class="fc" id="L1271">            menuBar.initMenuBar(this);</span>
        }

<span class="fc" id="L1274">        tintColor = laf.getDefaultFormTintColor();</span>
<span class="fc" id="L1275">        tactileTouchDuration = laf.getTactileTouchDuration();</span>
<span class="fc" id="L1276">    }</span>

    /**
     * Gets the current dragged Component
     */
    Component getDraggedComponent() {
<span class="fc" id="L1282">        return dragged;</span>
    }

    /**
     * Sets the current dragged Component
     */
    void setDraggedComponent(Component dragged) {
<span class="fc" id="L1289">        this.dragged = LeadUtil.leadParentImpl(dragged);</span>
<span class="fc" id="L1290">    }</span>

    /**
     * Returns true if the given dest component is in the column of the source component
     */
    private boolean isInSameColumn(Component source, Component dest) {
        // workaround for NPE
<span class="nc bnc" id="L1297" title="All 4 branches missed.">        if (source == null || dest == null) {</span>
<span class="nc" id="L1298">            return false;</span>
        }
<span class="nc" id="L1300">        return Rectangle.intersects(source.getAbsoluteX(), 0,</span>
<span class="nc" id="L1301">                source.getWidth(), Integer.MAX_VALUE, dest.getAbsoluteX(), dest.getAbsoluteY(),</span>
<span class="nc" id="L1302">                dest.getWidth(), dest.getHeight());</span>
    }

    /**
     * Returns true if the given dest component is in the row of the source component
     */
    private boolean isInSameRow(Component source, Component dest) {
<span class="nc" id="L1309">        return Rectangle.intersects(0, source.getAbsoluteY(),</span>
<span class="nc" id="L1310">                Integer.MAX_VALUE, source.getHeight(), dest.getAbsoluteX(), dest.getAbsoluteY(),</span>
<span class="nc" id="L1311">                dest.getWidth(), dest.getHeight());</span>
    }

    /**
     * Default command is invoked when a user presses fire, this functionality works
     * well in some situations but might collide with elements such as navigation
     * and combo boxes. Use with caution.
     *
     * @return the command to treat as default
     */
    public Command getDefaultCommand() {
<span class="fc" id="L1322">        return menuBar.getDefaultCommand();</span>
    }

    /**
     * Default command is invoked when a user presses fire, this functionality works
     * well in some situations but might collide with elements such as navigation
     * and combo boxes. Use with caution.
     *
     * @param defaultCommand the command to treat as default
     */
    public void setDefaultCommand(Command defaultCommand) {
<span class="nc" id="L1333">        menuBar.setDefaultCommand(defaultCommand);</span>
<span class="nc" id="L1334">    }</span>

    /**
     * Indicates the command that is defined as the clear command in this form.
     * A clear command can be used both to map to a &quot;clear&quot; hardware button
     * if such a button exists.
     *
     * @return the command to treat as the clear Command
     */
    public Command getClearCommand() {
<span class="nc" id="L1344">        return menuBar.getClearCommand();</span>
    }

    /**
     * Indicates the command that is defined as the clear command in this form.
     * A clear command can be used both to map to a &quot;clear&quot; hardware button
     * if such a button exists.
     *
     * @param clearCommand the command to treat as the clear Command
     */
    public void setClearCommand(Command clearCommand) {
<span class="nc" id="L1355">        menuBar.setClearCommand(clearCommand);</span>
<span class="nc" id="L1356">    }</span>

    /**
     * Shorthand for {@link #setBackCommand(com.codename1.ui.Command)} that
     * dynamically creates the command using {@link com.codename1.ui.Command#create(java.lang.String, com.codename1.ui.Image, com.codename1.ui.events.ActionListener)}.
     *
     * @param name the name/title of the command
     * @param icon the icon for the command
     * @param ev   the even handler
     * @return a newly created Command instance
     */
    public Command setBackCommand(String name, Image icon, ActionListener ev) {
<span class="nc" id="L1368">        Command cmd = Command.create(name, icon, ev);</span>
<span class="nc" id="L1369">        menuBar.setBackCommand(cmd);</span>
<span class="nc" id="L1370">        return cmd;</span>
    }

    /**
     * Indicates the command that is defined as the back command out of this form.
     * A back command can be used both to map to a hardware button (e.g. on the Sony Ericsson devices)
     * and by elements such as transitions etc. to change the behavior based on
     * direction (e.g. slide to the left to enter screen and slide to the right to exit with back).
     *
     * @return the command to treat as the back Command
     */
    public Command getBackCommand() {
<span class="fc" id="L1382">        return menuBar.getBackCommand();</span>
    }

    /**
     * Indicates the command that is defined as the back command out of this form.
     * A back command can be used both to map to a hardware button (e.g. on the Sony Ericsson devices)
     * and by elements such as transitions etc. to change the behavior based on
     * direction (e.g. slide to the left to enter screen and slide to the right to exit with back).
     *
     * @param backCommand the command to treat as the back Command
     */
    public void setBackCommand(Command backCommand) {
<span class="fc" id="L1394">        menuBar.setBackCommand(backCommand);</span>
<span class="fc" id="L1395">    }</span>

    /**
     * This method returns the Content pane instance
     *
     * @return a content pane instance
     */
    public Container getContentPane() {
<span class="fc" id="L1403">        return contentPane;</span>
    }

    /**
     * This method returns the layered pane of the Form, the layered pane is laid
     * on top of the content pane and is created lazily upon calling this method the layer
     * will be created. This is equivalent to getLayeredPane(null, false).
     *
     * @return the LayeredPane
     */
    public Container getLayeredPane() {
<span class="fc" id="L1414">        return getLayeredPane(null, false);</span>
    }

    /**
     * Returns the layered pane for the class and if one doesn't exist a new one is created dynamically and returned
     *
     * @param c   the class with which this layered pane is associated, null for the global layered pane which
     *            is always on the bottom
     * @param top if created this indicates whether the layered pane should be added on top or bottom
     * @return the layered pane instance
     */
    public Container getLayeredPane(Class c, boolean top) {
<span class="fc" id="L1426">        Container layeredPaneImpl = getLayeredPaneImpl();</span>
<span class="fc bfc" id="L1427" title="All 2 branches covered.">        if (c == null) {</span>
            // NOTE: We need to use getChildrenAsList(true) rather than simply iterating
            // over layeredPaneImpl because the latter won't find components while an animation
            // is in progress.... We could end up adding a whole bunch of layered panes
            // by accident
<span class="pc bpc" id="L1432" title="1 of 2 branches missed.">            for (Component cmp : layeredPaneImpl.getChildrenAsList(true)) {</span>
<span class="pc bpc" id="L1433" title="1 of 2 branches missed.">                if (cmp.getClientProperty(&quot;cn1$_cls&quot;) == null) {</span>
<span class="fc" id="L1434">                    return (Container) cmp;</span>
                }
<span class="nc" id="L1436">            }</span>
        }
<span class="fc" id="L1438">        String n = c.getName();</span>
        // NOTE: We need to use getChildrenAsList(true) rather than simply iterating
        // over layeredPaneImpl because the latter won't find components while an animation
        // is in progress.... We could end up adding a whole bunch of layered panes
        // by accident
<span class="fc" id="L1443">        java.util.List&lt;Component&gt; children = layeredPaneImpl.getChildrenAsList(true);</span>
<span class="fc bfc" id="L1444" title="All 2 branches covered.">        for (Component cmp : children) {</span>
<span class="fc bfc" id="L1445" title="All 2 branches covered.">            if (n.equals(cmp.getClientProperty(&quot;cn1$_cls&quot;))) {</span>
<span class="fc" id="L1446">                return (Container) cmp;</span>
            }
<span class="fc" id="L1448">        }</span>

<span class="fc" id="L1450">        Container cnt = new Container();</span>
<span class="fc" id="L1451">        int zIndex = 0;</span>
<span class="fc" id="L1452">        int componentCount = children.size();</span>
<span class="pc bpc" id="L1453" title="1 of 2 branches missed.">        if (top) {</span>
<span class="pc bpc" id="L1454" title="1 of 2 branches missed.">            if (componentCount &gt; 0) {</span>
<span class="fc" id="L1455">                Integer z = (Integer) children.get(componentCount - 1).getClientProperty(Z_INDEX_PROP);</span>
<span class="pc bpc" id="L1456" title="1 of 2 branches missed.">                if (z != null) {</span>
<span class="nc" id="L1457">                    zIndex = z.intValue();</span>
                }
            }
<span class="fc" id="L1460">            layeredPaneImpl.add(cnt);</span>
        } else {
<span class="nc bnc" id="L1462" title="All 2 branches missed.">            if (componentCount &gt; 0) {</span>
<span class="nc bnc" id="L1463" title="All 2 branches missed.">                if (componentCount &gt; 0) {</span>
<span class="nc" id="L1464">                    Integer z = (Integer) children.get(0).getClientProperty(Z_INDEX_PROP);</span>
<span class="nc bnc" id="L1465" title="All 2 branches missed.">                    if (z != null) {</span>
<span class="nc" id="L1466">                        zIndex = z.intValue();</span>
                    }
                }
            }
<span class="nc" id="L1470">            layeredPaneImpl.addComponent(0, cnt);</span>
        }
<span class="fc" id="L1472">        cnt.putClientProperty(&quot;cn1$_cls&quot;, n);</span>
<span class="fc" id="L1473">        cnt.putClientProperty(Z_INDEX_PROP, zIndex);</span>
<span class="fc" id="L1474">        return cnt;</span>
    }

    /**
     * Returns the layered pane for the class and if one doesn't exist a new one is created dynamically and returned
     *
     * @param c      the class with which this layered pane is associated, null for the global layered pane which
     *               is always on the bottom
     * @param zIndex if created this indicates the zIndex at which the pane is placed.  Higher z values in front of lower z values.
     * @return the layered pane instance
     */
    public Container getLayeredPane(Class c, int zIndex) {
<span class="nc" id="L1486">        Container layeredPaneImpl = getLayeredPaneImpl();</span>

<span class="nc bnc" id="L1488" title="All 2 branches missed.">        if (c == null) {</span>
            // NOTE: We need to use getChildrenAsList(true) rather than simply iterating
            // over layeredPaneImpl because the latter won't find components while an animation
            // is in progress.... We could end up adding a whole bunch of layered panes
            // by accident
<span class="nc bnc" id="L1493" title="All 2 branches missed.">            for (Component cmp : layeredPaneImpl.getChildrenAsList(true)) {</span>
<span class="nc bnc" id="L1494" title="All 2 branches missed.">                if (cmp.getClientProperty(&quot;cn1$_cls&quot;) == null) {</span>
<span class="nc" id="L1495">                    return (Container) cmp;</span>
                }
<span class="nc" id="L1497">            }</span>
        }
<span class="nc" id="L1499">        String n = c.getName();</span>
        // NOTE: We need to use getChildrenAsList(true) rather than simply iterating
        // over layeredPaneImpl because the latter won't find components while an animation
        // is in progress.... We could end up adding a whole bunch of layered panes
        // by accident
<span class="nc" id="L1504">        java.util.List&lt;Component&gt; children = layeredPaneImpl.getChildrenAsList(true);</span>
<span class="nc bnc" id="L1505" title="All 2 branches missed.">        for (Component cmp : children) {</span>
<span class="nc bnc" id="L1506" title="All 2 branches missed.">            if (n.equals(cmp.getClientProperty(&quot;cn1$_cls&quot;))) {</span>
<span class="nc" id="L1507">                return (Container) cmp;</span>
            }
<span class="nc" id="L1509">        }</span>

<span class="nc" id="L1511">        Container cnt = new Container();</span>
<span class="nc" id="L1512">        cnt.putClientProperty(Z_INDEX_PROP, zIndex);</span>
<span class="nc" id="L1513">        int len = children.size();</span>
<span class="nc" id="L1514">        int insertIndex = -1;</span>

<span class="nc bnc" id="L1516" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L1517">            Component cmp = children.get(i);</span>
<span class="nc" id="L1518">            Integer cmpZIndex = (Integer) cmp.getClientProperty(Z_INDEX_PROP);</span>
<span class="nc bnc" id="L1519" title="All 2 branches missed.">            int cmpZ = cmpZIndex == null ? 0 : cmpZIndex.intValue();</span>
<span class="nc bnc" id="L1520" title="All 2 branches missed.">            if (cmpZ &gt;= zIndex) {</span>
<span class="nc" id="L1521">                insertIndex = i;</span>
<span class="nc" id="L1522">                break;</span>
            }
        }

<span class="nc bnc" id="L1526" title="All 2 branches missed.">        if (insertIndex == -1) {</span>
<span class="nc" id="L1527">            layeredPaneImpl.add(cnt);</span>
        } else {
<span class="nc" id="L1529">            layeredPaneImpl.addComponent(insertIndex, cnt);</span>
        }
<span class="nc" id="L1531">        cnt.putClientProperty(&quot;cn1$_cls&quot;, n);</span>
<span class="nc" id="L1532">        return cnt;</span>
    }

    /**
     * Returns the layered pane for the class and if one doesn't exist a new one is created
     * dynamically and returned. This version of the method returns a layered pane on the whole
     * form
     *
     * @param c   the class with which this layered pane is associated, null for the global layered pane which
     *            is always on the bottom
     * @param top if created this indicates whether the layered pane should be added on top or bottom
     * @return the layered pane instance
     */
    public Container getFormLayeredPane(Class c, boolean top) {
<span class="fc bfc" id="L1546" title="All 2 branches covered.">        if (formLayeredPane == null) {</span>
<span class="fc" id="L1547">            formLayeredPane = new Container(new LayeredLayout()) {</span>
                @Override
                protected void paintBackground(Graphics g) {
<span class="pc bpc" id="L1550" title="1 of 2 branches missed.">                    if (getComponentCount() &gt; 0) {</span>
<span class="pc bpc" id="L1551" title="1 of 2 branches missed.">                        if (isVisible()) {</span>
<span class="fc" id="L1552">                            setVisible(false);</span>
<span class="fc" id="L1553">                            Form.this.paint(g);</span>
<span class="fc" id="L1554">                            setVisible(true);</span>
                        }
                    }
<span class="fc" id="L1557">                }</span>

                @Override
                public void paintBackgrounds(Graphics g) {
<span class="nc" id="L1561">                }</span>
            };
<span class="fc" id="L1563">            formLayeredPane.setName(&quot;FormLayeredPane&quot;);</span>
<span class="fc" id="L1564">            addComponentToForm(BorderLayout.OVERLAY, formLayeredPane);</span>
<span class="fc" id="L1565">            formLayeredPane.setWidth(getWidth());</span>
<span class="fc" id="L1566">            formLayeredPane.setHeight(getHeight());</span>
<span class="fc" id="L1567">            formLayeredPane.setShouldLayout(false);</span>
        }
<span class="pc bpc" id="L1569" title="1 of 2 branches missed.">        if (c == null) {</span>
            // NOTE: We need to use getChildrenAsList(true) rather than simply iterating
            // over layeredPaneImpl because the latter won't find components while an animation
            // is in progress.... We could end up adding a whole bunch of layered panes
            // by accident
<span class="nc bnc" id="L1574" title="All 2 branches missed.">            for (Component cmp : formLayeredPane.getChildrenAsList(true)) {</span>
<span class="nc bnc" id="L1575" title="All 2 branches missed.">                if (cmp.getClientProperty(&quot;cn1$_cls&quot;) == null) {</span>
<span class="nc" id="L1576">                    return (Container) cmp;</span>
                }
<span class="nc" id="L1578">            }</span>

<span class="nc" id="L1580">            Container cnt = new Container();</span>
<span class="nc" id="L1581">            cnt.setWidth(getWidth());</span>
<span class="nc" id="L1582">            cnt.setHeight(getHeight());</span>
<span class="nc" id="L1583">            cnt.setShouldLayout(false);</span>
<span class="nc" id="L1584">            cnt.setName(&quot;FormLayer: &quot; + c.getName());</span>
<span class="nc" id="L1585">            formLayeredPane.add(cnt);</span>
<span class="nc" id="L1586">            return cnt;</span>
        }
<span class="fc" id="L1588">        String n = c.getName();</span>
        // NOTE: We need to use getChildrenAsList(true) rather than simply iterating
        // over layeredPaneImpl because the latter won't find components while an animation
        // is in progress.... We could end up adding a whole bunch of layered panes
        // by accident
<span class="fc bfc" id="L1593" title="All 2 branches covered.">        for (Component cmp : formLayeredPane.getChildrenAsList(true)) {</span>
<span class="fc bfc" id="L1594" title="All 2 branches covered.">            if (n.equals(cmp.getClientProperty(&quot;cn1$_cls&quot;))) {</span>
<span class="fc" id="L1595">                return (Container) cmp;</span>
            }
<span class="fc" id="L1597">        }</span>
<span class="fc" id="L1598">        Container cnt = new Container();</span>
<span class="fc" id="L1599">        cnt.setWidth(getWidth());</span>
<span class="fc" id="L1600">        cnt.setHeight(getHeight());</span>
<span class="fc" id="L1601">        cnt.setShouldLayout(false);</span>
<span class="fc" id="L1602">        cnt.setName(&quot;FormLayer: &quot; + c.getName());</span>
<span class="fc bfc" id="L1603" title="All 2 branches covered.">        if (top) {</span>
<span class="fc" id="L1604">            formLayeredPane.add(cnt);</span>
        } else {
<span class="fc" id="L1606">            formLayeredPane.addComponent(0, cnt);</span>
        }
<span class="fc" id="L1608">        cnt.putClientProperty(&quot;cn1$_cls&quot;, n);</span>
<span class="fc" id="L1609">        return cnt;</span>
    }

    /**
     * Gets the layered pane of the container without trying to create it.  If {@link #getLayeredPane() }
     * hasn't been called yet for the form, then the layered pane will be {@literal null}.
     *
     * @return The layered pane if it's been created - or null.
     */
    protected Container getLayeredPaneIfExists() {
<span class="nc" id="L1619">        return layeredPane;</span>
    }

    /**
     * Gets the form layered pane of the container without trying to create it.  If {@link #getFormLayeredPane(java.lang.Class, boolean)  }
     * hasn't been called yet for the form, then the layered pane will be {@literal null}.
     *
     * @return The layered pane if it's been created - or null.
     */
    protected Container getFormLayeredPaneIfExists() {
<span class="fc" id="L1629">        return formLayeredPane;</span>
    }

    /**
     * This method returns the layered pane of the Form, the layered pane is laid
     * on top of the content pane and is created lazily upon calling this method the layer
     * will be created.
     *
     * @return the LayeredPane
     */
    private Container getLayeredPaneImpl() {
<span class="fc bfc" id="L1640" title="All 2 branches covered.">        if (layeredPane == null) {</span>
<span class="fc" id="L1641">            layeredPane = new Container(new LayeredLayout());</span>
<span class="fc" id="L1642">            Container parent = contentPane.wrapInLayeredPane();</span>
            // adds the global layered pane
<span class="fc" id="L1644">            layeredPane.add(new Container());</span>
<span class="fc" id="L1645">            parent.addComponent(layeredPane);</span>
<span class="fc" id="L1646">            revalidateWithAnimationSafety();</span>
        }
<span class="fc" id="L1648">        return layeredPane;</span>
    }

    Container getActualPane() {
<span class="fc bfc" id="L1652" title="All 2 branches covered.">        if (layeredPane != null) {</span>
<span class="fc" id="L1653">            return layeredPane.getParent();</span>
        } else {
<span class="fc" id="L1655">            return contentPane;</span>
        }
    }

    /**
     * Gets the actual pane, but first checks to see if the provided overlay
     * responds to events at the provided absolute x and y coordinates.
     *
     * @param overlay
     * @param x
     * @param y
     * @return If {@literal overlay} responds to events at {@literal (x,y)} then
     * it returns {@literal overlay}, otherwise it returns the result of {@link #getActualPane() }
     */
    private Container getActualPane(Container overlay, int x, int y) {
<span class="pc bpc" id="L1670" title="3 of 4 branches missed.">        if (overlay != null &amp;&amp; overlay.getResponderAt(x, y) != null) {</span>
<span class="nc" id="L1671">            return overlay;</span>
        }
        // the first part fixes https://github.com/codenameone/CodenameOne/issues/2560
        // the second part fixes a regression caused by this when we place an overlay
        // on top of the toolbar. This happens in the Uber clone app when trying to
        // go back from the &quot;Where To&quot; menu
<span class="pc bpc" id="L1677" title="4 of 6 branches missed.">        if (menuBar != null &amp;&amp; menuBar.contains(x, y) &amp;&amp; !getToolbar().contains(x, y)) {</span>
<span class="nc" id="L1678">            return menuBar;</span>
        }
<span class="fc" id="L1680">        return getActualPane();</span>
    }

    /**
     * Removes all Components from the Content Pane
     */
    public void removeAll() {
<span class="fc" id="L1687">        contentPane.removeAll();</span>
<span class="fc" id="L1688">    }</span>

    /**
     * Sets the background image to show behind the form
     *
     * @param bgImage the background image
     * @deprecated Use the style directly
     */
    public void setBgImage(Image bgImage) {
<span class="nc" id="L1697">        getStyle().setBgImage(bgImage);</span>
<span class="nc" id="L1698">    }</span>

    void updateIcsIconCommandBehavior() {
<span class="fc" id="L1701">        int b = Display.getInstance().getCommandBehavior();</span>
<span class="pc bpc" id="L1702" title="1 of 2 branches missed.">        if (b == Display.COMMAND_BEHAVIOR_ICS) {</span>
<span class="nc bnc" id="L1703" title="All 2 branches missed.">            if (getTitleComponent().getIcon() == null) {</span>
<span class="nc" id="L1704">                Image i = Display.impl.getApplicationIconImage();</span>
<span class="nc bnc" id="L1705" title="All 2 branches missed.">                if (i != null) {</span>
<span class="nc" id="L1706">                    int h = getTitleComponent().getStyle().getFont().getHeight();</span>
<span class="nc" id="L1707">                    i = i.scaled(h, h);</span>
<span class="nc" id="L1708">                    getTitleComponent().setIcon(i);</span>
                }
            }
        }
<span class="fc" id="L1712">    }</span>

    /**
     * Stops any active editing on the form.  Closes keyboard if it is opened.
     *
     * @param onFinish Callback to run on finish.
     */
    @Override
    public void stopEditing(Runnable onFinish) {
<span class="fc" id="L1721">        Display.getInstance().stopEditing(this, onFinish);</span>

<span class="fc" id="L1723">    }</span>

    @Override
    public boolean isEditing() {
<span class="nc" id="L1727">        return Display.getInstance().isTextEditing(this);</span>
    }

    /**
     * Returns the Form title text
     *
     * @return returns the form title
     */
    public String getTitle() {
<span class="fc bfc" id="L1736" title="All 2 branches covered.">        if (toolbar != null) {</span>
<span class="fc" id="L1737">            Component cmp = toolbar.getTitleComponent();</span>
<span class="pc bpc" id="L1738" title="1 of 2 branches missed.">            if (cmp instanceof Label) {</span>
<span class="nc" id="L1739">                return ((Label) cmp).getText();</span>
            }
<span class="fc" id="L1741">            return null;</span>
        }
<span class="fc" id="L1743">        return title.getText();</span>
    }

    /**
     * Sets the Form title to the given text
     *
     * @param title the form title
     */
    public void setTitle(String title) {
<span class="fc bfc" id="L1752" title="All 2 branches covered.">        if (toolbar != null) {</span>
<span class="fc" id="L1753">            toolbar.setTitle(title);</span>
<span class="fc" id="L1754">            return;</span>
        }

<span class="fc" id="L1757">        this.title.setText(title);</span>

<span class="pc bpc" id="L1759" title="1 of 2 branches missed.">        if (!Display.getInstance().isNativeTitle()) {</span>
<span class="fc" id="L1760">            updateIcsIconCommandBehavior();</span>
<span class="pc bpc" id="L1761" title="1 of 4 branches missed.">            if (isInitialized() &amp;&amp; this.title.isTickerEnabled()) {</span>
<span class="fc" id="L1762">                int b = Display.getInstance().getCommandBehavior();</span>
<span class="pc bpc" id="L1763" title="4 of 8 branches missed.">                if (b == Display.COMMAND_BEHAVIOR_BUTTON_BAR_TITLE_BACK || b == Display.COMMAND_BEHAVIOR_BUTTON_BAR_TITLE_RIGHT</span>
                        || b == Display.COMMAND_BEHAVIOR_ICS || b == Display.COMMAND_BEHAVIOR_SIDE_NAVIGATION) {
<span class="nc" id="L1765">                    titleArea.revalidateLater();</span>
                }
<span class="pc bpc" id="L1767" title="1 of 2 branches missed.">                if (this.title.shouldTickerStart()) {</span>
<span class="nc" id="L1768">                    this.title.startTicker(getUIManager().getLookAndFeel().getTickerSpeed(), true);</span>
                } else {
<span class="pc bpc" id="L1770" title="1 of 2 branches missed.">                    if (this.title.isTickerRunning()) {</span>
<span class="nc" id="L1771">                        this.title.stopTicker();</span>
                    }
                }
<span class="fc" id="L1774">            }</span>
        } else {
<span class="nc bnc" id="L1776" title="All 2 branches missed.">            if (super.contains(titleArea)) {</span>
<span class="nc" id="L1777">                removeComponentFromForm(titleArea);</span>
            }
            //if the Form is already displayed refresh the title
<span class="nc bnc" id="L1780" title="All 2 branches missed.">            if (Display.getInstance().getCurrent() == this) {</span>
<span class="nc" id="L1781">                Display.getInstance().refreshNativeTitle();</span>
            }
        }
<span class="fc" id="L1784">    }</span>

    /**
     * Adds Component to the Form's Content Pane
     *
     * @param cmp the added param
     */
    public void addComponent(Component cmp) {
<span class="fc" id="L1792">        contentPane.addComponent(cmp);</span>
<span class="fc" id="L1793">    }</span>

    /**
     * {@inheritDoc}
     */
    public void addComponent(Object constraints, Component cmp) {
<span class="fc" id="L1799">        contentPane.addComponent(constraints, cmp);</span>
<span class="fc" id="L1800">    }</span>

    /**
     * {@inheritDoc}
     */
    public void addComponent(int index, Object constraints, Component cmp) {
<span class="nc" id="L1806">        contentPane.addComponent(index, constraints, cmp);</span>
<span class="nc" id="L1807">    }</span>

    /**
     * Adds Component to the Form's Content Pane
     *
     * @param cmp the added param
     */
    public void addComponent(int index, Component cmp) {
<span class="nc" id="L1815">        contentPane.addComponent(index, cmp);</span>
<span class="nc" id="L1816">    }</span>

    /**
     * {@inheritDoc}
     */
    public void replace(Component current, Component next, Transition t) {
<span class="fc" id="L1822">        contentPane.replace(current, next, t);</span>
<span class="fc" id="L1823">    }</span>

    /**
     * {@inheritDoc}
     */
    public void replaceAndWait(Component current, Component next, Transition t) {
<span class="nc" id="L1829">        contentPane.replaceAndWait(current, next, t);</span>
<span class="nc" id="L1830">    }</span>

    /**
     * Removes a component from the Form's Content Pane
     *
     * @param cmp the component to be removed
     */
    public void removeComponent(Component cmp) {
<span class="fc" id="L1838">        contentPane.removeComponent(cmp);</span>
<span class="fc" id="L1839">    }</span>

    /**
     * {@inheritDoc}
     */
    public void animateHierarchy(int duration) {
<span class="fc" id="L1845">        contentPane.animateHierarchy(duration);</span>
<span class="fc" id="L1846">    }</span>

    /**
     * {@inheritDoc}
     */
    public void animateHierarchyAndWait(int duration) {
<span class="nc" id="L1852">        contentPane.animateHierarchyAndWait(duration);</span>
<span class="nc" id="L1853">    }</span>

    /**
     * {@inheritDoc}
     */
    public void animateHierarchyFade(int duration, int startingOpacity) {
<span class="nc" id="L1859">        contentPane.animateHierarchyFade(duration, startingOpacity);</span>
<span class="nc" id="L1860">    }</span>

    /**
     * {@inheritDoc}
     */
    public void animateHierarchyFadeAndWait(int duration,
                                            int startingOpacity) {
<span class="nc" id="L1867">        contentPane.animateHierarchyFadeAndWait(duration, startingOpacity);</span>
<span class="nc" id="L1868">    }</span>

    /**
     * {@inheritDoc}
     */
    public void animateLayout(int duration) {
<span class="nc" id="L1874">        contentPane.animateLayout(duration);</span>
<span class="nc" id="L1875">    }</span>

    /**
     * {@inheritDoc}
     */
    public void animateLayoutAndWait(int duration) {
<span class="nc" id="L1881">        contentPane.animateLayoutAndWait(duration);</span>
<span class="nc" id="L1882">    }</span>

    /**
     * {@inheritDoc}
     */
    public void animateLayoutFade(int duration, int startingOpacity) {
<span class="nc" id="L1888">        contentPane.animateLayoutFade(duration, startingOpacity);</span>
<span class="nc" id="L1889">    }</span>

    /**
     * {@inheritDoc}
     */
    public void animateLayoutFadeAndWait(int duration, int startingOpacity) {
<span class="nc" id="L1895">        contentPane.animateLayoutFadeAndWait(duration, startingOpacity);</span>
<span class="nc" id="L1896">    }</span>

    /**
     * {@inheritDoc}
     */
    public void animateUnlayout(int duration, int opacity, Runnable callback) {
<span class="nc" id="L1902">        contentPane.animateUnlayout(duration, opacity, callback);</span>
<span class="nc" id="L1903">    }</span>

    /**
     * {@inheritDoc}
     */
    public void animateUnlayoutAndWait(int duration, int opacity) {
<span class="nc" id="L1909">        contentPane.animateUnlayoutAndWait(duration, opacity);</span>
<span class="nc" id="L1910">    }</span>

    final void addComponentToForm(Object constraints, Component cmp) {
<span class="fc" id="L1913">        super.addComponent(constraints, cmp);</span>
<span class="fc" id="L1914">    }</span>

    void removeComponentFromForm(Component cmp) {
<span class="fc" id="L1917">        super.removeComponent(cmp);</span>
<span class="fc" id="L1918">    }</span>

    /**
     * Registering media component to this Form, that like to receive
     * animation events
     *
     * @param mediaCmp the Form media component to be registered
     */
    void registerMediaComponent(Component mediaCmp) {
<span class="nc bnc" id="L1927" title="All 2 branches missed.">        if (mediaComponents == null) {</span>
<span class="nc" id="L1928">            mediaComponents = new ArrayList&lt;Component&gt;();</span>
        }
<span class="nc bnc" id="L1930" title="All 2 branches missed.">        if (!mediaComponents.contains(mediaCmp)) {</span>
<span class="nc" id="L1931">            mediaComponents.add(mediaCmp);</span>
        }
<span class="nc" id="L1933">    }</span>

    /**
     * Used by the implementation to prevent flickering when flushing the double buffer
     *
     * @return true if the form has media components within it
     */
    public final boolean hasMedia() {
<span class="nc bnc" id="L1941" title="All 4 branches missed.">        return mediaComponents != null &amp;&amp; mediaComponents.size() &gt; 0;</span>
    }

    /**
     * Indicate that cmp would no longer like to receive animation events
     *
     * @param mediaCmp component that would no longer receive animation events
     */
    void deregisterMediaComponent(Component mediaCmp) {
<span class="nc" id="L1950">        mediaComponents.remove(mediaCmp);</span>
<span class="nc" id="L1951">    }</span>

    /**
     * The given component is interested in animating its appearance and will start
     * receiving callbacks when it is visible in the form allowing it to animate
     * its appearance. This method would not register a compnent instance more than once
     *
     * @param cmp component that would be animated
     */
    public void registerAnimated(Animation cmp) {
<span class="fc bfc" id="L1961" title="All 2 branches covered.">        if (animatableComponents == null) {</span>
<span class="fc" id="L1962">            animatableComponents = new ArrayList&lt;Animation&gt;();</span>
        }
<span class="fc bfc" id="L1964" title="All 2 branches covered.">        if (!animatableComponents.contains(cmp)) {</span>
<span class="fc" id="L1965">            animatableComponents.add(cmp);</span>
        }
<span class="fc" id="L1967">        Display.getInstance().notifyDisplay();</span>
<span class="fc" id="L1968">    }</span>

    /**
     * Identical to the none-internal version, the difference between the internal/none-internal
     * is that it references a different vector that is unaffected by the user actions.
     * That is why we can dynamically register/deregister without interfering with user interaction.
     */
    void registerAnimatedInternal(Animation cmp) {
<span class="pc bpc" id="L1976" title="1 of 2 branches missed.">        if (cmp instanceof Component) {</span>
<span class="fc" id="L1977">            Component c = (Component) cmp;</span>
<span class="fc bfc" id="L1978" title="All 2 branches covered.">            if (c.internalRegisteredAnimated) {</span>
<span class="fc" id="L1979">                return;</span>
            }
<span class="fc" id="L1981">            c.internalRegisteredAnimated = true;</span>
        }
<span class="fc bfc" id="L1983" title="All 2 branches covered.">        if (internalAnimatableComponents == null) {</span>
<span class="fc" id="L1984">            internalAnimatableComponents = new ArrayList&lt;Animation&gt;();</span>
        }
<span class="pc bpc" id="L1986" title="1 of 2 branches missed.">        if (!internalAnimatableComponents.contains(cmp)) {</span>
<span class="fc" id="L1987">            internalAnimatableComponents.add(cmp);</span>
        }
<span class="fc" id="L1989">        Display.getInstance().notifyDisplay();</span>
<span class="fc" id="L1990">    }</span>

    /**
     * Identical to the none-internal version, the difference between the internal/none-internal
     * is that it references a different vector that is unaffected by the user actions.
     * That is why we can dynamically register/deregister without interfering with user interaction.
     */
    void deregisterAnimatedInternal(Animation cmp) {
<span class="fc bfc" id="L1998" title="All 2 branches covered.">        if (internalAnimatableComponents != null) {</span>
<span class="pc bpc" id="L1999" title="1 of 2 branches missed.">            if (cmp instanceof Component) {</span>
<span class="fc" id="L2000">                Component c = (Component) cmp;</span>
<span class="fc bfc" id="L2001" title="All 2 branches covered.">                if (!c.internalRegisteredAnimated) {</span>
<span class="fc" id="L2002">                    return;</span>
                }
<span class="fc" id="L2004">                c.internalRegisteredAnimated = false;</span>
            }
<span class="fc" id="L2006">            internalAnimatableComponents.remove(cmp);</span>
        }
<span class="fc" id="L2008">    }</span>

    /**
     * Indicate that cmp would no longer like to receive animation events
     *
     * @param cmp component that would no longer receive animation events
     */
    public void deregisterAnimated(Animation cmp) {
<span class="fc bfc" id="L2016" title="All 2 branches covered.">        if (animatableComponents != null) {</span>
<span class="fc" id="L2017">            animatableComponents.remove(cmp);</span>
        }
<span class="fc" id="L2019">    }</span>

    /**
     * {@inheritDoc}
     */
    public boolean animate() {
<span class="pc bpc" id="L2025" title="1 of 2 branches missed.">        if (getParent() != null) {</span>
<span class="fc" id="L2026">            repaintAnimations();</span>
        }
<span class="fc" id="L2028">        return super.animate();</span>
    }

    /**
     * Makes sure all animations are repainted so they would be rendered in every
     * frame
     */
    void repaintAnimations() {
<span class="pc bpc" id="L2036" title="1 of 2 branches missed.">        if (rippleComponent != null) {</span>
<span class="nc" id="L2037">            rippleComponent.repaint();</span>
<span class="nc bnc" id="L2038" title="All 2 branches missed.">            if (rippleMotion == null) {</span>
<span class="nc" id="L2039">                rippleComponent = null;</span>
            }
        }
<span class="fc bfc" id="L2042" title="All 2 branches covered.">        if (animatableComponents != null) {</span>
<span class="fc" id="L2043">            loopAnimations(animatableComponents, null);</span>
        }
<span class="fc bfc" id="L2045" title="All 2 branches covered.">        if (internalAnimatableComponents != null) {</span>
<span class="fc" id="L2046">            loopAnimations(internalAnimatableComponents, animatableComponents);</span>
        }
<span class="pc bpc" id="L2048" title="1 of 2 branches missed.">        if (animMananger != null) {</span>
<span class="fc" id="L2049">            animMananger.updateAnimations();</span>
        }
<span class="fc" id="L2051">    }</span>

    /**
     * The form itself should
     *
     * @return
     */
    @Override
    public int getSideGap() {
<span class="fc bfc" id="L2060" title="All 2 branches covered.">        if (getParent() == null) {</span>
            // Top-level form shouldn't have its own sidegap.  The contentpane will.
<span class="fc" id="L2062">            return 0;</span>
        }
<span class="fc" id="L2064">        return super.getSideGap();</span>
    }

    @Override
    protected void paintScrollbars(Graphics g) {
<span class="nc bnc" id="L2069" title="All 2 branches missed.">        if (getParent() == null) {</span>
            // Don't paint scrollbars on top-level form.
            // Let the content pane do that.
        } else {
<span class="nc" id="L2073">            super.paintScrollbars(g);</span>
        }
<span class="nc" id="L2075">    }</span>

    private void loopAnimations(ArrayList&lt;Animation&gt; v, ArrayList&lt;Animation&gt; notIn) {
        // we don't save size() in a varible since the animate method may deregister
        // the animation thus invalidating the size
<span class="fc bfc" id="L2080" title="All 2 branches covered.">        for (int iter = 0; iter &lt; v.size(); iter++) {</span>
<span class="fc" id="L2081">            Animation c = v.get(iter);</span>
<span class="pc bpc" id="L2082" title="2 of 6 branches missed.">            if (c == null || notIn != null &amp;&amp; notIn.contains(c)) {</span>
<span class="nc" id="L2083">                continue;</span>
            }
<span class="fc bfc" id="L2085" title="All 2 branches covered.">            if (c.animate()) {</span>
<span class="fc bfc" id="L2086" title="All 2 branches covered.">                if (c instanceof Component) {</span>
<span class="fc" id="L2087">                    Rectangle rect = ((Component) c).getDirtyRegion();</span>
<span class="pc bpc" id="L2088" title="1 of 2 branches missed.">                    if (rect != null) {</span>
<span class="nc" id="L2089">                        Dimension d = rect.getSize();</span>

                        // this probably can't happen but we got a really weird partial stack trace to this
                        // method and this check doesn't hurt
<span class="nc bnc" id="L2093" title="All 2 branches missed.">                        if (d != null) {</span>
<span class="nc" id="L2094">                            ((Component) c).repaint(rect.getX(), rect.getY(), d.getWidth(), d.getHeight());</span>
                        }
<span class="nc" id="L2096">                    } else {</span>
<span class="fc" id="L2097">                        ((Component) c).repaint();</span>
                    }
<span class="fc" id="L2099">                } else {</span>
<span class="fc" id="L2100">                    Display.getInstance().repaint(c);</span>
                }
            }
        }
<span class="fc" id="L2104">    }</span>

    /**
     * If this method returns true the EDT won't go to sleep indefinitely
     *
     * @return true is form has animation; otherwise false
     */
    boolean hasAnimations() {
<span class="fc bfc" id="L2112" title="All 6 branches covered.">        return (animatableComponents != null &amp;&amp; animatableComponents.size() &gt; 0)</span>
<span class="pc bpc" id="L2113" title="1 of 4 branches missed.">                || (internalAnimatableComponents != null &amp;&amp; internalAnimatableComponents.size() &gt; 0)</span>
<span class="fc bfc" id="L2114" title="All 2 branches covered.">                || (animMananger != null &amp;&amp; animMananger.isAnimating());</span>
    }

    /**
     * {@inheritDoc}
     */
    public void refreshTheme(boolean merge) {
        // when changing the theme when a title/menu bar is not visible the refresh
        // won't apply to them. We need to protect against this occurance.
<span class="nc bnc" id="L2123" title="All 2 branches missed.">        if (menuBar != null) {</span>
<span class="nc" id="L2124">            menuBar.refreshTheme(merge);</span>
        }
<span class="nc bnc" id="L2126" title="All 2 branches missed.">        if (titleArea != null) {</span>
<span class="nc" id="L2127">            titleArea.refreshTheme(merge);</span>
        }
<span class="nc bnc" id="L2129" title="All 2 branches missed.">        if (toolbar != null) {</span>
<span class="nc" id="L2130">            toolbar.refreshTheme(merge);</span>
        }

<span class="nc" id="L2133">        super.refreshTheme(merge);</span>

<span class="nc bnc" id="L2135" title="All 2 branches missed.">        if (toolbar == null) {</span>
            // when  changing the theme the menu behavior might also change
<span class="nc" id="L2137">            hideMenu();</span>
<span class="nc" id="L2138">            restoreMenu();</span>
<span class="nc" id="L2139">            Command[] cmds = new Command[getCommandCount()];</span>
<span class="nc bnc" id="L2140" title="All 2 branches missed.">            for (int iter = 0; iter &lt; cmds.length; iter++) {</span>
<span class="nc" id="L2141">                cmds[iter] = getCommand(iter);</span>
            }
<span class="nc" id="L2143">            removeAllCommands();</span>
<span class="nc bnc" id="L2144" title="All 2 branches missed.">            for (int iter = 0; iter &lt; cmds.length; iter++) {</span>
<span class="nc" id="L2145">                addCommand(cmds[iter], getCommandCount());</span>
            }
<span class="nc bnc" id="L2147" title="All 2 branches missed.">            if (getBackCommand() != null) {</span>
<span class="nc" id="L2148">                setBackCommand(getBackCommand());</span>
            }
        }

<span class="nc" id="L2152">        revalidateWithAnimationSafety();</span>
<span class="nc" id="L2153">    }</span>

    /**
     * Exposing the background painting for the benefit of animations
     *
     * @param g the form graphics
     */
    public void paintBackground(Graphics g) {
<span class="fc" id="L2161">        super.paintBackground(g);</span>
<span class="fc" id="L2162">    }</span>

    /**
     * This property allows us to define a an animation that will draw the transition for
     * entering this form. A transition is an animation that would occur when
     * switching from one form to another.
     *
     * @return the Form in transition
     */
    public Transition getTransitionInAnimator() {
<span class="fc" id="L2172">        return transitionInAnimator;</span>
    }

    /**
     * This property allows us to define a an animation that will draw the transition for
     * entering this form. A transition is an animation that would occur when
     * switching from one form to another.
     *
     * @param transitionInAnimator the Form in transition
     */
    public void setTransitionInAnimator(Transition transitionInAnimator) {
<span class="fc" id="L2183">        this.transitionInAnimator = transitionInAnimator;</span>
<span class="fc" id="L2184">    }</span>

    /**
     * This property allows us to define a an animation that will draw the transition for
     * exiting this form. A transition is an animation that would occur when
     * switching from one form to another.
     *
     * @return the Form out transition
     */
    public Transition getTransitionOutAnimator() {
<span class="fc" id="L2194">        return transitionOutAnimator;</span>
    }

    /**
     * This property allows us to define a an animation that will draw the transition for
     * exiting this form. A transition is an animation that would occur when
     * switching from one form to another.
     *
     * @param transitionOutAnimator the Form out transition
     */
    public void setTransitionOutAnimator(Transition transitionOutAnimator) {
<span class="fc" id="L2205">        this.transitionOutAnimator = transitionOutAnimator;</span>
<span class="fc" id="L2206">    }</span>

    /**
     * A listener that is invoked when a command is clicked allowing multiple commands
     * to be handled by a single block
     *
     * @param l the command action listener
     */
    public void addCommandListener(ActionListener l) {
<span class="pc bpc" id="L2215" title="1 of 2 branches missed.">        if (commandListener == null) {</span>
<span class="fc" id="L2216">            commandListener = new EventDispatcher();</span>
        }
<span class="fc" id="L2218">        commandListener.addListener(l);</span>
<span class="fc" id="L2219">    }</span>

    /**
     * A listener that is invoked when a command is clicked allowing multiple commands
     * to be handled by a single block
     *
     * @param l the command action listener
     */
    public void removeCommandListener(ActionListener l) {
<span class="nc" id="L2228">        commandListener.removeListener(l);</span>
<span class="nc" id="L2229">    }</span>

    /**
     * Invoked to allow subclasses of form to handle a command from one point
     * rather than implementing many command instances. All commands selected
     * on the form will trigger this method implicitly.
     *
     * @param cmd the form commmand object
     */
    protected void actionCommand(Command cmd) {
<span class="fc" id="L2239">    }</span>

    /**
     * Dispatches a command via the standard form mechanism of firing a command event
     *
     * @param cmd The command to dispatch
     * @param ev  the event to dispatch
     */
    public void dispatchCommand(Command cmd, ActionEvent ev) {
<span class="nc" id="L2248">        cmd.actionPerformed(ev);</span>
<span class="nc bnc" id="L2249" title="All 2 branches missed.">        if (!ev.isConsumed()) {</span>
<span class="nc" id="L2250">            actionCommandImpl(cmd, ev);</span>
        }
<span class="nc" id="L2252">    }</span>

    /**
     * Invoked to allow subclasses of form to handle a command from one point
     * rather than implementing many command instances
     */
    void actionCommandImpl(Command cmd) {
<span class="nc" id="L2259">        actionCommandImpl(cmd, new ActionEvent(cmd, ActionEvent.Type.Command));</span>
<span class="nc" id="L2260">    }</span>

    /**
     * Invoked to allow subclasses of form to handle a command from one point
     * rather than implementing many command instances
     */
    void actionCommandImpl(Command cmd, ActionEvent ev) {
<span class="nc bnc" id="L2267" title="All 2 branches missed.">        if (cmd == null) {</span>
<span class="nc" id="L2268">            return;</span>
        }

<span class="nc bnc" id="L2271" title="All 2 branches missed.">        if (comboLock) {</span>
<span class="nc bnc" id="L2272" title="All 2 branches missed.">            if (cmd == menuBar.getCancelMenuItem()) {</span>
<span class="nc" id="L2273">                actionCommand(cmd);</span>
<span class="nc" id="L2274">                return;</span>
            }
<span class="nc" id="L2276">            Component c = getFocused();</span>
<span class="nc bnc" id="L2277" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc" id="L2278">                c.fireClicked();</span>
            }
<span class="nc" id="L2280">            return;</span>
        }
<span class="nc bnc" id="L2282" title="All 2 branches missed.">        if (cmd != menuBar.getSelectCommand()) {</span>
<span class="nc bnc" id="L2283" title="All 2 branches missed.">            if (commandListener != null) {</span>
<span class="nc" id="L2284">                commandListener.fireActionEvent(ev);</span>
<span class="nc bnc" id="L2285" title="All 2 branches missed.">                if (ev.isConsumed()) {</span>
<span class="nc" id="L2286">                    return;</span>
                }
            }
<span class="nc" id="L2289">            actionCommand(cmd);</span>
        } else {
<span class="nc" id="L2291">            Component c = getFocused();</span>
<span class="nc bnc" id="L2292" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc" id="L2293">                c.fireClicked();</span>
            }
        }
<span class="nc" id="L2296">    }</span>

    /**
     * Invoked to allow subclasses of form to handle a command from one point
     * rather than implementing many command instances
     */
    void actionCommandImplNoRecurseComponent(Command cmd, ActionEvent ev) {
<span class="pc bpc" id="L2303" title="1 of 2 branches missed.">        if (cmd == null) {</span>
<span class="nc" id="L2304">            return;</span>
        }

<span class="pc bpc" id="L2307" title="1 of 2 branches missed.">        if (comboLock) {</span>
<span class="nc bnc" id="L2308" title="All 2 branches missed.">            if (cmd == menuBar.getCancelMenuItem()) {</span>
<span class="nc" id="L2309">                actionCommand(cmd);</span>
<span class="nc" id="L2310">                return;</span>
            }
<span class="nc" id="L2312">            return;</span>
        }
<span class="pc bpc" id="L2314" title="1 of 2 branches missed.">        if (cmd != menuBar.getSelectCommand()) {</span>
<span class="fc bfc" id="L2315" title="All 2 branches covered.">            if (commandListener != null) {</span>
<span class="fc" id="L2316">                commandListener.fireActionEvent(ev);</span>
<span class="pc bpc" id="L2317" title="1 of 2 branches missed.">                if (ev.isConsumed()) {</span>
<span class="nc" id="L2318">                    return;</span>
                }
            }
<span class="fc" id="L2321">            actionCommand(cmd);</span>
        }
<span class="fc" id="L2323">    }</span>

    void initFocused() {
<span class="fc bfc" id="L2326" title="All 2 branches covered.">        if (focused == null) {</span>
<span class="fc bfc" id="L2327" title="All 2 branches covered.">            Component focusable = formLayeredPane != null ?</span>
<span class="fc" id="L2328">                    formLayeredPane.findFirstFocusable() :</span>
                    null;
<span class="fc bfc" id="L2330" title="All 2 branches covered.">            if (focusable == null) {</span>
<span class="fc" id="L2331">                focusable = getActualPane().findFirstFocusable();</span>
            }
<span class="fc" id="L2333">            setFocused(focusable);</span>
<span class="pc bpc" id="L2334" title="1 of 2 branches missed.">            if (!Display.getInstance().shouldRenderSelection()) {</span>
<span class="nc" id="L2335">                return;</span>
            }
<span class="fc" id="L2337">            layoutContainer();</span>
        }
<span class="fc" id="L2339">    }</span>

    /**
     * Displays the current form on the screen
     */
    public void show() {
<span class="fc" id="L2345">        Display.impl.onShow(this);</span>
<span class="fc" id="L2346">        show(false);</span>
<span class="fc" id="L2347">    }</span>

    /**
     * Displays the current form on the screen, this version of the method is
     * useful for &quot;back&quot; navigation since it reverses the direction of the transition.
     */
    public void showBack() {
<span class="fc" id="L2354">        show(true);</span>
<span class="fc" id="L2355">    }</span>

    /**
     * Displays the current form on the screen
     */
    private void show(boolean reverse) {
<span class="pc bpc" id="L2361" title="1 of 4 branches missed.">        if (transitionOutAnimator == null &amp;&amp; transitionInAnimator == null) {</span>
<span class="fc" id="L2362">            initLaf(getUIManager());</span>
        }
<span class="fc" id="L2364">        initFocused();</span>
<span class="fc" id="L2365">        onShow();</span>
<span class="fc" id="L2366">        tint = false;</span>
<span class="pc bpc" id="L2367" title="1 of 2 branches missed.">        if (getParent() == null) {</span>
<span class="fc" id="L2368">            com.codename1.ui.Display.getInstance().setCurrent(this, reverse);</span>
        } else {
<span class="nc" id="L2370">            revalidateWithAnimationSafety();</span>
        }
<span class="fc" id="L2372">    }</span>

    /**
     * {@inheritDoc}
     */
    void deinitializeImpl() {
<span class="pc bpc" id="L2378" title="1 of 2 branches missed.">        if (!comboLock) {</span>
            // Some input devices are compound widgets that contain
            // comboboxes.  If those comboboxes are selected, then
            // it shows the combobox popup (which is a Dialog) which will
            // denitialize the form.  We don't want this to trigger the
            // input device change (which may close the input device).
            // Specifically this is to fix an issue with the Calendar picker
            // https://groups.google.com/d/msgid/codenameone-discussions/b8e198a4-3dd1-4feb-81a1-456188e81d92%40googlegroups.com?utm_medium=email&amp;utm_source=footer
            try {
<span class="fc" id="L2387">                setCurrentInputDevice(null);</span>
<span class="nc" id="L2388">            } catch (Exception ex) {</span>
<span class="nc" id="L2389">                Log.e(ex);</span>
<span class="fc" id="L2390">            }</span>
        }
<span class="pc bpc" id="L2392" title="1 of 2 branches missed.">        if (getParent() != null) {</span>
<span class="nc" id="L2393">            Form f = getParent().getComponentForm();</span>
<span class="nc bnc" id="L2394" title="All 2 branches missed.">            if (f != null) {</span>
<span class="nc" id="L2395">                f.deregisterAnimated(this);</span>
            }
        }
<span class="fc" id="L2398">        super.deinitializeImpl();</span>
<span class="fc" id="L2399">        animMananger.flush();</span>
<span class="fc" id="L2400">        componentsAwaitingRelease = null;</span>
<span class="fc" id="L2401">        pressedCmp = null;</span>
<span class="fc" id="L2402">        dragged = null;</span>
<span class="fc" id="L2403">    }</span>

    /**
     * {@inheritDoc}
     */
    void initComponentImpl() {
<span class="fc" id="L2409">        super.initComponentImpl();</span>
<span class="fc" id="L2410">        dragged = null;</span>
<span class="pc bpc" id="L2411" title="1 of 2 branches missed.">        if (Display.getInstance().isNativeCommands()) {</span>
<span class="nc" id="L2412">            Display.impl.setNativeCommands(menuBar.getCommands());</span>
        }
<span class="fc bfc" id="L2414" title="All 2 branches covered.">        if (getParent() != null) {</span>
<span class="fc" id="L2415">            Form f = getParent().getComponentForm();</span>
<span class="pc bpc" id="L2416" title="1 of 2 branches missed.">            if (f != null) {</span>
<span class="fc" id="L2417">                f.registerAnimated(this);</span>
<span class="pc bpc" id="L2418" title="1 of 2 branches missed.">                if (pointerPressedListeners != null) {</span>
<span class="nc bnc" id="L2419" title="All 2 branches missed.">                    for (ActionListener l : (Collection&lt;ActionListener&gt;) pointerPressedListeners.getListenerCollection()) {</span>
<span class="nc" id="L2420">                        f.addPointerPressedListener(l);</span>
<span class="nc" id="L2421">                    }</span>
<span class="nc" id="L2422">                    pointerPressedListeners = null;</span>
                }
<span class="pc bpc" id="L2424" title="1 of 2 branches missed.">                if (pointerDraggedListeners != null) {</span>
<span class="nc bnc" id="L2425" title="All 2 branches missed.">                    for (ActionListener l : (Collection&lt;ActionListener&gt;) pointerDraggedListeners.getListenerCollection()) {</span>
<span class="nc" id="L2426">                        f.addPointerDraggedListener(l);</span>
<span class="nc" id="L2427">                    }</span>
<span class="nc" id="L2428">                    pointerDraggedListeners = null;</span>
                }
<span class="pc bpc" id="L2430" title="1 of 2 branches missed.">                if (pointerReleasedListeners != null) {</span>
<span class="nc bnc" id="L2431" title="All 2 branches missed.">                    for (ActionListener l : (Collection&lt;ActionListener&gt;) pointerReleasedListeners.getListenerCollection()) {</span>
<span class="nc" id="L2432">                        f.addPointerReleasedListener(l);</span>
<span class="nc" id="L2433">                    }</span>
<span class="nc" id="L2434">                    pointerReleasedListeners = null;</span>
                }
<span class="pc bpc" id="L2436" title="1 of 2 branches missed.">                if (longPressListeners != null) {</span>
<span class="nc bnc" id="L2437" title="All 2 branches missed.">                    for (ActionListener l : (Collection&lt;ActionListener&gt;) longPressListeners.getListenerCollection()) {</span>
<span class="nc" id="L2438">                        f.addLongPressListener(l);</span>
<span class="nc" id="L2439">                    }</span>
<span class="nc" id="L2440">                    longPressListeners = null;</span>
                }
            }
        }
<span class="fc" id="L2444">    }</span>

    /**
     * {@inheritDoc}
     */
    public boolean isSmoothScrolling() {
<span class="nc" id="L2450">        return contentPane.isSmoothScrolling();</span>
    }

    /**
     * {@inheritDoc}
     */
    public void setSmoothScrolling(boolean smoothScrolling) {
        // invoked by the constructor for component
<span class="fc bfc" id="L2458" title="All 2 branches covered.">        if (contentPane != null) {</span>
<span class="fc" id="L2459">            contentPane.setSmoothScrolling(smoothScrolling);</span>
        }
<span class="fc" id="L2461">    }</span>

    /**
     * {@inheritDoc}
     */
    public int getScrollAnimationSpeed() {
<span class="nc" id="L2467">        return contentPane.getScrollAnimationSpeed();</span>
    }

    /**
     * {@inheritDoc}
     */
    public void setScrollAnimationSpeed(int animationSpeed) {
<span class="nc" id="L2474">        contentPane.setScrollAnimationSpeed(animationSpeed);</span>
<span class="nc" id="L2475">    }</span>

    /**
     * Allows subclasses to bind functionality that occurs when
     * a specific form or dialog appears on the screen
     */
    protected void onShow() {
<span class="fc" id="L2482">    }</span>

    /**
     * Allows subclasses to bind functionality that occurs when
     * a specific form or dialog is &quot;really&quot; showing hence when
     * the transition is totally complete (unlike onShow which is called
     * on intent). The necessity for this is for special cases like
     * media that might cause artifacts if played during a transition.
     */
    protected void onShowCompleted() {
<span class="fc" id="L2492">    }</span>

    void onShowCompletedImpl() {
<span class="fc" id="L2495">        setLightweightMode(false);</span>
<span class="fc" id="L2496">        onShowCompleted();</span>
<span class="pc bpc" id="L2497" title="1 of 2 branches missed.">        if (showListener != null) {</span>
<span class="nc" id="L2498">            showListener.fireActionEvent(new ActionEvent(this, ActionEvent.Type.Show));</span>
        }
<span class="pc bpc" id="L2500" title="1 of 2 branches missed.">        if (editOnShow != null) {</span>
<span class="nc" id="L2501">            editOnShow.startEditingAsync();</span>
        }
<span class="fc" id="L2503">    }</span>

    /**
     * This method shows the form as a modal alert allowing us to produce a behavior
     * of an alert/dialog box. This method will block the calling thread even if the
     * calling thread is the EDT. Notice that this method will not release the block
     * until dispose is called even if show() from another form is called!
     * &lt;p&gt;Modal dialogs Allow the forms &quot;content&quot; to &quot;hang in mid air&quot; this is especially useful for
     * dialogs where you would want the underlying form to &quot;peek&quot; from behind the
     * form.
     *
     * @param top          space in pixels between the top of the screen and the form
     * @param bottom       space in pixels between the bottom of the screen and the form
     * @param left         space in pixels between the left of the screen and the form
     * @param right        space in pixels between the right of the screen and the form
     * @param includeTitle whether the title should hang in the top of the screen or
     *                     be glued onto the content pane
     * @param modal        indictes if this is a modal or modeless dialog true for modal dialogs
     */
    void showModal(int top, int bottom, int left, int right, boolean includeTitle, boolean modal, boolean reverse) {
<span class="fc" id="L2523">        Display.getInstance().flushEdt();</span>
<span class="pc bpc" id="L2524" title="1 of 2 branches missed.">        if (previousForm == null) {</span>
<span class="fc" id="L2525">            previousForm = Display.getInstance().getCurrent();</span>
            // special case for application opening with a dialog before any form is shown
<span class="pc bpc" id="L2527" title="1 of 2 branches missed.">            if (previousForm == null) {</span>
<span class="nc" id="L2528">                previousForm = new Form();</span>
<span class="nc" id="L2529">                previousForm.show();</span>
            } else {
<span class="pc bpc" id="L2531" title="1 of 2 branches missed.">                if (previousForm instanceof Dialog) {</span>
<span class="nc" id="L2532">                    Dialog previousDialog = (Dialog) previousForm;</span>
<span class="nc bnc" id="L2533" title="All 2 branches missed.">                    if (previousDialog.isDisposed()) {</span>
<span class="nc" id="L2534">                        previousForm = Display.getInstance().getCurrentUpcoming();</span>
                    }
                }
            }
        }

<span class="fc" id="L2540">        previousForm.tint = true;</span>
<span class="fc" id="L2541">        Painter p = getStyle().getBgPainter();</span>
<span class="pc bpc" id="L2542" title="5 of 8 branches missed.">        if (top &gt; 0 || bottom &gt; 0 || left &gt; 0 || right &gt; 0) {</span>
<span class="pc bpc" id="L2543" title="1 of 2 branches missed.">            if (!title.isVisible()) {</span>
<span class="fc" id="L2544">                includeTitle = false;</span>
            }
<span class="fc" id="L2546">            Style titleStyle = title.getStyle();</span>
<span class="fc" id="L2547">            titleStyle.removeListeners();</span>

<span class="fc" id="L2549">            Style contentStyle = contentPane.getUnselectedStyle();</span>
<span class="fc" id="L2550">            contentStyle.removeListeners();</span>

<span class="pc bpc" id="L2552" title="1 of 2 branches missed.">            if (includeTitle) {</span>
<span class="nc" id="L2553">                titleStyle.setMargin(Component.TOP, top, false);</span>
<span class="nc" id="L2554">                titleStyle.setMargin(Component.BOTTOM, 0, false);</span>
<span class="nc" id="L2555">                titleStyle.setMargin(Component.LEFT, left, false);</span>
<span class="nc" id="L2556">                titleStyle.setMargin(Component.RIGHT, right, false);</span>

<span class="nc" id="L2558">                contentStyle.setMargin(Component.TOP, 0, false);</span>
<span class="nc" id="L2559">                contentStyle.setMargin(Component.BOTTOM, bottom, false);</span>
<span class="nc" id="L2560">                contentStyle.setMargin(Component.LEFT, left, false);</span>
<span class="nc" id="L2561">                contentStyle.setMargin(Component.RIGHT, right, false);</span>
            } else {
<span class="fc" id="L2563">                titleStyle.setMargin(Component.TOP, 0, false);</span>
<span class="fc" id="L2564">                titleStyle.setMargin(Component.BOTTOM, 0, false);</span>
<span class="fc" id="L2565">                titleStyle.setMargin(Component.LEFT, 0, false);</span>
<span class="fc" id="L2566">                titleStyle.setMargin(Component.RIGHT, 0, false);</span>

<span class="fc" id="L2568">                contentStyle.setMargin(Component.TOP, top, false);</span>
<span class="fc" id="L2569">                contentStyle.setMargin(Component.BOTTOM, bottom, false);</span>
<span class="fc" id="L2570">                contentStyle.setMargin(Component.LEFT, left, false);</span>
<span class="fc" id="L2571">                contentStyle.setMargin(Component.RIGHT, right, false);</span>
            }
<span class="fc" id="L2573">            titleStyle.setMarginUnit(null);</span>
<span class="fc" id="L2574">            contentStyle.setMarginUnit(null);</span>
<span class="fc" id="L2575">            initDialogBgPainter(p, previousForm);</span>
<span class="fc" id="L2576">            revalidate();</span>
<span class="fc" id="L2577">        } else {</span>
            // If the keyboard was opened the top/bottom/left/right calculations
            // may be zeroes right now, but this will change when the keyboard
            // finishes closing, so we still need to add a BgPainter.
            // Fixes issue described at https://github.com/codenameone/CodenameOne/issues/1751#issuecomment-394707781
<span class="nc" id="L2582">            initDialogBgPainter(p, previousForm);</span>
        }

<span class="fc" id="L2585">        initFocused();</span>
<span class="pc bpc" id="L2586" title="1 of 4 branches missed.">        if (getTransitionOutAnimator() == null &amp;&amp; getTransitionInAnimator() == null) {</span>
<span class="fc" id="L2587">            initLaf(getUIManager());</span>
        }

<span class="fc" id="L2590">        initComponentImpl();</span>
<span class="fc" id="L2591">        Display.getInstance().setCurrent(this, reverse);</span>
<span class="fc" id="L2592">        onShow();</span>

<span class="fc bfc" id="L2594" title="All 2 branches covered.">        if (modal) {</span>
            // called to display a dialog and wait for modality
<span class="fc" id="L2596">            Display.getInstance().invokeAndBlock(new RunnableWrapper(this, p, reverse));</span>
            // if the virtual keyboard was opend by the dialog close it
<span class="fc" id="L2598">            Display.getInstance().setShowVirtualKeyboard(false);</span>
        }
<span class="fc" id="L2600">    }</span>

    /**
     * Allows Dialog to override background painting for blur
     *
     * @param p the painter
     */
    void initDialogBgPainter(Painter p, Form previousForm) {
<span class="pc bpc" id="L2608" title="2 of 4 branches missed.">        if (p instanceof BGPainter &amp;&amp; ((BGPainter) p).getPreviousForm() != null) {</span>
<span class="nc" id="L2609">            ((BGPainter) p).setPreviousForm(previousForm);</span>
        } else {
<span class="fc" id="L2611">            BGPainter b = new BGPainter(this, p);</span>
<span class="fc" id="L2612">            getStyle().setBgPainter(b);</span>
<span class="fc" id="L2613">            b.setPreviousForm(previousForm);</span>
        }
<span class="fc" id="L2615">    }</span>

    /**
     * The default version of show modal shows the dialog occupying the center portion
     * of the screen.
     */
    void showModal(boolean reverse) {
<span class="nc" id="L2622">        showDialog(true, reverse);</span>
<span class="nc" id="L2623">    }</span>

    /**
     * The default version of show dialog shows the dialog occupying the center portion
     * of the screen.
     */
    void showDialog(boolean modal, boolean reverse) {
<span class="fc" id="L2630">        int h = Display.getInstance().getDisplayHeight() - menuBar.getPreferredH() - title.getPreferredH();</span>
<span class="fc" id="L2631">        int w = Display.getInstance().getDisplayWidth();</span>
<span class="fc" id="L2632">        int topSpace = h / 100 * 20;</span>
<span class="fc" id="L2633">        int bottomSpace = h / 100 * 10;</span>
<span class="fc" id="L2634">        int sideSpace = w / 100 * 20;</span>
<span class="fc" id="L2635">        showModal(topSpace, bottomSpace, sideSpace, sideSpace, true, modal, reverse);</span>
<span class="fc" id="L2636">    }</span>

    /**
     * Works only for modal forms by returning to the previous form
     */
    void dispose() {
<span class="fc" id="L2642">        disposeImpl();</span>
<span class="fc" id="L2643">    }</span>

    boolean isDisposed() {
<span class="nc" id="L2646">        return false;</span>
    }

    /**
     * Works only for modal forms by returning to the previous form
     */
    void disposeImpl() {
<span class="fc bfc" id="L2653" title="All 2 branches covered.">        if (previousForm != null) {</span>
<span class="pc bpc" id="L2654" title="1 of 2 branches missed.">            boolean clearPrevious = Display.getInstance().getCurrent() == this;</span>
<span class="pc bpc" id="L2655" title="1 of 2 branches missed.">            if (!clearPrevious) {</span>
<span class="fc" id="L2656">                Form f = Display.getInstance().getCurrent();</span>
<span class="fc bfc" id="L2657" title="All 2 branches covered.">                while (f != null) {</span>
<span class="pc bpc" id="L2658" title="1 of 2 branches missed.">                    if (f.previousForm == this) {</span>
<span class="nc" id="L2659">                        f.previousForm = previousForm;</span>
<span class="nc" id="L2660">                        previousForm = null;</span>
<span class="nc" id="L2661">                        return;</span>
                    }
<span class="fc" id="L2663">                    f = f.previousForm;</span>
                }
            }
<span class="fc" id="L2666">            previousForm.tint = false;</span>

<span class="pc bpc" id="L2668" title="1 of 2 branches missed.">            if (previousForm instanceof Dialog) {</span>
<span class="nc bnc" id="L2669" title="All 2 branches missed.">                if (!previousForm.isDisposed()) {</span>
<span class="nc" id="L2670">                    Display.getInstance().setCurrent(previousForm, false);</span>
                }
            } else {
<span class="fc" id="L2673">                Display.getInstance().setCurrent(previousForm, false);</span>
                //previousForm.revalidate();
            }

<span class="pc bpc" id="L2677" title="1 of 2 branches missed.">            if (clearPrevious) {</span>
                // enable GC to cleanup the previous form if no longer referenced
<span class="nc" id="L2679">                previousForm = null;</span>
            }
        }
<span class="fc" id="L2682">    }</span>

    boolean isMenu() {
<span class="nc" id="L2685">        return false;</span>
    }

    /**
     * {@inheritDoc}
     */
    void repaint(Component cmp) {
<span class="pc bpc" id="L2692" title="1 of 2 branches missed.">        if (getParent() != null) {</span>
<span class="nc" id="L2693">            super.repaint(cmp);</span>
<span class="nc" id="L2694">            return;</span>
        }


<span class="pc bpc" id="L2698" title="1 of 2 branches missed.">        if (cmp.hasElevation()) {</span>
<span class="nc" id="L2699">            Container surface = cmp.findSurface();</span>
<span class="nc bnc" id="L2700" title="All 2 branches missed.">            if (surface != null) {</span>
<span class="nc" id="L2701">                surface.repaint(cmp.getAbsoluteX() + cmp.calculateShadowOffsetX(24), cmp.getAbsoluteY() + cmp.calculateShadowOffsetY(24), cmp.calculateShadowWidth(24), cmp.calculateShadowHeight(24));</span>
<span class="nc" id="L2702">                return;</span>
            }
        }


<span class="fc bfc" id="L2707" title="All 4 branches covered.">        if (isVisible() &amp;&amp; CN.getCurrentForm() == this) {</span>
<span class="fc" id="L2708">            Display.getInstance().repaint(cmp);</span>
        }
<span class="fc" id="L2710">    }</span>

    /**
     * {@inheritDoc}
     */
    public final Form getComponentForm() {
<span class="fc bfc" id="L2716" title="All 2 branches covered.">        if (getParent() != null) {</span>
<span class="fc" id="L2717">            return super.getComponentForm();</span>
        }
<span class="fc" id="L2719">        return this;</span>
    }

    /**
     * Invoked by display to hide the menu during transition
     *
     * @see {@link #restoreMenu()}
     */
    void hideMenu() {
<span class="nc" id="L2728">        menuBar.unInstallMenuBar();</span>
<span class="nc" id="L2729">    }</span>

    /**
     * Invoked by display to restore the menu after transition
     *
     * @see {@link #hideMenu()}
     */
    void restoreMenu() {
<span class="fc" id="L2737">        menuBar.installMenuBar();</span>
<span class="fc" id="L2738">    }</span>

    void setFocusedInternal(Component focused) {
<span class="fc" id="L2741">        this.focused = focused;</span>
<span class="fc" id="L2742">    }</span>

    /**
     * This method changes the cmp state to be focused/unfocused and fires the
     * focus gained/lost events.
     *
     * @param cmp    the Component to change the focus state
     * @param gained if true this Component needs to gain focus if false
     *               it needs to lose focus
     * @return this method returns true if the state change needs to trigger a
     * revalidate
     */
    private boolean changeFocusState(Component cmp, boolean gained) {
<span class="fc" id="L2755">        boolean trigger = false;</span>
<span class="fc" id="L2756">        Style selected = cmp.getSelectedStyle();</span>
<span class="fc" id="L2757">        Style unselected = cmp.getUnselectedStyle();</span>
        //if selected style is different then unselected style there is a good
        //chance we need to trigger a revalidate
<span class="pc bpc" id="L2760" title="1 of 2 branches missed.">        if (!selected.getFont().equals(unselected.getFont())</span>
<span class="pc bpc" id="L2761" title="1 of 2 branches missed.">                || selected.getPaddingTop() != unselected.getPaddingTop()</span>
<span class="pc bpc" id="L2762" title="1 of 2 branches missed.">                || selected.getPaddingBottom() != unselected.getPaddingBottom()</span>
<span class="pc bpc" id="L2763" title="1 of 2 branches missed.">                || selected.getPaddingRight(isRTL()) != unselected.getPaddingRight(isRTL())</span>
<span class="pc bpc" id="L2764" title="1 of 2 branches missed.">                || selected.getPaddingLeft(isRTL()) != unselected.getPaddingLeft(isRTL())</span>
<span class="pc bpc" id="L2765" title="1 of 2 branches missed.">                || selected.getMarginTop() != unselected.getMarginTop()</span>
<span class="pc bpc" id="L2766" title="1 of 2 branches missed.">                || selected.getMarginBottom() != unselected.getMarginBottom()</span>
<span class="pc bpc" id="L2767" title="1 of 2 branches missed.">                || selected.getMarginRight(isRTL()) != unselected.getMarginRight(isRTL())</span>
<span class="pc bpc" id="L2768" title="1 of 2 branches missed.">                || selected.getMarginLeft(isRTL()) != unselected.getMarginLeft(isRTL())) {</span>
<span class="nc" id="L2769">            trigger = true;</span>
        }
<span class="fc" id="L2771">        int prefW = 0;</span>
<span class="fc" id="L2772">        int prefH = 0;</span>
<span class="pc bpc" id="L2773" title="1 of 2 branches missed.">        if (trigger) {</span>
<span class="nc" id="L2774">            Dimension d = cmp.getPreferredSize();</span>
<span class="nc" id="L2775">            prefW = d.getWidth();</span>
<span class="nc" id="L2776">            prefH = d.getHeight();</span>
        }

<span class="fc bfc" id="L2779" title="All 2 branches covered.">        if (gained) {</span>
<span class="fc" id="L2780">            cmp.setFocus(true);</span>
<span class="fc" id="L2781">            cmp.fireFocusGained();</span>
<span class="fc" id="L2782">            fireFocusGained(cmp);</span>
        } else {
<span class="fc" id="L2784">            cmp.setFocus(false);</span>
<span class="fc" id="L2785">            cmp.fireFocusLost();</span>
<span class="fc" id="L2786">            fireFocusLost(cmp);</span>
        }

        //if the styles are different there is a chance the preffered size is
        //still the same therefore make sure there is a real need to preform
        //a revalidate
<span class="pc bpc" id="L2792" title="1 of 2 branches missed.">        if (trigger) {</span>
<span class="nc" id="L2793">            cmp.setShouldCalcPreferredSize(true);</span>
<span class="nc" id="L2794">            Dimension d = cmp.getPreferredSize();</span>
<span class="nc bnc" id="L2795" title="All 4 branches missed.">            if (prefW != d.getWidth() || prefH != d.getHeight()) {</span>
<span class="nc" id="L2796">                cmp.setShouldCalcPreferredSize(false);</span>
<span class="nc" id="L2797">                trigger = false;</span>
            }
        }

<span class="fc" id="L2801">        return trigger;</span>
    }

    /**
     * Returns the current focus component for this form
     *
     * @return the current focus component for this form
     */
    public Component getFocused() {
<span class="fc" id="L2810">        return focused;</span>
    }

    /**
     * Sets the focused component and fires the appropriate events to make it so
     *
     * @param focused the newly focused component or null for no focus
     */
    public void setFocused(Component focused) {
<span class="fc bfc" id="L2819" title="All 4 branches covered.">        if (this.focused == focused &amp;&amp; focused != null) {</span>
<span class="fc" id="L2820">            this.focused.repaint();</span>
<span class="fc" id="L2821">            return;</span>
        }
<span class="fc" id="L2823">        Component oldFocus = this.focused;</span>
<span class="fc" id="L2824">        this.focused = focused;</span>
<span class="fc" id="L2825">        boolean triggerRevalidate = false;</span>
<span class="fc bfc" id="L2826" title="All 2 branches covered.">        if (oldFocus != null) {</span>
<span class="fc" id="L2827">            triggerRevalidate = changeFocusState(oldFocus, false);</span>
            //if we need to revalidate no need to repaint the Component, it will
            //be painted from the Form
<span class="pc bpc" id="L2830" title="2 of 4 branches missed.">            if (!triggerRevalidate &amp;&amp; oldFocus.getParent() != null) {</span>
<span class="fc" id="L2831">                oldFocus.repaint();</span>
            }
        }
        // a listener might trigger a focus change event essentially
        // invalidating focus so we shouldn't break that
<span class="pc bpc" id="L2836" title="1 of 4 branches missed.">        if (focused != null &amp;&amp; this.focused == focused) {</span>
<span class="pc bpc" id="L2837" title="2 of 4 branches missed.">            triggerRevalidate = changeFocusState(focused, true) || triggerRevalidate;</span>
            //if we need to revalidate no need to repaint the Component, it will
            //be painted from the Form
<span class="pc bpc" id="L2840" title="1 of 2 branches missed.">            if (!triggerRevalidate) {</span>
<span class="fc" id="L2841">                focused.repaint();</span>
            }
        }
<span class="pc bpc" id="L2844" title="1 of 2 branches missed.">        if (triggerRevalidate) {</span>
<span class="nc" id="L2845">            revalidateLater();</span>
        }
<span class="fc" id="L2847">    }</span>

    /**
     * {@inheritDoc}
     */
    protected void longKeyPress(int keyCode) {
<span class="nc bnc" id="L2853" title="All 2 branches missed.">        if (focused != null) {</span>
<span class="nc bnc" id="L2854" title="All 2 branches missed.">            if (focused.getComponentForm() == this) {</span>
<span class="nc" id="L2855">                focused.longKeyPress(keyCode);</span>
            }
        }
<span class="nc" id="L2858">    }</span>

    /**
     * {@inheritDoc}
     */
    public void longPointerPress(int x, int y) {
<span class="pc bpc" id="L2864" title="1 of 4 branches missed.">        if (longPressListeners != null &amp;&amp; longPressListeners.hasListeners()) {</span>
<span class="fc" id="L2865">            ActionEvent ev = new ActionEvent(this, ActionEvent.Type.LongPointerPress, x, y);</span>
<span class="fc" id="L2866">            longPressListeners.fireActionEvent(ev);</span>
<span class="pc bpc" id="L2867" title="1 of 2 branches missed.">            if (ev.isConsumed()) {</span>
<span class="nc" id="L2868">                return;</span>
            }
        }
<span class="pc bpc" id="L2871" title="1 of 4 branches missed.">        if (focused != null &amp;&amp; focused.contains(x, y)) {</span>
<span class="pc bpc" id="L2872" title="1 of 2 branches missed.">            if (focused.getComponentForm() == this) {</span>
<span class="fc" id="L2873">                LeadUtil.longPointerPress(focused, x, y);</span>

            }
        }
<span class="fc" id="L2877">    }</span>

    /**
     * Indicates whether this form wants to receive pointerReleased events for touch
     * events that started in a different form
     *
     * @return false by default
     */
    protected boolean shouldSendPointerReleaseToOtherForm() {
<span class="nc" id="L2886">        return false;</span>
    }

    /**
     * Gets the next component in focus traversal order.  This will return the {@link Component#getNextFocusRight() }
     * if it is set.  If not, it will return {@link Component#getNextFocusDown() } if it is set.  If not, it will
     * return the next component according to the traversal order.
     *
     * @param current The current component.
     * @return The next component in the focus traversal order.
     */
    public Component getNextComponent(Component current) {
<span class="nc" id="L2898">        return getTabIterator(current).getNext();</span>
    }

    /**
     * Gets the previous component in focus traversal order.  This will return the {@link Component#getNextFocusLeft() }
     * if it is set.  If not, it will return {@link Component#getNextFocusUp() } if it is set.  If not, it will
     * return the previous component according to the traversal order defined by {@link Form#getTabIterator(com.codename1.ui.Component) }.
     *
     * @param current The current component.
     * @return The previous component in the traversal order.
     */
    public Component getPreviousComponent(Component current) {
<span class="nc" id="L2910">        return getTabIterator(current).getPrevious();</span>
    }

    /**
     * Returns an iterator that iterates over all of the components in this form, ordered
     * by their tab index.
     *
     * @param start The start position.  The iterator will automatically initialized such that {@link ListIterator#next() }
     *              will return the next component in the traversal order, and the {@link ListIterator#previous() } returns the previous
     *              component in traversal order.
     * @return An iterator for the traversal order of the components in this form.
     * @see #getNextComponent(com.codename1.ui.Component)
     * @see #getPreviousComponent(com.codename1.ui.Component)
     * @see Component#getPreferredTabIndex()
     * @see Component#setPreferredTabIndex(int)
     */
    public TabIterator getTabIterator(Component start) {
<span class="fc" id="L2927">        updateTabIndices(0);</span>
<span class="fc" id="L2928">        java.util.List&lt;Component&gt; out = new ArrayList&lt;Component&gt;();</span>
<span class="fc" id="L2929">        out.addAll(ComponentSelector.select(&quot;*&quot;, this).filter(new Filter() {</span>


            public boolean filter(Component c) {
<span class="pc bpc" id="L2933" title="4 of 10 branches missed.">                return c.getTabIndex() &gt;= 0 &amp;&amp; c.isVisible() &amp;&amp; c.isFocusable() &amp;&amp; c.isEnabled() &amp;&amp; !c.isHidden(true);</span>
            }

        }));
<span class="fc" id="L2937">        Collections.sort(out, new Comparator&lt;Component&gt;() {</span>


            public int compare(Component o1, Component o2) {
<span class="nc bnc" id="L2941" title="All 2 branches missed.">                return o1.getTabIndex() &lt; o2.getTabIndex() ? -1 :</span>
<span class="nc bnc" id="L2942" title="All 2 branches missed.">                        o2.getTabIndex() &lt; o1.getTabIndex() ? 1 :</span>
                                0;
            }

        });

<span class="fc" id="L2948">        return new TabIterator(out, start);</span>
    }

    /**
     * {@inheritDoc}
     */
    public void keyPressed(int keyCode) {
<span class="fc" id="L2955">        int game = Display.getInstance().getGameAction(keyCode);</span>
<span class="fc bfc" id="L2956" title="All 2 branches covered.">        if (menuBar.handlesKeycode(keyCode)) {</span>
<span class="fc" id="L2957">            menuBar.keyPressed(keyCode);</span>
<span class="fc" id="L2958">            return;</span>
        }

        //Component focused = focusManager.getFocused();
<span class="fc bfc" id="L2962" title="All 2 branches covered.">        if (focused != null) {</span>
<span class="pc bpc" id="L2963" title="1 of 2 branches missed.">            if (focused.isEnabled()) {</span>
<span class="fc" id="L2964">                focused.keyPressed(keyCode);</span>
            }
<span class="pc bpc" id="L2966" title="1 of 2 branches missed.">            if (focused == null) {</span>
<span class="nc" id="L2967">                initFocused();</span>
<span class="nc" id="L2968">                return;</span>
            }
<span class="pc bpc" id="L2970" title="1 of 2 branches missed.">            if (focused.handlesInput()) {</span>
<span class="nc" id="L2971">                return;</span>
            }
<span class="pc bpc" id="L2973" title="1 of 2 branches missed.">            if (focused.getComponentForm() == this) {</span>
                //if the arrow keys have been pressed update the focus.
<span class="fc" id="L2975">                updateFocus(game);</span>
            } else {
<span class="nc" id="L2977">                initFocused();</span>
            }
        } else {
<span class="fc" id="L2980">            initFocused();</span>
<span class="pc bpc" id="L2981" title="1 of 2 branches missed.">            if (focused == null) {</span>
<span class="nc" id="L2982">                getContentPane().moveScrollTowards(game, null);</span>
            }
        }

<span class="fc" id="L2986">    }</span>

    /**
     * Returns the layout manager of the form's content pane.
     *
     * @see #getActualLayout() For the actual layout of the form.
     */
    public Layout getLayout() {
<span class="fc" id="L2994">        return contentPane.getLayout();</span>
    }

    /**
     * {@inheritDoc}
     */
    public void setLayout(Layout layout) {
<span class="fc bfc" id="L3001" title="All 2 branches covered.">        if (layout instanceof BorderLayout) {</span>
<span class="fc" id="L3002">            setScrollable(false);</span>
        }
<span class="fc" id="L3004">        contentPane.setLayout(layout);</span>
<span class="fc" id="L3005">    }</span>

    /**
     * When set to true the physical back button will minimize the application
     *
     * @return the minimizeOnBack
     */
    public boolean isMinimizeOnBack() {
<span class="nc" id="L3013">        return menuBar.isMinimizeOnBack();</span>
    }

    /**
     * When set to true the physical back button will minimize the application
     *
     * @param minimizeOnBack the minimizeOnBack to set
     */
    public void setMinimizeOnBack(boolean minimizeOnBack) {
<span class="nc" id="L3022">        menuBar.setMinimizeOnBack(minimizeOnBack);</span>
<span class="nc" id="L3023">    }</span>

    /**
     * {@inheritDoc}
     */
    public void keyReleased(int keyCode) {
<span class="fc" id="L3029">        int game = Display.getInstance().getGameAction(keyCode);</span>
<span class="fc bfc" id="L3030" title="All 2 branches covered.">        if (menuBar.handlesKeycode(keyCode)) {</span>
<span class="fc" id="L3031">            menuBar.keyReleased(keyCode);</span>
<span class="fc" id="L3032">            return;</span>
        }

        //Component focused = focusManager.getFocused();
<span class="pc bpc" id="L3036" title="1 of 2 branches missed.">        if (focused != null) {</span>
<span class="pc bpc" id="L3037" title="1 of 2 branches missed.">            if (focused.getComponentForm() == this) {</span>
<span class="pc bpc" id="L3038" title="1 of 2 branches missed.">                if (focused.isEnabled()) {</span>
<span class="fc" id="L3039">                    focused.keyReleased(keyCode);</span>
                }
            }
        }

        // prevent the default action from stealing the behavior from the popup/combo box...
<span class="fc bfc" id="L3045" title="All 2 branches covered.">        if (game == Display.GAME_FIRE) {</span>
<span class="fc" id="L3046">            Command defaultCmd = getDefaultCommand();</span>
<span class="pc bpc" id="L3047" title="1 of 2 branches missed.">            if (defaultCmd != null) {</span>
<span class="nc" id="L3048">                defaultCmd.actionPerformed(new ActionEvent(defaultCmd, keyCode));</span>
<span class="nc" id="L3049">                actionCommandImpl(defaultCmd);</span>
            }
        }
<span class="fc" id="L3052">        fireKeyEvent(keyListeners, keyCode);</span>
<span class="fc" id="L3053">        fireKeyEvent(gameKeyListeners, game);</span>
<span class="fc" id="L3054">    }</span>

    private void fireKeyEvent(HashMap&lt;Integer, ArrayList&lt;ActionListener&gt;&gt; keyListeners, int keyCode) {
<span class="pc bpc" id="L3057" title="1 of 2 branches missed.">        if (keyListeners != null) {</span>
<span class="nc" id="L3058">            ArrayList&lt;ActionListener&gt; listeners = keyListeners.get(Integer.valueOf(keyCode));</span>
<span class="nc bnc" id="L3059" title="All 2 branches missed.">            if (listeners != null) {</span>
<span class="nc" id="L3060">                ActionEvent evt = new ActionEvent(this, keyCode);</span>
<span class="nc bnc" id="L3061" title="All 2 branches missed.">                for (int iter = 0; iter &lt; listeners.size(); iter++) {</span>
<span class="nc" id="L3062">                    listeners.get(iter).actionPerformed(evt);</span>
<span class="nc bnc" id="L3063" title="All 2 branches missed.">                    if (evt.isConsumed()) {</span>
<span class="nc" id="L3064">                        return;</span>
                    }
                }
            }
        }
<span class="fc" id="L3069">    }</span>

    /**
     * {@inheritDoc}
     */
    public void keyRepeated(int keyCode) {
<span class="nc bnc" id="L3075" title="All 2 branches missed.">        if (focused != null) {</span>
<span class="nc bnc" id="L3076" title="All 2 branches missed.">            if (focused.isEnabled()) {</span>
<span class="nc" id="L3077">                focused.keyRepeated(keyCode);</span>
            }
<span class="nc" id="L3079">            int game = Display.getInstance().getGameAction(keyCode);</span>
            // this has issues in the WTK
            // Fix for issue 433: the focus might be changed by the key repeated method in a way that can turn it to null
<span class="nc bnc" id="L3082" title="All 12 branches missed.">            if (focused != null &amp;&amp; !focused.handlesInput()</span>
                    &amp;&amp; (game == Display.GAME_DOWN || game == Display.GAME_UP || game == Display.GAME_LEFT || game == Display.GAME_RIGHT)) {
<span class="nc" id="L3084">                keyPressed(keyCode);</span>
<span class="nc" id="L3085">                keyReleased(keyCode);</span>
            }
<span class="nc" id="L3087">        } else {</span>
<span class="nc" id="L3088">            keyPressed(keyCode);</span>
<span class="nc" id="L3089">            keyReleased(keyCode);</span>
        }
<span class="nc" id="L3091">    }</span>

    private void initRippleEffect(int x, int y, Component cmp) {
<span class="pc bpc" id="L3094" title="1 of 2 branches missed.">        if (cmp.isRippleEffect()) {</span>
<span class="nc" id="L3095">            rippleMotion = Motion.createEaseInMotion(0, 1000, 800);</span>
<span class="nc" id="L3096">            rippleMotion.start();</span>
<span class="nc" id="L3097">            rippleComponent = cmp;</span>
<span class="nc" id="L3098">            rippleX = x;</span>
<span class="nc" id="L3099">            rippleY = y;</span>
        }
<span class="fc" id="L3101">    }</span>

    private void tactileTouchVibe(int x, int y, Component cmp) {
<span class="pc bpc" id="L3104" title="3 of 4 branches missed.">        if (tactileTouchDuration &gt; 0 &amp;&amp; cmp.isTactileTouch(x, y)) {</span>
<span class="nc" id="L3105">            Display.getInstance().vibrate(tactileTouchDuration);</span>
        }
<span class="fc" id="L3107">    }</span>

    //https://github.com/codenameone/CodenameOne/issues/2352
    private void cancelScrolling(Component cmp) {
<span class="nc" id="L3111">        Container parent = cmp.getParent();</span>
        //loop over the parents to check if there is a scrolling
        //gesture that should be stopped
<span class="nc bnc" id="L3114" title="All 2 branches missed.">        while (parent != null) {</span>
<span class="nc bnc" id="L3115" title="All 4 branches missed.">            if (parent.draggedMotionX != null || parent.draggedMotionY != null) {</span>
<span class="nc" id="L3116">                parent.draggedMotionX = null;</span>
<span class="nc" id="L3117">                parent.draggedMotionY = null;</span>
            }
<span class="nc" id="L3119">            parent = parent.getParent();</span>
        }
<span class="nc" id="L3121">    }</span>

    /**
     * This method fixes &lt;a href=&quot;https://github.com/codenameone/CodenameOne/issues/2352&quot;&gt;this tensile drag issue&lt;/a&gt;.
     * However, this might be undesireable in some cases and so this method
     * can be overriden to return false in some cases.
     *
     * @param x the x position of a pointer press operation
     * @param y the y position of a pointer press operation
     * @return true if drag should be resumed and false otherwise
     */
    protected boolean resumeDragAfterScrolling(int x, int y) {
<span class="fc" id="L3133">        Component cmp = getComponentAt(x, y);</span>
<span class="pc bpc" id="L3134" title="2 of 4 branches missed.">        while (cmp != null &amp;&amp; cmp.isIgnorePointerEvents()) {</span>
<span class="nc" id="L3135">            cmp = cmp.getParent();</span>
        }
<span class="pc bpc" id="L3137" title="1 of 2 branches missed.">        if (cmp != null) {</span>
<span class="fc" id="L3138">            cmp = LeadUtil.leadParentImpl(cmp);</span>

<span class="pc bpc" id="L3140" title="1 of 2 branches missed.">            if (isCurrentlyScrolling(cmp)) {</span>
<span class="nc" id="L3141">                cancelScrolling(cmp);</span>
<span class="nc" id="L3142">                cmp.initDragAndDrop(x, y);</span>
<span class="nc" id="L3143">                Display.getInstance().pointerDragged(new int[]{x}, new int[]{y});</span>
<span class="nc" id="L3144">                return true;</span>
            }
        }
<span class="fc" id="L3147">        return false;</span>
    }

    private void setPressedCmp(Component cmp) {
<span class="fc" id="L3151">        cmp = LeadUtil.leadParentImpl(cmp);</span>
<span class="fc" id="L3152">        pressedCmp = cmp;</span>
<span class="fc bfc" id="L3153" title="All 2 branches covered.">        if (cmp == null) {</span>
<span class="fc" id="L3154">            pressedCmpAbsBounds.setBounds(0, 0, 0, 0);</span>
        } else {
<span class="fc" id="L3156">            pressedCmpAbsBounds.setBounds(cmp.getAbsoluteX(), cmp.getAbsoluteY(), cmp.getWidth(), cmp.getHeight());</span>
        }

<span class="fc" id="L3159">    }</span>

    /**
     * Gets the handle for the current pointer press event.  A new object
     * is generated for each pointer press.
     *
     * @return
     * @since 7.0
     */
    Object getCurrentPointerPress() {
<span class="fc" id="L3169">        return currentPointerPress;</span>
    }


    /**
     * {@inheritDoc}
     */
    public void pointerPressed(int x, int y) {
<span class="fc" id="L3177">        currentPointerPress = new Object();</span>
        // See https://github.com/codenameone/CodenameOne/issues/2352
<span class="pc bpc" id="L3179" title="1 of 2 branches missed.">        if (resumeDragAfterScrolling(x, y)) {</span>
<span class="nc" id="L3180">            pointerPressedAgainDuringDrag = true;</span>
<span class="nc" id="L3181">            return;</span>
        }


<span class="fc" id="L3185">        setPressedCmp(null);</span>
<span class="fc" id="L3186">        stickyDrag = null;</span>
<span class="fc" id="L3187">        dragStopFlag = false;</span>
<span class="fc" id="L3188">        dragged = null;</span>
<span class="fc" id="L3189">        boolean isScrollWheeling = Display.impl.isScrollWheeling();</span>
<span class="pc bpc" id="L3190" title="1 of 4 branches missed.">        if (pointerPressedListeners != null &amp;&amp; pointerPressedListeners.hasListeners()) {</span>
<span class="fc" id="L3191">            ActionEvent e = new ActionEvent(this, ActionEvent.Type.PointerPressed, x, y);</span>
<span class="fc" id="L3192">            pointerPressedListeners.fireActionEvent(e);</span>
<span class="pc bpc" id="L3193" title="1 of 2 branches missed.">            if (e.isConsumed()) {</span>
<span class="nc" id="L3194">                return;</span>
            }
        }
        //check if the click is relevant to the menu bar.
        /*
        if (menuBar.contains(x, y)) {
            Component cmp = menuBar.getComponentAt(x, y);
            while (cmp != null &amp;&amp; cmp.isIgnorePointerEvents()) {
                cmp = cmp.getParent();
            }
            if (cmp != null &amp;&amp; cmp.isEnabled()) {
                cmp.pointerPressed(x, y);
                tactileTouchVibe(x, y, cmp);
                initRippleEffect(x, y, cmp);
            }
            return;
        }
        */
<span class="fc" id="L3212">        Container actual = getActualPane(formLayeredPane, x, y);</span>
<span class="pc bpc" id="L3213" title="1 of 4 branches missed.">        if (y &gt;= actual.getY() &amp;&amp; x &gt;= actual.getX()) {</span>
<span class="fc" id="L3214">            Component cmp = actual.getComponentAt(x, y);</span>
<span class="pc bpc" id="L3215" title="2 of 4 branches missed.">            while (cmp != null &amp;&amp; cmp.isIgnorePointerEvents()) {</span>
<span class="nc" id="L3216">                cmp = cmp.getParent();</span>
            }
<span class="pc bpc" id="L3218" title="1 of 2 branches missed.">            if (cmp != null) {</span>


<span class="fc" id="L3221">                cmp = LeadUtil.leadParentImpl(cmp);</span>
<span class="fc" id="L3222">                cmp.initDragAndDrop(x, y);</span>
<span class="fc bfc" id="L3223" title="All 2 branches covered.">                if (!cmp.isDragAndDropInitialized()) {</span>
<span class="fc" id="L3224">                    Container draggableCnt = cmp.getParent();</span>
<span class="fc bfc" id="L3225" title="All 4 branches covered.">                    while (draggableCnt != null &amp;&amp; !draggableCnt.isDraggable()) {</span>
<span class="fc" id="L3226">                        draggableCnt = draggableCnt.getParent();</span>
                    }
<span class="pc bpc" id="L3228" title="2 of 6 branches missed.">                    if (draggableCnt != null &amp;&amp; draggableCnt.isDraggable() &amp;&amp; !(draggableCnt instanceof Form)) {</span>
<span class="fc" id="L3229">                        draggableCnt.initDragAndDrop(x, y);</span>
                    }
                }
<span class="pc bpc" id="L3232" title="1 of 2 branches missed.">                if (isCurrentlyScrolling(cmp)) {</span>
<span class="nc" id="L3233">                    dragStopFlag = true;</span>
<span class="nc" id="L3234">                    cmp.clearDrag();</span>
<span class="nc" id="L3235">                    return;</span>
                }

<span class="fc bfc" id="L3238" title="All 2 branches covered.">                if (cmp.isEnabled()) {</span>
<span class="pc bpc" id="L3239" title="1 of 4 branches missed.">                    if (!isScrollWheeling &amp;&amp; cmp.isFocusable()) {</span>
<span class="fc" id="L3240">                        setFocused(cmp);</span>
                    }
<span class="fc" id="L3242">                    setPressedCmp(cmp);</span>

<span class="fc" id="L3244">                    LeadUtil.pointerPressed(cmp, x, y);</span>
<span class="fc" id="L3245">                    tactileTouchVibe(x, y, cmp);</span>
<span class="fc" id="L3246">                    initRippleEffect(x, y, cmp);</span>
                }

            }
<span class="fc" id="L3250">        } else {</span>
<span class="pc bpc" id="L3251" title="1 of 2 branches missed.">            if (y &lt; actual.getY()) {</span>
<span class="fc" id="L3252">                Component cmp = getTitleArea().getComponentAt(x, y);</span>
<span class="pc bpc" id="L3253" title="2 of 4 branches missed.">                while (cmp != null &amp;&amp; cmp.isIgnorePointerEvents()) {</span>
<span class="nc" id="L3254">                    cmp = cmp.getParent();</span>
                }
<span class="pc bpc" id="L3256" title="1 of 2 branches missed.">                if (cmp != null) {</span>

<span class="fc" id="L3258">                    cmp = LeadUtil.leadParentImpl(cmp);</span>
<span class="fc" id="L3259">                    setPressedCmp(cmp);</span>
<span class="fc" id="L3260">                    LeadUtil.pointerPressed(cmp, x, y);</span>

<span class="fc" id="L3262">                    tactileTouchVibe(x, y, cmp);</span>
<span class="fc" id="L3263">                    initRippleEffect(x, y, cmp);</span>
                }
<span class="fc" id="L3265">            } else {</span>
<span class="nc" id="L3266">                Component cmp = ((BorderLayout) super.getLayout()).getWest();</span>
<span class="nc bnc" id="L3267" title="All 2 branches missed.">                if (cmp != null) {</span>
<span class="nc" id="L3268">                    cmp = ((Container) cmp).getComponentAt(x, y);</span>
<span class="nc bnc" id="L3269" title="All 4 branches missed.">                    while (cmp != null &amp;&amp; cmp.isIgnorePointerEvents()) {</span>
<span class="nc" id="L3270">                        cmp = cmp.getParent();</span>
                    }
<span class="nc bnc" id="L3272" title="All 2 branches missed.">                    if (cmp != null) {</span>
<span class="nc" id="L3273">                        cmp = LeadUtil.leadParentImpl(cmp);</span>
<span class="nc" id="L3274">                        cmp.initDragAndDrop(x, y);</span>

<span class="nc" id="L3276">                        setPressedCmp(cmp);</span>
<span class="nc" id="L3277">                        LeadUtil.pointerPressed(cmp, x, y);</span>
<span class="nc" id="L3278">                        tactileTouchVibe(x, y, cmp);</span>
<span class="nc" id="L3279">                        initRippleEffect(x, y, cmp);</span>
                    }
                }
            }
        }
<span class="fc" id="L3284">        initialPressX = x;</span>
<span class="fc" id="L3285">        initialPressY = y;</span>
<span class="fc" id="L3286">    }</span>

    private boolean isCurrentlyScrolling(Component cmp) {
<span class="fc" id="L3289">        Container parent = cmp.getParent();</span>
        //loop over the parents to check if there is a scrolling 
        //gesture that should be stopped
<span class="fc bfc" id="L3292" title="All 2 branches covered.">        while (parent != null) {</span>
<span class="pc bpc" id="L3293" title="2 of 4 branches missed.">            if (parent.draggedMotionX != null || parent.draggedMotionY != null) {</span>
<span class="nc" id="L3294">                return true;</span>
            }
<span class="fc" id="L3296">            parent = parent.getParent();</span>
        }
<span class="fc" id="L3298">        return false;</span>
    }


    public &lt;C extends Component&gt; void addComponentAwaitingRelease(C c) {
<span class="fc bfc" id="L3303" title="All 2 branches covered.">        if (componentsAwaitingRelease == null) {</span>
<span class="fc" id="L3304">            componentsAwaitingRelease = new ArrayList&lt;Component&gt;();</span>
        }
<span class="fc" id="L3306">        componentsAwaitingRelease.add(c);</span>
<span class="fc" id="L3307">    }</span>

    public &lt;C extends Component&gt; void removeComponentAwaitingRelease(C c) {
<span class="fc bfc" id="L3310" title="All 2 branches covered.">        if (componentsAwaitingRelease != null) {</span>
<span class="fc" id="L3311">            componentsAwaitingRelease.remove(c);</span>
        }
<span class="fc" id="L3313">    }</span>

    public void clearComponentsAwaitingRelease() {
<span class="nc bnc" id="L3316" title="All 2 branches missed.">        if (componentsAwaitingRelease != null) {</span>
<span class="nc" id="L3317">            componentsAwaitingRelease.clear(); //componentsAwatingRelease = null;  //can be set to null or cleared, would be the same. clear may save some unnecessary GC operations when some releasable components are pressed multiple times</span>
        }
<span class="nc" id="L3319">    }</span>


    private void autoRelease(int x, int y) {
<span class="pc bpc" id="L3323" title="1 of 4 branches missed.">        if (componentsAwaitingRelease != null &amp;&amp; componentsAwaitingRelease.size() == 1) {</span>
            // special case allowing drag within a button
<span class="fc" id="L3325">            Component atXY = getComponentAt(x, y);</span>
<span class="pc bpc" id="L3326" title="1 of 2 branches missed.">            if (atXY != null) {</span>
<span class="fc" id="L3327">                atXY = LeadUtil.leadParentImpl(atXY);</span>
            }
<span class="fc" id="L3329">            Component pendingC = componentsAwaitingRelease.get(0);</span>
<span class="pc bpc" id="L3330" title="1 of 2 branches missed.">            if (pendingC != null) {</span>
<span class="fc" id="L3331">                pendingC = LeadUtil.leadParentImpl(pendingC);</span>
            }
<span class="fc" id="L3333">            Component pendingCLead = LeadUtil.leadComponentImpl(pendingC);</span>
<span class="fc bfc" id="L3334" title="All 2 branches covered.">            if (atXY != pendingC) {</span>
<span class="pc bpc" id="L3335" title="1 of 2 branches missed.">                if (pendingCLead instanceof ReleasableComponent) {</span>
<span class="fc" id="L3336">                    ReleasableComponent rc = (ReleasableComponent) pendingCLead;</span>
<span class="fc" id="L3337">                    int relRadius = rc.getReleaseRadius();</span>
<span class="pc bpc" id="L3338" title="1 of 2 branches missed.">                    if (relRadius &gt; 0) {</span>
<span class="nc" id="L3339">                        Rectangle r = new Rectangle(</span>
<span class="nc" id="L3340">                                pendingC.getAbsoluteX() - relRadius,</span>
<span class="nc" id="L3341">                                pendingC.getAbsoluteY() - relRadius,</span>
<span class="nc" id="L3342">                                pendingC.getWidth() + relRadius * 2,</span>
<span class="nc" id="L3343">                                pendingC.getHeight() + relRadius * 2</span>
                        );
<span class="nc bnc" id="L3345" title="All 2 branches missed.">                        if (!r.contains(x, y)) {</span>
<span class="nc" id="L3346">                            componentsAwaitingRelease = null;</span>
<span class="nc" id="L3347">                            LeadUtil.dragInitiated(pendingC);</span>
                        }
<span class="nc" id="L3349">                        return;</span>
                    }
<span class="fc" id="L3351">                    componentsAwaitingRelease = null;</span>
<span class="fc" id="L3352">                    LeadUtil.dragInitiated(pendingC);</span>
<span class="fc" id="L3353">                }</span>
<span class="pc bpc" id="L3354" title="2 of 4 branches missed.">            } else if (pendingCLead instanceof ReleasableComponent &amp;&amp; ((ReleasableComponent) pendingCLead).isAutoRelease()) {</span>
<span class="nc" id="L3355">                componentsAwaitingRelease = null;</span>
<span class="nc" id="L3356">                LeadUtil.dragInitiated(pendingC);</span>
            }
        }
<span class="fc" id="L3359">    }</span>

    /**
     * {@inheritDoc}
     */
    public void pointerDragged(int x, int y) {
        // disable the drag stop flag if we are dragging again
<span class="fc" id="L3366">        boolean isScrollWheeling = Display.impl.isScrollWheeling();</span>
<span class="pc bpc" id="L3367" title="1 of 2 branches missed.">        if (dragStopFlag) {</span>
<span class="nc" id="L3368">            pointerPressed(x, y);</span>
        }
<span class="fc" id="L3370">        autoRelease(x, y);</span>
<span class="fc" id="L3371">        boolean localPointerPressedAgainDuringDrag = pointerPressedAgainDuringDrag;</span>
<span class="fc" id="L3372">        pointerPressedAgainDuringDrag = false;</span>
<span class="fc bfc" id="L3373" title="All 2 branches covered.">        if (pointerDraggedListeners != null) {</span>
<span class="fc" id="L3374">            ActionEvent av = new ActionEvent(this, ActionEvent.Type.PointerDrag, x, y);</span>
<span class="fc" id="L3375">            av.setPointerPressedDuringDrag(localPointerPressedAgainDuringDrag);</span>
<span class="fc" id="L3376">            pointerDraggedListeners.fireActionEvent(av);</span>
<span class="pc bpc" id="L3377" title="1 of 2 branches missed.">            if (av.isConsumed()) {</span>
<span class="nc" id="L3378">                return;</span>
            }
        }

<span class="fc" id="L3382">        rippleMotion = null;</span>

<span class="fc bfc" id="L3384" title="All 2 branches covered.">        if (dragged != null) {</span>
<span class="fc" id="L3385">            LeadUtil.pointerDragged(dragged, x, y);</span>
<span class="fc" id="L3386">            return;</span>
        }

<span class="pc bpc" id="L3389" title="1 of 4 branches missed.">        if (pressedCmp != null &amp;&amp; pressedCmp.isStickyDrag()) {</span>
<span class="fc" id="L3390">            stickyDrag = pressedCmp;</span>
        }

<span class="fc bfc" id="L3393" title="All 2 branches covered.">        if (stickyDrag != null) {</span>
<span class="fc" id="L3394">            LeadUtil.pointerDragged(stickyDrag, x, y);</span>
<span class="fc" id="L3395">            repaint();</span>
<span class="fc" id="L3396">            return;</span>
        }
<span class="fc" id="L3398">        Container actual = getActualPane(formLayeredPane, x, y);</span>
<span class="pc bpc" id="L3399" title="1 of 2 branches missed.">        if (x &lt; actual.getX()) {</span>
            // special case for sidemenu
<span class="nc" id="L3401">            Component cmp = ((BorderLayout) super.getLayout()).getWest();</span>
<span class="nc bnc" id="L3402" title="All 2 branches missed.">            if (cmp != null) {</span>
<span class="nc" id="L3403">                cmp = ((Container) cmp).getComponentAt(x, y);</span>
<span class="nc bnc" id="L3404" title="All 4 branches missed.">                while (cmp != null &amp;&amp; cmp.isIgnorePointerEvents()) {</span>
<span class="nc" id="L3405">                    cmp = cmp.getParent();</span>
                }

<span class="nc bnc" id="L3408" title="All 4 branches missed.">                if (cmp != null &amp;&amp; cmp.isEnabled()) {</span>
<span class="nc" id="L3409">                    cmp.pointerDragged(x, y);</span>
<span class="nc" id="L3410">                    cmp.repaint();</span>
<span class="nc bnc" id="L3411" title="All 4 branches missed.">                    if (cmp == pressedCmp &amp;&amp; cmp.isStickyDrag()) {</span>
<span class="nc" id="L3412">                        stickyDrag = cmp;</span>
                    }
                }
            }
<span class="nc" id="L3416">            return;</span>
        }
<span class="fc" id="L3418">        Component cmp = actual.getComponentAt(x, y);</span>
<span class="pc bpc" id="L3419" title="2 of 4 branches missed.">        while (cmp != null &amp;&amp; cmp.isIgnorePointerEvents()) {</span>
<span class="nc" id="L3420">            cmp = cmp.getParent();</span>
        }
<span class="pc bpc" id="L3422" title="1 of 2 branches missed.">        if (cmp != null) {</span>
<span class="pc bpc" id="L3423" title="2 of 6 branches missed.">            if (!isScrollWheeling &amp;&amp; cmp.isFocusable() &amp;&amp; cmp.isEnabled()) {</span>
<span class="fc" id="L3424">                setFocused(cmp);</span>
            }
<span class="fc" id="L3426">            cmp = LeadUtil.leadParentImpl(cmp);</span>

<span class="fc" id="L3428">            LeadUtil.pointerDragged(cmp, x, y);</span>

<span class="pc bpc" id="L3430" title="1 of 4 branches missed.">            if (cmp == pressedCmp &amp;&amp; cmp.isStickyDrag()) {</span>
<span class="nc" id="L3431">                stickyDrag = cmp;</span>
            }
        }
<span class="fc" id="L3434">    }</span>

    @Override
    public void pointerDragged(int[] x, int[] y) {
        // disable the drag stop flag if we are dragging again
<span class="nc" id="L3439">        boolean isScrollWheeling = Display.impl.isScrollWheeling();</span>
<span class="nc bnc" id="L3440" title="All 2 branches missed.">        if (dragStopFlag) {</span>
<span class="nc" id="L3441">            pointerPressed(x, y);</span>
        }
<span class="nc" id="L3443">        autoRelease(x[0], y[0]);</span>
<span class="nc" id="L3444">        boolean localPointerPressedAgainDuringDrag = pointerPressedAgainDuringDrag;</span>
<span class="nc bnc" id="L3445" title="All 4 branches missed.">        if (pointerDraggedListeners != null &amp;&amp; pointerDraggedListeners.hasListeners()) {</span>
<span class="nc" id="L3446">            ActionEvent av = new ActionEvent(this, ActionEvent.Type.PointerDrag, x[0], y[0]);</span>
<span class="nc" id="L3447">            av.setPointerPressedDuringDrag(localPointerPressedAgainDuringDrag);</span>
<span class="nc" id="L3448">            pointerDraggedListeners.fireActionEvent(av);</span>
<span class="nc bnc" id="L3449" title="All 2 branches missed.">            if (av.isConsumed()) {</span>
<span class="nc" id="L3450">                return;</span>
            }
        }

<span class="nc" id="L3454">        rippleMotion = null;</span>

<span class="nc bnc" id="L3456" title="All 2 branches missed.">        if (dragged != null) {</span>
<span class="nc" id="L3457">            LeadUtil.pointerDragged(dragged, x, y);</span>
<span class="nc" id="L3458">            return;</span>
        }
<span class="nc bnc" id="L3460" title="All 4 branches missed.">        if (pressedCmp != null &amp;&amp; pressedCmp.isStickyDrag()) {</span>
<span class="nc" id="L3461">            stickyDrag = pressedCmp;</span>
        }
<span class="nc bnc" id="L3463" title="All 2 branches missed.">        if (stickyDrag != null) {</span>
<span class="nc" id="L3464">            LeadUtil.pointerDragged(stickyDrag, x, y);</span>
<span class="nc" id="L3465">            repaint();</span>
<span class="nc" id="L3466">            return;</span>
        }
<span class="nc" id="L3468">        Container actual = getActualPane(formLayeredPane, x[0], y[0]);</span>
<span class="nc bnc" id="L3469" title="All 2 branches missed.">        if (x[0] &lt; actual.getX()) {</span>
            // special case for sidemenu
<span class="nc" id="L3471">            Component cmp = ((BorderLayout) super.getLayout()).getWest();</span>
<span class="nc bnc" id="L3472" title="All 2 branches missed.">            if (cmp != null) {</span>
<span class="nc" id="L3473">                cmp = ((Container) cmp).getComponentAt(x[0], y[0]);</span>
<span class="nc bnc" id="L3474" title="All 4 branches missed.">                while (cmp != null &amp;&amp; cmp.isIgnorePointerEvents()) {</span>
<span class="nc" id="L3475">                    cmp = cmp.getParent();</span>
                }
<span class="nc bnc" id="L3477" title="All 4 branches missed.">                if (cmp != null &amp;&amp; cmp.isEnabled()) {</span>
<span class="nc" id="L3478">                    cmp.pointerDragged(x, y);</span>
<span class="nc" id="L3479">                    cmp.repaint();</span>
<span class="nc bnc" id="L3480" title="All 4 branches missed.">                    if (cmp == pressedCmp &amp;&amp; cmp.isStickyDrag()) {</span>
<span class="nc" id="L3481">                        stickyDrag = cmp;</span>
                    }
                }
            }
<span class="nc" id="L3485">            return;</span>
        }
<span class="nc" id="L3487">        Component cmp = actual.getComponentAt(x[0], y[0]);</span>
<span class="nc bnc" id="L3488" title="All 4 branches missed.">        while (cmp != null &amp;&amp; cmp.isIgnorePointerEvents()) {</span>
<span class="nc" id="L3489">            cmp = cmp.getParent();</span>
        }
<span class="nc bnc" id="L3491" title="All 2 branches missed.">        if (cmp != null) {</span>
<span class="nc" id="L3492">            cmp = LeadUtil.leadParentImpl(cmp);</span>


<span class="nc bnc" id="L3495" title="All 6 branches missed.">            if (!isScrollWheeling &amp;&amp; cmp.isFocusable() &amp;&amp; cmp.isEnabled()) {</span>
<span class="nc" id="L3496">                setFocused(cmp);</span>
            }
<span class="nc" id="L3498">            LeadUtil.pointerDragged(cmp, x, y);</span>

<span class="nc bnc" id="L3500" title="All 4 branches missed.">            if (cmp == pressedCmp &amp;&amp; cmp.isStickyDrag()) {</span>
<span class="nc" id="L3501">                stickyDrag = cmp;</span>
            }
        }
<span class="nc" id="L3504">    }</span>


    /**
     * {@inheritDoc}
     */
    public void pointerHoverReleased(int[] x, int[] y) {

<span class="pc bpc" id="L3512" title="1 of 2 branches missed.">        if (dragged != null) {</span>
<span class="nc" id="L3513">            LeadUtil.pointerHoverReleased(dragged, x, y);</span>
<span class="nc" id="L3514">            dragged = null;</span>
<span class="nc" id="L3515">            return;</span>
        }

<span class="fc" id="L3518">        Container actual = getActualPane(formLayeredPane, x[0], y[0]);</span>
<span class="fc" id="L3519">        Component cmp = actual.getComponentAt(x[0], y[0]);</span>
<span class="pc bpc" id="L3520" title="2 of 4 branches missed.">        while (cmp != null &amp;&amp; cmp.isIgnorePointerEvents()) {</span>
<span class="nc" id="L3521">            cmp = cmp.getParent();</span>
        }
<span class="pc bpc" id="L3523" title="1 of 2 branches missed.">        if (cmp != null) {</span>
<span class="fc" id="L3524">            cmp = LeadUtil.leadParentImpl(cmp);</span>
<span class="fc" id="L3525">            LeadUtil.pointerHoverReleased(cmp, x, y);</span>
        }
<span class="fc" id="L3527">    }</span>

    /**
     * {@inheritDoc}
     */
    public void pointerHoverPressed(int[] x, int[] y) {
<span class="fc" id="L3533">        boolean isScrollWheeling = Display.impl.isScrollWheeling();</span>

<span class="fc" id="L3535">        Container actual = getActualPane(formLayeredPane, x[0], y[0]);</span>
<span class="fc" id="L3536">        Component cmp = actual.getComponentAt(x[0], y[0]);</span>
<span class="pc bpc" id="L3537" title="2 of 4 branches missed.">        while (cmp != null &amp;&amp; cmp.isIgnorePointerEvents()) {</span>
<span class="nc" id="L3538">            cmp = cmp.getParent();</span>
        }
<span class="pc bpc" id="L3540" title="1 of 2 branches missed.">        if (cmp != null) {</span>
<span class="fc" id="L3541">            cmp = LeadUtil.leadParentImpl(cmp);</span>


<span class="pc bpc" id="L3544" title="6 of 8 branches missed.">            if (!isScrollWheeling &amp;&amp; cmp.isFocusable() &amp;&amp; cmp.isEnabled() &amp;&amp; !Display.getInstance().isDesktop()) {</span>
<span class="nc" id="L3545">                setFocused(cmp);</span>
            }
<span class="fc" id="L3547">            LeadUtil.pointerHoverPressed(cmp, x, y);</span>
        }
<span class="fc" id="L3549">    }</span>

    /**
     * {@inheritDoc}
     */
    public void pointerHover(int[] x, int[] y) {
<span class="fc" id="L3555">        boolean isScrollWheeling = Display.impl.isScrollWheeling();</span>
<span class="pc bpc" id="L3556" title="1 of 2 branches missed.">        if (dragged != null) {</span>
<span class="nc" id="L3557">            LeadUtil.pointerHover(dragged, x, y);</span>
<span class="nc" id="L3558">            return;</span>
        }

<span class="fc" id="L3561">        Container actual = getActualPane(formLayeredPane, x[0], y[0]);</span>
<span class="pc bpc" id="L3562" title="1 of 2 branches missed.">        if (actual != null) {</span>
<span class="fc" id="L3563">            Component cmp = actual.getComponentAt(x[0], y[0]);</span>
<span class="pc bpc" id="L3564" title="2 of 4 branches missed.">            while (cmp != null &amp;&amp; cmp.isIgnorePointerEvents()) {</span>
<span class="nc" id="L3565">                cmp = cmp.getParent();</span>
            }
<span class="pc bpc" id="L3567" title="1 of 2 branches missed.">            if (cmp != null) {</span>
<span class="fc" id="L3568">                cmp = LeadUtil.leadParentImpl(cmp);</span>

<span class="pc bpc" id="L3570" title="6 of 8 branches missed.">                if (!isScrollWheeling &amp;&amp; cmp.isFocusable() &amp;&amp; cmp.isEnabled() &amp;&amp; !Display.getInstance().isDesktop()) {</span>
<span class="nc" id="L3571">                    setFocused(cmp);</span>
                }
<span class="fc" id="L3573">                LeadUtil.pointerHover(cmp, x, y);</span>
            }
<span class="pc bpc" id="L3575" title="1 of 2 branches missed.">            if (TooltipManager.getInstance() != null) {</span>
<span class="nc" id="L3576">                String tip = cmp.getTooltip();</span>
<span class="nc bnc" id="L3577" title="All 4 branches missed.">                if (tip != null &amp;&amp; tip.length() &gt; 0) {</span>
<span class="nc" id="L3578">                    TooltipManager.getInstance().prepareTooltip(tip, cmp);</span>
                } else {
<span class="nc" id="L3580">                    TooltipManager.getInstance().clearTooltip();</span>
                }
            }
        }
<span class="fc" id="L3584">    }</span>

    /**
     * Returns true if there is only one focusable member in this form. This is useful
     * so setHandlesInput would always be true for this case.
     *
     * @return true if there is one focusable component in this form, false for 0 or more
     */
    public boolean isSingleFocusMode() {
<span class="pc bpc" id="L3593" title="1 of 2 branches missed.">        if (formLayeredPane != null) {</span>
<span class="nc bnc" id="L3594" title="All 2 branches missed.">            return countFocusables(formLayeredPane) + countFocusables(getActualPane()) &lt; 2;</span>
        }
<span class="pc bpc" id="L3596" title="1 of 2 branches missed.">        return isSingleFocusMode(0, getActualPane()) == 1;</span>
    }

    private int countFocusables(Container c) {
<span class="nc" id="L3600">        int count = 0;</span>
<span class="nc" id="L3601">        int t = c.getComponentCount();</span>
<span class="nc bnc" id="L3602" title="All 2 branches missed.">        for (int iter = 0; iter &lt; t; iter++) {</span>
<span class="nc" id="L3603">            Component cmp = c.getComponentAt(iter);</span>
<span class="nc bnc" id="L3604" title="All 2 branches missed.">            if (cmp.isFocusable()) {</span>
<span class="nc" id="L3605">                count++;</span>
            }
<span class="nc bnc" id="L3607" title="All 2 branches missed.">            if (cmp instanceof Container) {</span>
<span class="nc" id="L3608">                count += countFocusables((Container) cmp);</span>
            }
        }
<span class="nc" id="L3611">        return count;</span>
    }

    private int isSingleFocusMode(int b, Container c) {
<span class="fc" id="L3615">        int t = c.getComponentCount();</span>
<span class="fc bfc" id="L3616" title="All 2 branches covered.">        for (int iter = 0; iter &lt; t; iter++) {</span>
<span class="fc" id="L3617">            Component cmp = c.getComponentAt(iter);</span>
<span class="fc bfc" id="L3618" title="All 2 branches covered.">            if (cmp.isFocusable()) {</span>
<span class="fc bfc" id="L3619" title="All 2 branches covered.">                if (b &gt; 0) {</span>
<span class="fc" id="L3620">                    return 2;</span>
                }
<span class="fc" id="L3622">                b = 1;</span>
            }
<span class="fc bfc" id="L3624" title="All 2 branches covered.">            if (cmp instanceof Container) {</span>
<span class="fc" id="L3625">                b = isSingleFocusMode(b, (Container) cmp);</span>
<span class="fc bfc" id="L3626" title="All 2 branches covered.">                if (b &gt; 1) {</span>
<span class="fc" id="L3627">                    return b;</span>
                }
            }
        }
<span class="fc" id="L3631">        return b;</span>
    }


    private boolean fireReleaseListeners(int x, int y) {
<span class="fc bfc" id="L3636" title="All 4 branches covered.">        if (pointerReleasedListeners != null &amp;&amp; pointerReleasedListeners.hasListeners()) {</span>
<span class="fc" id="L3637">            ActionEvent ev = new ActionEvent(this, ActionEvent.Type.PointerReleased, x, y);</span>
<span class="fc" id="L3638">            pointerReleasedListeners.fireActionEvent(ev);</span>
<span class="pc bpc" id="L3639" title="1 of 2 branches missed.">            if (ev.isConsumed()) {</span>
<span class="nc bnc" id="L3640" title="All 2 branches missed.">                if (dragged != null) {</span>
<span class="nc bnc" id="L3641" title="All 2 branches missed.">                    if (dragged.isDragAndDropInitialized()) {</span>
<span class="nc" id="L3642">                        LeadUtil.dragFinished(dragged, x, y);</span>

                    }
<span class="nc" id="L3645">                    dragged = null;</span>
                }
<span class="nc" id="L3647">                return true;</span>
            }
        }
<span class="fc" id="L3650">        return false;</span>
    }

    /**
     * {@inheritDoc}
     */
    public void pointerReleased(int x, int y) {
        try {
<span class="fc" id="L3658">            Component origPressedCmp = pressedCmp;</span>
<span class="fc" id="L3659">            rippleMotion = null;</span>
<span class="fc" id="L3660">            setPressedCmp(null);</span>
<span class="fc" id="L3661">            boolean isScrollWheeling = Display.impl.isScrollWheeling();</span>
<span class="fc" id="L3662">            Container actual = getActualPane(formLayeredPane, x, y);</span>
<span class="pc bpc" id="L3663" title="1 of 4 branches missed.">            if (componentsAwaitingRelease != null &amp;&amp; componentsAwaitingRelease.size() == 1) {</span>
                // special case allowing drag within a button
<span class="fc" id="L3665">                Component atXY = actual.getComponentAt(x, y);</span>
<span class="pc bpc" id="L3666" title="1 of 2 branches missed.">                if (atXY != null) {</span>
<span class="fc" id="L3667">                    atXY = LeadUtil.leadParentImpl(atXY);</span>
                }

<span class="fc" id="L3670">                Component pendingC = componentsAwaitingRelease.get(0);</span>
<span class="pc bpc" id="L3671" title="1 of 2 branches missed.">                if (pendingC != null) {</span>
<span class="fc" id="L3672">                    pendingC = LeadUtil.leadParentImpl(pendingC);</span>
                }
<span class="fc bfc" id="L3674" title="All 2 branches covered.">                if (atXY == pendingC) {</span>
<span class="fc" id="L3675">                    componentsAwaitingRelease = null;</span>
<span class="pc bpc" id="L3676" title="1 of 2 branches missed.">                    if (dragged == pendingC) {</span>
<span class="nc bnc" id="L3677" title="All 2 branches missed.">                        if (pendingC.isDragAndDropInitialized()) {</span>
<span class="nc" id="L3678">                            LeadUtil.dragFinished(pendingC, x, y);</span>
                        } else {
<span class="nc" id="L3680">                            LeadUtil.pointerReleased(pendingC, x, y);</span>
                        }
<span class="nc" id="L3682">                        dragged = null;</span>
                    } else {
<span class="fc" id="L3684">                        LeadUtil.pointerReleased(pendingC, x, y);</span>
<span class="pc bpc" id="L3685" title="1 of 2 branches missed.">                        if (dragged != null) {</span>
<span class="nc bnc" id="L3686" title="All 2 branches missed.">                            if (dragged.isDragAndDropInitialized()) {</span>
<span class="nc" id="L3687">                                LeadUtil.dragFinished(dragged, x, y);</span>
<span class="nc" id="L3688">                                dragged = null;</span>
                            } else {
<span class="nc" id="L3690">                                LeadUtil.pointerReleased(dragged, x, y);</span>
<span class="nc" id="L3691">                                dragged = null;</span>
                            }
                        }
                    }
<span class="fc" id="L3695">                    fireReleaseListeners(x, y);</span>
<span class="fc" id="L3696">                    return;</span>
                }

<span class="pc bpc" id="L3699" title="1 of 2 branches missed.">                if (LeadUtil.leadComponentImpl(pendingC) instanceof ReleasableComponent) {</span>
<span class="fc" id="L3700">                    ReleasableComponent rc = (ReleasableComponent) LeadUtil.leadComponentImpl(pendingC);</span>
<span class="fc" id="L3701">                    int relRadius = rc.getReleaseRadius();</span>
<span class="pc bpc" id="L3702" title="1 of 4 branches missed.">                    if (relRadius &gt; 0 || pendingC.contains(x, y)) {</span>
<span class="fc" id="L3703">                        Rectangle r = new Rectangle(pendingC.getAbsoluteX() - relRadius, pendingC.getAbsoluteY() - relRadius, pendingC.getWidth() + relRadius * 2, pendingC.getHeight() + relRadius * 2);</span>
<span class="pc bpc" id="L3704" title="1 of 2 branches missed.">                        if (r.contains(x, y)) {</span>
<span class="fc" id="L3705">                            componentsAwaitingRelease = null;</span>
<span class="pc bpc" id="L3706" title="1 of 2 branches missed.">                            if (!pendingC.contains(x, y)) {</span>
<span class="nc" id="L3707">                                pointerReleased(pendingC.getAbsoluteX() + 1, pendingC.getAbsoluteY() + 1);</span>
<span class="nc" id="L3708">                                return;</span>
                            }
                        }
                    }
                }
            }
<span class="pc bpc" id="L3714" title="1 of 2 branches missed.">            if (fireReleaseListeners(x, y)) {</span>
<span class="nc" id="L3715">                return;</span>
            }
<span class="pc bpc" id="L3717" title="1 of 2 branches missed.">            if (dragStopFlag) {</span>
<span class="nc bnc" id="L3718" title="All 2 branches missed.">                if (dragged != null) {</span>
<span class="nc bnc" id="L3719" title="All 2 branches missed.">                    if (dragged.isDragAndDropInitialized()) {</span>
<span class="nc" id="L3720">                        LeadUtil.dragFinished(dragged, x, y);</span>

                    }
<span class="nc" id="L3723">                    dragged = null;</span>
                }
<span class="nc" id="L3725">                dragStopFlag = false;</span>

<span class="nc" id="L3727">                return;</span>
            }

<span class="fc bfc" id="L3730" title="All 2 branches covered.">            if (dragged == null) {</span>
                //if the pointer was released on the menu invoke the appropriate
                //soft button.
<span class="fc bfc" id="L3733" title="All 2 branches covered.">                if (origPressedCmp != null) {</span>
                    // The original pressed component should receive a pointer released event even if it falls
                    // outside of the bounds because it may need to know that a drag is complete.
<span class="pc bpc" id="L3736" title="1 of 2 branches missed.">                    if (origPressedCmp.isEnabled()) {</span>
<span class="fc" id="L3737">                        LeadUtil.pointerReleased(origPressedCmp, x, y);</span>
                    }
<span class="fc" id="L3739">                    return;</span>
                }
<span class="pc bpc" id="L3741" title="1 of 2 branches missed.">                if (menuBar.contains(x, y)) {</span>
<span class="nc" id="L3742">                    Component cmp = menuBar.getComponentAt(x, y);</span>
<span class="nc bnc" id="L3743" title="All 4 branches missed.">                    while (cmp != null &amp;&amp; cmp.isIgnorePointerEvents()) {</span>
<span class="nc" id="L3744">                        cmp = cmp.getParent();</span>
                    }
<span class="nc" id="L3746">                    cmp = LeadUtil.leadParentImpl(cmp);</span>
<span class="nc bnc" id="L3747" title="All 2 branches missed.">                    if (cmp.isEnabled()) {</span>
<span class="nc bnc" id="L3748" title="All 4 branches missed.">                        if (!isScrollWheeling &amp;&amp; cmp.isFocusable()) {</span>
<span class="nc" id="L3749">                            setFocused(cmp);</span>
                        }
<span class="nc" id="L3751">                        LeadUtil.pointerReleased(cmp, x, y);</span>
                    }
<span class="nc" id="L3753">                    return;</span>
                }

<span class="pc bpc" id="L3756" title="1 of 2 branches missed.">                if (stickyDrag != null) {</span>
<span class="nc bnc" id="L3757" title="All 2 branches missed.">                    if (stickyDrag.isDragAndDropInitialized()) {</span>
<span class="nc" id="L3758">                        LeadUtil.dragFinished(stickyDrag, x, y);</span>
                    } else {
<span class="nc" id="L3760">                        LeadUtil.pointerReleased(stickyDrag, x, y);</span>
                    }
<span class="nc" id="L3762">                    repaint();</span>
                } else {
                    //Container actual = getActualPane();
<span class="pc bpc" id="L3765" title="2 of 4 branches missed.">                    if (y &gt;= actual.getY() &amp;&amp; x &gt;= actual.getX()) {</span>
<span class="fc" id="L3766">                        Component cmp = actual.getComponentAt(x, y);</span>
<span class="pc bpc" id="L3767" title="2 of 4 branches missed.">                        while (cmp != null &amp;&amp; cmp.isIgnorePointerEvents()) {</span>
<span class="nc" id="L3768">                            cmp = cmp.getParent();</span>
                        }
<span class="pc bpc" id="L3770" title="2 of 4 branches missed.">                        if (cmp != null &amp;&amp; cmp.isEnabled()) {</span>
<span class="fc" id="L3771">                            cmp = LeadUtil.leadParentImpl(cmp);</span>

<span class="pc bpc" id="L3773" title="1 of 2 branches missed.">                            if (cmp.isEnabled()) {</span>
<span class="pc bpc" id="L3774" title="2 of 4 branches missed.">                                if (!isScrollWheeling &amp;&amp; cmp.isFocusable()) {</span>
<span class="fc" id="L3775">                                    setFocused(cmp);</span>
                                }
<span class="fc" id="L3777">                                LeadUtil.pointerReleased(cmp, x, y);</span>
                            }
                        }
<span class="fc" id="L3780">                    } else {</span>
<span class="nc bnc" id="L3781" title="All 2 branches missed.">                        if (y &lt; actual.getY()) {</span>
<span class="nc" id="L3782">                            Component cmp = getTitleArea().getComponentAt(x, y);</span>
<span class="nc bnc" id="L3783" title="All 4 branches missed.">                            while (cmp != null &amp;&amp; cmp.isIgnorePointerEvents()) {</span>
<span class="nc" id="L3784">                                cmp = cmp.getParent();</span>
                            }

<span class="nc bnc" id="L3787" title="All 2 branches missed.">                            if (cmp != null) {</span>
<span class="nc" id="L3788">                                cmp = LeadUtil.leadParentImpl(cmp);</span>

<span class="nc bnc" id="L3790" title="All 6 branches missed.">                                if (cmp.isEnabled() &amp;&amp; !isScrollWheeling &amp;&amp; cmp.isFocusable()) {</span>
<span class="nc" id="L3791">                                    setFocused(cmp);</span>
                                }
<span class="nc" id="L3793">                                LeadUtil.pointerReleased(cmp, x, y);</span>
                            }
<span class="nc" id="L3795">                        } else {</span>
<span class="nc" id="L3796">                            Component cmp = ((BorderLayout) super.getLayout()).getWest();</span>
<span class="nc bnc" id="L3797" title="All 2 branches missed.">                            if (cmp != null) {</span>
<span class="nc" id="L3798">                                cmp = ((Container) cmp).getComponentAt(x, y);</span>
<span class="nc bnc" id="L3799" title="All 4 branches missed.">                                while (cmp != null &amp;&amp; cmp.isIgnorePointerEvents()) {</span>
<span class="nc" id="L3800">                                    cmp = cmp.getParent();</span>
                                }
<span class="nc bnc" id="L3802" title="All 2 branches missed.">                                if (cmp != null) {</span>

<span class="nc" id="L3804">                                    cmp = LeadUtil.leadParentImpl(cmp);</span>

<span class="nc bnc" id="L3806" title="All 6 branches missed.">                                    if (!isScrollWheeling &amp;&amp; cmp.isEnabled() &amp;&amp; cmp.isFocusable()) {</span>
<span class="nc" id="L3807">                                        setFocused(cmp);</span>
                                    }
<span class="nc" id="L3809">                                    LeadUtil.pointerReleased(cmp, x, y);</span>

                                }
                            }
<span class="nc" id="L3813">                        }</span>
                    }
                }
            } else {
<span class="fc bfc" id="L3817" title="All 2 branches covered.">                if (dragged.isDragAndDropInitialized()) {</span>
<span class="fc" id="L3818">                    LeadUtil.dragFinished(dragged, x, y);</span>
<span class="fc" id="L3819">                    dragged = null;</span>
                } else {
<span class="fc" id="L3821">                    LeadUtil.pointerReleased(dragged, x, y);</span>
<span class="fc" id="L3822">                    dragged = null;</span>
                }
            }
<span class="fc" id="L3825">            stickyDrag = null;</span>
<span class="pc bpc" id="L3826" title="3 of 4 branches missed.">            if (componentsAwaitingRelease != null &amp;&amp; !Display.getInstance().isRecursivePointerRelease()) {</span>
<span class="nc bnc" id="L3827" title="All 2 branches missed.">                for (int iter = 0; iter &lt; componentsAwaitingRelease.size(); iter++) {</span>
<span class="nc" id="L3828">                    Component c = componentsAwaitingRelease.get(iter);</span>
<span class="nc bnc" id="L3829" title="All 2 branches missed.">                    if (LeadUtil.leadComponentImpl(c) instanceof ReleasableComponent) {</span>
<span class="nc" id="L3830">                        ReleasableComponent rc = (ReleasableComponent) LeadUtil.leadComponentImpl(c);</span>
<span class="nc" id="L3831">                        rc.setReleased();</span>
                    }
                }
<span class="nc" id="L3834">                componentsAwaitingRelease = null;</span>
            }
        } finally {
<span class="fc" id="L3837">            currentPointerPress = null;</span>
        }
<span class="fc" id="L3839">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isScrollVisible() {
<span class="nc" id="L3846">        return getContentPane().isScrollVisible();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void setScrollVisible(boolean isScrollVisible) {
<span class="nc" id="L3854">        getContentPane().setScrollVisible(isScrollVisible);</span>
<span class="nc" id="L3855">    }</span>

    /**
     * {@inheritDoc}
     */
    public int getComponentIndex(Component cmp) {
<span class="nc" id="L3861">        return getContentPane().getComponentIndex(cmp);</span>
    }

    /**
     * Adds a command to the menu bar softkeys or into the menu dialog,
     * this version of add allows us to place a command in an arbitrary location.
     * This allows us to force a command into the softkeys when order of command
     * addition can't be changed.
     *
     * @param cmd    the Form command to be added
     * @param offset position in which the command is added
     * @deprecated Please use {@link Toolbar#addCommandToLeftBar(com.codename1.ui.Command)} or similar methods
     */
    public void addCommand(Command cmd, int offset) {
<span class="fc" id="L3875">        menuBar.addCommand(cmd, offset);</span>
<span class="fc" id="L3876">    }</span>

    /**
     * A helper method to check the amount of commands within the form menu
     *
     * @return the number of commands
     * @deprecated Please use {@link Toolbar#getComponentCount()} or similar methods
     */
    public int getCommandCount() {
<span class="fc" id="L3885">        return menuBar.getCommandCount();</span>
    }

    /**
     * Returns the command occupying the given index
     *
     * @param index offset of the command
     * @return the command at the given index
     */
    public Command getCommand(int index) {
<span class="fc" id="L3895">        return menuBar.getCommand(index);</span>
    }

    /**
     * Adds a command to the menu bar softkeys.
     * The Commands are placed in the order they are added.
     * If the Form has 1 Command it will be placed on the right.
     * If the Form has 2 Commands the first one that was added will be placed on
     * the right and the second one will be placed on the left.
     * If the Form has more then 2 Commands the first one will stay on the left
     * and a Menu will be added with all the remain Commands.
     *
     * @param cmd the Form command to be added
     * @deprecated Please use {@link Toolbar#addCommandToLeftBar(com.codename1.ui.Command)} or similar methods
     */
    public void addCommand(Command cmd) {
        //menuBar.addCommand(cmd);
<span class="fc" id="L3912">        addCommand(cmd, 0);</span>
<span class="fc" id="L3913">    }</span>

    /**
     * Removes the command from the menu bar softkeys
     *
     * @param cmd the Form command to be removed
     */
    public void removeCommand(Command cmd) {
<span class="fc" id="L3921">        menuBar.removeCommand(cmd);</span>
<span class="fc" id="L3922">    }</span>

    private Component findNextFocusHorizontal(Component focused, Component bestCandidate, Container root, boolean right) {
<span class="nc" id="L3925">        int count = root.getComponentCount();</span>
<span class="nc bnc" id="L3926" title="All 2 branches missed.">        for (int iter = 0; iter &lt; count; iter++) {</span>
<span class="nc" id="L3927">            Component current = root.getComponentAt(iter);</span>
<span class="nc bnc" id="L3928" title="All 2 branches missed.">            if (current.isFocusable()) {</span>
<span class="nc bnc" id="L3929" title="All 2 branches missed.">                if (isInSameRow(focused, current)) {</span>
<span class="nc" id="L3930">                    int currentX = current.getAbsoluteX();</span>
<span class="nc" id="L3931">                    int focusedX = focused.getAbsoluteX();</span>
<span class="nc bnc" id="L3932" title="All 2 branches missed.">                    if (right) {</span>
<span class="nc bnc" id="L3933" title="All 2 branches missed.">                        if (focusedX &lt; currentX) {</span>
<span class="nc bnc" id="L3934" title="All 2 branches missed.">                            if (bestCandidate != null) {</span>
<span class="nc bnc" id="L3935" title="All 2 branches missed.">                                if (bestCandidate.getAbsoluteX() &lt; currentX) {</span>
<span class="nc" id="L3936">                                    continue;</span>
                                }
                            }
<span class="nc" id="L3939">                            bestCandidate = current;</span>
                        }
                    } else {
<span class="nc bnc" id="L3942" title="All 2 branches missed.">                        if (focusedX &gt; currentX) {</span>
<span class="nc bnc" id="L3943" title="All 2 branches missed.">                            if (bestCandidate != null) {</span>
<span class="nc bnc" id="L3944" title="All 2 branches missed.">                                if (bestCandidate.getAbsoluteX() &gt; currentX) {</span>
<span class="nc" id="L3945">                                    continue;</span>
                                }
                            }
<span class="nc" id="L3948">                            bestCandidate = current;</span>
                        }
                    }
                }
            }
<span class="nc bnc" id="L3953" title="All 4 branches missed.">            if (current instanceof Container &amp;&amp; !(((Container) current).isBlockFocus())) {</span>
<span class="nc" id="L3954">                bestCandidate = findNextFocusHorizontal(focused, bestCandidate, (Container) current, right);</span>
            }
        }
<span class="nc" id="L3957">        return bestCandidate;</span>
    }

    private Component findNextFocusVertical(Component focused, Component bestCandidate, Container root, boolean down) {
<span class="nc" id="L3961">        int count = root.getComponentCount();</span>
<span class="nc bnc" id="L3962" title="All 2 branches missed.">        for (int iter = 0; iter &lt; count; iter++) {</span>
<span class="nc" id="L3963">            Component current = root.getComponentAt(iter);</span>
<span class="nc bnc" id="L3964" title="All 2 branches missed.">            if (current.isFocusable()) {</span>
<span class="nc" id="L3965">                int currentY = current.getAbsoluteY();</span>
<span class="nc" id="L3966">                int focusedY = 0;</span>
<span class="nc bnc" id="L3967" title="All 2 branches missed.">                if (focused != null) {</span>
<span class="nc" id="L3968">                    focusedY = focused.getAbsoluteY();</span>
                }
<span class="nc bnc" id="L3970" title="All 2 branches missed.">                if (down) {</span>
<span class="nc bnc" id="L3971" title="All 2 branches missed.">                    if (focusedY &lt; currentY) {</span>
<span class="nc bnc" id="L3972" title="All 2 branches missed.">                        if (bestCandidate != null) {</span>
<span class="nc" id="L3973">                            boolean exitingInSame = isInSameColumn(focused, bestCandidate);</span>
<span class="nc bnc" id="L3974" title="All 2 branches missed.">                            if (bestCandidate.getAbsoluteY() &lt; currentY) {</span>
<span class="nc bnc" id="L3975" title="All 2 branches missed.">                                if (exitingInSame) {</span>
<span class="nc" id="L3976">                                    continue;</span>
                                }
<span class="nc bnc" id="L3978" title="All 4 branches missed.">                                if (isInSameRow(current, bestCandidate) &amp;&amp; !isInSameColumn(focused, current)) {</span>
<span class="nc" id="L3979">                                    continue;</span>
                                }
                            }
<span class="nc bnc" id="L3982" title="All 4 branches missed.">                            if (exitingInSame &amp;&amp; isInSameRow(current, bestCandidate)) {</span>
<span class="nc" id="L3983">                                continue;</span>
                            }
                        }
<span class="nc" id="L3986">                        bestCandidate = current;</span>
                    }
                } else {
<span class="nc bnc" id="L3989" title="All 2 branches missed.">                    if (focusedY &gt; currentY) {</span>
<span class="nc bnc" id="L3990" title="All 2 branches missed.">                        if (bestCandidate != null) {</span>
<span class="nc" id="L3991">                            boolean exitingInSame = isInSameColumn(focused, bestCandidate);</span>
<span class="nc bnc" id="L3992" title="All 2 branches missed.">                            if (bestCandidate.getAbsoluteY() &gt; currentY) {</span>
<span class="nc bnc" id="L3993" title="All 2 branches missed.">                                if (exitingInSame) {</span>
<span class="nc" id="L3994">                                    continue;</span>
                                }
<span class="nc bnc" id="L3996" title="All 4 branches missed.">                                if (isInSameRow(current, bestCandidate) &amp;&amp; !isInSameColumn(focused, current)) {</span>
<span class="nc" id="L3997">                                    continue;</span>
                                }
                            }
<span class="nc bnc" id="L4000" title="All 4 branches missed.">                            if (exitingInSame &amp;&amp; isInSameRow(current, bestCandidate)) {</span>
<span class="nc" id="L4001">                                continue;</span>
                            }
                        }
<span class="nc" id="L4004">                        bestCandidate = current;</span>
                    }
                }
            }
<span class="nc bnc" id="L4008" title="All 4 branches missed.">            if (current instanceof Container &amp;&amp; !(((Container) current).isBlockFocus())) {</span>
<span class="nc" id="L4009">                bestCandidate = findNextFocusVertical(focused, bestCandidate, (Container) current, down);</span>
            }
        }
<span class="nc" id="L4012">        return bestCandidate;</span>
    }

    /**
     * This method returns the next focusable Component vertically
     *
     * &lt;p&gt;NOTE:  This method does NOT make use of {@link Component#getNextFocusDown() } or {@link Component#getNextFocusUp() }.
     * It simply finds the next focusable component on the form based solely on absolute Y coordinate.&lt;/p&gt;
     *
     * @param down if true will the return the next focusable on the bottom else
     *             on the top
     * @return a focusable Component or null if not found
     */
    public Component findNextFocusVertical(boolean down) {
<span class="nc" id="L4026">        Component c = null;</span>
<span class="nc bnc" id="L4027" title="All 2 branches missed.">        if (formLayeredPane != null) {</span>
<span class="nc" id="L4028">            c = findNextFocusVertical(focused, null, formLayeredPane, down);</span>
<span class="nc bnc" id="L4029" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc" id="L4030">                return c;</span>
            }
        }
<span class="nc" id="L4033">        Container actual = getActualPane();</span>
<span class="nc" id="L4034">        c = findNextFocusVertical(focused, null, actual, down);</span>
<span class="nc bnc" id="L4035" title="All 2 branches missed.">        if (c != null) {</span>
<span class="nc" id="L4036">            return c;</span>
        }
<span class="nc bnc" id="L4038" title="All 2 branches missed.">        if (cyclicFocus) {</span>
<span class="nc bnc" id="L4039" title="All 2 branches missed.">            c = findNextFocusVertical(focused, null, actual, !down);</span>
<span class="nc bnc" id="L4040" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc bnc" id="L4041" title="All 2 branches missed.">                Component current = findNextFocusVertical(c, null, actual, !down);</span>
<span class="nc bnc" id="L4042" title="All 2 branches missed.">                while (current != null) {</span>
<span class="nc" id="L4043">                    c = current;</span>
<span class="nc bnc" id="L4044" title="All 2 branches missed.">                    current = findNextFocusVertical(c, null, actual, !down);</span>
                }
<span class="nc" id="L4046">                return c;</span>
            }
        }
<span class="nc" id="L4049">        return null;</span>
    }

    /**
     * This method returns the next focusable Component horizontally
     *
     * &lt;p&gt;NOTE:  This method does NOT make use of {@link Component#getNextFocusLeft() } or {@link Component#getNextFocusRight() }.
     * It simply finds the next focusable component on the form based solely on absolute X coordinate.&lt;/p&gt;
     *
     * @param right if true will the return the next focusable on the right else
     *              on the left
     * @return a focusable Component or null if not found
     */
    public Component findNextFocusHorizontal(boolean right) {
<span class="nc" id="L4063">        Component c = null;</span>
<span class="nc bnc" id="L4064" title="All 2 branches missed.">        if (formLayeredPane != null) {</span>
<span class="nc" id="L4065">            c = findNextFocusHorizontal(focused, null, formLayeredPane, right);</span>
<span class="nc bnc" id="L4066" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc" id="L4067">                return c;</span>
            }
        }
<span class="nc" id="L4070">        Container actual = getActualPane();</span>
<span class="nc" id="L4071">        c = findNextFocusHorizontal(focused, null, actual, right);</span>
<span class="nc bnc" id="L4072" title="All 2 branches missed.">        if (c != null) {</span>
<span class="nc" id="L4073">            return c;</span>
        }
<span class="nc bnc" id="L4075" title="All 2 branches missed.">        if (cyclicFocus) {</span>
<span class="nc bnc" id="L4076" title="All 2 branches missed.">            c = findNextFocusHorizontal(focused, null, actual, !right);</span>
<span class="nc bnc" id="L4077" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc bnc" id="L4078" title="All 2 branches missed.">                Component current = findNextFocusHorizontal(c, null, actual, !right);</span>
<span class="nc bnc" id="L4079" title="All 2 branches missed.">                while (current != null) {</span>
<span class="nc" id="L4080">                    c = current;</span>
<span class="nc bnc" id="L4081" title="All 2 branches missed.">                    current = findNextFocusHorizontal(c, null, actual, !right);</span>
                }
<span class="nc" id="L4083">                return c;</span>
            }
        }
<span class="nc" id="L4086">        return null;</span>
    }

    /**
     * Finds next focusable component.  This will first check {@link Component#getNextFocusDown() }
     * on the currently focused component.  Failing that it will scan the form based on Y-coord.
     *
     * @return
     */
    Component findNextFocusDown() {
<span class="nc bnc" id="L4096" title="All 2 branches missed.">        if (focused != null) {</span>
<span class="nc bnc" id="L4097" title="All 2 branches missed.">            if (focused.getNextFocusDown() != null) {</span>
<span class="nc" id="L4098">                return focused.getNextFocusDown();</span>
            }
<span class="nc" id="L4100">            return findNextFocusVertical(true);</span>
        }
<span class="nc" id="L4102">        return null;</span>
    }

    /**
     * Finds next focusable component in upward direction.  This will first check {@link Component#getNextFocusUp() }
     * on the currently focused component.  Failing that it will scan the form based on Y-coord.
     *
     * @return
     */
    Component findNextFocusUp() {
<span class="nc bnc" id="L4112" title="All 2 branches missed.">        if (focused != null) {</span>
<span class="nc bnc" id="L4113" title="All 2 branches missed.">            if (focused.getNextFocusUp() != null) {</span>
<span class="nc" id="L4114">                return focused.getNextFocusUp();</span>
            }
<span class="nc" id="L4116">            return findNextFocusVertical(false);</span>
        }
<span class="nc" id="L4118">        return null;</span>
    }

    /**
     * Finds next focusable component in rightward direction.  This will first check {@link Component#getNextFocusRight() }
     * on the currently focused component.  Failing that it will scan the form based on X-coord.
     *
     * @return
     */
    Component findNextFocusRight() {
<span class="nc bnc" id="L4128" title="All 2 branches missed.">        if (focused != null) {</span>
<span class="nc bnc" id="L4129" title="All 2 branches missed.">            if (focused.getNextFocusRight() != null) {</span>
<span class="nc" id="L4130">                return focused.getNextFocusRight();</span>
            }
<span class="nc" id="L4132">            return findNextFocusHorizontal(true);</span>
        }
<span class="nc" id="L4134">        return null;</span>
    }

    /**
     * Finds next focusable component in leftward direction.  This will first check {@link Component#getNextFocusLeft() }
     * on the currently focused component.  Failing that it will scan the form based on X-coord.
     *
     * @return
     */
    Component findNextFocusLeft() {
<span class="nc bnc" id="L4144" title="All 2 branches missed.">        if (focused != null) {</span>
<span class="nc bnc" id="L4145" title="All 2 branches missed.">            if (focused.getNextFocusLeft() != null) {</span>
<span class="nc" id="L4146">                return focused.getNextFocusLeft();</span>
            }
<span class="nc" id="L4148">            return findNextFocusHorizontal(false);</span>
        }
<span class="nc" id="L4150">        return null;</span>
    }

    /**
     * Indicates whether focus should cycle within the form
     *
     * @return true if focus should cycle
     */
    public boolean isCyclicFocus() {
<span class="nc" id="L4159">        return cyclicFocus;</span>
    }

    /**
     * Indicates whether focus should cycle within the form
     *
     * @param cyclicFocus marks whether focus should cycle
     */
    public void setCyclicFocus(boolean cyclicFocus) {
<span class="nc" id="L4168">        this.cyclicFocus = cyclicFocus;</span>
<span class="nc" id="L4169">    }</span>

    private void updateFocus(int gameAction) {
<span class="fc" id="L4172">        Component focused = getFocused();</span>
<span class="pc bpc" id="L4173" title="4 of 5 branches missed.">        switch (gameAction) {</span>
            case Display.GAME_DOWN: {
<span class="nc" id="L4175">                Component down = findNextFocusDown();</span>
<span class="nc bnc" id="L4176" title="All 2 branches missed.">                if (down != null) {</span>
<span class="nc" id="L4177">                    focused = down;</span>
                }
                break;
            }
            case Display.GAME_UP: {
<span class="nc" id="L4182">                Component up = findNextFocusUp();</span>
<span class="nc bnc" id="L4183" title="All 2 branches missed.">                if (up != null) {</span>
<span class="nc" id="L4184">                    focused = up;</span>
                }
                break;
            }
            case Display.GAME_RIGHT: {
<span class="nc" id="L4189">                Component right = findNextFocusRight();</span>
<span class="nc bnc" id="L4190" title="All 2 branches missed.">                if (right != null) {</span>
<span class="nc" id="L4191">                    focused = right;</span>
                }
                break;
            }
            case Display.GAME_LEFT: {
<span class="nc" id="L4196">                Component left = findNextFocusLeft();</span>
<span class="nc bnc" id="L4197" title="All 2 branches missed.">                if (left != null) {</span>
<span class="nc" id="L4198">                    focused = left;</span>
                }
                break;
            }
            default:
<span class="fc" id="L4203">                return;</span>
        }

        //if focused is now visible we need to give it the focus.
<span class="nc bnc" id="L4207" title="All 2 branches missed.">        if (isFocusScrolling()) {</span>
<span class="nc" id="L4208">            setFocused(focused);</span>
<span class="nc bnc" id="L4209" title="All 2 branches missed.">            if (focused != null) {</span>
<span class="nc" id="L4210">                scrollComponentToVisible(focused);</span>
            }
        } else {
<span class="nc bnc" id="L4213" title="All 2 branches missed.">            if (moveScrollTowards(gameAction, focused)) {</span>
<span class="nc" id="L4214">                setFocused(focused);</span>
<span class="nc" id="L4215">                scrollComponentToVisible(focused);</span>
            }
        }

<span class="nc" id="L4219">    }</span>

    /**
     * {@inheritDoc}
     */
    boolean moveScrollTowards(int direction, Component c) {
        //if the current focus item is in a scrollable Container
        //try and move it first
<span class="nc" id="L4227">        Component current = getFocused();</span>
<span class="nc bnc" id="L4228" title="All 2 branches missed.">        if (current != null) {</span>
            Container parent;
<span class="nc bnc" id="L4230" title="All 2 branches missed.">            if (current instanceof Container) {</span>
<span class="nc" id="L4231">                parent = (Container) current;</span>
            } else {
<span class="nc" id="L4233">                parent = current.getParent();</span>
            }
<span class="nc bnc" id="L4235" title="All 2 branches missed.">            while (parent != null) {</span>
<span class="nc bnc" id="L4236" title="All 2 branches missed.">                if (parent == this) {</span>
<span class="nc bnc" id="L4237" title="All 2 branches missed.">                    if (getContentPane().isScrollable()) {</span>
<span class="nc" id="L4238">                        getContentPane().moveScrollTowards(direction, c);</span>
                    }

                } else {
<span class="nc bnc" id="L4242" title="All 2 branches missed.">                    if (parent.isScrollable()) {</span>
<span class="nc" id="L4243">                        return parent.moveScrollTowards(direction, c);</span>
                    }
                }
<span class="nc" id="L4246">                parent = parent.getParent();</span>
            }
        }

<span class="nc" id="L4250">        return true;</span>
    }

    /**
     * Initiates a quick drag event on all containers of this form that have a negative scroll position.
     * Sometimes, after editing, or on a screen-size change, scroll positions can get caught in a
     * negative position, and need to be reset.  This is primarily to solve https://github.com/codenameone/CodenameOne/issues/2476
     */
    void fixNegativeScrolls() {
<span class="nc" id="L4259">        java.util.Set&lt;Component&gt; negativeScrolls = getContentPane().findNegativeScrolls(new java.util.HashSet&lt;Component&gt;());</span>
<span class="nc bnc" id="L4260" title="All 2 branches missed.">        for (Component cmp : negativeScrolls) {</span>
<span class="nc" id="L4261">            int x = cmp.getAbsoluteX() + cmp.getWidth() / 2;</span>
<span class="nc" id="L4262">            int y = cmp.getAbsoluteY() + cmp.getHeight() / 2;</span>
<span class="nc" id="L4263">            cmp.pointerPressed(x, y);</span>
<span class="nc" id="L4264">            cmp.pointerDragged(x, y);</span>
<span class="nc" id="L4265">            cmp.pointerReleased(x, y);</span>
<span class="nc" id="L4266">        }</span>
<span class="nc" id="L4267">    }</span>

    /**
     * Makes sure the component is visible in the scroll if this container
     * is scrollable
     *
     * @param c the componant to be visible
     */
    public void scrollComponentToVisible(Component c) {
<span class="fc" id="L4276">        initFocused();</span>
<span class="fc" id="L4277">        Container parent = c.getParent();</span>
<span class="fc bfc" id="L4278" title="All 2 branches covered.">        while (parent != null) {</span>
<span class="pc bpc" id="L4279" title="1 of 2 branches missed.">            if (parent.isScrollable()) {</span>
<span class="nc bnc" id="L4280" title="All 2 branches missed.">                if (parent == this) {</span>
                    // special case for Form
<span class="nc bnc" id="L4282" title="All 2 branches missed.">                    if (getContentPane().isScrollable()) {</span>
<span class="nc" id="L4283">                        getContentPane().scrollComponentToVisible(c);</span>
                    }
                } else {
<span class="nc" id="L4286">                    parent.scrollComponentToVisible(c);</span>
                }
<span class="nc" id="L4288">                return;</span>
            }
<span class="fc" id="L4290">            parent = parent.getParent();</span>
        }
<span class="fc" id="L4292">    }</span>

    /**
     * Determine the cell renderer used to render menu elements for themeing the
     * look of the menu options
     *
     * @param menuCellRenderer the menu cell renderer
     */
    public void setMenuCellRenderer(ListCellRenderer menuCellRenderer) {
<span class="nc" id="L4301">        menuBar.setMenuCellRenderer(menuCellRenderer);</span>
<span class="nc" id="L4302">    }</span>

    /**
     * Clear menu commands from the menu bar
     */
    public void removeAllCommands() {
<span class="nc" id="L4308">        menuBar.removeAllCommands();</span>
<span class="nc" id="L4309">    }</span>

    /**
     * Request focus for a form child component
     *
     * @param cmp the form child component
     */
    void requestFocus(Component cmp) {
<span class="pc bpc" id="L4317" title="1 of 4 branches missed.">        if (cmp.isFocusable() &amp;&amp; contains(cmp)) {</span>
<span class="fc" id="L4318">            scrollComponentToVisible(cmp);</span>
<span class="fc" id="L4319">            setFocused(cmp);</span>
        }
<span class="fc" id="L4321">    }</span>

    /**
     * {@inheritDoc}
     */
    public void setRTL(boolean r) {
<span class="nc" id="L4327">        super.setRTL(r);</span>
<span class="nc" id="L4328">        contentPane.setRTL(r);</span>
<span class="nc" id="L4329">    }</span>

    /**
     * {@inheritDoc}
     */
    public void paint(Graphics g) {
<span class="fc bfc" id="L4335" title="All 2 branches covered.">        if (!inInternalPaint) {</span>
<span class="fc" id="L4336">            paintComponentBackground(g);</span>
        }
<span class="fc" id="L4338">        super.paint(g);</span>
<span class="fc bfc" id="L4339" title="All 2 branches covered.">        if (tint) {</span>
<span class="fc" id="L4340">            g.setColor(tintColor);</span>
<span class="fc" id="L4341">            g.fillRect(0, 0, getWidth(), getHeight(), (byte) ((tintColor &gt;&gt; 24) &amp; 0xff));</span>
        }
<span class="fc" id="L4343">    }</span>

    void internalPaintImpl(Graphics g, boolean paintIntersects) {
        // workaround for form drawing its background twice on standard paint
<span class="fc" id="L4347">        inInternalPaint = true;</span>
<span class="fc" id="L4348">        super.internalPaintImpl(g, paintIntersects);</span>
<span class="fc" id="L4349">        inInternalPaint = false;</span>
<span class="fc" id="L4350">    }</span>

    /**
     * {@inheritDoc}
     */
    public boolean isScrollable() {
<span class="fc" id="L4356">        return getContentPane().isScrollable();</span>
    }

    /**
     * {@inheritDoc}
     */
    public void setScrollable(boolean scrollable) {
<span class="fc" id="L4363">        getContentPane().setScrollable(scrollable);</span>
<span class="fc" id="L4364">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isScrollableX() {
<span class="fc" id="L4371">        return getContentPane().isScrollableX();</span>
    }

    /**
     * {@inheritDoc}
     */
    public void setScrollableX(boolean scrollableX) {
<span class="nc" id="L4378">        getContentPane().setScrollableX(scrollableX);</span>
<span class="nc" id="L4379">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isScrollableY() {
<span class="fc" id="L4386">        return getContentPane().isScrollableY();</span>
    }

    /**
     * {@inheritDoc}
     */
    public void setScrollableY(boolean scrollableY) {
<span class="fc" id="L4393">        getContentPane().setScrollableY(scrollableY);</span>
<span class="fc" id="L4394">    }</span>

    /**
     * {@inheritDoc}
     */
    public void setVisible(boolean visible) {
<span class="fc" id="L4400">        super.setVisible(visible);</span>
<span class="pc bpc" id="L4401" title="1 of 2 branches missed.">        if (mediaComponents != null) {</span>
<span class="nc" id="L4402">            int size = mediaComponents.size();</span>
<span class="nc bnc" id="L4403" title="All 2 branches missed.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L4404">                Component mediaCmp = mediaComponents.get(i);</span>
<span class="nc" id="L4405">                mediaCmp.setVisible(visible);</span>
            }
        }
<span class="fc" id="L4408">    }</span>

    /**
     * Default color for the screen tint when a dialog or a menu is shown
     *
     * @return the tint color when a dialog or a menu is shown
     */
    public int getTintColor() {
<span class="fc" id="L4416">        return tintColor;</span>
    }

    /**
     * Default color for the screen tint when a dialog or a menu is shown
     *
     * @param tintColor the tint color when a dialog or a menu is shown
     */
    public void setTintColor(int tintColor) {
<span class="fc" id="L4425">        this.tintColor = tintColor;</span>
<span class="fc" id="L4426">    }</span>

    /**
     * Sets the menu transitions for showing/hiding the menu, can be null...
     *
     * @param transitionIn  the transition that will play when the menu appears
     * @param transitionOut the transition that will play when the menu is folded
     */
    public void setMenuTransitions(Transition transitionIn, Transition transitionOut) {
<span class="nc" id="L4435">        menuBar.setTransitions(transitionIn, transitionOut);</span>
<span class="nc" id="L4436">    }</span>

    /**
     * {@inheritDoc}
     */
    protected String paramString() {
<span class="nc" id="L4442">        return super.paramString() + &quot;, title = &quot; + title</span>
<span class="nc" id="L4443">                + &quot;, visible = &quot; + isVisible();</span>
    }

    /**
     * Returns the associated Menu Bar object
     *
     * @return the associated Menu Bar object
     */
    public MenuBar getMenuBar() {
<span class="fc" id="L4452">        return menuBar;</span>
    }

    /**
     * Sets the associated MenuBar Object.
     *
     * @param menuBar
     */
    public void setMenuBar(MenuBar menuBar) {
<span class="fc" id="L4461">        this.menuBar = menuBar;</span>
<span class="fc" id="L4462">        menuBar.initMenuBar(this);</span>
<span class="fc" id="L4463">    }</span>

    /**
     * Sets the Form Toolbar
     *
     * @param toolbar
     * @deprecated use setToolbar instead (lower case b)
     */
    public void setToolBar(Toolbar toolbar) {
<span class="fc" id="L4472">        this.toolbar = toolbar;</span>
<span class="fc" id="L4473">        setMenuBar(toolbar.getMenuBar());</span>
<span class="fc" id="L4474">    }</span>

    /**
     * Gets the Form Toolbar if exists or null
     *
     * @return the Toolbar instance or null if does not exists.
     */
    public Toolbar getToolbar() {
<span class="fc" id="L4482">        return toolbar;</span>
    }

    /**
     * Sets the Form Toolbar
     *
     * @param toolbar
     */
    public void setToolbar(Toolbar toolbar) {
<span class="fc" id="L4491">        this.toolbar = toolbar;</span>
<span class="fc" id="L4492">        setMenuBar(toolbar.getMenuBar());</span>
<span class="fc" id="L4493">    }</span>

    /**
     * Indicates whether lists and containers should scroll only via focus and thus &quot;jump&quot; when
     * moving to a larger component as was the case in older versions of Codename One.
     *
     * @return the value of focusScrolling
     */
    public boolean isFocusScrolling() {
<span class="nc" id="L4502">        return focusScrolling;</span>
    }

    /**
     * Indicates whether lists and containers should scroll only via focus and thus &quot;jump&quot; when
     * moving to a larger component as was the case in older versions of Codename One.
     *
     * @param focusScrolling the new value for focus scrolling
     */
    public void setFocusScrolling(boolean focusScrolling) {
<span class="nc" id="L4512">        this.focusScrolling = focusScrolling;</span>
<span class="nc" id="L4513">    }</span>

    /**
     * {@inheritDoc}
     */
    public String[] getPropertyNames() {
<span class="fc" id="L4519">        return new String[]{&quot;titleUIID&quot;, &quot;titleAreaUIID&quot;};</span>
    }

    /**
     * {@inheritDoc}
     */
    public Class[] getPropertyTypes() {
<span class="fc" id="L4526">        return new Class[]{</span>
                String.class,
                String.class
        };
    }

    /**
     * {@inheritDoc}
     */
    public String[] getPropertyTypeNames() {
<span class="fc" id="L4536">        return new String[]{&quot;String&quot;, &quot;String&quot;};</span>
    }

    /**
     * {@inheritDoc}
     */
    public Object getPropertyValue(String name) {
<span class="nc bnc" id="L4543" title="All 2 branches missed.">        if (name.equals(&quot;titleUIID&quot;)) {</span>
<span class="nc bnc" id="L4544" title="All 2 branches missed.">            if (getTitleComponent() != null) {</span>
<span class="nc" id="L4545">                return getTitleComponent().getUIID();</span>
            }
        }
<span class="nc bnc" id="L4548" title="All 2 branches missed.">        if (name.equals(&quot;titleAreaUIID&quot;)) {</span>
<span class="nc bnc" id="L4549" title="All 2 branches missed.">            if (getTitleArea() != null) {</span>
<span class="nc" id="L4550">                return getTitleArea().getUIID();</span>
            }
        }
<span class="nc" id="L4553">        return null;</span>
    }

    /**
     * {@inheritDoc}
     */
    public String setPropertyValue(String name, Object value) {
<span class="fc bfc" id="L4560" title="All 2 branches covered.">        if (name.equals(&quot;titleUIID&quot;)) {</span>
<span class="pc bpc" id="L4561" title="1 of 2 branches missed.">            if (getTitleComponent() != null) {</span>
<span class="fc" id="L4562">                getTitleComponent().setUIID((String) value);</span>
            }
<span class="fc" id="L4564">            return null;</span>
        }
<span class="pc bpc" id="L4566" title="1 of 2 branches missed.">        if (name.equals(&quot;titleAreaUIID&quot;)) {</span>
<span class="pc bpc" id="L4567" title="1 of 2 branches missed.">            if (getTitleArea() != null) {</span>
<span class="fc" id="L4568">                getTitleArea().setUIID((String) value);</span>
            }
<span class="fc" id="L4570">            return null;</span>
        }
<span class="nc" id="L4572">        return super.setPropertyValue(name, value);</span>
    }

    /**
     * A text component that will receive focus and start editing immediately as the form is shown
     *
     * @return the component instance
     */
    public TextArea getEditOnShow() {
<span class="nc" id="L4581">        return editOnShow;</span>
    }

    /**
     * A text component that will receive focus and start editing immediately as the form is shown
     *
     * @param editOnShow text component to edit when the form is shown
     */
    public void setEditOnShow(TextArea editOnShow) {
<span class="nc" id="L4590">        this.editOnShow = editOnShow;</span>
<span class="nc" id="L4591">    }</span>

    /**
     * Iterates through the components on this form in traversal order.
     *
     * @see #getTabIterator(com.codename1.ui.Component)
     */
    public class TabIterator implements ListIterator&lt;Component&gt; {
        private final java.util.List&lt;Component&gt; components;
        private int currPos;
        private Component current;

<span class="fc" id="L4603">        private TabIterator(java.util.List&lt;Component&gt; components, Component current) {</span>
<span class="fc" id="L4604">            this.components = components;</span>
<span class="fc" id="L4605">            setCurrent(current);</span>
<span class="fc" id="L4606">        }</span>

        /**
         * Gets the current component in this iterator.
         *
         * @return
         */
        public Component getCurrent() {
<span class="fc" id="L4614">            return current;</span>
        }

        /**
         * Sets the current component in the iterator.  This reposition the iterator
         * to the given component.
         *
         * @param cmp The component to set as the current component.
         */
        public void setCurrent(Component cmp) {
<span class="fc" id="L4624">            current = cmp;</span>

<span class="pc bpc" id="L4626" title="1 of 2 branches missed.">            currPos = cmp != null ? components.indexOf(cmp) : -1;</span>
<span class="fc" id="L4627">        }</span>

        /**
         * Gets the next component in this iterator.  If the current component explicitly specifies
         * a nextFocusRight or nextFocusDown component, then that component will be returned.
         * Otherwise it will follow the tab index order.
         *
         * @return The next component to be traversed after {@link #getCurrent() }
         */
        public Component getNext() {
<span class="fc" id="L4637">            Component current = getCurrent();</span>
<span class="pc bpc" id="L4638" title="3 of 4 branches missed.">            if (current == null &amp;&amp; components.isEmpty()) {</span>
<span class="nc" id="L4639">                return null;</span>
            }

<span class="pc bpc" id="L4642" title="1 of 2 branches missed.">            Component next = current != null ? current.getNextFocusRight() : null;</span>
<span class="pc bpc" id="L4643" title="7 of 8 branches missed.">            if (next != null &amp;&amp; next.isFocusable() &amp;&amp; next.isVisible() &amp;&amp; next.isEnabled()) {</span>
<span class="nc" id="L4644">                return next;</span>
            }
<span class="pc bpc" id="L4646" title="1 of 2 branches missed.">            next = current != null ? current.getNextFocusDown() : null;</span>
<span class="pc bpc" id="L4647" title="7 of 8 branches missed.">            if (next != null &amp;&amp; next.isFocusable() &amp;&amp; next.isVisible() &amp;&amp; next.isEnabled()) {</span>
<span class="nc" id="L4648">                return next;</span>
            }
<span class="pc bpc" id="L4650" title="3 of 4 branches missed.">            if (currPos &lt; 0 &amp;&amp; !components.isEmpty()) {</span>
<span class="nc" id="L4651">                return components.get(0);</span>
            }
<span class="pc bpc" id="L4653" title="1 of 2 branches missed.">            if (currPos &lt; components.size() - 1) {</span>
<span class="nc" id="L4654">                return components.get(currPos + 1);</span>
            }
<span class="fc" id="L4656">            return null;</span>
        }

        /**
         * Gets the previous component that should be traversed when going &quot;back&quot; in through the
         * form components.  If the current component has a nextFocusLeft or nextFocusUp field
         * explicitly specified, then it will return that.  Otherwise it just follows the traversal
         * order using the tab index.
         *
         * @return The previous component according to traversal order.
         */
        public Component getPrevious() {
<span class="fc" id="L4668">            Component current = getCurrent();</span>
<span class="pc bpc" id="L4669" title="3 of 4 branches missed.">            if (current == null &amp;&amp; components.isEmpty()) {</span>
<span class="nc" id="L4670">                return null;</span>
            }
<span class="pc bpc" id="L4672" title="1 of 2 branches missed.">            Component prev = current != null ? current.getNextFocusLeft() : null;</span>
<span class="pc bpc" id="L4673" title="7 of 8 branches missed.">            if (prev != null &amp;&amp; prev.isFocusable() &amp;&amp; prev.isVisible() &amp;&amp; prev.isEnabled()) {</span>
<span class="nc" id="L4674">                return prev;</span>
            }
<span class="pc bpc" id="L4676" title="1 of 2 branches missed.">            prev = current != null ? current.getNextFocusUp() : null;</span>
<span class="pc bpc" id="L4677" title="7 of 8 branches missed.">            if (prev != null &amp;&amp; prev.isFocusable() &amp;&amp; prev.isVisible() &amp;&amp; prev.isEnabled()) {</span>
<span class="nc" id="L4678">                return prev;</span>
            }
<span class="pc bpc" id="L4680" title="3 of 4 branches missed.">            if (currPos &lt; 0 &amp;&amp; !components.isEmpty()) {</span>
                // Negative current position means that we pick the last
                // component on the form.
<span class="nc" id="L4683">                return components.get(components.size() - 1);</span>
            }
<span class="pc bpc" id="L4685" title="3 of 4 branches missed.">            if (currPos &gt; 0 &amp;&amp; currPos &lt;= components.size()) {</span>
<span class="nc" id="L4686">                return components.get(currPos - 1);</span>
            }
<span class="fc" id="L4688">            return null;</span>
        }

        /**
         * Checks to see if there is a &quot;next&quot; component to traverse focus to in this iterator.
         *
         * @return True if there is a &quot;next&quot; component in this iterator.
         */
        public boolean hasNext() {
<span class="pc bpc" id="L4697" title="1 of 2 branches missed.">            return getNext() != null;</span>
        }

        /**
         * Returns the next component in this iterator, and repositions the iterator at this component.
         *
         * @return The &quot;next&quot; component in the iterator.
         */

        public Component next() {
<span class="nc" id="L4707">            Component next = getNext();</span>
<span class="nc" id="L4708">            setCurrent(next);</span>
<span class="nc" id="L4709">            return next;</span>
        }

        /**
         * Checks if this iterator has a &quot;previous&quot; component.
         *
         * @return
         */

        public boolean hasPrevious() {
<span class="pc bpc" id="L4719" title="1 of 2 branches missed.">            return getPrevious() != null;</span>
        }

        /**
         * Returns the previous component in this iterator, and repositions the iterator at this component.
         *
         * @return
         */

        public Component previous() {
<span class="nc" id="L4729">            Component prev = getPrevious();</span>
<span class="nc" id="L4730">            setCurrent(prev);</span>
<span class="nc" id="L4731">            return prev;</span>
        }

        /**
         * Gets the index within the iterator of the next component.
         *
         * @return
         */

        public int nextIndex() {
<span class="nc" id="L4741">            Component next = getNext();</span>
<span class="nc bnc" id="L4742" title="All 2 branches missed.">            if (next == null) {</span>
<span class="nc" id="L4743">                return -1;</span>
            }
<span class="nc" id="L4745">            return components.indexOf(next);</span>
        }

        /**
         * Gets the index within the iterator of the previous component.
         *
         * @return
         */

        public int previousIndex() {
<span class="nc" id="L4755">            Component prev = getPrevious();</span>
<span class="nc bnc" id="L4756" title="All 2 branches missed.">            if (prev == null) {</span>
<span class="nc" id="L4757">                return -1;</span>
            }
<span class="nc" id="L4759">            return components.indexOf(prev);</span>
        }

        /**
         * Removes the current component from the iterator, and repositions the iterator to the previous
         * component, or the next component (if previous doesn't exist).
         */

        public void remove() {
<span class="nc" id="L4768">            Component newCurr = getPrevious();</span>
<span class="nc bnc" id="L4769" title="All 2 branches missed.">            if (newCurr == null) {</span>
<span class="nc" id="L4770">                newCurr = getNext();</span>
            }
<span class="nc bnc" id="L4772" title="All 2 branches missed.">            if (current != null) {</span>
<span class="nc" id="L4773">                components.remove(current);</span>
<span class="nc" id="L4774">                setCurrent(newCurr);</span>
            }

<span class="nc" id="L4777">        }</span>

        /**
         * Replaces the current component, in the iterator, with the provided component.
         * This will not actually replace the component in the form's hierarchy.  Just within
         * the iterator.
         *
         * @param e The component to set as the current component.
         */

        public void set(Component e) {
<span class="nc bnc" id="L4788" title="All 4 branches missed.">            if (currPos &gt;= 0 &amp;&amp; currPos &lt; components.size() - 1) {</span>
<span class="nc" id="L4789">                components.set(currPos, e);</span>
<span class="nc" id="L4790">                setCurrent(e);</span>
            }
<span class="nc" id="L4792">        }</span>

        /**
         * Adds a component to the end of the iterator.
         *
         * @param e The component to add to the iterator.
         */

        public void add(Component e) {
<span class="nc" id="L4801">            components.add(e);</span>
<span class="nc" id="L4802">        }</span>

    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>