<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LayeredLayout.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codenameone-core-unittests</a> &gt; <a href="index.source.html" class="el_package">com.codename1.ui.layouts</a> &gt; <span class="el_source">LayeredLayout.java</span></div><h1>LayeredLayout.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores
 * CA 94065 USA or visit www.oracle.com if you need additional information or
 * have any questions.
 */
package com.codename1.ui.layouts;

import com.codename1.io.Log;
import com.codename1.io.Util;
import com.codename1.l10n.L10NManager;
import com.codename1.ui.Component;
import com.codename1.ui.Container;
import com.codename1.ui.Display;
import com.codename1.ui.Font;
import com.codename1.ui.geom.Dimension;
import com.codename1.ui.geom.Rectangle;
import com.codename1.ui.layouts.LayeredLayout.LayeredLayoutConstraint.Inset;
import com.codename1.ui.plaf.Style;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Set;

/**
 * &lt;p&gt;
 * The {@code LayeredLayout} places the components in order one on top of the
 * other and sizes them all to the size of the largest component. This is useful
 * when trying to create an overlay on top of an existing component. E.g. an &quot;x&quot;
 * button to allow removing the component as shown here&lt;/p&gt;
 *
 * &lt;img src=&quot;https://www.codenameone.com/img/developer-guide/layered-layout.png&quot; alt=&quot;The X on this button was placed there using the layered layout code below&quot; /&gt;
 *
 * &lt;p&gt;
 * The code to generate this UI is slightly complex and contains very little
 * relevant pieces. The only truly relevant piece the last line of code:&lt;/p&gt;
 *
 * &lt;script src=&quot;https://gist.github.com/codenameone/d0491ce08ce6b889bbd5.js&quot;&gt;&lt;/script&gt;*
 *
 *
 * &lt;p&gt;
 * We are doing three distinct things here:&lt;/p&gt;
 * &lt;ul&gt;
 * .
 * &lt;li&gt; We are adding a layered layout to the form.&lt;/li&gt;
 * &lt;li&gt; We are creating a layered layout and placing two components within. This
 * would be the equivalent of just creating a {@code LayeredLaout}
 * {@link com.codename1.ui.Container} and invoking `add` twice.&lt;/li&gt;
 * .* &lt;li&gt; We use
 * https://www.codenameone.com/javadoc/com/codename1/ui/layouts/FlowLayout.html[FlowLayout]
 * to position the `X` close button in the right position.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * A common use case for {@code LayeredLayout} is the iOS carousel effect which
 * we can achieve by combing the {@code LayeredLayout} with
 * {@link com.codename1.ui.Tabs}.
 * &lt;/p&gt;
 * &lt;script src=&quot;https://gist.github.com/codenameone/e981c3f91f98f1515987.js&quot;&gt;&lt;/script&gt;
 * &lt;img src=&quot;https://www.codenameone.com/img/developer-guide/components-tabs-swipe1.png&quot; alt=&quot;Tabs carousel page 1&quot; /&gt;
 *
 * &lt;p&gt;
 * Notice that the layered layout sizes all components to the exact same size
 * one on top of the other. It usually requires that we use another container
 * within; in order to position the components correctly.&lt;br /&gt;
 * &lt;p&gt;
 * Forms have a built in layered layout that you can access via
 * `getLayeredPane()`, this allows you to overlay elements on top of the content
 * pane.&lt;br /&gt;
 * &lt;p&gt;
 * The layered pane is used internally by components such as {@link com.codename1.components.InteractionDialog},
 * {@link com.codename1.u./AutoCompleteTextField} etc.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Warning: Placing native widgets within a layered layout is problematic due to
 * the behavior of peer components. Sample of peer components include the
 * {@link com.codename1.ui.BrowserComponent}, video playback etc.
 * &lt;/p&gt;
 *
 * &lt;h3&gt;Insets&lt;/h3&gt;
 *
 * &lt;p&gt;This layout optionally supports insets for laying out its children. Use of insets can allow you to
 * achieve precise placement of components while adjusting properly to screen resizing.&lt;/p&gt;
 *
 * &lt;p&gt;Insets may be either fixed or flexible.  Fixed insets may be specified in pixels ({@link #UNIT_PIXELS}),
 * millimetres ({@link #UNIT_DIPS}), or percentage ({@link #UNIT_PERCENT}).  Insets may also be specified as just &quot;auto&quot; ({@link #UNIT_AUTO}),
 * in which case it is considered to be flexible (it will adapt to the component size and other insets).&lt;/p&gt;
 *
 * &lt;p&gt;Insets may also be anchored to a &quot;reference component&quot; so that it will always be measured from that reference component.&lt;/p&gt;
 *
 * &lt;h4&gt;Insets Example&lt;/h4&gt;
 *
 * &lt;p&gt;Adding a button to the top right of the parent:&lt;/p&gt;
 * &lt;pre&gt;
 * {@code
 * Container cnt = new Container(new LayeredLayout());
 * LayeredLayout ll = (LayeredLayout)cnt.getLayout();
 * Button btn = new Button(&quot;My Button&quot;);
 * cnt.add(btn);
 * ll.setInsets(btn, &quot;0 0 auto auto&quot;);
 *     // NOTE: Insets are expressed in same order as &quot;margin&quot; in CSS.  Clockwise starting on top.
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;Changing top inset to 2mm, and right inset to 1mm:&lt;/p&gt;
 * &lt;pre&gt;{@code ll.setInsets(btn, &quot;2mm 1mm auto auto&quot;);}&lt;/pre&gt;
 *
 * &lt;p&gt;Using percentage insets:&lt;/p&gt;
 * &lt;pre&gt;{@code ll.setInsets(btn, &quot;25% 25% auto auto&quot;);}&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; When using percent units, the percentage is always in terms of the &quot;reference box&quot; of the component.
 * The &quot;reference box&quot; is the bounding rectangle from which the insets are measured.  If none of the insets
 * is anchored to a reference component, then the bounding box will simply be the inner bounds of the parent container (i.e.
 * the bounds of the inside padding in the container.&lt;/p&gt;
 *
 * &lt;p&gt;&lt;strong&gt;Using &quot;auto&quot; insets&lt;/strong&gt;&lt;/p&gt;
 * &lt;p&gt;An &quot;auto&quot; inset is an inset that is flexible.  If all 4 insets are set to auto, then the component will tend to the
 * centre of the parent component, and its size will be the component's preferred size (though the size will be bounded by the size of the component's reference box).
 * If one inset is fixed, and the opposite inset is &quot;auto&quot;, then the fixed inset and the component's preferred size will dictate the'
 * calculated size of the inset.
 * &lt;/p&gt;
 *
 * &lt;h4&gt;Reference Components&lt;/h4&gt;
 *
 * &lt;p&gt;Insets may also have reference componnents.  E.g. If you want a button to be anchored to the right side of a search field, you could
 * make the button's left inset &quot;reference&quot; the text field.  This would be achieved as follows:
 *
 * &lt;pre&gt;
 * {@code
 * Container cnt = new Container(new LayeredLayout());
 * LayeredLayout ll = (LayeredLayout)cnt.getLayout();
 * TextField searchField = new TextField();
 * Button btn = new Button(&quot;Search&quot;);
 * cnt.add(searchField).add(btn);
 * ll
 *   .setInsets(searchField, &quot;1mm auto auto auto&quot;)
 *   .setInsets(btn, &quot;0 auto auto 0&quot;)
 *   .setReferenceComponentLeft(btn, searchField, 1f)
 *   .setReferenceComponentTop(btn, searchField, 0);
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;In the above example we set the search field to be anchored to the top of its parent (1mm inset),
 * but for all other insets to be auto.  This will result it being centered horizontally in its parent.  We then
 * anchor the button to the left and top of the search field so that the top and left insets of button will always be
 * calculated relative to the position of searchField.  In particular since the button has top and left insets of 0,
 * the button will always be placed just to the right of the search field, with its top edge aligned with the top edge
 * of search field.&lt;/p&gt;
 *
 * &lt;p&gt;&lt;strong&gt;Reference Positions&lt;/strong&gt;&lt;/p&gt;
 * &lt;p&gt;The second parameter of {@code setReferenceComponentLeft(btn, searchField, 1f)} is the reference position and it dictates
 * which edge of the reference component ({@literal searchField}) the inset should be anchored to.  A value of {@literal 1} indicates that
 * it should anchor to the opposite side of the inset  (e.g. in this case it is the &quot;left&quot; inset we are setting, so the {@literal 1}
 * value dictates that it is anchored to the &quot;right&quot; side of the text field.  A value of {@literal 0} indicates that it should anchor
 * to the same side as the inset.  This is why we used {@literal 0} in the subsequent call to {@code .setReferenceComponentTop(btn, searchField, 0);},
 * because we want to anchor the &quot;top&quot; inset of {@literal button} to the &quot;top&quot; edge of {@literal searchField}.&lt;/p&gt;
 *
 * @author Shai Almog
 * @see com.codename1.ui.Form#getLayeredPane()
 * @see com.codename1.ui.Form#getLayeredPane(java.lang.Class, boolean)
 * @see com.codename1.ui.Form#setGlassPane(com.codename1.ui.Painter)
 */
<span class="fc" id="L183">public class LayeredLayout extends Layout {</span>

    /**
     * Unit used for insets.  Millimetres.
     *
     * @see Inset#unit(byte)
     * @see Inset#changeUnits(byte)
     */
    public static final byte UNIT_DIPS = Style.UNIT_TYPE_DIPS;

    /**
     * Unit used for insets.  Pixels.
     *
     * @see Inset#unit(byte)
     * @see Inset#changeUnits(byte)
     */
    public static final byte UNIT_PIXELS = Style.UNIT_TYPE_PIXELS;

    /**
     * Unit used for insets.  Percent.
     *
     * @see Inset#unit(byte)
     * @see Inset#changeUnits(byte)
     */
    public static final byte UNIT_PERCENT = Style.UNIT_TYPE_SCREEN_PERCENTAGE;

    /**
     * Unit used for insets.  Auto.  Auto unit type for an inset indicates the
     * the inset will be automatically determined at layout time.
     *
     * @see Inset#unit(byte)
     * @see Inset#changeUnits(byte)
     */
    public static final byte UNIT_AUTO = 100;

    /**
     * Unit used for insets.  Baseline.  Baseline unit type for an inset indicates
     * the inset will be aligned with the baseline of the reference component.  This only
     * makes sense for the top inset.  The height will automatically become the preferred
     * height and the bottom inset will become &quot;auto&quot; if the top inset uses the baseline unit.
     */
    public static final byte UNIT_BASELINE = 101;

    /**
     * Temp collection to keep track of which components in the container
     * have been laid out.
     */
<span class="fc" id="L230">    private final HashSet&lt;Component&gt; tmpLaidOut = new HashSet&lt;Component&gt;();</span>

    /**
     * The preferred height in MM of this layout which serves as a sort of minimum
     * height even when the components in the layout don't demand space.
     *
     * &lt;p&gt;The actual preferred height will be the max of this value and the
     * calculated preferred height based on the container's children.&lt;p&gt;
     */
    private float preferredHeightMM;

    /**
     * The preferred width (in MM) of this layout which serves as a sort of minimum
     * width even when the components in the layout don't demand space.
     *
     * &lt;p&gt;The actual preferred width will be the max of this value and the
     * calculated preferred width based on the container's children.&lt;p&gt;
     */
    private float preferredWidthMM;

    /**
     * Shorthand for Container.encloseIn(new LayeredLayout(), cmps);
     *
     * @param cmps the components to add to a new layered layout container
     * @return a newly created layered layout
     */
    public static Container encloseIn(Component... cmps) {
<span class="fc" id="L257">        return Container.encloseIn(new LayeredLayout(), cmps);</span>
    }

    private static int getOuterHeight(Component cmp) {
<span class="fc" id="L261">        Style s = cmp.getStyle();</span>
<span class="fc" id="L262">        return cmp.getHeight() + s.getVerticalMargins();</span>
    }

    private static int getOuterPreferredH(Component cmp) {
<span class="fc" id="L266">        Style s = cmp.getStyle();</span>
<span class="fc" id="L267">        return cmp.getPreferredH() + s.getVerticalMargins();</span>
    }

    private static int getInnerHeight(Component cmp) {
<span class="nc" id="L271">        Style s = cmp.getStyle();</span>
<span class="nc" id="L272">        return cmp.getHeight() - s.getPaddingTop() - s.getPaddingBottom();</span>
    }

    private static int getInnerPreferredH(Component cmp) {
<span class="nc" id="L276">        Style s = cmp.getStyle();</span>
<span class="nc" id="L277">        return cmp.getPreferredH() - s.getPaddingTop() - s.getPaddingBottom();</span>
    }

    private static int getOuterWidth(Component cmp) {
<span class="fc" id="L281">        Style s = cmp.getStyle();</span>
<span class="fc" id="L282">        return cmp.getWidth() + s.getHorizontalMargins();</span>
    }

    private static int getOuterPreferredW(Component cmp) {
<span class="fc" id="L286">        Style s = cmp.getStyle();</span>
<span class="fc" id="L287">        return cmp.getPreferredW() + s.getHorizontalMargins();</span>
    }

    private static int getOuterX(Component cmp) {
<span class="fc" id="L291">        return cmp.getX() - cmp.getStyle().getMarginLeftNoRTL();</span>
    }

    private static int getOuterY(Component cmp) {
<span class="fc" id="L295">        return cmp.getY() - cmp.getStyle().getMarginTop();</span>
    }

    
   
    /*
    // We don't see to use this right now so commenting out.  However
    // it is conceivable that we might want to reintroduce this ability later, so
    // I'm leaving the code here.
    private void uninstallConstraint(Component cmp) {
        LayeredLayoutConstraint constraint = (LayeredLayoutConstraint)getComponentConstraint(cmp);
        if (constraint != null) {
            constraint.cmp = null;
        }
        cmp.putClientProperty(&quot;$$LayeredLayoutConstraint&quot;, null);
    }
    */

    /**
     * Sets the preferred size of this layout in MM.  This serves as a minimum
     * size that will be returned by calcPreferredSize().
     *
     * @param width  The preferred width in MM.
     * @param height The preferred height in MM.
     */
    public void setPreferredSizeMM(float width, float height) {
<span class="fc" id="L321">        this.preferredHeightMM = height;</span>
<span class="fc" id="L322">        this.preferredWidthMM = width;</span>
<span class="fc" id="L323">    }</span>

    /**
     * The preferred height in MM of this layout which serves as a sort of minimum
     * height even when the components in the layout don't demand space.
     *
     * &lt;p&gt;The actual preferred height will be the max of this value and the
     * calculated preferred height based on the container's children.&lt;p&gt;
     */
    public float getPreferredHeightMM() {
<span class="fc" id="L333">        return preferredHeightMM;</span>
    }

    /**
     * Sets the preferred height of this layout in MM.
     *
     * @param mm
     */
    public void setPreferredHeightMM(float mm) {
<span class="fc" id="L342">        preferredHeightMM = mm;</span>
<span class="fc" id="L343">    }</span>

    /**
     * The preferred width (in MM) of this layout which serves as a sort of minimum
     * width even when the components in the layout don't demand space.
     *
     * &lt;p&gt;The actual preferred width will be the max of this value and the
     * calculated preferred width based on the container's children.&lt;p&gt;
     */
    public float getPreferredWidthMM() {
<span class="fc" id="L353">        return preferredWidthMM;</span>
    }

    /**
     * Sets the preferred width of this layout in MM.
     *
     * @param mm
     */
    public void setPreferredWidthMM(float mm) {
<span class="fc" id="L362">        preferredWidthMM = mm;</span>
<span class="fc" id="L363">    }</span>

    @Override
    public void addLayoutComponent(Object value, Component comp, Container c) {
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">        if (value instanceof LayeredLayoutConstraint.Inset) {</span>
<span class="nc" id="L368">            value = ((LayeredLayoutConstraint.Inset) value).constraint();</span>
        }
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">        if (value instanceof LayeredLayoutConstraint) {</span>

<span class="nc" id="L372">            installConstraint((LayeredLayoutConstraint) value, comp);</span>
        }
<span class="fc" id="L374">    }</span>

    /**
     * Wraps {@link #getComponentConstraint(com.codename1.ui.Component) } and casts it
     * directly to {@link LayeredLayoutConstraint}.
     *
     * @param cmp The component whose constraint we want to retrieve.
     * @return The layered layout constraint for this component.
     */
    public LayeredLayoutConstraint getLayeredLayoutConstraint(Component cmp) {
<span class="fc" id="L384">        return (LayeredLayoutConstraint) getComponentConstraint(cmp);</span>
    }

    /**
     * Installs the given constraint in the provided component.
     *
     * @param constraint
     * @param cmp
     * @return
     */
    private LayeredLayoutConstraint installConstraint(LayeredLayoutConstraint constraint, Component cmp) {

<span class="pc bpc" id="L396" title="4 of 6 branches missed.">        if (constraint.outer() != this || (constraint.cmp != null &amp;&amp; constraint.cmp != cmp)) {</span>
<span class="nc" id="L397">            LayeredLayoutConstraint tmp = createConstraint();</span>
<span class="nc" id="L398">            constraint.copyTo(tmp);</span>
<span class="nc" id="L399">            constraint = tmp;</span>
        }
<span class="fc" id="L401">        constraint.cmp = cmp;</span>
<span class="fc" id="L402">        cmp.putClientProperty(&quot;$$LayeredLayoutConstraint&quot;, constraint);</span>
<span class="fc" id="L403">        return constraint;</span>
    }

    /**
     * Makes a copy of the given constraint.
     *
     * @param constraint The constraint to copy.
     * @return The copied constraint.
     */
    @Override
    public Object cloneConstraint(Object constraint) {
<span class="nc bnc" id="L414" title="All 2 branches missed.">        if (constraint instanceof LayeredLayoutConstraint) {</span>
<span class="nc" id="L415">            return ((LayeredLayoutConstraint) constraint).copy();</span>
        }
<span class="nc" id="L417">        return super.cloneConstraint(constraint);</span>
    }

    /**
     * Gets the LayeredLayoutConstraint associated with the given component.
     * &lt;p&gt;
     * May return null if there is no constraint.
     *
     * @param comp
     * @return
     */
    @Override
    public Object getComponentConstraint(Component comp) {
<span class="fc" id="L430">        return comp.getClientProperty(&quot;$$LayeredLayoutConstraint&quot;);</span>
    }

    /**
     * Creates a default layered layout constraint.  Default constraint
     * has zero insets on all four sides.
     *
     * @param constraint
     * @return
     */
    public LayeredLayoutConstraint createConstraint(String constraint) {
<span class="nc" id="L441">        return new LayeredLayoutConstraint().setInsets(constraint);</span>
    }

    /**
     * If the given component already has a LayeredLayoutConstraint, then this
     * will return it. Otherwise it will create a constraint, install it in {@literal cmp}
     * and return the constraint for inspection or manipulation.
     *
     * @param cmp The component whose constraint we wish to retrieve.
     * @return The constraint for a given component.
     */
    public LayeredLayoutConstraint getOrCreateConstraint(Component cmp) {
<span class="fc" id="L453">        LayeredLayoutConstraint constraint = (LayeredLayoutConstraint) getComponentConstraint(cmp);</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">        if (constraint == null) {</span>
            //System.out.println(&quot;Constraint is null... creating a new one&quot;);
<span class="fc" id="L456">            constraint = createConstraint();</span>
<span class="fc" id="L457">            constraint = installConstraint(constraint, cmp);</span>
        }
<span class="fc" id="L459">        return constraint;</span>
    }

    /**
     * Gets an {@link Inset} associated with the provided component
     *
     * @param cmp  The component whose inset we wish to retrieve.
     * @param side The side of the inset.  One of {@link Component#TOP}, {@link Component#LEFT}, {@link Component#BOTTOM}
     *             or {@link Component#RIGHT}.
     * @return The {@link Inset} for the given side of the component.
     */
    public Inset getInset(Component cmp, int side) {
<span class="nc" id="L471">        return getOrCreateConstraint(cmp).insets[side];</span>
    }

    /**
     * Returns the insets for the given component as a string.  This can return the
     * insets in one of two formats depending on the value of the {@literal withLabels}
     * parameter.
     *
     * @param cmp        The component whose insets we wish to retrieve.
     * @param withLabels If {@literal false}, then this returns a string of the format {@code &quot;top right bottom left&quot;}
     *                   e.g {@code &quot;2mm 2mm 2mm 2mm&quot;}.  If {@literal true}, then it will be formatted like CSS properties: {@code &quot;top:2mm; right:2mm; bottom:2mm; left:2mm&quot;}.
     * @return The insets associated with {@literal cmp} as a string. Each inset will include the unit.   E.g.:
     * &lt;ul&gt;&lt;li&gt;{@literal 2mm} = 2 millimetres/dips&lt;/li&gt;&lt;li&gt;{@literal 2px} = 2 pixels&lt;/li&gt;&lt;li&gt;{@literal 25%} = 25%&lt;/li&gt;&lt;li&gt;{@literal auto} = Flexible inset&lt;/li&gt;&lt;/ul&gt;
     */
    public String getInsetsAsString(Component cmp, boolean withLabels) {
<span class="nc" id="L486">        return getOrCreateConstraint(cmp).getInsetsAsString(withLabels);</span>
    }

    /**
     * Gets the top inset as a string. Return value will include the unit, so the following
     * are possible values:
     * &lt;p&gt;
     * &lt;ul&gt;&lt;li&gt;{@literal 2mm} = 2 millimetres&lt;/li&gt;
     * &lt;li&gt;{@literal 2px} = 2 pixels&lt;/li&gt;
     * &lt;li&gt;{@literal 25%} = 25%&lt;/li&gt;
     * &lt;li&gt;{@literal auto} = Flexible Inset&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;/p&gt;
     *
     * @param cmp The component whose inset we wish to retrieve.
     * @return The inset formatted as a string with the unit abbreviation (&quot;mm&quot;, &quot;px&quot;, or &quot;%&quot;) suffixed.
     */
    public String getTopInsetAsString(Component cmp) {
<span class="nc" id="L504">        return getOrCreateConstraint(cmp).top().getValueAsString();</span>
    }

    /**
     * Gets the bottom inset as a string. Return value will include the unit, so the following
     * are possible values:
     * &lt;p&gt;
     * &lt;ul&gt;&lt;li&gt;{@literal 2mm} = 2 millimetres&lt;/li&gt;
     * &lt;li&gt;{@literal 2px} = 2 pixels&lt;/li&gt;
     * &lt;li&gt;{@literal 25%} = 25%&lt;/li&gt;
     * &lt;li&gt;{@literal auto} = Flexible Inset&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;/p&gt;
     *
     * @param cmp The component whose inset we wish to retrieve.
     * @return The inset formatted as a string with the unit abbreviation (&quot;mm&quot;, &quot;px&quot;, or &quot;%&quot;) suffixed.
     */
    public String getBottomInsetAsString(Component cmp) {
<span class="nc" id="L522">        return getOrCreateConstraint(cmp).bottom().getValueAsString();</span>
    }

    /**
     * Gets the left inset as a string. Return value will include the unit, so the following
     * are possible values:
     * &lt;p&gt;
     * &lt;ul&gt;&lt;li&gt;{@literal 2mm} = 2 millimetres&lt;/li&gt;
     * &lt;li&gt;{@literal 2px} = 2 pixels&lt;/li&gt;
     * &lt;li&gt;{@literal 25%} = 25%&lt;/li&gt;
     * &lt;li&gt;{@literal auto} = Flexible Inset&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;/p&gt;
     *
     * @param cmp The component whose inset we wish to retrieve.
     * @return The inset formatted as a string with the unit abbreviation (&quot;mm&quot;, &quot;px&quot;, or &quot;%&quot;) suffixed.
     */
    public String getLeftInsetAsString(Component cmp) {
<span class="nc" id="L540">        return getOrCreateConstraint(cmp).left().getValueAsString();</span>
    }

    /**
     * Gets the right inset as a string. Return value will include the unit, so the following
     * are possible values:
     * &lt;p&gt;
     * &lt;ul&gt;&lt;li&gt;{@literal 2mm} = 2 millimetres&lt;/li&gt;
     * &lt;li&gt;{@literal 2px} = 2 pixels&lt;/li&gt;
     * &lt;li&gt;{@literal 25%} = 25%&lt;/li&gt;
     * &lt;li&gt;{@literal auto} = Flexible Inset&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;/p&gt;
     *
     * @param cmp The component whose inset we wish to retrieve.
     * @return The inset formatted as a string with the unit abbreviation (&quot;mm&quot;, &quot;px&quot;, or &quot;%&quot;) suffixed.
     */
    public String getRightInsetAsString(Component cmp) {
<span class="nc" id="L558">        return getOrCreateConstraint(cmp).right().getValueAsString();</span>
    }

    /**
     * Sets the insets for the component {@literal cmp} to the values specified in {@literal insets}.
     *
     * @param cmp    The component whose insets we wish to set.
     * @param insets The insets expressed as a string.  See {@link LayeredLayoutConstraint#setInsets(java.lang.String) } for
     *               details on the format of this parameter.
     * @return Self for chaining.
     * @see LayeredLayoutConstraint#setInsets(java.lang.String) For details on the {@literal insets} parameter
     * format.
     */
    public LayeredLayout setInsets(Component cmp, String insets) {
<span class="fc" id="L572">        getOrCreateConstraint(cmp).setInsets(insets);</span>
<span class="fc" id="L573">        return this;</span>
    }

    /**
     * Sets the top inset for this component to the prescribed value.
     *
     * @param cmp   The component whose inset we wish to set.
     * @param inset The inset value, including unit.  Units are Percent (%), Millimetres (mm), Pixels (px), and &quot;auto&quot;.  E.g. the
     *              following insets values would all be acceptable:
     *              &lt;p&gt;
     *              &lt;ul&gt;
     *                &lt;li&gt;{@code &quot;2mm&quot;} = 2 millimetres&lt;/li&gt;
     *                &lt;li&gt;{@code &quot;2px&quot;} = 2 pixels&lt;/li&gt;
     *                &lt;li&gt;{@code &quot;25%&quot;} = 25 percent.&lt;/li&gt;
     *                &lt;li&gt;{@code &quot;auto&quot;} = Flexible inset&lt;/li&gt;
     *              &lt;/ul&gt;
     *              &lt;/p&gt;
     * @return Self for chaining.
     */
    public LayeredLayout setInsetTop(Component cmp, String inset) {
<span class="nc" id="L593">        getOrCreateConstraint(cmp).top().setValue(inset);</span>
<span class="nc" id="L594">        return this;</span>
    }

    /**
     * Sets the top inset for this component to the prescribed value.
     *
     * @param cmp   The component whose inset we wish to set.
     * @param inset The inset value, including unit.  Units are Percent (%), Millimetres (mm), Pixels (px), and &quot;auto&quot;.  E.g. the
     *              following insets values would all be acceptable:
     *              &lt;p&gt;
     *              &lt;ul&gt;
     *                &lt;li&gt;{@code &quot;2mm&quot;} = 2 millimetres&lt;/li&gt;
     *                &lt;li&gt;{@code &quot;2px&quot;} = 2 pixels&lt;/li&gt;
     *                &lt;li&gt;{@code &quot;25%&quot;} = 25 percent.&lt;/li&gt;
     *                &lt;li&gt;{@code &quot;auto&quot;} = Flexible inset&lt;/li&gt;
     *              &lt;/ul&gt;
     *              &lt;/p&gt;
     * @return Self for chaining.
     */
    public LayeredLayout setInsetBottom(Component cmp, String inset) {
<span class="nc" id="L614">        getOrCreateConstraint(cmp).bottom().setValue(inset);</span>
<span class="nc" id="L615">        return this;</span>
    }

    /**
     * Sets the left inset for this component to the prescribed value.
     *
     * @param cmp   The component whose inset we wish to set.
     * @param inset The inset value, including unit.  Units are Percent (%), Millimetres (mm), Pixels (px), and &quot;auto&quot;.  E.g. the
     *              following insets values would all be acceptable:
     *              &lt;p&gt;
     *              &lt;ul&gt;
     *                &lt;li&gt;{@code &quot;2mm&quot;} = 2 millimetres&lt;/li&gt;
     *                &lt;li&gt;{@code &quot;2px&quot;} = 2 pixels&lt;/li&gt;
     *                &lt;li&gt;{@code &quot;25%&quot;} = 25 percent.&lt;/li&gt;
     *                &lt;li&gt;{@code &quot;auto&quot;} = Flexible inset&lt;/li&gt;
     *              &lt;/ul&gt;
     *              &lt;/p&gt;
     * @return Self for chaining.
     */
    public LayeredLayout setInsetLeft(Component cmp, String inset) {
<span class="nc" id="L635">        getOrCreateConstraint(cmp).left().setValue(inset);</span>
<span class="nc" id="L636">        return this;</span>
    }

    /**
     * Sets the right inset for this component to the prescribed value.
     *
     * @param cmp   The component whose inset we wish to set.
     * @param inset The inset value, including unit.  Units are Percent (%), Millimetres (mm), Pixels (px), and &quot;auto&quot;.  E.g. the
     *              following insets values would all be acceptable:
     *              &lt;p&gt;
     *              &lt;ul&gt;
     *                &lt;li&gt;{@code &quot;2mm&quot;} = 2 millimetres&lt;/li&gt;
     *                &lt;li&gt;{@code &quot;2px&quot;} = 2 pixels&lt;/li&gt;
     *                &lt;li&gt;{@code &quot;25%&quot;} = 25 percent.&lt;/li&gt;
     *                &lt;li&gt;{@code &quot;auto&quot;} = Flexible inset&lt;/li&gt;
     *              &lt;/ul&gt;
     *              &lt;/p&gt;
     * @return Self for chaining.
     */
    public LayeredLayout setInsetRight(Component cmp, String inset) {
<span class="nc" id="L656">        getOrCreateConstraint(cmp).right().setValue(inset);</span>
<span class="nc" id="L657">        return this;</span>
    }

    /**
     * Sets the reference components for the insets of {@literal cmp}. See {@link LayeredLayoutConstraint#setReferenceComponents(com.codename1.ui.Component...) }
     * for a full description of the parameters.
     *
     * @param cmp                 The component whose reference components we wish to check.
     * @param referenceComponents The reference components.  This var arg may contain 1 to 4 values.  See {@link LayeredLayoutConstraint#setReferenceComponents(com.codename1.ui.Component...) }
     *                            for a full description.
     * @return Self for chaining.
     */
    public LayeredLayout setReferenceComponents(Component cmp, Component... referenceComponents) {
<span class="nc" id="L670">        getOrCreateConstraint(cmp).setReferenceComponents(referenceComponents);</span>
<span class="nc" id="L671">        return this;</span>
    }

    /**
     * Sets the reference components for this component as a string of 1 to 4 component indices separated by spaces. An
     * index of {@literal -1} indicates no reference for the corresponding inset.  See {@link LayeredLayoutConstraint#setReferenceComponentIndices(com.codename1.ui.Container, java.lang.String) }
     * for a description of the {@literal refs} parameter.
     *
     * @param cmp  The component whose references we're setting.
     * @param refs Reference components as a string of component indices in the parent.
     * @return Self for chaining.
     */
    public LayeredLayout setReferenceComponents(Component cmp, String refs) {
<span class="nc" id="L684">        getOrCreateConstraint(cmp).setReferenceComponentIndices(cmp.getParent(), refs);</span>
<span class="nc" id="L685">        return this;</span>
    }

    /**
     * Sets the reference component for the top inset of the given component.
     *
     * @param cmp                The component whose insets we are manipulating.
     * @param referenceComponent The component to anchor the inset to.
     * @return Self for chaining.
     */
    public LayeredLayout setReferenceComponentTop(Component cmp, Component referenceComponent) {
<span class="nc" id="L696">        getOrCreateConstraint(cmp).top().referenceComponent(referenceComponent);</span>
<span class="nc" id="L697">        return this;</span>
    }

    /**
     * Sets the reference component for the bottom inset of the given component.
     *
     * @param cmp                The component whose insets we are manipulating.
     * @param referenceComponent The component to anchor the inset to.
     * @return Self for chaining.
     */
    public LayeredLayout setReferenceComponentBottom(Component cmp, Component referenceComponent) {
<span class="nc" id="L708">        getOrCreateConstraint(cmp).bottom().referenceComponent(referenceComponent);</span>
<span class="nc" id="L709">        return this;</span>
    }

    /**
     * Sets the reference component for the left inset of the given component.
     *
     * @param cmp                The component whose insets we are manipulating.
     * @param referenceComponent The component to anchor the inset to.
     * @return Self for chaining.
     */
    public LayeredLayout setReferenceComponentLeft(Component cmp, Component referenceComponent) {
<span class="nc" id="L720">        getOrCreateConstraint(cmp).left().referenceComponent(referenceComponent);</span>
<span class="nc" id="L721">        return this;</span>
    }

    /**
     * Sets the reference component for the right inset of the given component.
     *
     * @param cmp                The component whose insets we are manipulating.
     * @param referenceComponent The component to anchor the inset to.
     * @return Self for chaining.
     */
    public LayeredLayout setReferenceComponentRight(Component cmp, Component referenceComponent) {
<span class="nc" id="L732">        getOrCreateConstraint(cmp).top().referenceComponent(referenceComponent);</span>
<span class="nc" id="L733">        return this;</span>
    }

    /**
     * Sets the reference positions for reference components.  See {@link LayeredLayoutConstraint#setReferencePositions(float...) }
     * for a description of the parameters.
     *
     * @param cmp                The component whose insets we are manipulating.
     * @param referencePositions The reference positions for the reference components. See {@link LayeredLayoutConstraint#setReferencePositions(float...) }
     *                           for a full description of this parameter.
     * @return Self for chaining.
     */
    public LayeredLayout setReferencePositions(Component cmp, float... referencePositions) {
<span class="nc" id="L746">        getOrCreateConstraint(cmp).setReferencePositions(referencePositions);</span>
<span class="nc" id="L747">        return this;</span>
    }

    /**
     * Sets the reference positions for reference components.  See {@link LayeredLayoutConstraint#setReferencePositions(float...) }
     * for a description of the parameters.
     *
     * @param cmp       The component whose insets we are manipulating.
     * @param positions The reference positions for the reference components. See {@link LayeredLayoutConstraint#setReferencePositions(float...) }
     *                  for a full description of this parameter.
     * @return Self for chaining.
     */
    public LayeredLayout setReferencePositions(Component cmp, String positions) {
<span class="nc" id="L760">        getOrCreateConstraint(cmp).setReferencePositions(positions);</span>
<span class="nc" id="L761">        return this;</span>
    }

    /**
     * Sets the top inset reference position.  Only applicable if the top inset has a reference
     * component specified.
     *
     * @param cmp      The component whose insets were are manipulating.
     * @param position The position.  See {@link LayeredLayoutConstraint#setReferencePositions(float...) } for a full
     *                 description of the possible values here.
     * @return
     */
    public LayeredLayout setReferencePositionTop(Component cmp, float position) {
<span class="nc" id="L774">        getOrCreateConstraint(cmp).top().referencePosition(position);</span>
<span class="nc" id="L775">        return this;</span>
    }

    /**
     * Sets the reference component for the top inset of the given component.
     *
     * @param cmp                The component whose insets we are manipulating.
     * @param referenceComponent The component to which the inset should be anchored.
     * @param position           The position of the reference anchor.  See {@link LayeredLayoutConstraint#setReferencePositions(float...) }
     *                           for a full description of reference positions.
     * @return
     */
    public LayeredLayout setReferenceComponentTop(Component cmp, Component referenceComponent, float position) {
<span class="fc" id="L788">        getOrCreateConstraint(cmp).top().referenceComponent(referenceComponent).referencePosition(position);</span>
<span class="fc" id="L789">        return this;</span>
    }

    /**
     * Sets the bottom inset reference position.  Only applicable if the top inset has a reference
     * component specified.
     *
     * @param cmp      The component whose insets were are manipulating.
     * @param position The position.  See {@link LayeredLayoutConstraint#setReferencePositions(float...) } for a full
     *                 description of the possible values here.
     * @return
     */
    public LayeredLayout setReferencePositionBottom(Component cmp, float position) {
<span class="nc" id="L802">        getOrCreateConstraint(cmp).bottom().referencePosition(position);</span>
<span class="nc" id="L803">        return this;</span>
    }

    /**
     * Sets the reference component for the bottom inset of the given component.
     *
     * @param cmp                The component whose insets we are manipulating.
     * @param referenceComponent The component to which the inset should be anchored.
     * @param position           The position of the reference anchor.  See {@link LayeredLayoutConstraint#setReferencePositions(float...) }
     *                           for a full description of reference positions.
     * @return
     */
    public LayeredLayout setReferenceComponentBottom(Component cmp, Component referenceComponent, float position) {
<span class="fc" id="L816">        getOrCreateConstraint(cmp).bottom().referenceComponent(referenceComponent).referencePosition(position);</span>
<span class="fc" id="L817">        return this;</span>
    }

    /**
     * Sets the left inset reference position.  Only applicable if the top inset has a reference
     * component specified.
     *
     * @param cmp      The component whose insets were are manipulating.
     * @param position The position.  See {@link LayeredLayoutConstraint#setReferencePositions(float...) } for a full
     *                 description of the possible values here.
     * @return
     */
    public LayeredLayout setReferencePositionLeft(Component cmp, float position) {
<span class="nc" id="L830">        getOrCreateConstraint(cmp).left().referencePosition(position);</span>
<span class="nc" id="L831">        return this;</span>
    }

    /**
     * Sets the reference component for the left inset of the given component.
     *
     * @param cmp                The component whose insets we are manipulating.
     * @param referenceComponent The component to which the inset should be anchored.
     * @param position           The position of the reference anchor.  See {@link LayeredLayoutConstraint#setReferencePositions(float...) }
     *                           for a full description of reference positions.
     * @return
     */
    public LayeredLayout setReferenceComponentLeft(Component cmp, Component referenceComponent, float position) {
<span class="fc" id="L844">        getOrCreateConstraint(cmp).left().referenceComponent(referenceComponent).referencePosition(position);</span>
<span class="fc" id="L845">        return this;</span>
    }

    /**
     * Sets the right inset reference position.  Only applicable if the top inset has a reference
     * component specified.
     *
     * @param cmp      The component whose insets were are manipulating.
     * @param position The position.  See {@link LayeredLayoutConstraint#setReferencePositions(float...) } for a full
     *                 description of the possible values here.
     * @return
     */
    public LayeredLayout setReferencePositionRight(Component cmp, float position) {
<span class="nc" id="L858">        getOrCreateConstraint(cmp).right().referencePosition(position);</span>
<span class="nc" id="L859">        return this;</span>
    }

    /**
     * Sets the reference component for the right inset of the given component.
     *
     * @param cmp                The component whose insets we are manipulating.
     * @param referenceComponent The component to which the inset should be anchored.
     * @param position           The position of the reference anchor.  See {@link LayeredLayoutConstraint#setReferencePositions(float...) }
     *                           for a full description of reference positions.
     * @return
     */
    public LayeredLayout setReferenceComponentRight(Component cmp, Component referenceComponent, float position) {
<span class="fc" id="L872">        getOrCreateConstraint(cmp).right().referenceComponent(referenceComponent).referencePosition(position);</span>
<span class="fc" id="L873">        return this;</span>
    }

    /**
     * See {@link LayeredLayoutConstraint#setPercentInsetAnchorHorizontal(float) }
     *
     * @param cmp
     * @param anchor
     * @return Self for chaining
     */
    public LayeredLayout setPercentInsetAnchorHorizontal(Component cmp, float anchor) {
<span class="nc" id="L884">        getOrCreateConstraint(cmp).setPercentInsetAnchorHorizontal(anchor);</span>
<span class="nc" id="L885">        return this;</span>
    }

    /**
     * See {@link LayeredLayoutConstraint#setPercentInsetAnchorVertical(float) }
     *
     * @param cmp
     * @param anchor
     * @return Self for chaining
     */
    public LayeredLayout setPercentInsetAnchorVertical(Component cmp, float anchor) {
<span class="nc" id="L896">        getOrCreateConstraint(cmp).setPercentInsetAnchorVertical(anchor);</span>
<span class="nc" id="L897">        return this;</span>
    }

    /**
     * See {@link LayeredLayoutConstraint#getPercentInsetAnchorHorizontal() }
     *
     * @param cmp
     * @return
     */
    public float getPercentInsetAnchorHorizontal(Component cmp) {
<span class="nc" id="L907">        return getOrCreateConstraint(cmp).getPercentInsetAnchorHorizontal();</span>
    }

    /**
     * See {@link LayeredLayoutConstraint#getPercentInsetAnchorVertical() }
     *
     * @param cmp
     * @return
     */
    public float getPercentInsetAnchorVertical(Component cmp) {
<span class="nc" id="L917">        return getOrCreateConstraint(cmp).getPercentInsetAnchorVertical();</span>
    }

    /**
     * {@inheritDoc}
     */
    public void layoutContainer(Container parent) {
<span class="fc" id="L924">        Style s = parent.getStyle();</span>
<span class="fc" id="L925">        int top = s.getPaddingTop();</span>
<span class="fc" id="L926">        int bottom = parent.getLayoutHeight() - parent.getBottomGap() - s.getPaddingBottom();</span>
<span class="fc" id="L927">        int left = s.getPaddingLeft(parent.isRTL());</span>
<span class="fc" id="L928">        int right = parent.getLayoutWidth() - parent.getSideGap() - s.getPaddingRight(parent.isRTL());</span>

<span class="fc" id="L930">        int numOfcomponents = parent.getComponentCount();</span>
<span class="fc" id="L931">        tmpLaidOut.clear();</span>
<span class="fc bfc" id="L932" title="All 2 branches covered.">        for (int i = 0; i &lt; numOfcomponents; i++) {</span>
<span class="fc" id="L933">            Component cmp = parent.getComponentAt(i);</span>
<span class="fc" id="L934">            layoutComponent(parent, cmp, top, left, bottom, right);</span>
        }

<span class="fc" id="L937">    }</span>

    /**
     * Lays out the specific component within the container.  This will first lay out any components that it depends on.
     *
     * @param parent The parent container being laid out.
     * @param cmp    The component being laid out.
     * @param top
     * @param left
     * @param bottom
     * @param right
     */
    private void layoutComponent(Container parent, Component cmp, int top, int left, int bottom, int right) {
<span class="fc bfc" id="L950" title="All 2 branches covered.">        if (tmpLaidOut.contains(cmp)) {</span>
<span class="fc" id="L951">            return;</span>
        }
<span class="fc" id="L953">        tmpLaidOut.add(cmp);</span>
<span class="fc" id="L954">        LayeredLayoutConstraint constraint = (LayeredLayoutConstraint) getComponentConstraint(cmp);</span>
<span class="fc bfc" id="L955" title="All 2 branches covered.">        if (constraint != null) {</span>
<span class="fc" id="L956">            constraint.fixDependencies(parent);</span>
<span class="fc bfc" id="L957" title="All 2 branches covered.">            for (LayeredLayoutConstraint.Inset inset : constraint.insets) {</span>
<span class="pc bpc" id="L958" title="1 of 4 branches missed.">                if (inset.referenceComponent != null &amp;&amp; inset.referenceComponent.getParent() == parent) {</span>
<span class="fc" id="L959">                    layoutComponent(parent, inset.referenceComponent, top, left, bottom, right);</span>
                }
            }
        }

<span class="fc" id="L964">        Style s = cmp.getStyle();</span>
<span class="fc bfc" id="L965" title="All 2 branches covered.">        if (constraint != null) {</span>
            //int innerTop = top;
            //int innerBottom = bottom;
            //left = 0;
            //right = parent.getLayoutWidth();
<span class="fc" id="L970">            int leftInset = constraint.insets[Component.LEFT].calculate(cmp, top, left, bottom, right);</span>
<span class="fc" id="L971">            int rightInset = constraint.insets[Component.RIGHT].calculate(cmp, top, left, bottom, right);</span>
<span class="fc" id="L972">            int topInset = constraint.insets[Component.TOP].calculate(cmp, top, left, bottom, right);</span>
<span class="fc" id="L973">            int bottomInset = constraint.insets[Component.BOTTOM].calculate(cmp, top, left, bottom, right);</span>
<span class="fc" id="L974">            cmp.setX(left + leftInset + s.getMarginLeft(parent.isRTL()));</span>
<span class="fc" id="L975">            cmp.setY(top + topInset + s.getMarginTop());</span>
<span class="fc" id="L976">            cmp.setWidth(Math.max(0, right - cmp.getX() - s.getMarginRight(parent.isRTL()) - rightInset));</span>
            //cmp.setWidth(Math.max(0, right - left - s.getHorizontalMargins() - rightInset - leftInset));
            //cmp.setHeight(Math.max(0, bottom - top - s.getVerticalMargins() - bottomInset - topInset));
<span class="fc" id="L979">            cmp.setHeight(Math.max(0, bottom - cmp.getY() - s.getMarginBottom() - bottomInset));</span>

<span class="fc" id="L981">        } else {</span>

<span class="fc" id="L983">            int x = left + s.getMarginLeft(parent.isRTL());</span>
<span class="fc" id="L984">            int y = top + s.getMarginTop();</span>
<span class="fc" id="L985">            int w = right - left - s.getHorizontalMargins();</span>
<span class="fc" id="L986">            int h = bottom - top - s.getVerticalMargins();</span>

<span class="fc" id="L988">            cmp.setX(x);</span>
<span class="fc" id="L989">            cmp.setY(y);</span>
<span class="fc" id="L990">            cmp.setWidth(Math.max(0, w));</span>
<span class="fc" id="L991">            cmp.setHeight(Math.max(0, h));</span>
            //System.out.println(&quot;Component laid out &quot;+cmp);
        }
<span class="fc" id="L994">    }</span>

    private void calcPreferredValues(Component cmp) {
<span class="pc bpc" id="L997" title="1 of 2 branches missed.">        if (tmpLaidOut.contains(cmp)) {</span>
<span class="nc" id="L998">            return;</span>
        }
<span class="fc" id="L1000">        tmpLaidOut.add(cmp);</span>
<span class="fc" id="L1001">        LayeredLayoutConstraint constraint = (LayeredLayoutConstraint) getComponentConstraint(cmp);</span>
<span class="fc bfc" id="L1002" title="All 2 branches covered.">        if (constraint != null) {</span>
<span class="fc" id="L1003">            constraint.fixDependencies(cmp.getParent());</span>
<span class="fc bfc" id="L1004" title="All 2 branches covered.">            for (LayeredLayoutConstraint.Inset inset : constraint.insets) {</span>
<span class="pc bpc" id="L1005" title="3 of 4 branches missed.">                if (inset.referenceComponent != null &amp;&amp; inset.referenceComponent.getParent() == cmp.getParent()) {</span>
<span class="nc" id="L1006">                    calcPreferredValues(inset.referenceComponent);</span>
                }
<span class="fc" id="L1008">                inset.calcPreferredValue(cmp.getParent(), cmp);</span>
            }
        }
<span class="fc" id="L1011">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public Dimension getPreferredSize(Container parent) {
<span class="fc" id="L1018">        int maxWidth = 0;</span>
<span class="fc" id="L1019">        int maxHeight = 0;</span>
<span class="fc" id="L1020">        int numOfcomponents = parent.getComponentCount();</span>
<span class="fc" id="L1021">        tmpLaidOut.clear();</span>
<span class="fc" id="L1022">        boolean requiresSecondPassToCalculatePercentInsets = false;</span>
<span class="fc bfc" id="L1023" title="All 2 branches covered.">        for (int i = 0; i &lt; numOfcomponents; i++) {</span>
<span class="fc" id="L1024">            Component cmp = parent.getComponentAt(i);</span>
<span class="fc" id="L1025">            calcPreferredValues(cmp);</span>
<span class="fc" id="L1026">            LayeredLayoutConstraint constraint = (LayeredLayoutConstraint) getComponentConstraint(cmp);</span>
<span class="fc" id="L1027">            int vInsets = 0;</span>
<span class="fc" id="L1028">            int hInsets = 0;</span>
<span class="fc bfc" id="L1029" title="All 2 branches covered.">            if (constraint != null) {</span>
<span class="fc bfc" id="L1030" title="All 2 branches covered.">                if (!requiresSecondPassToCalculatePercentInsets) {</span>
<span class="fc bfc" id="L1031" title="All 2 branches covered.">                    for (Inset ins : constraint.insets) {</span>
<span class="pc bpc" id="L1032" title="1 of 4 branches missed.">                        if (ins.unit == UNIT_PERCENT &amp;&amp; ins.referenceComponent == null) {</span>
<span class="fc" id="L1033">                            requiresSecondPassToCalculatePercentInsets = true;</span>
<span class="fc" id="L1034">                            break;</span>
                        }
                    }
                }
<span class="fc" id="L1038">                vInsets += constraint.insets[Component.TOP].preferredValue</span>
<span class="fc" id="L1039">                        + constraint.insets[Component.BOTTOM].preferredValue;</span>
<span class="fc" id="L1040">                hInsets += constraint.insets[Component.LEFT].preferredValue</span>
<span class="fc" id="L1041">                        + constraint.insets[Component.RIGHT].preferredValue;</span>
                /*
                // Commenting all this stuff out because the calcPreferredValues() call should
                // take all of this into account already.
                Component topRef = constraint.top().getReferenceComponent();
                LayeredLayoutConstraint currConstraint = constraint;
                int maxIterations = numOfcomponents;
                int iter = 0;
                while (topRef != null) {
                    if (iter++ &gt;= maxIterations) break;
                    vInsets += Math.max(0, topRef.getOuterPreferredH() * currConstraint.top().getReferencePosition());
                    currConstraint = getOrCreateConstraint(topRef);
                    topRef = currConstraint.top().getReferenceComponent();
                }
                Component bottomRef = constraint.bottom().getReferenceComponent();
                currConstraint = constraint;
                iter = 0;
                while (bottomRef != null) {
                    if (iter++ &gt;= maxIterations) break;
                    vInsets += Math.max(0, bottomRef.getOuterPreferredH() * currConstraint.bottom().getReferencePosition());
                    currConstraint = getOrCreateConstraint(bottomRef);
                    bottomRef = currConstraint.bottom().getReferenceComponent();
                }

                Component leftRef = constraint.left().getReferenceComponent();
                currConstraint = constraint;
                iter = 0;
                while (leftRef != null) {
                    if (iter++ &gt;= maxIterations) break;
                    hInsets += Math.max(0, leftRef.getOuterPreferredW() * currConstraint.left().getReferencePosition());
                    currConstraint = getOrCreateConstraint(leftRef);
                    leftRef = currConstraint.left().getReferenceComponent();
                }

                Component rightRef = constraint.right().getReferenceComponent();
                currConstraint = constraint;
                iter = 0;
                while (rightRef != null) {
                    if (iter++ &gt;= maxIterations) break;
                    hInsets += Math.max(0, rightRef.getOuterPreferredW() * currConstraint.right().getReferencePosition());
                    currConstraint = getOrCreateConstraint(rightRef);
                    rightRef = currConstraint.right().getReferenceComponent();
                }
                */

            }
<span class="fc" id="L1087">            maxHeight = Math.max(maxHeight, cmp.getPreferredH() + cmp.getStyle().getMarginTop() + cmp.getStyle().getMarginBottom() + vInsets);</span>
<span class="fc" id="L1088">            maxWidth = Math.max(maxWidth, cmp.getPreferredW() + cmp.getStyle().getMarginLeftNoRTL() + cmp.getStyle().getMarginRightNoRTL() + hInsets);</span>

        }
<span class="fc" id="L1091">        Style s = parent.getStyle();</span>
<span class="fc" id="L1092">        Dimension d = new Dimension(maxWidth + s.getPaddingLeftNoRTL() + s.getPaddingRightNoRTL(),</span>
<span class="fc" id="L1093">                maxHeight + s.getPaddingTop() + s.getPaddingBottom() + parent.getBottomGap());</span>
<span class="fc bfc" id="L1094" title="All 2 branches covered.">        if (preferredWidthMM &gt; 0) {</span>
<span class="fc" id="L1095">            int minW = Display.getInstance().convertToPixels(preferredWidthMM);</span>
<span class="pc bpc" id="L1096" title="1 of 2 branches missed.">            if (d.getWidth() &lt; minW) {</span>
<span class="fc" id="L1097">                d.setWidth(minW);</span>
            }
        }

<span class="fc bfc" id="L1101" title="All 2 branches covered.">        if (preferredHeightMM &gt; 0) {</span>
<span class="fc" id="L1102">            int minH = Display.getInstance().convertToPixels(preferredHeightMM);</span>
<span class="pc bpc" id="L1103" title="1 of 2 branches missed.">            if (d.getHeight() &lt; Display.getInstance().convertToPixels(preferredHeightMM)) {</span>
<span class="fc" id="L1104">                d.setHeight(minH);</span>
            }
        }

<span class="fc bfc" id="L1108" title="All 2 branches covered.">        if (requiresSecondPassToCalculatePercentInsets) {</span>
            // We will do a second pass to deal with percent unit insets
            // since these were set to have zero preferred sizes in the calculation.
            // This is still a bit of a hack as it only deals with components that
            // don't depend on any other components.  E.g. If we have a label that is
            // supposed to have a top inset of 75%.  The preferred height should then
            // be 4 times the preferred height of the label rather than just the
            // preferred height of the label itself.
            // This still doesn't deal with the case where there is another label
            // that references that label and has an inset of an additional 20%
            // Ref https://github.com/codenameone/CodenameOne/issues/2720
<span class="fc" id="L1119">            float maxHRatio = 0;</span>
<span class="fc" id="L1120">            float maxWRatio = 0;</span>
<span class="fc bfc" id="L1121" title="All 2 branches covered.">            for (int i = 0; i &lt; numOfcomponents; i++) {</span>
<span class="fc" id="L1122">                Component cmp = parent.getComponentAt(i);</span>
<span class="fc" id="L1123">                LayeredLayoutConstraint constraint = (LayeredLayoutConstraint) getComponentConstraint(cmp);</span>
<span class="pc bpc" id="L1124" title="1 of 2 branches missed.">                if (constraint != null) {</span>
<span class="fc" id="L1125">                    float hRatio = 0;</span>
<span class="pc bpc" id="L1126" title="3 of 4 branches missed.">                    if (constraint.top().unit == UNIT_PERCENT &amp;&amp; constraint.top().referenceComponent == null) {</span>
<span class="nc" id="L1127">                        hRatio += constraint.top().value / 100f;</span>
                    }
<span class="pc bpc" id="L1129" title="3 of 4 branches missed.">                    if (constraint.bottom().unit == UNIT_PERCENT &amp;&amp; constraint.bottom().referenceComponent == null) {</span>
<span class="nc" id="L1130">                        hRatio += constraint.bottom().value / 100f;</span>
                    }
<span class="fc" id="L1132">                    hRatio = Math.min(1f, hRatio);</span>
<span class="fc" id="L1133">                    maxHRatio = Math.max(maxHRatio, hRatio);</span>

<span class="fc" id="L1135">                    float wRatio = 0;</span>
<span class="pc bpc" id="L1136" title="1 of 4 branches missed.">                    if (constraint.left().unit == UNIT_PERCENT &amp;&amp; constraint.left().referenceComponent == null) {</span>
<span class="fc" id="L1137">                        wRatio += constraint.left().value / 100f;</span>
                    }
<span class="pc bpc" id="L1139" title="1 of 4 branches missed.">                    if (constraint.right().unit == UNIT_PERCENT &amp;&amp; constraint.right().referenceComponent == null) {</span>
<span class="fc" id="L1140">                        wRatio += constraint.right().value / 100f;</span>
                    }
<span class="fc" id="L1142">                    wRatio = Math.min(1f, wRatio);</span>
<span class="fc" id="L1143">                    maxWRatio = Math.max(maxWRatio, wRatio);</span>
                }
            }
<span class="pc bpc" id="L1146" title="3 of 4 branches missed.">            if (maxHRatio &gt; 0 &amp;&amp; maxHRatio &lt; 1) {</span>
<span class="nc" id="L1147">                d.setHeight(Math.round(d.getHeight() / (1 - maxHRatio)));</span>
            }
<span class="pc bpc" id="L1149" title="2 of 4 branches missed.">            if (maxWRatio &gt; 0 &amp;&amp; maxWRatio &lt; 1) {</span>
<span class="fc" id="L1150">                d.setWidth(Math.round(d.getWidth() / (1 - maxWRatio)));</span>
            }
        }
<span class="fc" id="L1153">        return d;</span>
    }

    /**
     * {@inheritDoc}
     */
    public String toString() {
<span class="fc" id="L1160">        return &quot;LayeredLayout&quot;;</span>
    }

    /**
     * {@inheritDoc}
     */
    public boolean isOverlapSupported() {
<span class="fc" id="L1167">        return true;</span>
    }

    /**
     * {@inheritDoc}
     */
    public boolean obscuresPotential(Container parent) {
<span class="nc" id="L1174">        return true;</span>
    }

    /**
     * Creates a new {@link LayeredLayoutConstraint}
     *
     * @return
     */
    public LayeredLayoutConstraint createConstraint() {
<span class="fc" id="L1183">        return new LayeredLayoutConstraint();</span>
    }

    @Override
    public boolean overridesTabIndices(Container parent) {
<span class="nc" id="L1188">        return true;</span>
    }

    @Override
    protected Component[] getChildrenInTraversalOrder(Container parent) {
<span class="nc" id="L1193">        java.util.List&lt;Component&gt; cmps = new ArrayList&lt;Component&gt;();</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">        for (Component cmp : parent) {</span>
<span class="nc" id="L1195">            cmps.add(cmp);</span>
<span class="nc" id="L1196">        }</span>

<span class="nc" id="L1198">        Collections.sort(cmps, new Comparator&lt;Component&gt;() {</span>

            @Override
            public int compare(Component o1, Component o2) {
<span class="nc bnc" id="L1202" title="All 2 branches missed.">                if (o1.getY() &lt; o2.getY()) {</span>
<span class="nc" id="L1203">                    return -1;</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">                } else if (o1.getY() &gt; o2.getY()) {</span>
<span class="nc" id="L1205">                    return 1;</span>
                } else {
<span class="nc bnc" id="L1207" title="All 2 branches missed.">                    if (o1.getX() &lt; o2.getX()) {</span>
<span class="nc" id="L1208">                        return -1;</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">                    } else if (o1.getX() &gt; o2.getX()) {</span>
<span class="nc" id="L1210">                        return 1;</span>
                    } else {
<span class="nc" id="L1212">                        return 0;</span>
                    }
                }
            }

        });
<span class="nc" id="L1218">        Component[] cmpArr = cmps.toArray(new Component[cmps.size()]);</span>
<span class="nc" id="L1219">        return cmpArr;</span>
    }

    /**
     * A class that encapsulates the insets for a component in layered layout.
     */
<span class="fc" id="L1225">    public class LayeredLayoutConstraint {</span>

        /**
         * The insets for this constraint.
         */
<span class="fc" id="L1230">        private final Inset[] insets = new Inset[]{</span>
                new Inset(Component.TOP),
                new Inset(Component.LEFT),
                new Inset(Component.BOTTOM),
                new Inset(Component.RIGHT)
        };
        /**
         * The component that this constraint belongs to.  If you try to add
         * this constraint to a different component, then it will cause a copy
         * to be made rather than using the same component so that constraints
         * to bleed into other components.
         */
        private Component cmp;
        /**
         * Anchors used for percentage insets
         */
<span class="fc" id="L1246">        private float percAnchorH = 0f;</span>
<span class="fc" id="L1247">        private float percAnchorV = 0f;</span>

        /**
         * Gets the insets as a string.
         *
         * @return
         */
        public String toString() {
<span class="nc" id="L1255">            return getInsetsAsString(true);</span>
        }

        private LayeredLayout outer() {
<span class="fc" id="L1259">            return LayeredLayout.this;</span>
        }

        /**
         * Recursively fixes all dependencies so that they are contained inside
         * the provided parent.  A dependency is a &quot;referenceComponent&quot;.
         *
         * @param parent The parent container within which all dependencies should reside.
         * @return Self for chaining.
         * @see #setReferenceComponents(com.codename1.ui.Component...)
         */
        public LayeredLayoutConstraint fixDependencies(Container parent) {
<span class="fc bfc" id="L1271" title="All 2 branches covered.">            for (Inset inset : insets) {</span>
<span class="fc" id="L1272">                inset.fixDependencies(parent);</span>
            }
<span class="fc" id="L1274">            return this;</span>
        }

        /**
         * Checks to see if this constraint has any circular dependencies.  E.g.
         * Component A has an inset that has Component B as a reference, which has
         * an inset that depends on Component A.
         *
         * @param start The start component to check.
         * @return True this forms a circular dependency.
         */
        public boolean hasCircularDependency(Component start) {
<span class="nc" id="L1286">            return dependsOn(start);</span>
        }

        /**
         * Gets the inset for a particular side.
         *
         * @param inset One of {@link Component#TOP}, {@link Component#BOTTOM }, {@link Component#LEFT} or
         *              {@link Component#RIGHT}.
         * @return The inset.
         */
        public Inset getInset(int inset) {
<span class="nc" id="L1297">            return insets[inset];</span>
        }

        /**
         * Makes a full copy of this inset.
         *
         * @return
         */
        public LayeredLayoutConstraint copy() {
<span class="nc" id="L1306">            return copyTo(new LayeredLayoutConstraint());</span>
        }

        /**
         * Copies the settings of this constraint into another constraint.
         *
         * @param dest The inset to copy to.
         * @return Self for chaining.
         */
        public LayeredLayoutConstraint copyTo(LayeredLayoutConstraint dest) {
<span class="fc bfc" id="L1316" title="All 2 branches covered.">            for (int i = 0; i &lt; 4; i++) {</span>
                //Inset inset = new Inset(i);
<span class="fc" id="L1318">                dest.insets[i] = insets[i].copyTo(dest.insets[i]);</span>
            }
<span class="fc" id="L1320">            return dest;</span>
        }

        /**
         * Returns a reference box within which insets of the given component are calculated.  If
         * {@link cmp} has no reference components in any of its insets, then the resulting box will
         * just bee the inner box of the parent (e.g. the parent's inner bounds.
         *
         * @param parent The parent container.
         * @param parent
         * @param box    An out parameter.  This will store the bounds of the box.
         * @return The reference box.  (This will be the same object that is passed in the {@literal box} parameter.
         */
        public Rectangle getReferenceBox(Container parent, Rectangle box) {
<span class="nc" id="L1334">            return getReferenceBox(parent, null, box);</span>

        }

        /**
         * Returns a reference box within which insets of the given component are calculated.  If
         * {@link cmp} has no reference components in any of its insets, then the resulting box will
         * just bee the inner box of the parent (e.g. the parent's inner bounds.
         *
         * @param parent The parent container.
         * @param cmp    The component whose reference box we are obtaining.  Not used.  May be null.
         * @param box    An out parameter.  This will store the bounds of the box.
         * @return The reference box.  (This will be the same object that is passed in the {@literal box} parameter.
         * @deprecated Use {@link #getReferenceBox(com.codename1.ui.Container, com.codename1.ui.geom.Rectangle) } instead.
         */
        public Rectangle getReferenceBox(Container parent, Component cmp2, Rectangle box) {
<span class="nc" id="L1350">            Style parentStyle = parent.getStyle();</span>
            //Style cmpStyle = cmp.getStyle();

<span class="nc bnc" id="L1353" title="All 2 branches missed.">            if (top().getReferenceComponent() == null) {</span>
<span class="nc" id="L1354">                box.setY(parentStyle.getPaddingTop());</span>
            } else {
<span class="nc" id="L1356">                Component ref = top().getReferenceComponent();</span>
<span class="nc" id="L1357">                box.setY((int) (getOuterY(ref) + (top().getReferencePosition() * getOuterHeight(ref))));</span>
            }

<span class="nc bnc" id="L1360" title="All 2 branches missed.">            if (left().getReferenceComponent() == null) {</span>
<span class="nc" id="L1361">                box.setX(parentStyle.getPaddingLeftNoRTL());</span>
            } else {
<span class="nc" id="L1363">                Component ref = left().getReferenceComponent();</span>
<span class="nc" id="L1364">                box.setX((int) (getOuterX(ref) + (left().getReferencePosition() * getOuterWidth(ref))));</span>
            }

<span class="nc bnc" id="L1367" title="All 2 branches missed.">            if (right().getReferenceComponent() == null) {</span>
<span class="nc" id="L1368">                box.setWidth(parent.getLayoutWidth() - box.getX() - parentStyle.getPaddingRightNoRTL() - parent.getSideGap());</span>
            } else {
<span class="nc" id="L1370">                Component ref = right().getReferenceComponent();</span>
<span class="nc" id="L1371">                int refX = (int) (getOuterX(ref) + getOuterWidth(ref) - (right().getReferencePosition() * getOuterWidth(ref)));</span>
<span class="nc" id="L1372">                box.setWidth(refX - box.getX());</span>
            }

<span class="nc bnc" id="L1375" title="All 2 branches missed.">            if (bottom().getReferenceComponent() == null) {</span>
<span class="nc" id="L1376">                box.setHeight(parent.getLayoutHeight() - box.getY() - parentStyle.getPaddingBottom() - parent.getBottomGap());</span>
            } else {
<span class="nc" id="L1378">                Component ref = bottom().getReferenceComponent();</span>
<span class="nc" id="L1379">                int refY = (int) (getOuterY(ref) + getOuterHeight(ref) - (bottom().getReferencePosition() * getOuterHeight(ref)));</span>
<span class="nc" id="L1380">                box.setHeight(refY - box.getY());</span>
            }
<span class="nc" id="L1382">            return box;</span>
        }

        /**
         * Returns a reference box within which insets of the given component are calculated.  If
         * {@link cmp} has no reference components in any of its insets, then the resulting box will
         * just bee the inner box of the parent (e.g. the parent's inner bounds.
         *
         * @param parent The parent container.
         * @param cmp    The component whose reference box we are obtaining.
         * @return The reference box.
         * @deprecated Use {@link #getReferenceBox(com.codename1.ui.Container)
         */
        public Rectangle getReferenceBox(Container parent, Component cmp) {
<span class="nc" id="L1396">            return getReferenceBox(parent, cmp, new Rectangle());</span>
        }

        /**
         * Returns a reference box within which insets of the given component are calculated.  If
         * {@link cmp} has no reference components in any of its insets, then the resulting box will
         * just bee the inner box of the parent (e.g. the parent's inner bounds.
         *
         * @param parent The parent container.
         * @return The reference box.
         */
        public Rectangle getReferenceBox(Container parent) {
<span class="nc" id="L1408">            return getReferenceBox(parent, (Component) null);</span>
        }

        /**
         * Shifts the constraint by the specified number of pixels while maintaining the same units.  This is
         * used mainly in the GUI builder to facilitate dragging and resizing of the component.
         *
         * @param x        The number of pixels that the insets should be shifted on the x axis.
         * @param y        The number of pixels that the insets should be shifted on the y axis.
         * @param preferMM If an inset needs to be switched from flexible to fixed, then this indicates where it will
         *                 be changed to millimetres or pixels.  {@literal true} for millimetres.
         * @param parent   The parent container in which calculations should be performed.
         * @return Self for chaining.
         * @see #translateMM(float, float, boolean, com.codename1.ui.Container)
         */
        public LayeredLayoutConstraint translatePixels(int x, int y, boolean preferMM, Container parent) {
<span class="nc bnc" id="L1424" title="All 2 branches missed.">            if (y != 0) {</span>
<span class="nc bnc" id="L1425" title="All 2 branches missed.">                if (top().getUnit() == UNIT_BASELINE) {</span>
<span class="nc bnc" id="L1426" title="All 2 branches missed.">                    top().changeUnits(preferMM ? UNIT_DIPS : UNIT_PIXELS);</span>
<span class="nc bnc" id="L1427" title="All 4 branches missed.">                } else if (top().isFlexible() &amp;&amp; top().autoIsClipped) {</span>
<span class="nc bnc" id="L1428" title="All 2 branches missed.">                    top().changeUnits(preferMM ? UNIT_DIPS : UNIT_PIXELS);</span>
                }
<span class="nc bnc" id="L1430" title="All 4 branches missed.">                if (bottom().isFlexible() &amp;&amp; bottom().autoIsClipped) {</span>
<span class="nc bnc" id="L1431" title="All 2 branches missed.">                    bottom().changeUnits(preferMM ? UNIT_DIPS : UNIT_PIXELS);</span>
                }
<span class="nc bnc" id="L1433" title="All 4 branches missed.">                if (top().isFlexible() &amp;&amp; bottom().isFlexible()) {</span>
                    // Both top and bottom are flexible... we need to make one of these
                    // fixed
<span class="nc bnc" id="L1436" title="All 2 branches missed.">                    if (y &gt; 0) {</span>
                        // we're moving it to toward the bottom, so we'll choose the bottom
                        // as an anchor point.
<span class="nc" id="L1439">                        bottom().translatePixels(-y, preferMM, parent);</span>
                    } else {
<span class="nc" id="L1441">                        top().translatePixels(y, preferMM, parent);</span>
                    }
                } else {
<span class="nc bnc" id="L1444" title="All 2 branches missed.">                    if (top().isFixed()) {</span>
<span class="nc" id="L1445">                        top().translatePixels(y, preferMM, parent);</span>
                    }
<span class="nc bnc" id="L1447" title="All 2 branches missed.">                    if (bottom().isFixed()) {</span>
<span class="nc" id="L1448">                        bottom().translatePixels(-y, preferMM, parent);</span>
                    }
                }
            }
<span class="nc bnc" id="L1452" title="All 2 branches missed.">            if (x != 0) {</span>
<span class="nc bnc" id="L1453" title="All 4 branches missed.">                if (left().isFlexible() &amp;&amp; left().autoIsClipped) {</span>
<span class="nc bnc" id="L1454" title="All 2 branches missed.">                    left().changeUnits(preferMM ? UNIT_DIPS : UNIT_PIXELS);</span>

                }
<span class="nc bnc" id="L1457" title="All 4 branches missed.">                if (right().isFlexible() &amp;&amp; right().autoIsClipped) {</span>
<span class="nc bnc" id="L1458" title="All 2 branches missed.">                    right().changeUnits(preferMM ? UNIT_DIPS : UNIT_PIXELS);</span>
                }
<span class="nc bnc" id="L1460" title="All 4 branches missed.">                if (left().isFlexible() &amp;&amp; right().isFlexible()) {</span>
                    // Both top and bottom are flexible... we need to make one of these
                    // fixed
<span class="nc bnc" id="L1463" title="All 2 branches missed.">                    if (x &gt; 0) {</span>
                        // we're moving it to toward the bottom, so we'll choose the bottom
                        // as an anchor point.
<span class="nc" id="L1466">                        right().translatePixels(-x, preferMM, parent);</span>
                    } else {
<span class="nc" id="L1468">                        left().translatePixels(x, preferMM, parent);</span>
                    }
                } else {
<span class="nc bnc" id="L1471" title="All 2 branches missed.">                    if (left().isFixed()) {</span>
<span class="nc" id="L1472">                        left().translatePixels(x, preferMM, parent);</span>
                    }
<span class="nc bnc" id="L1474" title="All 2 branches missed.">                    if (right().isFixed()) {</span>
<span class="nc" id="L1475">                        right().translatePixels(-x, preferMM, parent);</span>
                    }
                }
            }
<span class="nc" id="L1479">            return this;</span>
        }

        /**
         * Shifts the constraint by the specified number of millimetres while maintaining the same units.  This is
         * used mainly in the GUI builder to facilitate dragging and resizing of the component.
         *
         * @param x        The number of pixels that the insets should be shifted on the x axis.
         * @param y        The number of pixels that the insets should be shifted on the y axis.
         * @param preferMM If an inset needs to be switched from flexible to fixed, then this indicates where it will
         *                 be changed to millimetres or pixels.  {@literal true} for millimetres.
         * @param parent   The parent container in which calculations should be performed.
         * @return Self for chaining.
         * @see #translatePixels(int, int, boolean, com.codename1.ui.Container)
         */
        public LayeredLayoutConstraint translateMM(float x, float y, boolean preferMM, Container parent) {
<span class="nc" id="L1495">            return translatePixels(Display.getInstance().convertToPixels(x), Display.getInstance().convertToPixels(y), preferMM, parent);</span>

        }

        /**
         * Gets the set of insets on this constraint that are fixed.  An inset is
         * considered fixed if it's unit is NOT {@link #UNIT_AUTO}.
         *
         * @return
         */
        public Collection&lt;Inset&gt; getFixedInsets() {
<span class="nc" id="L1506">            ArrayList&lt;Inset&gt; out = new ArrayList&lt;Inset&gt;();</span>
<span class="nc bnc" id="L1507" title="All 2 branches missed.">            for (Inset i : insets) {</span>
<span class="nc bnc" id="L1508" title="All 2 branches missed.">                if (i.unit != UNIT_AUTO) {</span>
<span class="nc" id="L1509">                    out.add(i);</span>
                }
            }
<span class="nc" id="L1512">            return out;</span>
        }

        /**
         * Gets the set of insets in this constraint that are flexible.  An inset is
         * considered flexible if it's unit is {@link #UNIT_AUTO}.
         *
         * @return
         */
        public Collection&lt;Inset&gt; getFlexibleInsets() {
<span class="nc" id="L1522">            ArrayList&lt;Inset&gt; out = new ArrayList&lt;Inset&gt;();</span>
<span class="nc bnc" id="L1523" title="All 2 branches missed.">            for (Inset i : insets) {</span>
<span class="nc bnc" id="L1524" title="All 2 branches missed.">                if (i.unit == UNIT_AUTO) {</span>
<span class="nc" id="L1525">                    out.add(i);</span>
                }
            }
<span class="nc" id="L1528">            return out;</span>
        }

        /**
         * Gets the reference positions of this constraint as a string.
         *
         * @param withLabels True to return the string in CSS format:  e.g. {@code &quot;top:1.0; right:0; bottom:1.0; left:1.0&quot;}  {@literal false}
         *                   to return as a space-delimited string of inset reference positions in the order &quot;top right bottom left&quot;.  E.g. {@literal &quot;1.0 0 1.0 1.0&quot;}
         * @return The reference positions as a string.
         */
        public String getReferencePositionsAsString(boolean withLabels) {
<span class="nc" id="L1539">            StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L1540" title="All 2 branches missed.">            if (withLabels) {</span>
<span class="nc" id="L1541">                sb.append(&quot;top:&quot;).append(top().referencePosition).append(&quot;; &quot;)</span>
<span class="nc" id="L1542">                        .append(&quot;right:&quot;).append(right().referencePosition).append(&quot;; &quot;)</span>
<span class="nc" id="L1543">                        .append(&quot;bottom:&quot;).append(bottom().referencePosition).append(&quot;; &quot;)</span>
<span class="nc" id="L1544">                        .append(&quot;left:&quot;).append(left().referencePosition);</span>
            } else {
<span class="nc" id="L1546">                sb.append(top().referencePosition).append(&quot; &quot;)</span>
<span class="nc" id="L1547">                        .append(right().referencePosition).append(&quot; &quot;)</span>
<span class="nc" id="L1548">                        .append(bottom().referencePosition).append(&quot; &quot;)</span>
<span class="nc" id="L1549">                        .append(left().referencePosition);</span>
            }
<span class="nc" id="L1551">            return sb.toString();</span>
        }

        /**
         * Sets the reference component positions for this constraint from a string.  The string format
         * may be either using labels following the same output format of {@literal getReferencePositionsAsString(true)}
         * or as a space-delimited string (e.g. {@literal getReferencePositionsAsString(false)}.  When using the label
         * format, you may provide one or more inset values in the string.  E.g. the following are all acceptable:
         * &lt;p&gt;
         * &lt;ul&gt;&lt;li&gt;{@literal top:1.0; left:0; right:0; bottom:1.0}&lt;/li&gt;
         * &lt;li&gt;{@literal left:0.5}&lt;/li&gt;
         * &lt;li&gt;{@literal left:1.0; right:0.5}&lt;/li&gt;
         * &lt;/ul&gt;
         * &lt;/p&gt;
         * &lt;p&gt;
         * If you provide the positions as a space-delimited string, then they are expected to follow the same format
         * as is used in CSS for providing &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/CSS/margin&quot;&gt;margin&lt;/a&gt;. To summarize:
         * &lt;/p&gt;
         * &lt;p&gt;
         * {@code
         * //Apply to all four sides
         * 1.0
         * &lt;p&gt;
         * //vertical | horizontal
         * 1.0 0
         * &lt;p&gt;
         * // top | horizontal | bottom
         * 1.0 0.0 0.5
         * &lt;p&gt;
         * // top | right | bottom | left
         * 1.0 1.0 1.0 1.0
         * }
         * &lt;/p&gt;
         *
         * &lt;p&gt;&lt;strong&gt;Interpretation of Reference Positions:&lt;/strong&gt;&lt;/p&gt;
         * &lt;p&gt;When an inset includes a reference component, that means that the inset is &quot;anchored&quot; to that
         * reference component.  I.e. An inset of {@literal 1mm} is measured 1mm from the outer edge of the
         * reference component.  By default it chooses the edge of on the &lt;em&gt;same side&lt;/em&gt; as the inset.  So
         * if this is a &quot;left&quot; inset, then it will measure against the &quot;left&quot; outer edge of the reference component.
         * This is the meaning of a {@literal 0} value for the associated reference positions.&lt;/p&gt;
         *
         * &lt;p&gt;A reference position of {@literal 1.0} will start measuring from the opposite edge.  So for a &quot;left&quot; inset,
         * it will measure from the &quot;right&quot; outer edge of the reference component.  You can choose any real value for the
         * reference position, and it will cause the measurement to be scaled accordingly.  E.g. {@literal 0.5.} would measure
         * from the center point of the reference component.&lt;/p&gt;
         *
         * @param positionsStr The reference positions.
         * @return Self for chaining.
         */
        public LayeredLayoutConstraint setReferencePositions(String positionsStr) {
<span class="nc" id="L1601">            positionsStr = positionsStr.trim();</span>
<span class="nc" id="L1602">            LayeredLayoutConstraint cnst = this;</span>
<span class="nc bnc" id="L1603" title="All 2 branches missed.">            if (positionsStr.indexOf(&quot;:&quot;) != -1) {</span>
<span class="nc" id="L1604">                String[] parts = Util.split(positionsStr, &quot;;&quot;);</span>
<span class="nc bnc" id="L1605" title="All 2 branches missed.">                for (String part : parts) {</span>
<span class="nc bnc" id="L1606" title="All 2 branches missed.">                    if (part.trim().length() == 0) {</span>
<span class="nc" id="L1607">                        continue;</span>
                    }
<span class="nc" id="L1609">                    String[] kv = Util.split(part, &quot;:&quot;);</span>
<span class="nc" id="L1610">                    String key = kv[0].trim();</span>
<span class="nc" id="L1611">                    String val = kv[1].trim();</span>
<span class="nc bnc" id="L1612" title="All 2 branches missed.">                    if (&quot;top&quot;.equals(key)) {</span>
<span class="nc" id="L1613">                        cnst.top().referencePosition = Float.parseFloat(val);</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">                    } else if (&quot;bottom&quot;.equals(key)) {</span>
<span class="nc" id="L1615">                        cnst.bottom().referencePosition = Float.parseFloat(val);</span>
<span class="nc bnc" id="L1616" title="All 2 branches missed.">                    } else if (&quot;left&quot;.equals(key)) {</span>
<span class="nc" id="L1617">                        cnst.left().referencePosition = Float.parseFloat(val);</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">                    } else if (&quot;right&quot;.equals(key)) {</span>
<span class="nc" id="L1619">                        cnst.right().referencePosition = Float.parseFloat(val);</span>
                    }


                }
<span class="nc" id="L1624">            } else {</span>
<span class="nc" id="L1625">                String[] parts = Util.split(positionsStr, &quot; &quot;);</span>
<span class="nc bnc" id="L1626" title="All 2 branches missed.">                if (parts.length == 1) {</span>
<span class="nc" id="L1627">                    float f = Float.parseFloat(parts[0]);</span>
<span class="nc" id="L1628">                    top().referencePosition = f;</span>
<span class="nc" id="L1629">                    right().referencePosition = f;</span>
<span class="nc" id="L1630">                    bottom().referencePosition = f;</span>
<span class="nc" id="L1631">                    left().referencePosition = f;</span>

<span class="nc bnc" id="L1633" title="All 2 branches missed.">                } else if (parts.length == 2) {</span>
<span class="nc" id="L1634">                    float f0 = Float.parseFloat(parts[0]);</span>
<span class="nc" id="L1635">                    float f1 = Float.parseFloat(parts[1]);</span>
<span class="nc" id="L1636">                    top().referencePosition = f0;</span>
<span class="nc" id="L1637">                    bottom().referencePosition = f0;</span>
<span class="nc" id="L1638">                    left().referencePosition = f1;</span>
<span class="nc" id="L1639">                    right().referencePosition = f1;</span>
<span class="nc bnc" id="L1640" title="All 2 branches missed.">                } else if (parts.length == 3) {</span>
<span class="nc" id="L1641">                    float f0 = Float.parseFloat(parts[0]);</span>
<span class="nc" id="L1642">                    float f1 = Float.parseFloat(parts[1]);</span>
<span class="nc" id="L1643">                    float f2 = Float.parseFloat(parts[2]);</span>
<span class="nc" id="L1644">                    top().referencePosition = f0;</span>
<span class="nc" id="L1645">                    left().referencePosition = f1;</span>
<span class="nc" id="L1646">                    right().referencePosition = f1;</span>
<span class="nc" id="L1647">                    bottom().referencePosition = f2;</span>
<span class="nc bnc" id="L1648" title="All 2 branches missed.">                } else if (parts.length == 4) {</span>
<span class="nc" id="L1649">                    float f0 = Float.parseFloat(parts[0]);</span>
<span class="nc" id="L1650">                    float f1 = Float.parseFloat(parts[1]);</span>
<span class="nc" id="L1651">                    float f2 = Float.parseFloat(parts[2]);</span>
<span class="nc" id="L1652">                    float f3 = Float.parseFloat(parts[3]);</span>
<span class="nc" id="L1653">                    top().referencePosition = f0;</span>
<span class="nc" id="L1654">                    right().referencePosition = f1;</span>
<span class="nc" id="L1655">                    bottom().referencePosition = f2;</span>
<span class="nc" id="L1656">                    left().referencePosition = f3;</span>
                }
            }
<span class="nc" id="L1659">            return this;</span>
        }

        /**
         * Gets the reference component indexes within the provided {@literal parent} container as a string.
         * If an inset doesn't have a reference component, then the corresponding index will be {@literal -1}.
         * &lt;p&gt;
         * Use the {@literal withLabels} parameter to choose whether to include labels with the indices or not.  E.g:
         * &lt;p&gt;
         * {@code
         * String indices = getReferenceComponentIndicesAsString(parent, true);
         * // Would return something like
         * // &quot;top:-1; right:2; bottom:-1; left: 0&quot;
         * &lt;p&gt;
         * indices = getReferenceComponentIndicesAsString(parent, false);
         * // Would return something like:
         * // &quot;-1 2 -1 0&quot;  (i.e. Top Right Bottom Left)
         * &lt;p&gt;
         * // Interpretation:
         * //   Top inset has no reference component
         * //   Right inset has component with index 2 (i.e. parent.getComponentIndex(rightReferenceComponent) == 2)
         * //   Bottom inset has no reference component
         * //   Left inset has component with index 0 as a reference component.
         * }
         * &lt;/p&gt;
         *
         * @param parent
         * @param withLabels
         * @return
         */
        public String getReferenceComponentIndicesAsString(Container parent, boolean withLabels) {
<span class="nc" id="L1690">            fixDependencies(parent);</span>
<span class="nc" id="L1691">            StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L1692" title="All 2 branches missed.">            if (withLabels) {</span>
<span class="nc bnc" id="L1693" title="All 4 branches missed.">                if (top().referenceComponent != null &amp;&amp; top().referenceComponent.getParent() != null) {</span>
<span class="nc" id="L1694">                    Component cmp = top().referenceComponent;</span>
<span class="nc" id="L1695">                    sb.append(&quot;top:&quot;).append(cmp.getParent().getComponentIndex(cmp)).append(&quot;; &quot;);</span>
<span class="nc" id="L1696">                } else {</span>
<span class="nc" id="L1697">                    sb.append(&quot;top:-1; &quot;);</span>
                }
<span class="nc bnc" id="L1699" title="All 4 branches missed.">                if (right().referenceComponent != null &amp;&amp; right().referenceComponent.getParent() != null) {</span>
<span class="nc" id="L1700">                    Component cmp = right().referenceComponent;</span>
<span class="nc" id="L1701">                    sb.append(&quot;right:&quot;).append(cmp.getParent().getComponentIndex(cmp)).append(&quot;; &quot;);</span>
<span class="nc" id="L1702">                } else {</span>
<span class="nc" id="L1703">                    sb.append(&quot;right:-1; &quot;);</span>
                }
<span class="nc bnc" id="L1705" title="All 4 branches missed.">                if (bottom().referenceComponent != null &amp;&amp; bottom().referenceComponent.getParent() != null) {</span>
<span class="nc" id="L1706">                    Component cmp = bottom().referenceComponent;</span>
<span class="nc" id="L1707">                    sb.append(&quot;bottom:&quot;).append(cmp.getParent().getComponentIndex(cmp)).append(&quot;; &quot;);</span>
<span class="nc" id="L1708">                } else {</span>
<span class="nc" id="L1709">                    sb.append(&quot;bottom:-1; &quot;);</span>
                }

<span class="nc bnc" id="L1712" title="All 4 branches missed.">                if (left().referenceComponent != null &amp;&amp; left().referenceComponent.getParent() != null) {</span>
<span class="nc" id="L1713">                    Component cmp = left().referenceComponent;</span>
<span class="nc" id="L1714">                    sb.append(&quot;left:&quot;).append(cmp.getParent().getComponentIndex(cmp)).append(&quot;; &quot;);</span>
<span class="nc" id="L1715">                } else {</span>
<span class="nc" id="L1716">                    sb.append(&quot;left:-1&quot;);</span>
                }
            } else {
<span class="nc bnc" id="L1719" title="All 4 branches missed.">                if (top().referenceComponent != null &amp;&amp; top().referenceComponent.getParent() != null) {</span>
<span class="nc" id="L1720">                    Component cmp = top().referenceComponent;</span>
<span class="nc" id="L1721">                    sb.append(cmp.getParent().getComponentIndex(cmp)).append(&quot; &quot;);</span>
<span class="nc" id="L1722">                } else {</span>
<span class="nc" id="L1723">                    sb.append(&quot;-1 &quot;);</span>
                }
<span class="nc bnc" id="L1725" title="All 4 branches missed.">                if (right().referenceComponent != null &amp;&amp; right().referenceComponent.getParent() != null) {</span>
<span class="nc" id="L1726">                    Component cmp = right().referenceComponent;</span>
<span class="nc" id="L1727">                    sb.append(cmp.getParent().getComponentIndex(cmp)).append(&quot; &quot;);</span>
<span class="nc" id="L1728">                } else {</span>
<span class="nc" id="L1729">                    sb.append(&quot;-1 &quot;);</span>
                }
<span class="nc bnc" id="L1731" title="All 4 branches missed.">                if (bottom().referenceComponent != null &amp;&amp; bottom().referenceComponent.getParent() != null) {</span>
<span class="nc" id="L1732">                    Component cmp = bottom().referenceComponent;</span>
<span class="nc" id="L1733">                    sb.append(cmp.getParent().getComponentIndex(cmp)).append(&quot; &quot;);</span>
<span class="nc" id="L1734">                } else {</span>
<span class="nc" id="L1735">                    sb.append(&quot;-1 &quot;);</span>
                }

<span class="nc bnc" id="L1738" title="All 4 branches missed.">                if (left().referenceComponent != null &amp;&amp; left().referenceComponent.getParent() != null) {</span>
<span class="nc" id="L1739">                    Component cmp = left().referenceComponent;</span>
<span class="nc" id="L1740">                    sb.append(cmp.getParent().getComponentIndex(cmp)).append(&quot; &quot;);</span>
<span class="nc" id="L1741">                } else {</span>
<span class="nc" id="L1742">                    sb.append(&quot;-1&quot;);</span>
                }
            }

<span class="nc" id="L1746">            return sb.toString();</span>

        }

        /**
         * Sets the reference components of the insets of this constraint as indices of the provided parent
         * container.
         *
         * @param parent  The parent container whose children are to be used as reference components.
         * @param indices The indices to set as the reference components.
         *                &lt;p&gt;The string format
         *                may be either using labels following the same output format of {@literal cnst.getReferenceComponentIndicesAsString(true)}
         *                or as a space-delimited string (e.g. {@literal cnst.getReferenceComponentIndicesAsString(false)}.  When using the label
         *                format, you may provide one or more inset values in the string.  E.g. the following are all acceptable:&lt;/p&gt;
         *                &lt;p&gt;
         *                &lt;ul&gt;&lt;li&gt;{@literal top:-1; left:0; right:0; bottom:1}&lt;/li&gt;
         *                &lt;li&gt;{@literal left:1}&lt;/li&gt;
         *                &lt;li&gt;{@literal left:10; right:-1}&lt;/li&gt;
         *                &lt;/ul&gt;
         *                &lt;/p&gt;
         *                &lt;p&gt;
         *                If you provide the positions as a space-delimited string, then they are expected to follow the same format
         *                as is used in CSS for providing &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/CSS/margin&quot;&gt;margin&lt;/a&gt;. To summarize:
         *                &lt;/p&gt;
         *                &lt;p&gt;
         *                {@code
         *                //Set component at index 0 as reference for all 4 insets.
         *                0
         *                &lt;p&gt;
         *                //vertical insets use component index 2 | horizontal insets use component index 1
         *                2 1
         *                &lt;p&gt;
         *                // top | horizontal | bottom
         *                -1 3 10
         *                &lt;p&gt;
         *                // top | right | bottom | left
         *                -1 -1 -1 -1
         *                }
         *
         *                &lt;/p&gt;
         *                &lt;p&gt;&lt;strong&gt;Note: An index of {@literal -1} means that the corresponding inset has no reference component.&lt;/strong&gt;&lt;/p&gt;
         * @return
         */
        public LayeredLayoutConstraint setReferenceComponentIndices(Container parent, String indices) {
<span class="nc" id="L1790">            indices = indices.trim();</span>
<span class="nc" id="L1791">            LayeredLayoutConstraint cnst = this;</span>
<span class="nc bnc" id="L1792" title="All 2 branches missed.">            if (indices.indexOf(&quot;:&quot;) != -1) {</span>
<span class="nc" id="L1793">                String[] parts = Util.split(indices, &quot;;&quot;);</span>
<span class="nc bnc" id="L1794" title="All 2 branches missed.">                for (String part : parts) {</span>
<span class="nc bnc" id="L1795" title="All 2 branches missed.">                    if (part.trim().length() == 0) {</span>
<span class="nc" id="L1796">                        continue;</span>
                    }
<span class="nc" id="L1798">                    String[] kv = Util.split(part, &quot;:&quot;);</span>
<span class="nc" id="L1799">                    String key = kv[0].trim();</span>
<span class="nc" id="L1800">                    String val = kv[1].trim();</span>
<span class="nc bnc" id="L1801" title="All 2 branches missed.">                    if (&quot;top&quot;.equals(key)) {</span>
<span class="nc" id="L1802">                        int index = Integer.parseInt(val);</span>
<span class="nc bnc" id="L1803" title="All 2 branches missed.">                        if (index &gt;= 0) {</span>
<span class="nc" id="L1804">                            cnst.top().referenceComponent = parent.getComponentAt(index);</span>
                        } else {
<span class="nc" id="L1806">                            cnst.top().referenceComponent = null;</span>
                        }
<span class="nc bnc" id="L1808" title="All 2 branches missed.">                    } else if (&quot;bottom&quot;.equals(key)) {</span>
<span class="nc" id="L1809">                        int index = Integer.parseInt(val);</span>
<span class="nc bnc" id="L1810" title="All 2 branches missed.">                        if (index &gt;= 0) {</span>
<span class="nc" id="L1811">                            cnst.bottom().referenceComponent = parent.getComponentAt(index);</span>
                        } else {
<span class="nc" id="L1813">                            cnst.bottom().referenceComponent = null;</span>
                        }
<span class="nc bnc" id="L1815" title="All 2 branches missed.">                    } else if (&quot;left&quot;.equals(key)) {</span>
<span class="nc" id="L1816">                        int index = Integer.parseInt(val);</span>
<span class="nc bnc" id="L1817" title="All 2 branches missed.">                        if (index &gt;= 0) {</span>
<span class="nc" id="L1818">                            cnst.left().referenceComponent = parent.getComponentAt(index);</span>
                        } else {
<span class="nc" id="L1820">                            cnst.left().referenceComponent = null;</span>
                        }
<span class="nc bnc" id="L1822" title="All 2 branches missed.">                    } else if (&quot;right&quot;.equals(key)) {</span>
<span class="nc" id="L1823">                        int index = Integer.parseInt(val);</span>
<span class="nc bnc" id="L1824" title="All 2 branches missed.">                        if (index &gt;= 0) {</span>
<span class="nc" id="L1825">                            cnst.right().referenceComponent = parent.getComponentAt(index);</span>
                        } else {
<span class="nc" id="L1827">                            cnst.right().referenceComponent = null;</span>
                        }
                    }


                }
<span class="nc" id="L1833">            } else {</span>
<span class="nc" id="L1834">                String[] parts = Util.split(indices, &quot; &quot;);</span>
<span class="nc bnc" id="L1835" title="All 2 branches missed.">                if (parts.length == 1) {</span>
<span class="nc" id="L1836">                    int i0 = Integer.parseInt(parts[0]);</span>
<span class="nc bnc" id="L1837" title="All 2 branches missed.">                    if (i0 == -1) {</span>
<span class="nc" id="L1838">                        top().referenceComponent = null;</span>
<span class="nc" id="L1839">                        right().referenceComponent = null;</span>
<span class="nc" id="L1840">                        bottom().referenceComponent = null;</span>
<span class="nc" id="L1841">                        left().referenceComponent = null;</span>
                    } else {
<span class="nc" id="L1843">                        Component cmp = parent.getComponentAt(i0);</span>
<span class="nc" id="L1844">                        top().referenceComponent = cmp;</span>
<span class="nc" id="L1845">                        right().referenceComponent = cmp;</span>
<span class="nc" id="L1846">                        bottom().referenceComponent = cmp;</span>
<span class="nc" id="L1847">                        left().referenceComponent = cmp;</span>
                    }
<span class="nc bnc" id="L1849" title="All 2 branches missed.">                } else if (parts.length == 2) {</span>
<span class="nc" id="L1850">                    int i0 = Integer.parseInt(parts[0]);</span>
<span class="nc" id="L1851">                    int i1 = Integer.parseInt(parts[1]);</span>
<span class="nc" id="L1852">                    Component cmp = null;</span>
<span class="nc bnc" id="L1853" title="All 2 branches missed.">                    if (i0 != -1) {</span>
<span class="nc" id="L1854">                        cmp = parent.getComponentAt(i0);</span>
                    }
<span class="nc" id="L1856">                    top().referenceComponent = cmp;</span>
<span class="nc" id="L1857">                    bottom().referenceComponent = cmp;</span>

<span class="nc" id="L1859">                    cmp = null;</span>
<span class="nc bnc" id="L1860" title="All 2 branches missed.">                    if (i1 != -1) {</span>
<span class="nc" id="L1861">                        cmp = parent.getComponentAt(i1);</span>
                    }
<span class="nc" id="L1863">                    left().referenceComponent = cmp;</span>
<span class="nc" id="L1864">                    right().referenceComponent = cmp;</span>
<span class="nc bnc" id="L1865" title="All 2 branches missed.">                } else if (parts.length == 3) {</span>
<span class="nc" id="L1866">                    int i0 = Integer.parseInt(parts[0]);</span>
<span class="nc" id="L1867">                    int i1 = Integer.parseInt(parts[1]);</span>
<span class="nc" id="L1868">                    int i2 = Integer.parseInt(parts[2]);</span>
<span class="nc" id="L1869">                    Component cmp = null;</span>
<span class="nc bnc" id="L1870" title="All 2 branches missed.">                    if (i0 != -1) {</span>
<span class="nc" id="L1871">                        cmp = parent.getComponentAt(i0);</span>
                    }
<span class="nc" id="L1873">                    top().referenceComponent = cmp;</span>
<span class="nc" id="L1874">                    cmp = null;</span>
<span class="nc bnc" id="L1875" title="All 2 branches missed.">                    if (i1 != -1) {</span>
<span class="nc" id="L1876">                        cmp = parent.getComponentAt(i1);</span>
                    }
<span class="nc" id="L1878">                    left().referenceComponent = cmp;</span>
<span class="nc" id="L1879">                    right().referenceComponent = cmp;</span>
<span class="nc" id="L1880">                    cmp = null;</span>
<span class="nc bnc" id="L1881" title="All 2 branches missed.">                    if (i2 != -1) {</span>
<span class="nc" id="L1882">                        cmp = parent.getComponentAt(i2);</span>
                    }
<span class="nc" id="L1884">                    bottom().referenceComponent = cmp;</span>

<span class="nc bnc" id="L1886" title="All 2 branches missed.">                } else if (parts.length == 4) {</span>
<span class="nc" id="L1887">                    int i0 = Integer.parseInt(parts[0]);</span>
<span class="nc" id="L1888">                    int i1 = Integer.parseInt(parts[1]);</span>
<span class="nc" id="L1889">                    int i2 = Integer.parseInt(parts[2]);</span>
<span class="nc" id="L1890">                    int i3 = Integer.parseInt(parts[3]);</span>
<span class="nc" id="L1891">                    Component cmp = null;</span>
<span class="nc bnc" id="L1892" title="All 2 branches missed.">                    if (i0 != -1) {</span>
<span class="nc" id="L1893">                        cmp = parent.getComponentAt(i0);</span>
                    }
<span class="nc" id="L1895">                    top().referenceComponent = cmp;</span>
<span class="nc" id="L1896">                    cmp = null;</span>
<span class="nc bnc" id="L1897" title="All 2 branches missed.">                    if (i1 != -1) {</span>
<span class="nc" id="L1898">                        cmp = parent.getComponentAt(i1);</span>
                    }
<span class="nc" id="L1900">                    right().referenceComponent = cmp;</span>
<span class="nc" id="L1901">                    cmp = null;</span>
<span class="nc bnc" id="L1902" title="All 2 branches missed.">                    if (i2 != -1) {</span>
<span class="nc" id="L1903">                        cmp = parent.getComponentAt(i2);</span>
                    }

<span class="nc" id="L1906">                    bottom().referenceComponent = cmp;</span>
<span class="nc" id="L1907">                    cmp = null;</span>
<span class="nc bnc" id="L1908" title="All 2 branches missed.">                    if (i3 != -1) {</span>
<span class="nc" id="L1909">                        cmp = parent.getComponentAt(i3);</span>
                    }
<span class="nc" id="L1911">                    left().referenceComponent = cmp;</span>
                }
            }
<span class="nc" id="L1914">            return this;</span>
        }

        /**
         * Gets the insets of this constraint as a string. If {@literal withLabels} is {@literal true}, then it
         * will return a string of the format:
         * &lt;p&gt;{@literal top:2mm; right:0; bottom:10%; left:auto}&lt;/p&gt;
         * &lt;p&gt;If {@literal withLabels} is {@literal false} then it will return a space-delimited string with
         * the inset values ordered &quot;top right bottom left&quot; (the same as for CSS margins) order.&lt;/p&gt;
         *
         * @param withLabels
         * @return
         */
        public String getInsetsAsString(boolean withLabels) {
<span class="nc" id="L1928">            StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L1929" title="All 2 branches missed.">            if (withLabels) {</span>
<span class="nc" id="L1930">                sb.append(&quot;top:&quot;).append(top().getValueAsString()).append(&quot;; &quot;)</span>
<span class="nc" id="L1931">                        .append(&quot;right:&quot;).append(right().getValueAsString()).append(&quot;; &quot;)</span>
<span class="nc" id="L1932">                        .append(&quot;bottom:&quot;).append(bottom().getValueAsString()).append(&quot;; &quot;)</span>
<span class="nc" id="L1933">                        .append(&quot;left:&quot;).append(left().getValueAsString());</span>
            } else {
<span class="nc" id="L1935">                sb.append(top().getValueAsString()).append(&quot; &quot;)</span>
<span class="nc" id="L1936">                        .append(right().getValueAsString()).append(&quot; &quot;)</span>
<span class="nc" id="L1937">                        .append(bottom().getValueAsString()).append(&quot; &quot;)</span>
<span class="nc" id="L1938">                        .append(left().getValueAsString());</span>
            }
<span class="nc" id="L1940">            return sb.toString();</span>
        }

        /**
         * Sets the reference components for the constraint.
         *
         * @param refs May contain 1, 2, 3, or 4 values.  If only 1 value is passed, then it is
         *             set on all 4 insets.  If two values are passed, then the first is set on the top and bottom
         *             insets, and the 2nd is set on the left and right insets (i.e. vertical | horizontal).
         *             If 3 values are passed, then, they are used for top, horizontal, and bottom.
         *             If 4 values are passed, then they are used for top, right, bottom, left (in that order).
         * @return Self for chaining.
         */
        public LayeredLayoutConstraint setReferenceComponents(Component... refs) {
<span class="nc bnc" id="L1954" title="All 2 branches missed.">            if (refs.length == 1) {</span>
<span class="nc" id="L1955">                top().referenceComponent = refs[0];</span>
<span class="nc" id="L1956">                right().referenceComponent = refs[0];</span>
<span class="nc" id="L1957">                bottom().referenceComponent = refs[0];</span>
<span class="nc" id="L1958">                left().referenceComponent = refs[0];</span>
<span class="nc bnc" id="L1959" title="All 2 branches missed.">            } else if (refs.length == 2) {</span>
<span class="nc" id="L1960">                top().referenceComponent = refs[0];</span>
<span class="nc" id="L1961">                bottom().referenceComponent = refs[0];</span>
<span class="nc" id="L1962">                left().referenceComponent = refs[1];</span>
<span class="nc" id="L1963">                right().referenceComponent = refs[1];</span>
<span class="nc bnc" id="L1964" title="All 2 branches missed.">            } else if (refs.length == 3) {</span>
<span class="nc" id="L1965">                top().referenceComponent = refs[0];</span>
<span class="nc" id="L1966">                left().referenceComponent = refs[1];</span>
<span class="nc" id="L1967">                right().referenceComponent = refs[1];</span>
<span class="nc" id="L1968">                bottom().referenceComponent = refs[2];</span>
<span class="nc bnc" id="L1969" title="All 2 branches missed.">            } else if (refs.length == 4) {</span>
<span class="nc" id="L1970">                top().referenceComponent = refs[0];</span>
<span class="nc" id="L1971">                right().referenceComponent = refs[1];</span>
<span class="nc" id="L1972">                bottom().referenceComponent = refs[2];</span>
<span class="nc" id="L1973">                left().referenceComponent = refs[3];</span>
            }
<span class="nc" id="L1975">            return this;</span>
        }

        /**
         * Sets the reference positions for the constraint.
         * &lt;p&gt;&lt;strong&gt;Interpretation of Reference Positions:&lt;/strong&gt;&lt;/p&gt;
         * &lt;p&gt;When an inset includes a reference component, that means that the inset is &quot;anchored&quot; to that
         * reference component.  I.e. An inset of {@literal 1mm} is measured 1mm from the outer edge of the
         * reference component.  By default it chooses the edge of on the &lt;em&gt;same side&lt;/em&gt; as the inset.  So
         * if this is a &quot;left&quot; inset, then it will measure against the &quot;left&quot; outer edge of the reference component.
         * This is the meaning of a {@literal 0} value for the associated reference positions.&lt;/p&gt;
         *
         * &lt;p&gt;A reference position of {@literal 1.0} will start measuring from the opposite edge.  So for a &quot;left&quot; inset,
         * it will measure from the &quot;right&quot; outer edge of the reference component.  You can choose any real value for the
         * reference position, and it will cause the measurement to be scaled accordingly.  E.g. {@literal 0.5.} would measure
         * from the center point of the reference component.&lt;/p&gt;
         *
         * @param p May contain 1, 2, 3, or 4 values.  If only 1 value is passed, then it is
         *          set on all 4 insets.  If two values are passed, then the first is set on the top and bottom
         *          insets, and the 2nd is set on the left and right insets (i.e. vertical | horizontal).
         *          If 3 values are passed, then, they are used for top, horizontal, and bottom.
         *          If 4 values are passed, then they are used for top, right, bottom, left (in that order).
         * @return Self for chaining.
         */
        public LayeredLayoutConstraint setReferencePositions(float... p) {
<span class="nc bnc" id="L2000" title="All 2 branches missed.">            if (p.length == 1) {</span>
<span class="nc bnc" id="L2001" title="All 2 branches missed.">                for (Inset i : insets) {</span>
<span class="nc" id="L2002">                    i.referencePosition = p[0];</span>
                }
<span class="nc bnc" id="L2004" title="All 2 branches missed.">            } else if (p.length == 2) {</span>
<span class="nc bnc" id="L2005" title="All 2 branches missed.">                for (Inset i : insets) {</span>
<span class="nc bnc" id="L2006" title="All 2 branches missed.">                    switch (i.side) {</span>
                        case Component.TOP:
                        case Component.BOTTOM:
<span class="nc" id="L2009">                            i.referencePosition = p[0];</span>
<span class="nc" id="L2010">                            break;</span>
                        default:
<span class="nc" id="L2012">                            i.referencePosition = p[1];</span>
                    }
                }
<span class="nc bnc" id="L2015" title="All 2 branches missed.">            } else if (p.length == 3) {</span>
<span class="nc bnc" id="L2016" title="All 2 branches missed.">                for (Inset i : insets) {</span>
<span class="nc bnc" id="L2017" title="All 3 branches missed.">                    switch (i.side) {</span>
                        case Component.TOP:
<span class="nc" id="L2019">                            i.referencePosition = p[0];</span>
<span class="nc" id="L2020">                            break;</span>
                        case Component.LEFT:
                        case Component.RIGHT:
<span class="nc" id="L2023">                            i.referencePosition = p[1];</span>
<span class="nc" id="L2024">                            break;</span>
                        default:
<span class="nc" id="L2026">                            i.referencePosition = p[2];</span>
                    }
                }
<span class="nc bnc" id="L2029" title="All 2 branches missed.">            } else if (p.length == 4) {</span>
<span class="nc bnc" id="L2030" title="All 2 branches missed.">                for (Inset i : insets) {</span>
<span class="nc bnc" id="L2031" title="All 4 branches missed.">                    switch (i.side) {</span>
                        case Component.TOP:
<span class="nc" id="L2033">                            i.referencePosition = p[0];</span>
<span class="nc" id="L2034">                            break;</span>
                        case Component.RIGHT:
<span class="nc" id="L2036">                            i.referencePosition = p[1];</span>
<span class="nc" id="L2037">                            break;</span>
                        case Component.BOTTOM:
<span class="nc" id="L2039">                            i.referencePosition = p[2];</span>
<span class="nc" id="L2040">                            break;</span>


                        default:
<span class="nc" id="L2044">                            i.referencePosition = p[3];</span>
                    }
                }
            }
<span class="nc" id="L2048">            return this;</span>
        }

        /**
         * Sets the insets for this constraint as a string.  The string may include labels
         * or it may be a space delimited string of values with &quot;top right bottom left&quot; order.
         *
         * &lt;p&gt;
         * If providing as a space-delimited string of inset values, then you can provide 1, 2, 3, or 4
         * values.  If only 1 value is passed, then it is
         * set on all 4 insets.  If two values are passed, then the first is set on the top and bottom
         * insets, and the 2nd is set on the left and right insets (i.e. vertical | horizontal).
         * If 3 values are passed, then, they are used for top, horizontal, and bottom.
         * If 4 values are passed, then they are used for top, right, bottom, left (in that order).
         * &lt;/p&gt;
         * &lt;p&gt;
         * &lt;strong&gt;Example Inputs&lt;/strong&gt;
         * &lt;/p&gt;
         * &lt;p&gt;
         * &lt;ul&gt;
         *   &lt;li&gt;{@literal &quot;0 0 0 0&quot;} = all 4 insets are zero pixels&lt;/li&gt;
         *   &lt;li&gt;{@literal &quot;0 1mm&quot;} = Vertical insets are zero.  Horizontal insets are 1mm&lt;/li&gt;
         *   &lt;li&gt;{@literal &quot;10% auto 20%&quot;} = Top inset is 10%.  Horizontal insets are flexible.  Bottom is 20%&lt;/li&gt;
         *   &lt;li&gt;{@literal &quot;1mm 2mm 3mm 4mm&quot;} = Top=1mm, Right=2mm, Bottom=3mm, Left=4mm&lt;/li&gt;
         * &lt;/ul&gt;
         * &lt;/p&gt;
         *
         * @param insetStr
         * @return Self for chaining.
         */
        public LayeredLayoutConstraint setInsets(String insetStr) {

<span class="fc" id="L2080">            LayeredLayoutConstraint cnst = this;</span>
<span class="pc bpc" id="L2081" title="1 of 2 branches missed.">            if (insetStr.indexOf(&quot;:&quot;) != -1) {</span>
<span class="nc" id="L2082">                String[] parts = Util.split(insetStr, &quot;;&quot;);</span>
<span class="nc bnc" id="L2083" title="All 2 branches missed.">                for (String part : parts) {</span>
<span class="nc bnc" id="L2084" title="All 2 branches missed.">                    if (part.trim().length() == 0) {</span>
<span class="nc" id="L2085">                        continue;</span>
                    }
<span class="nc" id="L2087">                    String[] kv = Util.split(part, &quot;:&quot;);</span>
<span class="nc" id="L2088">                    String key = kv[0].trim();</span>
<span class="nc" id="L2089">                    String val = kv[1].trim();</span>
<span class="nc bnc" id="L2090" title="All 2 branches missed.">                    if (&quot;top&quot;.equals(key)) {</span>
<span class="nc" id="L2091">                        cnst.top().setValue(val);</span>
<span class="nc bnc" id="L2092" title="All 2 branches missed.">                    } else if (&quot;bottom&quot;.equals(key)) {</span>
<span class="nc" id="L2093">                        cnst.bottom().setValue(val);</span>
<span class="nc bnc" id="L2094" title="All 2 branches missed.">                    } else if (&quot;left&quot;.equals(key)) {</span>
<span class="nc" id="L2095">                        cnst.left().setValue(val);</span>
<span class="nc bnc" id="L2096" title="All 2 branches missed.">                    } else if (&quot;right&quot;.equals(key)) {</span>
<span class="nc" id="L2097">                        cnst.right().setValue(val);</span>
                    }


                }
<span class="nc" id="L2102">            } else {</span>
<span class="fc" id="L2103">                String[] parts = Util.split(insetStr, &quot; &quot;);</span>
<span class="pc bpc" id="L2104" title="1 of 2 branches missed.">                if (parts.length == 1) {</span>
<span class="nc" id="L2105">                    top().setValue(parts[0]);</span>
<span class="nc" id="L2106">                    right().setValue(parts[0]);</span>
<span class="nc" id="L2107">                    bottom().setValue(parts[0]);</span>
<span class="nc" id="L2108">                    left().setValue(parts[0]);</span>

<span class="pc bpc" id="L2110" title="1 of 2 branches missed.">                } else if (parts.length == 2) {</span>
<span class="nc" id="L2111">                    top().setValue(parts[0]);</span>
<span class="nc" id="L2112">                    bottom().setValue(parts[0]);</span>
<span class="nc" id="L2113">                    left().setValue(parts[1]);</span>
<span class="nc" id="L2114">                    right().setValue(parts[1]);</span>
<span class="pc bpc" id="L2115" title="1 of 2 branches missed.">                } else if (parts.length == 3) {</span>
<span class="nc" id="L2116">                    top().setValue(parts[0]);</span>
<span class="nc" id="L2117">                    left().setValue(parts[1]);</span>
<span class="nc" id="L2118">                    right().setValue(parts[1]);</span>
<span class="nc" id="L2119">                    bottom().setValue(parts[2]);</span>
<span class="pc bpc" id="L2120" title="1 of 2 branches missed.">                } else if (parts.length == 4) {</span>
<span class="fc" id="L2121">                    top().setValue(parts[0]);</span>
<span class="fc" id="L2122">                    right().setValue(parts[1]);</span>
<span class="fc" id="L2123">                    bottom().setValue(parts[2]);</span>
<span class="fc" id="L2124">                    left().setValue(parts[3]);</span>
                }
            }
<span class="fc" id="L2127">            return this;</span>
        }

        /**
         * Gets the left inset.
         *
         * @return The left inset
         */
        public Inset left() {
<span class="fc" id="L2136">            return insets[Component.LEFT];</span>
        }

        /**
         * Gets the right inset.
         *
         * @return The right inset.
         */
        public Inset right() {
<span class="fc" id="L2145">            return insets[Component.RIGHT];</span>
        }

        /**
         * Gets the top inset
         *
         * @return The top inset
         */
        public Inset top() {
<span class="fc" id="L2154">            return insets[Component.TOP];</span>
        }

        /**
         * Gets the bottom inset.
         *
         * @return The bottom inset
         */
        public Inset bottom() {
<span class="fc" id="L2163">            return insets[Component.BOTTOM];</span>
        }

        /**
         * @return anchor used for left and right percentage insets
         */
        public float getPercentInsetAnchorHorizontal() {
<span class="fc" id="L2170">            return this.percAnchorH;</span>
        }

        /**
         * Sets the anchor used for left and right percentage insets. An anchor
         * of {@literal 0} points to the component's edge which is on that side
         * the inset refers to (e.g. in case of the left inset the left edge).
         * An anchor of {@literal 1} points to the edge on the opposite side.
         * By default {@literal 0} is used as anchor.
         *
         * @param anchor
         * @return Self for chaining
         */
        public LayeredLayoutConstraint setPercentInsetAnchorHorizontal(float anchor) {
<span class="nc" id="L2184">            this.percAnchorH = anchor;</span>
<span class="nc" id="L2185">            return this;</span>
        }

        /**
         * @return anchor used for top and bottom percentage insets
         */
        public float getPercentInsetAnchorVertical() {
<span class="nc" id="L2192">            return this.percAnchorV;</span>
        }

        /**
         * Sets the anchor used for top and bottom percentage insets. An anchor
         * of {@literal 0} points to the component's edge which is on that side
         * the inset refers to (e.g. in case of the top inset the top edge).
         * An anchor of {@literal 1} points to the edge on the opposite side.
         * By default {@literal 0} is used as anchor.
         *
         * @param anchor
         * @return Self for chaining
         */
        public LayeredLayoutConstraint setPercentInsetAnchorVertical(float anchor) {
<span class="nc" id="L2206">            this.percAnchorV = anchor;</span>
<span class="nc" id="L2207">            return this;</span>
        }

        /**
         * Gets the constraint itself.
         *
         * @return
         */
        public LayeredLayoutConstraint constraint() {
<span class="nc" id="L2216">            return this;</span>
        }

        //private Rectangle preferredBounds;

        /**
         * Gets the dependencies (i.e. recursively gets  all reference components).
         *
         * @param deps A set to add the dependencies to. (An &quot;out&quot; parameter).
         * @return The set of dependencies.  Same as {@literal dep} parameter.
         */
        public Set&lt;Component&gt; getDependencies(Set&lt;Component&gt; deps) {
<span class="nc bnc" id="L2228" title="All 2 branches missed.">            for (Inset inset : insets) {</span>
<span class="nc" id="L2229">                inset.getDependencies(deps);</span>
            }
<span class="nc" id="L2231">            return deps;</span>
        }

        /**
         * Gets the dependencies (i.e. recursively gets  all reference components).
         *
         * @return The set of dependencies.
         */
        public Set&lt;Component&gt; getDependencies() {
<span class="nc" id="L2240">            return getDependencies(new HashSet&lt;Component&gt;());</span>
        }

        /**
         * Checks to see if this constraint has the given component in its set of dependencies.
         *
         * @param cmp The component to check.
         * @return True if {@literal cmp} is a reference component of some inset in this
         * constraint (recursively).
         */
        public boolean dependsOn(Component cmp) {
<span class="nc" id="L2251">            return getDependencies().contains(cmp);</span>
        }


        /**
         * Encapsulates an inset.
         */
        public class Inset {
            int delta;
            /**
             * One of
             * {@link Component#TOP}, {@link Component#Bottom}, {@link Component#LEFT}, {@link Component#RIGHT}
             */
            private final int side;
            /**
             * The component that is used a reference for this inset.
             * {@literal null} for the parent component.
             */
            private Component referenceComponent;
            /**
             * {@code 0.0 } = left/top of {@link #referenceComponent}.  {@code 1.0 } for bottom/right or {@link #referenceComponent}.
             */
            private float referencePosition;
            /**
             * The value of this inset. Interpreted in {@link #unit} units.
             */
            private float value;
            /**
             * The unit of this inset.
             */
<span class="fc" id="L2281">            private byte unit = UNIT_PIXELS;</span>
            /**
             * Caches the preferred value of this inset last time it was calculated.
             */
            private int preferredValue;
            /**
             * The calculated value of this inset in pixels.  This is calculated in the {@link #calculate(com.codename1.ui.Component, int, int, int, int) }
             * method which is only called during layout.  It will be the absolute size of the inset in pixels
             * including all reference components.
             */
            private int calculatedValue;
            /**
             * The calculated base value of this inset in pixels.  This is calculated during the layout step, so
             * this will always be the pixel &quot;base&quot; value the last time layout was performed.  The base value
             * is the absolute value of the reference box inset.  E.g. if this inset has no reference component,
             * then this will always be zero.  If there is a reference componnet, then this will be the value
             * of the &quot;zero&quot; point for measuing the inset.  {@link #calculatedValue} - {@link #calculatedBaseValue} should
             * be equal to {@link #value} (if value is in pixels).
             */
            private int calculatedBaseValue;
            /**
             * Tracks whether the size of the component was clipped during the last layout.  This will occur
             * when the preferred size of the component would have it overflowing the reference box.  In such cases
             * the component is &quot;clipped&quot; to not obtain its full preferred value.
             */
            private boolean autoIsClipped;

            /**
             * Creates a new inset for the given side.
             *
             * @param side One of {@link Component#TOP}, {@link Component#BOTTOM}, {@link Component#LEFT}, or {@link Component#RIGHT}.
             */
<span class="fc" id="L2313">            public Inset(int side) {</span>
<span class="fc" id="L2314">                this.side = side;</span>
<span class="fc" id="L2315">            }</span>

            /**
             * Prints this inset as a string.
             *
             * @return
             */
            public String toString() {
<span class="nc bnc" id="L2323" title="All 4 branches missed.">                switch (side) {</span>
                    case Component.TOP:
<span class="nc" id="L2325">                        return &quot;top=&quot; + getValueAsString();</span>
                    case Component.BOTTOM:
<span class="nc" id="L2327">                        return &quot;bottom=&quot; + getValueAsString();</span>
                    case Component.LEFT:
<span class="nc" id="L2329">                        return &quot;left=&quot; + getValueAsString();</span>
                    default:
<span class="nc" id="L2331">                        return &quot;right=&quot; + getValueAsString();</span>
                }
            }

            /**
             * Gets the value of this inset as a string. Values will be in the format {@literal &lt;value&gt;&lt;unit&gt;}, e.g.
             * {@literal 2mm}, {@literal 15%}, {@literal 5px}, {@literal auto} (meaning it is flexible.
             *
             * @return The value of this inset as a string.
             */
            public String getValueAsString() {
<span class="pc bpc" id="L2342" title="4 of 6 branches missed.">                switch (unit) {</span>
                    case UNIT_DIPS:
<span class="nc" id="L2344">                        return value + &quot;mm&quot;;</span>
                    case UNIT_PIXELS:
<span class="fc" id="L2346">                        return ((int) value) + &quot;px&quot;;</span>
                    case UNIT_PERCENT:
<span class="fc" id="L2348">                        return value + &quot;%&quot;;</span>
                    case UNIT_AUTO:
<span class="nc" id="L2350">                        return &quot;auto&quot;;</span>
                    case UNIT_BASELINE:
<span class="nc" id="L2352">                        return &quot;baseline&quot;;</span>
                }
<span class="nc" id="L2354">                return null;</span>
            }

            /**
             * Sets the value of this inset as a string.  E.g. &quot;2mm&quot;, or &quot;2px&quot;, or &quot;3%&quot;, &quot;auto&quot;, or &quot;baseline&quot;.
             *
             * @param value The value of this inset.
             * @return Self for chaining.
             */
            public Inset setValueAsString(String value) {
<span class="fc" id="L2364">                setValue(value);</span>
<span class="fc" id="L2365">                return this;</span>
            }

            /**
             * Gets the value of this inset as a string rounding to the specified number of decimal places.
             * Values will be in the format {@literal &lt;value&gt;&lt;unit&gt;}, e.g.
             * {@literal 2mm}, {@literal 15%}, {@literal 5px}, {@literal auto} (meaning it is flexible.
             *
             * @return The value of this inset as a string.
             * @see #getValueAsString()
             */
            public String getValueAsString(int decimalPlaces) {
<span class="nc" id="L2377">                L10NManager l10n = L10NManager.getInstance();</span>

<span class="nc bnc" id="L2379" title="All 6 branches missed.">                switch (unit) {</span>
                    case UNIT_DIPS:
<span class="nc" id="L2381">                        return l10n.format(value, decimalPlaces) + &quot;mm&quot;;</span>
                    case UNIT_PIXELS:
<span class="nc" id="L2383">                        return ((int) value) + &quot;px&quot;;</span>
                    case UNIT_PERCENT:
<span class="nc" id="L2385">                        return l10n.format(value, decimalPlaces) + &quot;%&quot;;</span>
                    case UNIT_AUTO:
<span class="nc" id="L2387">                        return &quot;auto&quot;;</span>
                    case UNIT_BASELINE:
<span class="nc" id="L2389">                        return &quot;baseline&quot;;</span>
                }
<span class="nc" id="L2391">                return null;</span>
            }

            /**
             * Fixes dependencies in this inset recursively so that all reference
             * components are children of the given parent container.  If a reference
             * component is not in the parent, then it will first check to find a
             * child of {@literal parent} with the same name as the reference component.
             * Failing that, it will try to find a child of {@literal parent} with the
             * same index.
             * &lt;p&gt;
             * If an appropriate match is found, it will replace the referenceComponent
             * with the match.
             *
             * @param parent The container in which all reference components should reside.
             * @return Self for chaining.
             */
            private Inset fixDependencies(Container parent) {
                Container refParent;
<span class="pc bpc" id="L2410" title="1 of 4 branches missed.">                if (referenceComponent != null &amp;&amp; (refParent = referenceComponent.getParent()) != parent) {</span>
                    // The reference component is not in this parent
<span class="nc" id="L2412">                    String name = referenceComponent.getName();</span>
<span class="nc" id="L2413">                    boolean found = false;</span>
<span class="nc bnc" id="L2414" title="All 4 branches missed.">                    if (name != null &amp;&amp; name.length() &gt; 0) {</span>
<span class="nc bnc" id="L2415" title="All 2 branches missed.">                        for (Component child : parent) {</span>
<span class="nc bnc" id="L2416" title="All 2 branches missed.">                            if (name.equals(child.getName())) {</span>
<span class="nc" id="L2417">                                referenceComponent = child;</span>
<span class="nc" id="L2418">                                found = true;</span>
<span class="nc" id="L2419">                                break;</span>
                            }
<span class="nc" id="L2421">                        }</span>
                    }
<span class="nc bnc" id="L2423" title="All 4 branches missed.">                    if (!found &amp;&amp; refParent != null) {</span>
<span class="nc" id="L2424">                        int index = refParent.getComponentIndex(referenceComponent);</span>
<span class="nc bnc" id="L2425" title="All 4 branches missed.">                        if (index != -1 &amp;&amp; parent.getComponentCount() &gt; index) {</span>
<span class="nc" id="L2426">                            referenceComponent = parent.getComponentAt(index);</span>
<span class="nc" id="L2427">                            found = true;</span>
                        }
                    }

<span class="nc bnc" id="L2431" title="All 2 branches missed.">                    if (found) {</span>
<span class="nc" id="L2432">                        LayeredLayoutConstraint refCnst = getOrCreateConstraint(referenceComponent);</span>
<span class="nc" id="L2433">                        refCnst.getInset(side).fixDependencies(parent);</span>
                    }

                }
<span class="fc" id="L2437">                return this;</span>
            }

            /**
             * Gets the left inset in this constraint.
             *
             * @return The left inset of the constraint.
             */
            public Inset left() {
<span class="nc" id="L2446">                return constraint().left();</span>
            }

            /**
             * Gets the right inset in the constraint.
             *
             * @return The right inset of the constraint.
             */
            public Inset right() {
<span class="nc" id="L2455">                return constraint().right();</span>
            }

            /**
             * Gets the top inset in this constraint.
             *
             * @return The top inset in this constraint.
             */
            public Inset top() {
<span class="nc" id="L2464">                return constraint().top();</span>
            }

            /**
             * Gets the bottom inset in this constraint.
             *
             * @return The bottom inset.
             */
            public Inset bottom() {
<span class="nc" id="L2473">                return constraint().bottom();</span>
            }

            /**
             * Gets the constraint that contains this inset.
             *
             * @return The parent constraint of this inset.
             */
            public LayeredLayoutConstraint constraint() {
<span class="nc" id="L2482">                return LayeredLayoutConstraint.this;</span>
            }

            /**
             * Sets the unit for this constraint.  This doesn't perform any recalculation
             * on the value.  Just sets the unit.
             *
             * @param unit The unit.  One of {@link #UNIT_AUTO}, {@link #UNIT_DIPS}, {@link #UNIT_PIXELS}, or {@link #UNIT_PERCENT}.
             * @return Self for chaining.
             * @see #setAuto()
             * @see #setDips()
             * @see #setPixels()
             * @see #setPercent()
             * @see #changeUnits(byte) To change units while recalculating the value to be effectively equivalent.
             */
            public Inset unit(byte unit) {
<span class="pc bpc" id="L2498" title="3 of 4 branches missed.">                if (unit == UNIT_BASELINE &amp;&amp; side != Component.TOP) {</span>
<span class="nc" id="L2499">                    throw new IllegalArgumentException(&quot;baseline unit can only be used on the top inset.&quot;);</span>
                }
<span class="fc" id="L2501">                this.unit = unit;</span>
<span class="pc bpc" id="L2502" title="1 of 2 branches missed.">                if (unit == UNIT_BASELINE) {</span>
<span class="nc" id="L2503">                    referencePosition = 0f;</span>
<span class="nc" id="L2504">                    getOppositeInset().setAuto().referenceComponent(null).referencePosition(0f);</span>
                }
<span class="fc" id="L2506">                return this;</span>
            }

            /**
             * Sets the units to &quot;auto&quot; (i.e. makes the inset flexible).  Doesn't perform any calculations
             * on the value.
             *
             * @return Self for chaining.
             * @see #unit(byte)
             */
            public Inset setAuto() {
<span class="fc" id="L2517">                return unit(UNIT_AUTO);</span>
            }

            /**
             * Sets the units to &quot;dips&quot; (millimetres).  Doesn't perform any calculations on the value.
             *
             * @return Self for chaining.
             * @see #unit(byte)
             */
            public Inset setDips() {
<span class="nc" id="L2527">                return unit(UNIT_DIPS);</span>
            }

            /**
             * Sets the units to percent.  Doesn't perform any calculations on the value.
             *
             * @return Self for chaining.
             * @see #unit(byte)
             */
            public Inset setPercent() {
<span class="nc" id="L2537">                return unit(UNIT_PERCENT);</span>
            }

            /**
             * Sets the units to pixels.  Doesn't perform any calculations on the value.
             *
             * @return Self for chaining.
             */
            public Inset setPixels() {
<span class="nc" id="L2546">                return unit(UNIT_PIXELS);</span>
            }

            /**
             * Sets the inset value to the provided number of pixels.  This will chnage the unit
             * to pixels.
             *
             * @param px The pixel value of the inset.
             * @return Self for chaining.
             */
            public Inset setPixels(int px) {
<span class="fc" id="L2557">                this.value = px;</span>
<span class="fc" id="L2558">                return unit(UNIT_PIXELS);</span>
            }

            /**
             * Sets the inset value to the provided dips/millimetre value. This will change
             * the unit to millimetres.
             *
             * @param dips The inset value in millimetres.
             * @return Self for chaining.
             */
            public Inset setDips(float dips) {
<span class="nc" id="L2569">                this.value = dips;</span>
<span class="nc" id="L2570">                return unit(UNIT_DIPS);</span>
            }

            /**
             * Sets the inset value in percentage.  This will change the unit to percentage.
             *
             * @param percent The inset value as a percentage.
             * @return Self for chaining.
             */
            public Inset setPercent(float percent) {
<span class="pc bpc" id="L2580" title="2 of 4 branches missed.">                if (percent == Float.POSITIVE_INFINITY || percent == Float.NEGATIVE_INFINITY) {</span>
<span class="nc" id="L2581">                    throw new IllegalArgumentException(&quot;Attempt to set illegal percent value&quot;);</span>
                }
<span class="fc" id="L2583">                this.value = percent;</span>
<span class="fc" id="L2584">                return unit(UNIT_PERCENT);</span>
            }

            /**
             * Sets the reference component for this inset.
             *
             * @param cmp The reference component. (I.e. the component that the inset is &quot;anchored&quot; to).
             * @return Self for chaining.
             * @see #referencePosition(float)
             * @see LayeredLayoutConstraint#setReferenceComponents(com.codename1.ui.Component...)
             */
            public Inset referenceComponent(Component cmp) {
<span class="fc" id="L2596">                referenceComponent = cmp;</span>
<span class="fc" id="L2597">                return this;</span>
            }

            /**
             * Sets the reference position for this inset.  A value of {@literal 0} indicates that the inset
             * is anchored to the same side of the reference component (e.g. right inset anchored to right edge of reference component,
             * left inset anchored to left edge of reference component).  A value of {@literal 1} indicates that the
             * inset is anchored to the opposite side of the reference component. E.g. right inset to left edge.
             *
             * @param position The reference position.
             * @return Self for chaining.
             * @see #setReferencePositions(java.lang.String)
             * @see #setReferencePositions(com.codename1.ui.Component, java.lang.String)
             * @see #setReferencePositions(com.codename1.ui.Component, float...)
             */
            public Inset referencePosition(float position) {
<span class="fc" id="L2613">                this.referencePosition = position;</span>
<span class="fc" id="L2614">                return this;</span>
            }

            /**
             * Sets the value of this inset.  The interpretation of the value will depend on the {@link #unit}.
             * If the unit is {@link #UNIT_DIPS}, then this value is interpreted in millimetres, etc..
             *
             * @param value The value to set this inset to.
             * @return Self for chaining.
             */
            public Inset value(float value) {
<span class="nc" id="L2625">                this.value = value;</span>
<span class="nc" id="L2626">                return this;</span>
            }

            /**
             * Gets the side of this inset. One of {@link Component#TOP}, {@link Component#Bottom}, {@link Component#LEFT}, {@link Component#RIGHT}
             *
             * @return The side of this inset.  One of {@link Component#TOP}, {@link Component#Bottom}, {@link Component#LEFT}, {@link Component#RIGHT}
             */
            public int getSide() {
<span class="nc" id="L2635">                return side;</span>
            }

            /**
             * Gets the reference component for this inset.
             *
             * @return The reference component for this inset.
             * @see #referenceComponent(com.codename1.ui.Component)
             */
            public Component getReferenceComponent() {
<span class="fc" id="L2645">                return referenceComponent;</span>
            }

            /**
             * Gets the reference position for this inset.
             *
             * @return The reference position for this inset.
             */
            public float getReferencePosition() {
<span class="fc" id="L2654">                return referencePosition;</span>
            }

            /**
             * Calculate the preferred value of this inset.
             *
             * @param parent The parent container.
             * @param cmp    The component
             * @return The preferred value of this inset in pixels.
             */
            public int calcPreferredValue(Container parent, Component cmp) {

<span class="pc bpc" id="L2666" title="1 of 2 branches missed.">                if (referenceComponent == null) {</span>
                    // There is no reference component for this inset so we measure
                    // against the parent component directly.
<span class="pc bpc" id="L2669" title="2 of 4 branches missed.">                    switch (unit) {</span>
                        case UNIT_PIXELS:
<span class="fc" id="L2671">                            preferredValue = (int) value;</span>
<span class="fc" id="L2672">                            break;</span>
                        case UNIT_DIPS:
<span class="nc" id="L2674">                            preferredValue = Display.getInstance().convertToPixels(value);</span>
<span class="nc" id="L2675">                            break;</span>
                        case UNIT_PERCENT:
                        case UNIT_AUTO:
                        case UNIT_BASELINE:
<span class="fc" id="L2679">                            preferredValue = 0;</span>
<span class="fc" id="L2680">                            break;</span>
                        default:
<span class="nc" id="L2682">                            throw new RuntimeException(&quot;Invalid unit &quot; + unit);</span>
                    }
<span class="fc" id="L2684">                    return preferredValue;</span>
                } else {
                    // There is a reference component so we need to add our own value
                    // to the base inset of the reference component.
<span class="nc" id="L2688">                    LayeredLayoutConstraint refCnst = (LayeredLayoutConstraint) getComponentConstraint(referenceComponent);</span>
<span class="nc" id="L2689">                    int baseValue = 0;</span>
<span class="nc bnc" id="L2690" title="All 2 branches missed.">                    if (refCnst != null) {</span>
<span class="nc" id="L2691">                        baseValue = refCnst.insets[side].preferredValue;</span>
                    }

                    // We should have already calculated the preferred size of the
                    // reference component.
                    //Dimension refPreferredSize = referenceComponent.getPreferredSize();
<span class="nc" id="L2697">                    int refPreferredH = getOuterPreferredH(referenceComponent);</span>
<span class="nc" id="L2698">                    int refPreferredW = getOuterPreferredW(referenceComponent);</span>

<span class="nc bnc" id="L2700" title="All 2 branches missed.">                    if (referencePosition != 0) {</span>
                        // If the inset is not in reference to the edge of the component
                        // then we need to adjust the base value accordingly.
<span class="nc bnc" id="L2703" title="All 2 branches missed.">                        switch (side) {</span>
                            case Component.TOP:
                            case Component.BOTTOM:
<span class="nc" id="L2706">                                baseValue += ((float) refPreferredH) * referencePosition;</span>
<span class="nc" id="L2707">                                break;</span>
                            default:
<span class="nc" id="L2709">                                baseValue += ((float) refPreferredW) * referencePosition;</span>
                        }
                    }

                    // Now we add our own value to the base value.
<span class="nc bnc" id="L2714" title="All 5 branches missed.">                    switch (unit) {</span>
                        case UNIT_PIXELS:
<span class="nc" id="L2716">                            preferredValue = baseValue + (int) value;</span>
<span class="nc" id="L2717">                            break;</span>
                        case UNIT_DIPS:
<span class="nc" id="L2719">                            preferredValue = baseValue + Display.getInstance().convertToPixels(value);</span>
<span class="nc" id="L2720">                            break;</span>
                        case UNIT_PERCENT:
                        case UNIT_AUTO:
<span class="nc" id="L2723">                            preferredValue = baseValue;</span>
<span class="nc" id="L2724">                            break;</span>
                        case UNIT_BASELINE: {
<span class="nc" id="L2726">                            Style rs = referenceComponent.getStyle();</span>
<span class="nc" id="L2727">                            Style s = cmp.getStyle();</span>
<span class="nc" id="L2728">                            preferredValue = baseValue + (referenceComponent.getPreferredH() - cmp.getPreferredH()) / 2</span>
<span class="nc" id="L2729">                                    + (rs.getFont().getAscent() - s.getFont().getAscent())</span>
<span class="nc" id="L2730">                                    + (rs.getPaddingTop() - s.getPaddingTop());</span>
<span class="nc" id="L2731">                            break;</span>
                        }
                        default:
<span class="nc" id="L2734">                            throw new RuntimeException(&quot;Invalid unit &quot; + unit);</span>
                    }
<span class="nc" id="L2736">                    return preferredValue;</span>
                }
            }

            /**
             * Calculates the &quot;base&quot; value off of which the inset's value should be calculated.
             *
             * @param top    The top &quot;y&quot; coordinate within the parent container from which insets are measured.
             * @param left   The left &quot;x&quot; coordinate within the parent container from which insets are measured.
             * @param bottom The bottom &quot;y&quot; coordinate within the parent container from which insets are measured.
             * @param right  The right &quot;x&quot; coordinate within the parent container from which insets are measured.
             * @return
             */
            private int calcBaseValue(int top, int left, int bottom, int right) {//, int paddingTop, int paddingLeft, int paddingBottom, int paddingRight) {
<span class="fc" id="L2750">                int h = bottom - top;</span>
<span class="fc" id="L2751">                int w = right - left;</span>
<span class="fc" id="L2752">                int baseValue = 0;</span>
<span class="fc bfc" id="L2753" title="All 2 branches covered.">                if (referenceComponent != null) {</span>
<span class="pc bpc" id="L2754" title="1 of 4 branches missed.">                    switch (side) {</span>
                        case Component.TOP:
<span class="fc" id="L2756">                            baseValue = getOuterY(referenceComponent) + (int) (getOuterHeight(referenceComponent) * referencePosition) - top;</span>
<span class="fc" id="L2757">                            break;</span>
                        case Component.BOTTOM:
<span class="nc" id="L2759">                            baseValue = (bottom - getOuterHeight(referenceComponent) - getOuterY(referenceComponent)) + (int) (getOuterHeight(referenceComponent) * referencePosition);</span>
<span class="nc" id="L2760">                            break;</span>
                        case Component.LEFT:
<span class="fc" id="L2762">                            baseValue = getOuterX(referenceComponent) + (int) (getOuterWidth(referenceComponent) * referencePosition) - left;</span>
<span class="fc" id="L2763">                            break;</span>
                        default:
<span class="fc" id="L2765">                            baseValue = (right - getOuterWidth(referenceComponent) - getOuterX(referenceComponent)) + (int) (getOuterWidth(referenceComponent) * referencePosition);</span>
                            break;
                    }
<span class="fc" id="L2768">                    calculatedBaseValue = baseValue;</span>
<span class="fc" id="L2769">                    return baseValue;</span>
                }

<span class="fc bfc" id="L2772" title="All 2 branches covered.">                    if (referencePosition != 0) {</span>
<span class="pc bpc" id="L2773" title="2 of 3 branches missed.">                        switch (side) {</span>
                            case Component.TOP:
                            case Component.BOTTOM:
<span class="fc" id="L2776">                                baseValue = (int) (h * referencePosition);</span>
<span class="fc" id="L2777">                                break;</span>
                            case Component.LEFT:
                            case Component.RIGHT:
<span class="nc" id="L2780">                                baseValue = (int) (w * referencePosition);</span>
<span class="nc" id="L2781">                                break;</span>
                            default:
<span class="nc" id="L2783">                                throw new RuntimeException(&quot;Illegal side for inset: &quot; + side);</span>
                        }
                    }
<span class="fc" id="L2786">                calculatedBaseValue = baseValue;</span>
<span class="fc" id="L2787">                return baseValue;</span>
            }

            /**
             * True if this is top or bottom.
             *
             * @return
             */
            private boolean isVerticalInset() {
<span class="fc bfc" id="L2796" title="All 4 branches covered.">                return side == Component.TOP || side == Component.BOTTOM;</span>
            }

            /**
             * True if this is left or right.
             *
             * @return
             */
            private boolean isHorizontalInset() {
<span class="nc bnc" id="L2805" title="All 4 branches missed.">                return side == Component.LEFT || side == Component.RIGHT;</span>
            }


            /**
             * Calculates the actual value of this inset.  This is used inside {@link #layoutComponent(com.codename1.ui.Container, com.codename1.ui.Component, int, int, int, int) }.
             *
             * @param cmp    The component.
             * @param top
             * @param left
             * @param bottom
             * @param right
             * @return The actual value of this inset.
             */
            private int calculate(Component cmp, int top, int left, int bottom, int right) {
<span class="pc bpc" id="L2820" title="1 of 4 branches missed.">                if (side == Component.BOTTOM &amp;&amp; getOppositeInset().unit == UNIT_BASELINE) {</span>
<span class="nc" id="L2821">                    unit = UNIT_AUTO;</span>
                }
<span class="fc" id="L2823">                int w = right - left;</span>
<span class="fc" id="L2824">                int h = bottom - top;</span>
<span class="fc" id="L2825">                int baseValue = calcBaseValue(top, left, bottom, right);</span>
<span class="fc" id="L2826">                autoIsClipped = false;</span>
<span class="pc bpc" id="L2827" title="3 of 6 branches missed.">                switch (unit) {</span>
                    case UNIT_PIXELS:
<span class="fc" id="L2829">                        calculatedValue = baseValue + (int) value;</span>
<span class="fc" id="L2830">                        break;</span>
                    case UNIT_DIPS:
<span class="nc" id="L2832">                        calculatedValue = baseValue + Display.getInstance().convertToPixels(value);</span>
<span class="nc" id="L2833">                        break;</span>
                    case UNIT_PERCENT: {
<span class="fc" id="L2835">                        Inset oppositeInset = getOppositeInset();</span>

<span class="fc" id="L2837">                        int oppositeBaseValue = oppositeInset.calcBaseValue(top, left, bottom, right);</span>
<span class="pc bpc" id="L2838" title="1 of 2 branches missed.">                        if (isVerticalInset()) {</span>
<span class="nc" id="L2839">                            float anchorV = LayeredLayoutConstraint.this.getPercentInsetAnchorVertical();</span>
<span class="nc bnc" id="L2840" title="All 2 branches missed.">                            calculatedValue = (int) (baseValue + (h - oppositeBaseValue - baseValue) * value / 100f</span>
<span class="nc" id="L2841">                                    - (anchorV != 0 ? (getOuterPreferredH(cmp) * anchorV) : 0));</span>
<span class="nc" id="L2842">                        } else {</span>
<span class="fc" id="L2843">                            float anchorH = LayeredLayoutConstraint.this.getPercentInsetAnchorHorizontal();</span>
<span class="pc bpc" id="L2844" title="1 of 2 branches missed.">                            calculatedValue = (int) (baseValue + (w - oppositeBaseValue - baseValue) * value / 100f</span>
<span class="pc" id="L2845">                                    - (anchorH != 0 ? (getOuterPreferredW(cmp) * anchorH) : 0));</span>
                        }
<span class="fc" id="L2847">                        break;</span>
                    }
                    case UNIT_BASELINE: {
<span class="nc bnc" id="L2850" title="All 2 branches missed.">                        if (getReferenceComponent() == null) {</span>
<span class="nc" id="L2851">                            calculatedValue = baseValue;</span>
                        } else {
<span class="nc" id="L2853">                            Component ref = getReferenceComponent();</span>
<span class="nc" id="L2854">                            Style rs = ref.getStyle();</span>
<span class="nc" id="L2855">                            Style s = cmp.getStyle();</span>
<span class="nc" id="L2856">                            Font rf = rs.getFont();</span>
<span class="nc" id="L2857">                            Font sf = s.getFont();</span>
<span class="nc bnc" id="L2858" title="All 4 branches missed.">                            int ra = rf == null || sf == null ? 0 : rf.getAscent();</span>
<span class="nc bnc" id="L2859" title="All 4 branches missed.">                            int sa = rf == null || sf == null ? 0 : sf.getAscent();</span>
<span class="nc" id="L2860">                            calculatedValue = baseValue + (ref.getHeight() - cmp.getPreferredH()) / 2</span>
<span class="nc" id="L2861">                                    + (rs.getPaddingTop() - s.getPaddingTop())</span>
<span class="nc" id="L2862">                                    + (rs.getMarginTop() - s.getMarginTop())</span>
                                    + (ra - sa);
                        }

<span class="nc" id="L2866">                        break;</span>
                    }
                    case UNIT_AUTO: {
<span class="fc" id="L2869">                        Inset oppositeInset = getOppositeInset();</span>
<span class="fc" id="L2870">                        int oppositeBaseValue = oppositeInset.calcBaseValue(top, left, bottom, right);</span>

<span class="fc bfc" id="L2872" title="All 2 branches covered.">                        if (oppositeInset.unit == UNIT_AUTO) {</span>

<span class="fc bfc" id="L2874" title="All 2 branches covered.">                            if (isVerticalInset()) {</span>
<span class="pc bpc" id="L2875" title="1 of 2 branches missed.">                                if (cmp.getPreferredH() &lt;= 0) {</span>
<span class="nc" id="L2876">                                    calculatedValue = baseValue;</span>
<span class="nc" id="L2877">                                    autoIsClipped = true;</span>
                                } else {
<span class="fc" id="L2879">                                    calculatedValue = baseValue + (h - oppositeBaseValue - baseValue - getOuterPreferredH(cmp)) / 2;</span>
                                }
                            } else {
<span class="fc bfc" id="L2882" title="All 2 branches covered.">                                if (cmp.getPreferredW() &lt;= 0) {</span>
<span class="fc" id="L2883">                                    calculatedValue = baseValue;</span>
<span class="fc" id="L2884">                                    autoIsClipped = true;</span>
                                } else {
<span class="fc" id="L2886">                                    calculatedValue = baseValue + (w - oppositeBaseValue - baseValue - getOuterPreferredW(cmp)) / 2;</span>
                                }
                            }
<span class="fc bfc" id="L2889" title="All 2 branches covered.">                            if (calculatedValue &lt; 0) {</span>
<span class="fc" id="L2890">                                autoIsClipped = true;</span>
                            }
<span class="fc" id="L2892">                            calculatedValue = Math.max(0, calculatedValue);</span>
                        } else {
<span class="fc bfc" id="L2894" title="All 2 branches covered.">                            if (isVerticalInset()) {</span>
<span class="fc bfc" id="L2895" title="All 2 branches covered.">                                if (cmp.getPreferredH() &lt;= 0) {</span>
<span class="fc" id="L2896">                                    calculatedValue = baseValue;</span>
<span class="fc" id="L2897">                                    autoIsClipped = true;</span>
                                } else {
<span class="fc" id="L2899">                                    calculatedValue = h - oppositeInset.calculate(cmp, top, left, bottom, right) - getOuterPreferredH(cmp);</span>
                                }

                            } else {
<span class="pc bpc" id="L2903" title="1 of 2 branches missed.">                                if (cmp.getPreferredW() &lt;= 0) {</span>
<span class="nc" id="L2904">                                    calculatedValue = baseValue;</span>
<span class="nc" id="L2905">                                    autoIsClipped = true;</span>
                                } else {
<span class="fc" id="L2907">                                    calculatedValue = w - oppositeInset.calculate(cmp, top, left, bottom, right) - getOuterPreferredW(cmp);</span>
                                }
                            }
<span class="pc bpc" id="L2910" title="1 of 2 branches missed.">                            if (calculatedValue &lt; 0) {</span>
<span class="nc" id="L2911">                                autoIsClipped = true;</span>
                            }
<span class="fc" id="L2913">                            calculatedValue = Math.max(0, calculatedValue);</span>
                        }
<span class="fc" id="L2915">                        break;</span>
                    }
                    default:
<span class="nc" id="L2918">                        throw new RuntimeException(&quot;Invalid unit &quot; + unit);</span>
                }
<span class="fc" id="L2920">                delta = 0;</span>
<span class="fc" id="L2921">                return calculatedValue;</span>
            }

            /**
             * Recursively gets all of the reference components of this inset.
             *
             * @param deps An &quot;out&quot; parameter.  The set that will hold the dependencies.
             * @return The set of all reference components (crawled recursively of this inset.
             */
            public Set&lt;Component&gt; getDependencies(Set&lt;Component&gt; deps) {
<span class="nc bnc" id="L2931" title="All 2 branches missed.">                if (referenceComponent != null) {</span>
<span class="nc bnc" id="L2932" title="All 2 branches missed.">                    if (deps.contains(referenceComponent)) {</span>
<span class="nc" id="L2933">                        return deps;</span>
                    }
<span class="nc" id="L2935">                    deps.add(referenceComponent);</span>
<span class="nc" id="L2936">                    getOrCreateConstraint(referenceComponent).getDependencies(deps);</span>
                }
<span class="nc" id="L2938">                return deps;</span>
            }

            /**
             * Recursively gets all of the reference components of this inset.
             *
             * @return The set of all reference components (crawled recursively of this inset.
             */
            public Set&lt;Component&gt; getDependencies() {
<span class="nc" id="L2947">                return getDependencies(new HashSet&lt;Component&gt;());</span>
            }

            /**
             * Gets the opposite inset of this inset within its parent constraint.  E.g. if this is the
             * left inset, it will get the associated right inset.
             *
             * @return The opposite inset.
             */
            public Inset getOppositeInset() {
<span class="fc" id="L2957">                LayeredLayoutConstraint cnst = LayeredLayoutConstraint.this;</span>
<span class="pc bpc" id="L2958" title="1 of 2 branches missed.">                if (cnst != null) {</span>
<span class="fc" id="L2959">                    int oppSide = 0;</span>
<span class="fc bfc" id="L2960" title="All 4 branches covered.">                    switch (side) {</span>
                        case Component.TOP:
<span class="fc" id="L2962">                            oppSide = Component.BOTTOM;</span>
<span class="fc" id="L2963">                            break;</span>
                        case Component.BOTTOM:
<span class="fc" id="L2965">                            oppSide = Component.TOP;</span>
<span class="fc" id="L2966">                            break;</span>
                        case Component.LEFT:
<span class="fc" id="L2968">                            oppSide = Component.RIGHT;</span>
<span class="fc" id="L2969">                            break;</span>
                        default:
<span class="fc" id="L2971">                            oppSide = Component.LEFT;</span>

                    }
<span class="fc" id="L2974">                    return cnst.insets[oppSide];</span>
                }
<span class="nc" id="L2976">                return null;</span>
            }

            /**
             * Sets the value of this inset.  E.g. &quot;2mm&quot;, &quot;1px&quot;, &quot;25%&quot;, or &quot;auto&quot;.
             *
             * @param val
             */
            private void setValue(String val) {
                int pos;
<span class="pc bpc" id="L2986" title="1 of 2 branches missed.">                if ((pos = val.indexOf(&quot;mm&quot;)) != -1) {</span>
<span class="nc" id="L2987">                    this.setDips(Float.parseFloat(val.substring(0, pos)));</span>
<span class="fc bfc" id="L2988" title="All 2 branches covered.">                } else if ((pos = val.indexOf(&quot;px&quot;)) != -1) {</span>
<span class="fc" id="L2989">                    this.setPixels(Integer.parseInt(val.substring(0, pos)));</span>
<span class="fc bfc" id="L2990" title="All 2 branches covered.">                } else if ((pos = val.indexOf(&quot;%&quot;)) != -1) {</span>
<span class="fc" id="L2991">                    this.setPercent(Float.parseFloat(val.substring(0, pos)));</span>
<span class="fc bfc" id="L2992" title="All 2 branches covered.">                } else if (&quot;auto&quot;.equals(val)) {</span>
<span class="fc" id="L2993">                    this.setAuto();</span>
<span class="pc bpc" id="L2994" title="1 of 2 branches missed.">                } else if (&quot;baseline&quot;.equals(val)) {</span>
<span class="nc" id="L2995">                    this.unit(UNIT_BASELINE);</span>
                } else {
<span class="fc" id="L2997">                    this.setPixels(Integer.parseInt(val));</span>

                }
<span class="fc" id="L3000">            }</span>

            /**
             * Copies this inset into another inset.
             *
             * @param dest The inset to copy to.
             * @return The copied inset.
             */
            public Inset copyTo(Inset dest) {
<span class="fc" id="L3009">                dest.autoIsClipped = autoIsClipped;</span>
<span class="fc" id="L3010">                dest.calculatedValue = calculatedValue;</span>
<span class="fc" id="L3011">                dest.delta = delta;</span>
<span class="fc" id="L3012">                dest.calculatedBaseValue = calculatedBaseValue;</span>
<span class="fc" id="L3013">                dest.preferredValue = preferredValue;</span>

<span class="fc" id="L3015">                dest.value = value;</span>
<span class="fc" id="L3016">                dest.unit = unit;</span>
                // We won't copy the side since that allows us to f things up
                //dest.side = side;
<span class="fc" id="L3019">                dest.referenceComponent = referenceComponent;</span>
<span class="fc" id="L3020">                dest.referencePosition = referencePosition;</span>
<span class="fc" id="L3021">                return dest;</span>
            }

            /**
             * Copies this inset to the corresponding inset of the provided constraint.
             *
             * @param dest The constraint to copy the inset into.
             * @return The corresponding inset in {@literal dest} that we copied the inset into.
             */
            public Inset copyTo(LayeredLayoutConstraint dest) {
<span class="nc" id="L3031">                copyTo(dest.insets[side]);</span>
<span class="nc" id="L3032">                return dest.insets[side];</span>
            }

            /**
             * Copies this inset into the corresponding inset of the provided component.
             *
             * @param cmp The component that we are copying the inset into.
             * @return The copied inset.
             */
            public Inset copyTo(Component cmp) {
<span class="nc" id="L3042">                copyTo(getOrCreateConstraint(cmp));</span>
<span class="nc" id="L3043">                return this;</span>
            }

            /**
             * Creates a copy of this inset.
             *
             * @return
             */
            public Inset copy() {
<span class="nc" id="L3052">                return copyTo(new Inset(side));</span>
            }

            /**
             * Gets the unit of this inset.
             *
             * @return One of {@link #UNIT_AUTO}, {@link #UNIT_DIPS}, {@link #UNIT_PIXELS}, or {@link #UNIT_PERCENT}.
             */
            public byte getUnit() {
<span class="fc" id="L3061">                return unit;</span>
            }

            /**
             * Checks if this is a fixed inset. An inset is considered &quot;fixed&quot; if its unit is not {@link #UNIT_AUTO}
             *
             * @return True if the inset is fixed.
             */
            public boolean isFixed() {
<span class="nc bnc" id="L3070" title="All 2 branches missed.">                return unit != UNIT_AUTO;</span>
            }

            /**
             * Gets the current value of this inset in millimetres.  If the inset uses a different unit, then
             * this will calculate the corresponding value.
             *
             * @return
             */
            public float getCurrentValueMM() {
<span class="nc bnc" id="L3080" title="All 2 branches missed.">                if (unit == UNIT_DIPS) {</span>
<span class="nc" id="L3081">                    return value;</span>
<span class="nc bnc" id="L3082" title="All 2 branches missed.">                } else if (unit == UNIT_PIXELS) {</span>
<span class="nc" id="L3083">                    float pixelsPerDip = Display.getInstance().convertToPixels(1000) / 1000f;</span>
<span class="nc" id="L3084">                    return value / pixelsPerDip;</span>
                } else {
                    // In both auto and percent cases, we'll use the existing calculated value as our base
<span class="nc" id="L3087">                    float pixelsPerDip = Display.getInstance().convertToPixels(1000) / 1000f;</span>
<span class="nc" id="L3088">                    int calc = calculatedValue;</span>
                    //System.out.println(&quot;Calculated value of side &quot;+side+&quot; = &quot;+calc);
                    //new RuntimeException(&quot;Foobar&quot;).printStackTrace();
<span class="nc bnc" id="L3091" title="All 2 branches missed.">                    if (referenceComponent != null) {</span>
<span class="nc" id="L3092">                        calc -= calculatedBaseValue;</span>
                    }
<span class="nc" id="L3094">                    float out = calc / pixelsPerDip;</span>
                    //System.out.println(&quot;calc=&quot;+out+&quot;mm&quot;);
<span class="nc" id="L3096">                    return out + (delta / pixelsPerDip);</span>

                }
            }

            /**
             * Gets the current value of this inset in pixels.  If the inset uses a different unit
             * then this will calculate the corresponding value.
             *
             * @return The value of this inset in pixels.
             */
            public int getCurrentValuePx() {
<span class="nc bnc" id="L3108" title="All 2 branches missed.">                if (unit == UNIT_DIPS) {</span>
<span class="nc" id="L3109">                    return Display.getInstance().convertToPixels(value);</span>
<span class="nc bnc" id="L3110" title="All 2 branches missed.">                } else if (unit == UNIT_PIXELS) {</span>
<span class="nc" id="L3111">                    return (int) value;</span>
                } else {
                    // In both auto and percent cases, we'll use the existing calculated value as our source.
<span class="nc" id="L3114">                    int calc = calculatedValue;</span>
<span class="nc bnc" id="L3115" title="All 2 branches missed.">                    if (referenceComponent != null) {</span>

<span class="nc" id="L3117">                        calc -= calculatedBaseValue;</span>
                    }
<span class="nc" id="L3119">                    return calc + delta;</span>
                }
            }

            /**
             * True if this is a vertical inset (top or bottom).
             *
             * @return
             */
            public boolean isVertical() {
<span class="nc bnc" id="L3129" title="All 4 branches missed.">                return side == Component.TOP || side == Component.BOTTOM;</span>
            }

            /**
             * True if this is a horizontal inset (left or right).
             *
             * @return
             */
            public boolean isHorizontal() {
<span class="nc bnc" id="L3138" title="All 4 branches missed.">                return side == Component.LEFT || side == Component.RIGHT;</span>
            }

            /**
             * Changes the units of this inset, and updates the value to remain
             * the same as the current value.
             *
             * @param unit The unit.  One of {@link #UNIT_AUTO}, {@link #UNIT_DIPS}, {@link #UNIT_PIXELS}, or {@link #UNIT_PERCENT}.
             * @return Self for chaining.
             * @deprecated Use {@link #changeUnitsTo(byte, com.codename1.ui.Container) }
             */
            public Inset changeUnits(byte unit) {
<span class="nc" id="L3150">                return changeUnits(unit, cmp);</span>

            }

            /**
             * Changes the units of this inset, and updates the value to remain
             * the same as the current value.
             *
             * @param unit The unit.  One of {@link #UNIT_AUTO}, {@link #UNIT_DIPS}, {@link #UNIT_PIXELS}, or {@link #UNIT_PERCENT}.
             * @param cmp  The component for which the inset is applying.
             * @return Self for chaining.
             * @deprecated Use {@link #changeUnitsTo(byte, com.codename1.ui.Container) }
             */
            public Inset changeUnits(byte unit, Component cmp) {
<span class="nc bnc" id="L3164" title="All 2 branches missed.">                return changeUnitsTo(unit, cmp == null ? null : cmp.getParent());</span>
            }

            /**
             * Changes the units of this inset, and updates the value to remain
             * the same as the current value.
             *
             * @param unit   The unit.  One of {@link #UNIT_AUTO}, {@link #UNIT_DIPS}, {@link #UNIT_PIXELS}, or {@link #UNIT_PERCENT}.
             * @param parent The container in which the layout applies.
             * @return Self for chaining.
             */
            public Inset changeUnitsTo(byte unit, Container parent) {
<span class="nc bnc" id="L3176" title="All 2 branches missed.">                if (unit != this.unit) {</span>
<span class="nc bnc" id="L3177" title="All 2 branches missed.">                    if (unit == UNIT_PIXELS) {</span>
<span class="nc" id="L3178">                        setPixels(getCurrentValuePx());</span>
<span class="nc bnc" id="L3179" title="All 2 branches missed.">                    } else if (unit == UNIT_DIPS) {</span>
<span class="nc" id="L3180">                        setDips(getCurrentValueMM());</span>
<span class="nc bnc" id="L3181" title="All 2 branches missed.">                    } else if (unit == UNIT_PERCENT) {</span>
                        try {
<span class="nc bnc" id="L3183" title="All 2 branches missed.">                            if (parent != null) {</span>
<span class="nc" id="L3184">                                Rectangle refBox = constraint().getReferenceBox(parent);</span>

<span class="nc bnc" id="L3186" title="All 2 branches missed.">                                setPercent(getCurrentValuePx() * 100f / (isVertical() ? refBox.getHeight() : refBox.getWidth()));</span>
<span class="nc" id="L3187">                            } else {</span>
<span class="nc" id="L3188">                                throw new IllegalArgumentException(&quot;Cannot change unit to percent without specifying the target component.&quot;);</span>
                            }
<span class="nc" id="L3190">                        } catch (IllegalArgumentException ex) {</span>
<span class="nc" id="L3191">                            Log.p(&quot;Unable to calculate percentage because height or width is zero.  Setting to 100%&quot;);</span>
<span class="nc" id="L3192">                            setPercent(100f);</span>
<span class="nc" id="L3193">                        }</span>
<span class="nc bnc" id="L3194" title="All 2 branches missed.">                    } else if (unit == UNIT_BASELINE) {</span>
<span class="nc bnc" id="L3195" title="All 2 branches missed.">                        if (side != Component.TOP) {</span>
<span class="nc" id="L3196">                            throw new IllegalArgumentException(&quot;Baseline unit only allowed on top inset&quot;);</span>
                        }
<span class="nc" id="L3198">                        getOppositeInset().changeUnitsTo(UNIT_AUTO, parent);</span>
<span class="nc" id="L3199">                        unit(unit);</span>
                    } else {
<span class="nc" id="L3201">                        unit(unit);</span>
                    }
                }
<span class="nc" id="L3204">                return this;</span>
            }


            public Inset changeUnitsTo(byte unit, Rectangle refBox) {
<span class="nc bnc" id="L3209" title="All 2 branches missed.">                if (unit != this.unit) {</span>
<span class="nc bnc" id="L3210" title="All 2 branches missed.">                    if (unit == UNIT_PIXELS) {</span>
<span class="nc" id="L3211">                        setPixels(getCurrentValuePx());</span>
<span class="nc bnc" id="L3212" title="All 2 branches missed.">                    } else if (unit == UNIT_DIPS) {</span>
<span class="nc" id="L3213">                        setDips(getCurrentValueMM());</span>
<span class="nc bnc" id="L3214" title="All 2 branches missed.">                    } else if (unit == UNIT_PERCENT) {</span>
                        try {
<span class="nc bnc" id="L3216" title="All 2 branches missed.">                            setPercent(getCurrentValuePx() * 100f / (isVertical() ? refBox.getHeight() : refBox.getWidth()));</span>
<span class="nc" id="L3217">                        } catch (IllegalArgumentException ex) {</span>
<span class="nc" id="L3218">                            Log.p(ex.getMessage());</span>
<span class="nc" id="L3219">                            setPercent(100f);</span>
<span class="nc" id="L3220">                        }</span>
<span class="nc bnc" id="L3221" title="All 2 branches missed.">                    } else if (unit == UNIT_BASELINE) {</span>
<span class="nc bnc" id="L3222" title="All 2 branches missed.">                        if (side != Component.TOP) {</span>
<span class="nc" id="L3223">                            throw new IllegalArgumentException(&quot;Baseline unit only allowed on top inset&quot;);</span>
                        }
<span class="nc" id="L3225">                        getOppositeInset().changeUnitsTo(UNIT_AUTO, refBox);</span>
<span class="nc" id="L3226">                        unit(unit);</span>
                    } else {
<span class="nc" id="L3228">                        unit(unit);</span>
                    }
                }
<span class="nc" id="L3231">                return this;</span>
            }

            /**
             * Changes the reference component, while updating the value to remain in the same
             * absolute position.
             *
             * @param parent The parent container.
             * @param newRef The new reference component.
             * @param pos    The reference position.
             * @return Self for chaining.
             */
            public Inset changeReference(Container parent, Component newRef, float pos) {
<span class="nc bnc" id="L3244" title="All 2 branches missed.">                if (newRef != null) {</span>
<span class="nc" id="L3245">                    LayeredLayoutConstraint refCnst = getOrCreateConstraint(newRef);</span>
<span class="nc bnc" id="L3246" title="All 4 branches missed.">                    if (cmp != null &amp;&amp; refCnst.dependsOn(cmp)) {</span>
<span class="nc" id="L3247">                        throw new IllegalArgumentException(&quot;Attempted to set a reference that would produce a circular dependency in LayeredLayout&quot;);</span>
                    }
                }
                //if (isFlexible()) {
                //    // This could potentially affect the opposite inset if it is a percentage
                //    referenceComponent(newRef).referencePosition(pos);
                //} else {
<span class="nc bnc" id="L3254" title="All 4 branches missed.">                if (newRef != referenceComponent || pos != referencePosition) {</span>
                    // This may potentially affect both this inset
                    // and the opposite inset if it is either flexible or
                    // percent.

<span class="nc bnc" id="L3259" title="All 2 branches missed.">                    if (unit == UNIT_BASELINE) {</span>
<span class="nc" id="L3260">                        changeUnitsTo(UNIT_DIPS, parent);</span>
                    }

<span class="nc" id="L3263">                    byte restoreUnit = -1;</span>
<span class="nc bnc" id="L3264" title="All 4 branches missed.">                    if (unit == UNIT_PERCENT || isFlexible()) {</span>
<span class="nc" id="L3265">                        restoreUnit = unit;</span>
<span class="nc" id="L3266">                        changeUnitsTo(UNIT_DIPS, parent);</span>
                    }
<span class="nc" id="L3268">                    byte oppRestoreUnit = -1;</span>
<span class="nc bnc" id="L3269" title="All 4 branches missed.">                    if (getOppositeInset().unit == UNIT_PERCENT || isFlexible()) {</span>
<span class="nc" id="L3270">                        oppRestoreUnit = getOppositeInset().unit;</span>
<span class="nc" id="L3271">                        getOppositeInset().changeUnitsTo(UNIT_DIPS, parent);</span>
                    }
<span class="nc" id="L3273">                    LayeredLayoutConstraint cpy = constraint().copy();</span>
<span class="nc" id="L3274">                    cpy.insets[side].referenceComponent(newRef).referencePosition(pos);</span>

                    //Container parent = context.getParent();


<span class="nc" id="L3279">                    Style s = parent.getStyle();</span>
<span class="nc" id="L3280">                    int top = s.getPaddingTop();</span>
<span class="nc" id="L3281">                    int bottom = parent.getLayoutHeight() - parent.getBottomGap() - s.getPaddingBottom();</span>
<span class="nc" id="L3282">                    int left = s.getPaddingLeft(parent.isRTL());</span>
<span class="nc" id="L3283">                    int right = parent.getLayoutWidth() - parent.getSideGap() - s.getPaddingRight(parent.isRTL());</span>
<span class="nc" id="L3284">                    int newBase = cpy.insets[side].calcBaseValue(top, left, bottom, right);</span>
<span class="nc" id="L3285">                    int oldBase = calcBaseValue(top, left, bottom, right);</span>


<span class="nc" id="L3288">                    referenceComponent(newRef).referencePosition(pos);</span>
<span class="nc" id="L3289">                    calculatedBaseValue += (newBase - oldBase);</span>
<span class="nc" id="L3290">                    calculatedValue += (newBase - oldBase);</span>
<span class="nc bnc" id="L3291" title="All 2 branches missed.">                    if (getOppositeInset().isFlexible()) {</span>
<span class="nc" id="L3292">                        getOppositeInset().delta -= (newBase - oldBase);</span>
                    }

<span class="nc" id="L3295">                    translatePixels(oldBase - newBase, true, parent);</span>
<span class="nc bnc" id="L3296" title="All 2 branches missed.">                    if (restoreUnit &gt;= 0) {</span>
<span class="nc" id="L3297">                        changeUnitsTo(restoreUnit, parent);</span>
                    }
<span class="nc bnc" id="L3299" title="All 2 branches missed.">                    if (oppRestoreUnit &gt;= 0) {</span>
<span class="nc" id="L3300">                        getOppositeInset().changeUnitsTo(oppRestoreUnit, parent);</span>
                    }
                }
                //}

<span class="nc" id="L3305">                return this;</span>


            }

            /**
             * Checks if this is a flexible inset.  An inset is considered flexible if its unit is {@link #UNIT_AUTO}.
             *
             * @return True if this is a flexible inset.
             * @see #isFixed()
             */
            public boolean isFlexible() {
<span class="nc bnc" id="L3317" title="All 2 branches missed.">                return unit == UNIT_AUTO;</span>
            }

            /**
             * Returns the total inset of this inset when applied to the given component.
             * This will calculate and sum all of the insets of reference components to
             * get the total inset in pixels from the parent component.
             *
             * @param cmp The component context.
             * @return The total inset in pixels from the parent.
             */
            public int getAbsolutePixels(Component cmp) {
<span class="fc" id="L3329">                Container parent = cmp.getParent();</span>
<span class="fc" id="L3330">                Style s = parent.getStyle();</span>
<span class="fc" id="L3331">                int top = s.getPaddingTop();</span>
<span class="fc" id="L3332">                int bottom = parent.getLayoutHeight() - parent.getBottomGap() - s.getPaddingBottom();</span>
<span class="fc" id="L3333">                int left = s.getPaddingLeft(parent.isRTL());</span>
<span class="fc" id="L3334">                int right = parent.getLayoutWidth() - parent.getSideGap() - s.getPaddingRight(parent.isRTL());</span>
<span class="fc" id="L3335">                int baseValue = calcBaseValue(top, left, bottom, right);</span>
                //Rectangle baseRect = getReferenceBox(cmp.getParent(), cmp);

<span class="pc bpc" id="L3338" title="4 of 6 branches missed.">                switch (unit) {</span>
                    case UNIT_PIXELS:
<span class="fc" id="L3340">                        return baseValue + (int) value;</span>
                    case UNIT_DIPS:
<span class="nc" id="L3342">                        return baseValue + Display.getInstance().convertToPixels(value);</span>
                    case UNIT_PERCENT: {

<span class="nc" id="L3345">                        Rectangle baseRect = getReferenceBox(parent, cmp);</span>
                        //System.out.println(&quot;Baserect is &quot;+baseRect+&quot; baseValue=&quot;+baseValue+&quot; for percent &quot;+value);
<span class="nc bnc" id="L3347" title="All 2 branches missed.">                        int out = (int) (baseValue + (isHorizontalInset() ? baseRect.getWidth() : baseRect.getHeight()) * value / 100f);</span>
                        //System.out.println(&quot;Result is &quot;+out);
<span class="nc" id="L3349">                        return out;</span>
                    }
                    case UNIT_BASELINE: {
<span class="nc" id="L3352">                        Component ref = getReferenceComponent();</span>
<span class="nc bnc" id="L3353" title="All 2 branches missed.">                        if (ref == null) {</span>
<span class="nc" id="L3354">                            return baseValue;</span>
                        } else {
<span class="nc" id="L3356">                            Style rs = ref.getStyle();</span>
<span class="nc" id="L3357">                            Style cs = cmp.getStyle();</span>
<span class="nc" id="L3358">                            Font rf = rs.getFont();</span>
<span class="nc" id="L3359">                            Font cf = cs.getFont();</span>
<span class="nc bnc" id="L3360" title="All 4 branches missed.">                            int ra = rf == null || cf == null ? 0 : rf.getAscent();</span>
<span class="nc bnc" id="L3361" title="All 4 branches missed.">                            int ca = rf == null || cf == null ? 0 : cf.getAscent();</span>
<span class="nc" id="L3362">                            return baseValue + (ref.getHeight() - cmp.getPreferredH()) / 2</span>
<span class="nc" id="L3363">                                    + (rs.getPaddingTop() - cs.getPaddingTop())</span>
<span class="nc" id="L3364">                                    + (rs.getMarginTop() - cs.getMarginTop())</span>
                                    + (ra - ca);
                        }
                    }
                    case UNIT_AUTO: {
<span class="fc" id="L3369">                        Inset oppositeInset = getOppositeInset();</span>
<span class="pc bpc" id="L3370" title="1 of 2 branches missed.">                        if (oppositeInset.unit == UNIT_AUTO) {</span>
<span class="nc" id="L3371">                            Rectangle baseRect = getReferenceBox(parent, cmp);</span>
                            // they're both auto,
                            //int oppositeBase = oppositeInset.calcBaseValue(top, left, bottom, right);
<span class="nc bnc" id="L3374" title="All 2 branches missed.">                            if (isVerticalInset()) {</span>
<span class="nc" id="L3375">                                return (baseRect.getHeight() - getOuterPreferredH(cmp)) / 2;</span>
                            } else {
<span class="nc" id="L3377">                                return (baseRect.getWidth() - getOuterPreferredW(cmp)) / 2;</span>
                            }
                        } else {
<span class="pc bpc" id="L3380" title="1 of 2 branches missed.">                            if (isVerticalInset()) {</span>
<span class="nc" id="L3381">                                return bottom - top - oppositeInset.getAbsolutePixels(cmp) - baseValue - getOuterPreferredH(cmp);</span>
                            } else {
                                //System.out.println(&quot;Checking opposite inset for value&quot;);
<span class="fc" id="L3384">                                int out = right - left - oppositeInset.getAbsolutePixels(cmp) - baseValue - getOuterPreferredW(cmp);</span>
                                //System.out.println(&quot;Auto value is &quot;+out);
<span class="fc" id="L3386">                                return out;</span>
                            }
                        }
                    }
                    default:
<span class="nc" id="L3391">                        throw new RuntimeException(&quot;Illegal state in inset.  Unknown unit &quot; + unit);</span>

                }

            }

            /**
             * Translates the inset by {@literal delta} pixels.
             *
             * @param delta    Pixels to translate this inset by.
             * @param preferMM If this is a flexible inset, then translating it will require changing it to fixed.  {@literal true} to use millimetres.  {@literal false} to use pixels.
             * @param parent   The parent container used for calculating equivalent percent if this is a percent inset.
             * @return Self for chaining.
             * @see #translateMM(float, boolean, com.codename1.ui.Container)
             */
            public Inset translatePixels(int delta, boolean preferMM, Container parent) {

<span class="nc bnc" id="L3408" title="All 6 branches missed.">                switch (unit) {</span>
                    case UNIT_PIXELS:
<span class="nc" id="L3410">                        value += delta;</span>
<span class="nc" id="L3411">                        break;</span>
                    case UNIT_DIPS: {
<span class="nc" id="L3413">                        float pixelsPerDip = Display.getInstance().convertToPixels(1000) / 1000f;</span>
                        //System.out.println(&quot;Old dips for side &quot;+side+&quot; = &quot;+value);
<span class="nc" id="L3415">                        value += (delta / pixelsPerDip);</span>
                        //System.out.println(&quot;New dips for side &quot;+side+&quot; = &quot;+value);
<span class="nc" id="L3417">                        break;</span>
                    }
                    case UNIT_PERCENT: {
                        //Container parent = cmp.getParent();
                        //Style parentStyle = parent.getStyle();
<span class="nc" id="L3422">                        Style s = parent.getStyle();</span>
<span class="nc" id="L3423">                        int top = s.getPaddingTop();</span>
<span class="nc" id="L3424">                        int bottom = parent.getLayoutHeight() - parent.getBottomGap() - s.getPaddingBottom();</span>
<span class="nc" id="L3425">                        int left = s.getPaddingLeft(parent.isRTL());</span>
<span class="nc" id="L3426">                        int right = parent.getLayoutWidth() - parent.getSideGap() - s.getPaddingRight(parent.isRTL());</span>
<span class="nc" id="L3427">                        int baseValue = calculatedBaseValue;</span>
<span class="nc" id="L3428">                        int oppositeBaseValue = getOppositeInset().calculatedBaseValue;</span>
<span class="nc bnc" id="L3429" title="All 2 branches missed.">                        if (isVerticalInset()) {</span>
<span class="nc" id="L3430">                            float relH = bottom - top - baseValue - oppositeBaseValue;</span>
<span class="nc bnc" id="L3431" title="All 2 branches missed.">                            if (Math.abs(relH) &lt; 1f) {</span>
<span class="nc" id="L3432">                                return this;</span>
                            }
<span class="nc" id="L3434">                            float percentDelta = delta / relH * 100f;</span>
<span class="nc bnc" id="L3435" title="All 4 branches missed.">                            if (percentDelta == Float.NEGATIVE_INFINITY || percentDelta == Float.POSITIVE_INFINITY) {</span>
<span class="nc" id="L3436">                                percentDelta = 0f;</span>
                            }
<span class="nc" id="L3438">                            value += percentDelta;</span>

<span class="nc" id="L3440">                        } else {</span>
<span class="nc" id="L3441">                            float relH = right - left - baseValue - oppositeBaseValue;</span>
                            //System.out.println(&quot;relH=&quot;+relH+&quot; delta=&quot;+delta);
<span class="nc bnc" id="L3443" title="All 2 branches missed.">                            if (Math.abs(relH) &lt; 1f) {</span>
<span class="nc" id="L3444">                                return this;</span>
                            }
<span class="nc" id="L3446">                            float percentDelta = delta / relH * 100f;</span>
                            //System.out.println(&quot;percentDelta=&quot;+percentDelta);
<span class="nc bnc" id="L3448" title="All 4 branches missed.">                            if (percentDelta == Float.NEGATIVE_INFINITY || percentDelta == Float.POSITIVE_INFINITY) {</span>
<span class="nc" id="L3449">                                percentDelta = 0f;</span>
                            }
<span class="nc" id="L3451">                            value += percentDelta;</span>
                            //System.out.println(&quot;Value=&quot;+value);
                        }
<span class="nc" id="L3454">                        break;</span>

                    }
                    case UNIT_BASELINE: {
<span class="nc" id="L3458">                        changeUnitsTo(UNIT_DIPS, parent);</span>
<span class="nc" id="L3459">                        return translatePixels(delta, preferMM, parent);</span>
                    }
                    case UNIT_AUTO: {
                        // If this is auto then we'll need to make it fixed... but we'll start
                        // by making it fixed
<span class="nc bnc" id="L3464" title="All 2 branches missed.">                        unit = preferMM ? UNIT_DIPS : UNIT_PIXELS;</span>
<span class="nc bnc" id="L3465" title="All 2 branches missed.">                        if (unit == UNIT_PIXELS) {</span>
<span class="nc" id="L3466">                            value = calculatedValue + delta - calculatedBaseValue;</span>
                        } else {
<span class="nc" id="L3468">                            float pixelsPerDip = Display.getInstance().convertToPixels(1000) / 1000f;</span>
<span class="nc" id="L3469">                            value = (calculatedValue + delta - calculatedBaseValue) / pixelsPerDip;</span>
                        }
                        break;
                    }

                }
                //calculatedValue += delta;

<span class="nc" id="L3477">                this.delta += delta;</span>
<span class="nc bnc" id="L3478" title="All 2 branches missed.">                if (getOppositeInset().isFlexible()) {</span>
<span class="nc" id="L3479">                    getOppositeInset().delta -= delta;</span>
                }
<span class="nc" id="L3481">                return this;</span>
            }

            /**
             * Translates the inset by {@literal delta} millimetres.
             *
             * @param delta    Pixels to translate this inset by.
             * @param preferMM If this is a flexible inset, then translating it will require changing it to fixed.  {@literal true} to use millimetres.  {@literal false} to use pixels.
             * @param parent   The parent container used for calculating equivalent percent if this is a percent inset.
             * @return Self for chaining.
             */
            public Inset translateMM(float delta, boolean preferMM, Container parent) {
<span class="nc" id="L3493">                return translatePixels(Display.getInstance().convertToPixels(delta), preferMM, parent);</span>

            }

        }

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>