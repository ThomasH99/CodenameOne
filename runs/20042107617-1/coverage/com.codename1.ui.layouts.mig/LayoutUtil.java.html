<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LayoutUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">codenameone-core-unittests</a> &gt; <a href="index.source.html" class="el_package">com.codename1.ui.layouts.mig</a> &gt; <span class="el_source">LayoutUtil.java</span></div><h1>LayoutUtil.java</h1><pre class="source lang-java linenums">package com.codename1.ui.layouts.mig;

import com.codename1.util.MathUtil;

import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.TreeSet;

/*
 * License (BSD):
 * ==============
 *
 * Copyright (c) 2004, Mikael Grev, MiG InfoCom AB. (miglayout (at) miginfocom (dot) com)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * Redistributions of source code must retain the above copyright notice, this list
 * of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this
 * list of conditions and the following disclaimer in the documentation and/or other
 * materials provided with the distribution.
 * Neither the name of the MiG InfoCom AB nor the names of its contributors may be
 * used to endorse or promote products derived from this software without specific
 * prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 * @version 1.0
 * @author Mikael Grev, MiG InfoCom AB
 *         Date: 2006-sep-08
 */

/**
 * A utility class that has only static helper methods.
 */
public final class LayoutUtil {
    /**
     * A substitute value for aa really large value. Integer.MAX_VALUE is not used since that means a lot of defensive code
     * for potential overflow must exist in many places. This value is large enough for being unreasonable yet it is hard to
     * overflow.
     */
    public static final int INF = (Integer.MAX_VALUE &gt;&gt; 10) - 100; // To reduce likelihood of overflow errors when calculating.
    // Index for the different sizes
    public static final int MIN = 0;
    public static final int PREF = 1;
    public static final int MAX = 2;
    public static final int HORIZONTAL = 0;
    public static final int VERTICAL = 1;
<span class="fc" id="L59">    public static final boolean HAS_BEANS = hasBeans();</span>
    /**
     * Tag int for a value that in considered &quot;not set&quot;. Used as &quot;null&quot; element in int arrays.
     */
    static final int NOT_SET = Integer.MIN_VALUE + 12346;   // Magic value...
<span class="fc" id="L64">    private static final IdentityHashMap&lt;Object, Object&gt; SER_MAP = new IdentityHashMap&lt;Object, Object&gt;(2);</span>
<span class="fc" id="L65">    private static volatile HashMap&lt;Object, String&gt; CR_MAP = null;</span>
<span class="fc" id="L66">    private static volatile HashMap&lt;Object, Boolean&gt; DT_MAP = null;      // The Containers that have design time. Value not used.</span>
<span class="fc" id="L67">    private static int eSz = 0;</span>
<span class="fc" id="L68">    private static int globalDebugMillis = 0;</span>

    private LayoutUtil() {
    }

    private static boolean hasBeans() {
<span class="fc" id="L74">        return false;</span>
    }

    /**
     * Returns the current version of MiG Layout.
     *
     * @return The current version of MiG Layout. E.g. &quot;3.6.3&quot; or &quot;4.0&quot;
     */
    public static String getVersion() {
<span class="nc" id="L83">        return &quot;5.0&quot;;</span>
    }

    /**
     * If global debug should be on or off. If &amp;gt; 0 then debug is turned on for all MigLayout
     * instances.
     *
     * @return The current debug milliseconds.
     * @see LC#setDebugMillis(int)
     */
    public static int getGlobalDebugMillis() {
<span class="fc" id="L94">        return globalDebugMillis;</span>
    }

    /**
     * If global debug should be on or off. If &amp;gt; 0 then debug is turned on for all MigLayout
     * instances.
     * &lt;p&gt;
     * Note! This is a passive value and will be read by panels when the needed, which is normally
     * when they repaint/layout.
     *
     * @param millis The new debug milliseconds. 0 turns of global debug and leaves debug up to every
     *               individual panel.
     * @see LC#setDebugMillis(int)
     */
    public static void setGlobalDebugMillis(int millis) {
<span class="nc" id="L109">        globalDebugMillis = millis;</span>
<span class="nc" id="L110">    }</span>

    /**
     * Sets if design time is turned on for a Container in {@link ContainerWrapper}.
     *
     * @param cw The container to set design time for. &lt;code&gt;null&lt;/code&gt; is legal and can be used as
     *           a key to turn on/off design time &quot;in general&quot;. Note though that design time &quot;in general&quot; is
     *           always on as long as there is at least one ContainerWrapper with design time.
     *           &lt;p&gt;
     *           &lt;strong&gt;If this method has not ever been called it will default to what
     *           &lt;code&gt;Beans.isDesignTime()&lt;/code&gt; returns.&lt;/strong&gt; This means that if you call
     *           this method you indicate that you will take responsibility for the design time value.
     * @param b  &lt;code&gt;true&lt;/code&gt; means design time on.
     */
    public static void setDesignTime(ContainerWrapper cw, boolean b) {
<span class="nc bnc" id="L125" title="All 2 branches missed.">        if (DT_MAP == null)</span>
<span class="nc" id="L126">            DT_MAP = new HashMap&lt;Object, Boolean&gt;();</span>

<span class="nc bnc" id="L128" title="All 2 branches missed.">        DT_MAP.put((cw != null ? cw.getComponent() : null), b);</span>
<span class="nc" id="L129">    }</span>

    /**
     * Returns if design time is turned on for a Container in {@link ContainerWrapper}.
     *
     * @param cw The container to set design time for. &lt;code&gt;null&lt;/code&gt; is legal will return &lt;code&gt;true&lt;/code&gt;
     *           if there is at least one &lt;code&gt;ContainerWrapper&lt;/code&gt; (or &lt;code&gt;null&lt;/code&gt;) that have design time
     *           turned on.
     * @return If design time is set for &lt;code&gt;cw&lt;/code&gt;.
     */
    public static boolean isDesignTime(ContainerWrapper cw) {
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">        if (DT_MAP == null)</span>
<span class="fc" id="L141">            return HAS_BEANS;</span>

<span class="nc bnc" id="L143" title="All 4 branches missed.">        if (cw != null &amp;&amp; !DT_MAP.containsKey(cw.getComponent()))</span>
<span class="nc" id="L144">            cw = null;</span>

<span class="nc bnc" id="L146" title="All 2 branches missed.">        Boolean b = DT_MAP.get(cw != null ? cw.getComponent() : null);</span>
<span class="nc bnc" id="L147" title="All 4 branches missed.">        return b != null &amp;&amp; b;</span>
    }

    /**
     * The size of an empty row or columns in a grid during design time.
     *
     * @return The number of pixels. Default is 15.
     */
    public static int getDesignTimeEmptySize() {
<span class="nc" id="L156">        return eSz;</span>
    }

    /**
     * The size of an empty row or columns in a grid during design time.
     *
     * @param pixels The number of pixels. Default is 0 (it was 15 prior to v3.7.2, but since that meant different behaviour
     *               under design time by default it was changed to be 0, same as non-design time). IDE vendors can still set it to 15 to
     *               get the old behaviour.
     */
    public static void setDesignTimeEmptySize(int pixels) {
<span class="nc" id="L167">        eSz = pixels;</span>
<span class="nc" id="L168">    }</span>

    /**
     * Associates &lt;code&gt;con&lt;/code&gt; with the creation string &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;con&lt;/code&gt; object should
     * probably have an equals method that compares identities or &lt;code&gt;con&lt;/code&gt; objects that .equals() will only
     * be able to have &lt;b&gt;one&lt;/b&gt; creation string.
     * &lt;p&gt;
     * If {@link LayoutUtil#isDesignTime(ContainerWrapper)} returns &lt;code&gt;false&lt;/code&gt; the method does nothing.
     *
     * @param con The object. if &lt;code&gt;null&lt;/code&gt; the method does nothing.
     * @param s   The creation string. if &lt;code&gt;null&lt;/code&gt; the method does nothing.
     */
    static void putCCString(Object con, String s) {
<span class="pc bpc" id="L181" title="2 of 6 branches missed.">        if (s != null &amp;&amp; con != null &amp;&amp; isDesignTime(null)) {</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">            if (CR_MAP == null)</span>
<span class="nc" id="L183">                CR_MAP = new HashMap&lt;Object, String&gt;(64);</span>

<span class="nc" id="L185">            CR_MAP.put(con, s);</span>
        }
<span class="fc" id="L187">    }</span>

    /**
     * Returns strings set with {@link #putCCString(Object, String)} or &lt;code&gt;null&lt;/code&gt; if nothing is associated or
     * {@link LayoutUtil#isDesignTime(ContainerWrapper)} returns &lt;code&gt;false&lt;/code&gt;.
     *
     * @param con The constrain object.
     * @return The creation string or &lt;code&gt;null&lt;/code&gt; if nothing is registered with the &lt;code&gt;con&lt;/code&gt; object.
     */
    static String getCCString(Object con) {
<span class="nc bnc" id="L197" title="All 2 branches missed.">        return CR_MAP != null ? CR_MAP.get(con) : null;</span>
    }

    static void throwCC() {
<span class="nc" id="L201">        throw new IllegalStateException(&quot;setStoreConstraintData(true) must be set for strings to be saved.&quot;);</span>
    }

    /**
     * Takes a number on min/preferred/max sizes and resize constraints and returns the calculated sizes which sum should add up to &lt;code&gt;bounds&lt;/code&gt;. Whether the sum
     * will actually equal &lt;code&gt;bounds&lt;/code&gt; is dependent om the pref/max sizes and resize constraints.
     *
     * @param sizes          [ix],[MIN][PREF][MAX]. Grid.CompWrap.NOT_SET will be treated as N/A or 0. A &quot;[MIN][PREF][MAX]&quot; array with null elements will be interpreted as very flexible (no bounds)
     *                       but if the array itself is null it will not get any size.
     * @param resConstr      Elements can be &lt;code&gt;null&lt;/code&gt; and the whole array can be &lt;code&gt;null&lt;/code&gt;. &lt;code&gt;null&lt;/code&gt; means that the size will not be flexible at all.
     *                       Can have length less than &lt;code&gt;sizes&lt;/code&gt; in which case the last element should be used for the elements missing.
     * @param defPushWeights If there is no grow weight for a resConstr the corresponding value of this array is used.
     *                       These forced resConstr will be grown last though and only if needed to fill to the bounds.
     * @param startSizeType  The initial size to use. E.g. {@link net.miginfocom.layout.LayoutUtil#MIN}.
     * @param bounds         To use for relative sizes.
     * @return The sizes. Array length will match &lt;code&gt;sizes&lt;/code&gt;.
     */
    static int[] calculateSerial(int[][] sizes, ResizeConstraint[] resConstr, Float[] defPushWeights, int startSizeType, int bounds) {
<span class="fc" id="L219">        float[] lengths = new float[sizes.length];    // heights/widths that are set</span>
<span class="fc" id="L220">        float usedLength = 0.0f;</span>

        // Give all preferred size to start with
<span class="fc bfc" id="L223" title="All 2 branches covered.">        for (int i = 0; i &lt; sizes.length; i++) {</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">            if (sizes[i] != null) {</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">                float len = sizes[i][startSizeType] != NOT_SET ? sizes[i][startSizeType] : 0;</span>
<span class="fc" id="L226">                int newSizeBounded = getBrokenBoundary(len, sizes[i][MIN], sizes[i][MAX]);</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">                if (newSizeBounded != NOT_SET)</span>
<span class="nc" id="L228">                    len = newSizeBounded;</span>

<span class="fc" id="L230">                usedLength += len;</span>
<span class="fc" id="L231">                lengths[i] = len;</span>
            }
        }

<span class="fc" id="L235">        int useLengthI = MathUtil.round(usedLength);</span>
<span class="pc bpc" id="L236" title="1 of 4 branches missed.">        if (useLengthI != bounds &amp;&amp; resConstr != null) {</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">            boolean isGrow = useLengthI &lt; bounds;</span>

            // Create a Set with the available priorities
<span class="fc" id="L240">            TreeSet&lt;Integer&gt; prioList = new TreeSet&lt;Integer&gt;();</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">            for (int i = 0; i &lt; sizes.length; i++) {</span>
<span class="fc" id="L242">                ResizeConstraint resC = (ResizeConstraint) getIndexSafe(resConstr, i);</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">                if (resC != null)</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">                    prioList.add(Integer.valueOf(isGrow ? resC.growPrio : resC.shrinkPrio));</span>
            }
<span class="fc" id="L246">            Integer[] prioIntegers = prioList.toArray(new Integer[prioList.size()]);</span>

<span class="pc bpc" id="L248" title="2 of 6 branches missed.">            for (int force = 0; force &lt;= ((isGrow &amp;&amp; defPushWeights != null) ? 1 : 0); force++) {    // Run twice if defGrow and the need for growing.</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">                for (int pr = prioIntegers.length - 1; pr &gt;= 0; pr--) {</span>
<span class="fc" id="L250">                    int curPrio = prioIntegers[pr];</span>

<span class="fc" id="L252">                    float totWeight = 0f;</span>
<span class="fc" id="L253">                    Float[] resizeWeight = new Float[sizes.length];</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">                    for (int i = 0; i &lt; sizes.length; i++) {</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">                        if (sizes[i] == null)   // if no min/pref/max size at all do not grow or shrink.</span>
<span class="fc" id="L256">                            continue;</span>

<span class="fc" id="L258">                        ResizeConstraint resC = (ResizeConstraint) getIndexSafe(resConstr, i);</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">                        if (resC != null) {</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">                            int prio = isGrow ? resC.growPrio : resC.shrinkPrio;</span>

<span class="fc bfc" id="L262" title="All 2 branches covered.">                            if (curPrio == prio) {</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">                                if (isGrow) {</span>
<span class="pc bpc" id="L264" title="5 of 6 branches missed.">                                    resizeWeight[i] = (force == 0 || resC.grow != null) ? resC.grow : (defPushWeights[i &lt; defPushWeights.length ? i : defPushWeights.length - 1]);</span>
                                } else {
<span class="nc" id="L266">                                    resizeWeight[i] = resC.shrink;</span>
                                }
<span class="fc bfc" id="L268" title="All 2 branches covered.">                                if (resizeWeight[i] != null)</span>
<span class="fc" id="L269">                                    totWeight += resizeWeight[i];</span>
                            }
                        }
                    }

<span class="fc bfc" id="L274" title="All 2 branches covered.">                    if (totWeight &gt; 0f) {</span>
                        boolean hit;
                        do {
<span class="fc" id="L277">                            float toChange = bounds - usedLength;</span>
<span class="fc" id="L278">                            hit = false;</span>
<span class="fc" id="L279">                            float changedWeight = 0f;</span>
<span class="pc bpc" id="L280" title="1 of 4 branches missed.">                            for (int i = 0; i &lt; sizes.length &amp;&amp; totWeight &gt; 0.0001f; i++) {</span>

<span class="fc" id="L282">                                Float weight = resizeWeight[i];</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">                                if (weight != null) {</span>
<span class="fc" id="L284">                                    float sizeDelta = toChange * weight / totWeight;</span>
<span class="fc" id="L285">                                    float newSize = lengths[i] + sizeDelta;</span>

<span class="pc bpc" id="L287" title="1 of 2 branches missed.">                                    if (sizes[i] != null) {</span>
<span class="fc" id="L288">                                        int newSizeBounded = getBrokenBoundary(newSize, sizes[i][MIN], sizes[i][MAX]);</span>
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">                                        if (newSizeBounded != NOT_SET) {</span>
<span class="nc" id="L290">                                            resizeWeight[i] = null;</span>
<span class="nc" id="L291">                                            hit = true;</span>
<span class="nc" id="L292">                                            changedWeight += weight;</span>
<span class="nc" id="L293">                                            newSize = newSizeBounded;</span>
<span class="nc" id="L294">                                            sizeDelta = newSize - lengths[i];</span>
                                        }
                                    }

<span class="fc" id="L298">                                    lengths[i] = newSize;</span>
<span class="fc" id="L299">                                    usedLength += sizeDelta;</span>
                                }
                            }
<span class="fc" id="L302">                            totWeight -= changedWeight;</span>
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">                        } while (hit);</span>
                    }
                }
            }
        }
<span class="fc" id="L308">        return roundSizes(lengths);</span>
    }

    static Object getIndexSafe(Object[] arr, int ix) {
<span class="pc bpc" id="L312" title="2 of 4 branches missed.">        return arr != null ? arr[ix &lt; arr.length ? ix : arr.length - 1] : null;</span>
    }

    /**
     * Returns the broken boundary if &lt;code&gt;sz&lt;/code&gt; is outside the boundaries &lt;code&gt;lower&lt;/code&gt; or &lt;code&gt;upper&lt;/code&gt;. If both boundaries
     * are broken, the lower one is returned. If &lt;code&gt;sz&lt;/code&gt; is &amp;lt; 0 then &lt;code&gt;new Float(0f)&lt;/code&gt; is returned so that no sizes can be
     * negative.
     *
     * @param sz    The size to check
     * @param lower The lower boundary (or &lt;code&gt;null&lt;/code&gt; fo no boundary).
     * @param upper The upper boundary (or &lt;code&gt;null&lt;/code&gt; fo no boundary).
     * @return The broken boundary.
     */
    private static int getBrokenBoundary(float sz, int lower, int upper) {
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">        if (lower != NOT_SET) {</span>
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">            if (sz &lt; lower)</span>
<span class="nc" id="L328">                return lower;</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">        } else if (sz &lt; 0f) {</span>
<span class="nc" id="L330">            return 0;</span>
        }

<span class="pc bpc" id="L333" title="2 of 4 branches missed.">        if (upper != NOT_SET &amp;&amp; sz &gt; upper)</span>
<span class="nc" id="L334">            return upper;</span>

<span class="fc" id="L336">        return NOT_SET;</span>
    }

    static int sum(int[] terms, int start, int len) {
<span class="nc" id="L340">        int s = 0;</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">        for (int i = start, iSz = start + len; i &lt; iSz; i++)</span>
<span class="nc" id="L342">            s += terms[i];</span>
<span class="nc" id="L343">        return s;</span>
    }

    static int sum(int[] terms) {
<span class="nc" id="L347">        return sum(terms, 0, terms.length);</span>
    }

    public static int getSizeSafe(int[] sizes, int sizeType) {
<span class="pc bpc" id="L351" title="2 of 4 branches missed.">        if (sizes == null || sizes[sizeType] == NOT_SET)</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">            return sizeType == MAX ? LayoutUtil.INF : 0;</span>
<span class="fc" id="L353">        return sizes[sizeType];</span>
    }

    static BoundSize derive(BoundSize bs, UnitValue min, UnitValue pref, UnitValue max) {
<span class="nc bnc" id="L357" title="All 4 branches missed.">        if (bs == null || bs.isUnset())</span>
<span class="nc" id="L358">            return new BoundSize(min, pref, max, null);</span>

<span class="nc bnc" id="L360" title="All 2 branches missed.">        return new BoundSize(</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">                min != null ? min : bs.getMin(),</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">                pref != null ? pref : bs.getPreferred(),</span>
<span class="nc" id="L363">                max != null ? max : bs.getMax(),</span>
<span class="nc" id="L364">                bs.getGapPush(),</span>
                null);
    }

    /**
     * Returns if left-to-right orientation is used. If not set explicitly in the layout constraints the Locale
     * of the &lt;code&gt;parent&lt;/code&gt; is used.
     *
     * @param lc        The constraint if there is one. Can be &lt;code&gt;null&lt;/code&gt;.
     * @param container The parent that may be used to get the left-to-right if ffc does not specify this.
     * @return If left-to-right orientation is currently used.
     */
    public static boolean isLeftToRight(LC lc, ContainerWrapper container) {
<span class="pc bpc" id="L377" title="2 of 4 branches missed.">        if (lc != null &amp;&amp; lc.getLeftToRight() != null)</span>
<span class="nc" id="L378">            return lc.getLeftToRight();</span>

<span class="pc bpc" id="L380" title="2 of 4 branches missed.">        return container == null || container.isLeftToRight();</span>
    }

    /**
     * Round a number of float sizes into int sizes so that the total length match up
     *
     * @param sizes The sizes to round
     * @return An array of equal length as &lt;code&gt;sizes&lt;/code&gt;.
     */
    static int[] roundSizes(float[] sizes) {
<span class="fc" id="L390">        int[] retInts = new int[sizes.length];</span>
<span class="fc" id="L391">        float posD = 0;</span>

<span class="fc bfc" id="L393" title="All 2 branches covered.">        for (int i = 0; i &lt; retInts.length; i++) {</span>
<span class="fc" id="L394">            int posI = (int) (posD + 0.5f);</span>

<span class="fc" id="L396">            posD += sizes[i];</span>

<span class="fc" id="L398">            retInts[i] = (int) (posD + 0.5f) - posI;</span>
        }

<span class="fc" id="L401">        return retInts;</span>
    }

//	static int getBaselineCorrect(Component comp)
//	{
//		Dimension pSize = comp.getPreferredSize();
//		int baseline = comp.getBaseline(pSize.width, pSize.height);
//		int nextBaseline = comp.getBaseline(pSize.width, pSize.height + 1);
//
//		// Amount to add to height when calculating where baseline
//		// lands for a particular height:
//		int padding = 0;
//
//		// Where the baseline is relative to the mid point
//		int baselineOffset = baseline - pSize.height / 2;
//		if (pSize.height % 2 == 0 &amp;&amp; baseline != nextBaseline) {
//			padding = 1;
//		} else if (pSize.height % 2 == 1 &amp;&amp; baseline == nextBaseline) {
//			baselineOffset--;
//			padding = 1;
//		}
//
//		// The following calculates where the baseline lands for
//		// the height z:
//		return (pSize.height + padding) / 2 + baselineOffset;
//	}

    /**
     * Safe equals. null == null, but null never equals anything else.
     *
     * @param o1 The first object. May be &lt;code&gt;null&lt;/code&gt;.
     * @param o2 The second object. May be &lt;code&gt;null&lt;/code&gt;.
     * @return Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;o1&lt;/code&gt; and &lt;code&gt;o2&lt;/code&gt; are equal (using .equals()) or both are &lt;code&gt;null&lt;/code&gt;.
     */
    static boolean equals(Object o1, Object o2) {
<span class="nc bnc" id="L436" title="All 8 branches missed.">        return o1 == o2 || (o1 != null &amp;&amp; o2 != null &amp;&amp; o1.equals(o2));</span>
    }

    /**
     * Returns the inset for the side.
     *
     * @param side       top == 0, left == 1, bottom = 2, right = 3.
     * @param getDefault If &lt;code&gt;true&lt;/code&gt; the default insets will get retrieved if &lt;code&gt;lc&lt;/code&gt; has none set.
     * @return The inset for the side. Never &lt;code&gt;null&lt;/code&gt;.
     */
    static UnitValue getInsets(LC lc, int side, boolean getDefault) {
<span class="fc" id="L447">        UnitValue[] i = lc.getInsets();</span>
<span class="pc bpc" id="L448" title="4 of 6 branches missed.">        return (i != null &amp;&amp; i[side] != null) ? i[side] : (getDefault ? PlatformDefaults.getPanelInsets(side) : UnitValue.ZERO);</span>
    }

    /**
     * Sets the serialized object and associates it with &lt;code&gt;caller&lt;/code&gt;.
     *
     * @param caller The object created &lt;code&gt;o&lt;/code&gt;
     * @param o      The just serialized object.
     */
    public static void setSerializedObject(Object caller, Object o) {
<span class="nc" id="L458">        synchronized (SER_MAP) {</span>
<span class="nc" id="L459">            SER_MAP.put(caller, o);</span>
<span class="nc" id="L460">        }</span>
<span class="nc" id="L461">    }</span>

    /**
     * Returns the serialized object that are associated with &lt;code&gt;caller&lt;/code&gt;. It also removes it from the list.
     *
     * @param caller The original creator of the object.
     * @return The object.
     */
    public static Object getSerializedObject(Object caller) {
<span class="nc" id="L470">        synchronized (SER_MAP) {</span>
<span class="nc" id="L471">            return SER_MAP.remove(caller);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>